# message-viewer
![npm stable version](https://badger.yandex-team.ru/npm/@ps-int/message-viewer/version.svg)

React-компонент просмотрщик письма

## Разработка

### В Storybook

```bash
npm ci
npm run storybook
```

### В сервисе

1. В директории пакета делаем
```bash
npm i
npm link
```
2. В нужном нам "хостовом сервисе" делаем
```bash
npm link @ps-int/message-viewer
```
3. Запускаем сборку в watch-режиме (в screen/tmux/whatever)
```bash
# в директории пакета
npm start
```

### Сборка и публикация

```bash
# в директории пакета
# версия по semver
npm run package X.Y.Z
```

## Плагины

Просмотр письма поддерживает создание плагинов к нему.
Стандартные плагины экспортируются из пакета отдельно и требуют подключения
при инициализации компонента просмотра письма.

### Разработка плагинов

Плагин — объект с 6 полями:
* `name` — **обязательное**, имя плагина, должно быть уникальным;
* `processBodyAsString` — функция для процессинга тела письма в виде строки;
* `processBodyAsDOMTreeSync` — функция для процессинга тела письма как DOM-дерева перед отрисовкой письма;
* `onMessageBodyProcessed` — функция, вызываемая движком плагина после завершения транформаций, получает на вход движок плагинов;
* `onMessageBodyUpdated` — функция, вызываемая движком плагина после обновления тела пиьма посредством асинхронной транформации, получает на вход движок плагинов;
* `onMessageDataUpdated` — функция, вызываемая движком плагина при изменении данных о письме;
* `onDisplayOptionsUpdated` — функция, вызываемая движком плагина при изменении настроек отображения письма;
* `onSettingsUpdated` — функция, вызываемая движком плагина при изменении настроек просмотрщика;
* `Widget` — React-компонент, рисующий визуальную часть плагина;
* `BarComponent` — React-компонент, рисующий плашку, если она нужна плагину;
* `storage` — объект хранилища данных плагина (подробней про `storage` ниже).

Все поля кроме name опциональны. Соответствующие интерфейсы можно увидеть в месте объявления
(в данный момент `src/pluginsEngine/PluginsEngine`).

#### storage

Может иметь 2 "служебных" поля:
* `init` — **обязательное**, функция, вызывающаяся перед процессингом тела письма, на вход получает данные о письме;
* `bodyClassName` — имя css-класса, которое будет добавлено контейнеру с письмом.

Заставить движок плагинов обновить классы на теле письма можно, вызвав у него метод `resetBodyClassNames`; это
приведёт к обновлению всех css-классов, которые предоставляют стораджи всех плагинов на момент вызова.

#### Как трансформировать тело письма после завершения первичной трансформации?

Движок плагинов (для использования в виджетах можно взять его из [контекста](./src/contexts/PluginsContext.ts))
предоставляет метод `runAsyncProcessor`, принимающий функцию, обрабатывающую тела письма в по состоянию на
момент вызова. Функция может быть асинхронной, работать в ней можно прямо с телом письма в виде DOM.

Во избежание конкурирующих изменений в теле письма от разных транформаций, запуск асинхронных трансформеров
происходит в порядке очереди запросов на трансформацию. В случае переинициализации тела письма (сменившийся `mid`)
очередь будет остановлена и очищена.

#### Как сделать простой плагин с виджетом?

Для виджетов в системе плагинов есть собственный движок, позволяющий абстрагироваться при разработке
плагина от управления точками монтирования реакта. Однако, чтобы движок виджетов знал, что делать с вашим
виджетом, его необходимо зарегистрировать в процессе обработки письма. Лучшее место для этого — `processBodyAsDOMTreeSync`.

`processBodyAsDOMTreeSync` принимает 2 аргумента: текущее тело письма в виде `DocumentFragment` и инстанс движка
виджетов. Чтобы зарегистрировать новый виджет, нужно вызвать у переданного инстанса движка виджетов метод
`registerWidget`, передав туда сам объект плагина и DOM-ноду, в которую должен быть отрендерен виджет, и получив, в случае
успешной регистрации, `id` виджета.

Промежуточным хранилищем данных для передачи из процессоров тела в виджеты может быть `storage` плагина.

При рендеринге компонент `Widget` получает два пропа:
* `widgetId` — позволяет понять, что показывать, поскольку один плагин может зарегистрировать множество виджетов в одном теле письма
* `node` — DOM-нода, на которую зарегистрирован виджет, может быть не пустой, в таком случае виджет отрендерится в качесте её последнего ребёнка

#### Как трансформировать другие поля письма из плагина?
Объект движка плагинов `pluginsEngine` предоставляет метод `overrideMessageData`, принимающий объект с переопределенными
полями письма (интерфейс [MessageDataInterface](./src/contexts/MessageDataContext.ts)). В метод нужно передавать только те
поля, которые нужно переопределить, то есть, например, вызов
```javascript
pluginsEngine.overrideMessageData({ subject: 'Переопределенная тема' });
```
изменит только тему письма и не затронет другие поля. Последующие вызовы `overrideMessageData`
не сбросят заданное переопредление, а добавят к нему новые поля. То есть после вызовов
```javascript
pluginsEngine.overrideMessageData({ subject: 'Переопределенная тема' });
pluginsEngine.overrideMessageData({ subjectPrefix: 'fwd' });
```
будут переопределены и тема, и префикс. Все текущие переопределенные поля хранятся в поле `pluginsEngine.messageDataOverrides`.

Чтобы сбросить передпределение поля, нужно передать объект со значением поля равным `undefined`. Например:
`pluginsEngine.overrideMessageData({ subject: undefined });`

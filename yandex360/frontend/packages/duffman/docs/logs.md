# Логирование

## Формат tskv
Полное описание лежит [здесь](https://wiki.yandex-team.ru/logfeller/parser/formats/#tskvnerekomendovandljanovyxdannyx)
1. Одна строка - одна запись.
2. Запись начинается с символов "tskv" за которыми следует символ табуляции.
3. Далее следуют разделённые символом табуляции пары «имя поля»=«значение», при этом набор полей и их порядок произволен, но имена полей уникальны в рамках записи. Имя поля должно быть в нижнем регистре.
4. Символы "\t", "\n", "\r", "\0", "\", "=", '"' экранируются с помощью "\". Символ "=" экранируется только для имени поля, например   ключ\=содержащий равно=значение=содержащее равно
5. Для задания времени записи используются поля «timestamp»+«timezone» или «unixtime».
6. Для задания типа лога используется поле «tskv_format»

Дополнения:

1. Мы не используем `=` в именах полей, и нигде не экранируем этот символ.
2. В текущем описании на вики рекомендуется использовать `unixtime`. Мы можем пренебречь данной рекомендацией, пока не решим отправлять логи в статистику.

Пример:
```
tskv	tskv_format=duffman-access-log	timestamp=2016-03-10 02:12:31	timezone=+0300	reason=AUTH_ERROR	message=not authenticated	x_real_ip=176.107.245.11	x_request_id=dc2a1b086816e8deabb8f1dc8c5f0738	host=mail.yandex-team.ru	uid=1120000000000231
```

## Структура лога
Любая запись в лог имеет стандартные поля 
- `tskv_format` - метка, по которой мы определяем в какой лог файл писать данные. [список файлов](#Темы-логирования)
- `timestamp` - время записи в лог во временной зоне сервера
- `timezone` - временная зона сервера
- `reason` - причина записи в лог. [список причин](#Причины-логирования)
- `x_real_ip` - ip пользователя, пришедший в заголовке от nginx
- `x_request_id` - уникальный id запроса, пришедший в заголовке от nginx. Этот id продрасывается во все бекэнд сервисы и должен там логироваться.
- `host` - хост, с которого пришел пользователь
- `uid` - uid пользователя. Записывается, если это возможно. Для моделей, если мы не смогли запросить авторизацию, мы берем uid переданный нам с клиента.

Любая ошибка имеет так же обязательное поле `message`, которое несет основную текстовую информацию об ошибке. Поля для дополнительной информации строго не регламентированы.

## Темы логирования
- `master-log` — все что связано с работой кластера. (Не удалось запустить воркер, воркер упал, пришел системный сигнал, кластер запустился)
- `http-log` — информация об http запросах к бекэндам. (Только то, что связано с http протоколом).
- `access-log` — всё остальное.

## Причины логирования
### access-log
Название | Описание
:------: | :-------
**MODEL_RESOLVED** | Модель была успешно обработана. В процессе обработки не случилось никаких критических ошибок, модель возвращает прогнозируемые данные. Здесь можно посмотреть с какими параметрами к нам пришла модель.
**MODEL_REJECTED** | В процессе обработки модели случилась какая либо ошибка (не ответил сервер, или ответил данными, которые мы не смогли обработать, или с клиента пришли непридвиденные параметры запроса).
**MODEL_EXEC_ERROR** | (**critical**) JS ошибка при обработке запроса внутри модели. (Например попытались поискать данные в объекте, а он оказался строкой - неожиданно).
**CALL_EXCEPTION** | (**critical**) Cпецифическая js ошибка для парсера данных о пдд.
**HTTP_REQUEST_ERROR** | Ошибка запроса к серверу. (Сервер не ответил за положенное время, ответил непридвиденным кодом >= 400)
**AUTH_ERROR** | Ошибка при запросе авторизации (Сервер не ответил за положенное время или ответил непридвиденным ошибкой)
**CKEY_ERROR** | Невалидный ckey, дополнительная информация о причине невалидности хранится в других полях
**RUN_MODEL_ERROR** | (**critical**) Ошибка исполнения модели. Увидеть такую очень сложно, потому что в большинстве случаев она будет перехвачена в **MODEL_EXEC_ERROR**
**SETTING_RETRY** | Сделали перезапрос за настройками. Не является ошибкой, скорее предупреждение для статистики.
**SETTINGS_NO_DATA** | Специфическая ошибка, если сервер настроек вернул нам что-то не то.
**REQUEST_FINISHED** | Запись об успешном завершении запроса. Здесь можно посмотреть с какими параметрами к нам пришел запрос.
**COMMON_REQUEST_ERROR** | (**critical**) Ошибка на самой вершине стека обработки запроса. Может случиться, если нам по какой-то причине не удалось отправить ответ пользователю.
**COMMON_REQUEST_EXCEPTION** | (**critical**) Ошибка на самой вершине стека обработки запроса. Может случиться, если нам по какой-то причине не удалось обработать **COMMON_REQUEST_ERROR** или **REQUEST_FINISHED**.

### http-log
Название | Описание
:------: | :-------
**HTTP_SUCCESS** | Запрос прошел успешно
**HTTP_FAILURE** | При запросе произошла ошибка сетевого уровня (Таймаут соединения, непредвиденный обрыв сокета)

### master-log
Название | Описание
:------: | :-------
**UNCAUGHT_EXCEPTION** | Непредвиденная ошибка в работе мастер процесса. После такой ошибки процесс моментально закроется с кодом 0.
**CLUSTER_ERROR** | Непонятно когда мастер может вызвать это событие, но если вызовет, то уйдет в мягкий рестарт.
**SIGHUP** | Мастеру прислали системный сигнал `SIGHUP`
**SIGINT** | Мастеру прислали системный сигнал `SIGINT`
**SIGQUIT** | Мастеру прислали системный сигнал `SIGQUIT`
**IGNORED_PONG_RESPONSE** | Если worker не успел ответить за 500мс мы его больше не ждем. Если он все же ответит нам через 1сек мы должны проигнорировать этот ответ. Это очень странная ситуация - worker должен успеть ответить перед тем как мы его убьем.
**INITIALIZATION_ERROR** | Если по какой-то причине воркер не знает своего wid нам нужно рестартовать весь кластер
**RESTART_HANGED_WORKER** | Не даем воркеру второго шанса - если не успел ответить сразу рестартуем
**WORKER_EXIT** | Непредвиденное закрытие воркера (Если мы не пытаемся в этот момент мягко перезапустить сервер, то любое завершение воркера для нас неожиданное)
**WORKER_DEAD** | Непредвиденная смерть воркера (Его никто не пытался закрыть, он закрылся сам)
**WORKER_UNCAUGHT_EXCEPTION** | Непредвиденная ошибка в работе воркер процесса. После такой ошибки процесс моментально закроется с кодом 0.
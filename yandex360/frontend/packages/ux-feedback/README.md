# @ps-int/ux-feedback

_Пакет сделан на основе `packages/boilerplate`_

Пакет нужен для внедрения компонента по измерению NPS через сбор фидбека пользователей на странице.

Компонент предоставляется внешней компанией.
https://uxfeedback.ru/

[Руководство по внедрению для Яндекса](https://docs.google.com/document/d/1riJjF6Yti_UXAbARCsN1LI3bBWBLeIxcbmhGmKms684/edit)

## Быстрый старт

Сначала нам нужно узнать специальный id из админки UX Feedback, соответствующий нашему сервису (аналогично Метрике).
Дальше добавляем в наш сервис зависимость.
```
npm i -D @ps-int/ux-feedback
```

Самый простой вариант внедрения на сервис - добавить куда-то в корневой элемент приложения `UXFeedbackComponent`.

```tsx
import { UXFeedbackComponent } from "@ps-int/ux-feedback";

...
<UXFeedbackComponent accountId="<id сервиса в UX Feedback>">
```

**Важный нюанс.** Стили компонента нужно импортировать без обработки. То есть не нужно обрабатывать их через CSS 
Modules. Иначе точно что-то пойдет не так.


### Исходники vs Артефакты

Компонент поставляется как в виде исходников (папка `lib`), так и виде артефактов (папка `dist`, дефолтная точка входа).


## Публикация пакета
**Важно!** При публикации автоматически создастся коммит INFRA со специальным тегом публикации.

Поэтому лучше сначала отвести нужную ветку, внести правки и их закоммитить. А только потом вызвать скрипт публикации.
```
npm run package 1.2.3
```

## Код встраиваемого iframe
Код элементарный, но универсальный. Находится в `iframe-template/iframe.html`.
Если вдруг его нужно обновить, то можно поменять и руками положить по адресу
`https://yastatic.net/s3/psf/uxfeedback/iframe.html`

## Что же там под капотом?
Компонент встраивается через `iframe` (адрес на бескуковом домене, в нашем случае `yastatic.net`), общение происходит 
через `postMessage`. Поведение компонента сбора фидбека задается через админку. Например, можно задать появление только
на определенных страницах, после определенных действий и т.п. Также через админку можно настроить внешний вид 
компонента, виды пользовательских опросов и прочее.

Общение между компонентом и страницей сервиса двухстороннее.
- _Компонент => Родитель._ Например, когда компоненту нужно поменять своё визуальное отображение, он посылает сообщения
из iframe к родительскому окну с новыми стилями.
- _Родитель => Компонент._ Например, если мы скроллим страницу сервиса, а фидбек отображает всплывающее окно, то 
  родитель может отсылать событие скролла в iframe, чтобы тот мог перерасчитать стили отображения.

За обработку сообщений на стороне сервиса отвечает `UXFeedbackIframeController`. При использовании компонента 
`UXFeedbackComponent` контроллер создается автоматически. Но при желании можно передать и использовать свой.

## Особые сценарии

Иногда может понадобиться как отправить своё сообщение `iframe`, так и добавить свою логику обработки входящих
сообщений (или модифицировать текущую). Чтобы этого достичь, можно отнаследоваться от дефолтного контроллера и
добавить свою логику.
```tsx
import { UXFeedbackComponent, UXFeedbackIframeController, UXFeedbackIncomingMessage } from "@ps-int/ux-feedback";

class MyAwesomeController extends UXFeedbackIframeController {
  sendCustomMessage() {
    // Своё особое сообщение
    this.sendMessage({ type: 'uxfb/special-message', payload: { /*...*/ } })
  }
  
  override handleIncomingMessage(message: UXFeedbackIncomingMessage): void {
    // Дефолтная обработка
    super.handleIncomingMessage(message);
    
    // Обработаем новый особый тип сообщения
    if (message.type === 'uxfb/special-case') {
      //...
    }
  }

  override onStyleMessage(style: string): void {
    // Дефолтная обработка стилей
    super.onStyleMessage(style);

    // Выставим свой особый z-index
    if (this.iframe) {
      this.iframe.style.zIndex = 3000;
    }
  }
}

const myController = new MyAwesomeController();

// ...
<UXFeedbackComponent accountId="<id сервиса в UX Feedback>" uxfbController={myController}>
```

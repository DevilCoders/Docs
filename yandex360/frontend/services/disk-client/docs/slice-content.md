Срез фото в Диске
===

Как устроен срез.
----------

Полезные ссылки:
### [работа с REST-API] (https://tech.yandex.ru/disk/api/concepts/quickstart-docpage/)
### [описание ручек для среза] (https://beta.wiki.yandex-team.ru/disk/photoslice-smartcache/#spisokruchek)
### [архитектура среза] (https://beta.wiki.yandex-team.ru/esd/frontend-photoslice/)
### [синхронизация среза] (https://wiki.yandex-team.ru/disk/photoslice-smartcache#spisokdelt)

Для работы среза используем следующие запросы в REST:
(для работы с ручками из REST-апи используем descript-блок `cloudAPI`)

  * инициализация среза
      - принимает параметр - тип кластеризации (по умолчанию `geo`)
      - возвращает id снапшота и номер ревизии, продлевает жизнь снапшота на сервере на 1 день
  * получение снапшота
      - принимает параметры - id снапшота, номер ревизии (те, которые вернул запрос инициализации среза)
        и набор полей, которые надо вернуть (запрашиваем только index - то есть только данные о кластерах, без их записей)
      - возвращает данные про все кластеры среза, без данных о записях каждого кластера
      - на сервере препроцессим полученные данные, чтобы облегчить размер ответа, передаваемого на клиент
        (гео-данные приходят на всех возможных языках)
  * получение записей кластеров
      - принимает параметры - список id-ников кластеров и id снапшота, номер ревизии (те, которые вернул запрос инициализации среза)
      - возвращает записи для каждого кластера, которые содержат id ресурса, без данных о самом ресурсе
  * получение изменений среза
      - принимает параметры - id снапшота и номер текущей ревизии (послейней, чьи изменения применены к снапшоту на клиенте)
      - возвращает изменения снапшота - от переданной ревизии до текущей

и ручка mpfs:

  * балковая ручка получения данных о ресурсах (bulk_info)
      - примимает список id ресурсов
      - возвращает данные (info) для каждого ресурса из переданного списка



Модели для среза, основные (для хранения данных):
----------

  * snapshot
      - модель коллекция кластеров
      - содержит все кластеры загруженного снапшота
      - содержит ссылку на модель `sliceContent`, которую наполняет своими данными порционно
        (изначально туда попадают только первые 100 кластеров,
         затем, по необходимости, по запросу вьюшки или модели,следующие порции кластеров)
         это сделано, чтобы не отрисовывать сразу все кластеры пользователя, их может слишком много
      - нужна для отрисовки диалога фастскролла
      - данные модели (без данных о записях каждого кластера) сохраняются в локальном хранилище при загрузке снапшота

  * sliceContent
      - модель коллекция кластеров
      - нужна для отрисовки листинга среза
      - есть ссылка на модель `snapshot` для наполнения новыми порциями данных и запросов структуры кластеров
        (нужен номер ревизии, эти данные хранятся только в главной модели с данными снапшота)
      - делает сгруппированные запросы за структурой кластеров и за данными о ресурсах
        (необходимость загрузить данные исходит от модели конкретного кластера, а там, в свою очередь, от вьюшки, но
        ручки предусматривают возможность сгруппированного запроса, поэтому делаем группировку параметров в родительской модели)

  * clusterSlice
      - модель коллекция записей кластера
      - есть ссылка на родительскую модель `sliceContent` (для связи посредством событий и загрузки структуры кластера и данных о ресурсах)
        (сам запрос делает родительская модель - чтобы иметь возможность группировать параметры запроса)
      - `.id` кластера - это поле для сортировки кластера в коллекции всех кластеров

  * recordSlice
      - запись кластера
      - есть ссылка на модель `resource` (в данных самой модели `recordSlice` нет данных о ресурсе, только id)
      - реагирует на события от связанного с ним ресурса (удаление, загрузка, скрытие, создание клона (перемещение/переименование)
      - `.item_id` - поле для сортировки записи в коллекции записей кластера

вспомогательные модели (для запросов):

  * initSnapshot - для инициализации снапшота
  * getSnapshot  - для получения данных снапшота (кластеров снапшота)
  * getClusters  - для получения записей кластеров
  * getDiff      - для получения изменения снапшота

и соответственно модели-операции:
  * operationInitSnapshot
  * operationGetSnapshot
  * operationUpdateSnapshot



Вьюшки для среза:
------

  * sliceContent
      - коллекция кластеров
      - отображает все кластеры модели `sliceContent`, кроме пустых (`.isEmpty`)
      - обеспечивает наполнение `sliceContent` следующими порциями данных (если они есть), если долистали до конца вьюшки
      - размеры каждого кластера соответствуют его содержанию, поэтому высота вьюшки соответствует действительности
        (это сделано, чтобы иметь возможность листать файлы в срезе обычным скроллом, в каком бы месте мы не находились)
      - при открытии среза, скролинге или ресайзе окна - проверяет какая часть среза попадает в видимую область
        и обеспечивает загрузку всех необходимых данных для отображения фото в данной области
        (на самом деле видимая область берется с запасом - это вьюпорт + фиксированная высота в обе стороны)
      - загрузка данных - сначала определяется какие кластеры попали в видимую область,
        затем каждый кластер определяет какой кусок его записей попал в видимую область
        (причем если не загружена структура кластера, сначала грузим ее, а затем вычисляем id-ники ресурсов)
      - при скроллинге, данные запрашиваем только на окончание скролла
      - при быстром скролинге видимая область тоже проверятся, но ресурсы не грузятся,
        в этом случае надо только обновлять данные о видимом кластере, чтобы менять заголовок в процессе скролла
      - при проверке на вхождение в видимую области, все, что в нее не попало - скрывается,
        а именно это абсолютно спозиционированные item'ы и заглушки кластеров, которые в данный момент не видно,
        это нужно для облегчения reflow - DOM-дерево в срезе может быть довольно жирным

  * clusterSlice
      - коллекция записей кластера
      - состоит из контейнера для дочерних вьюшек (`itemSlice`) и контейнера для заглушек,
        и те и другие позиционируются абсолютно внутри своих контейнеров
      - при отрисовке вьюшки кластера, ей сразу проставляются ее размеры (ширина и высота),
        это возможно сделать, т.к. данные о количестве записей в кластере известно сразу
      - пока у кластера не загружены данные про его записи, отрисованы только заглушки
        (и то если был "сигнал" от вьюшки о необходимости показать заглушки - если кластер оказался в видимой области)
      - дочерняя вьюшка `itemSlice` появляется в коллекции только тогда, когда загружена соответствующая модель `resource`
      - вьюшка обновляет позиции своих дочерних вьюшек и размер сетки, в связи с изменением в коллекции своих записей
      - значения для позиционирования закешированы и лежат в замыкании, пересчитываются при изменении ширины

  * itemSlice
      - запись кластера (фото)
      - вьюшка наследуется от вьюшки `resource`
      - зависит дополнительно еще и от модели `recordSlice`
      - абсолютно позиционируется в контейнере родительской вьюшки `clusterSlice`
        (абсолютное позиционирование сделано, для того, чтобы можно было отрисовать любой диапазон записей кластера,
        например, в видимую область попадает только конец кластера, т.е. загружены только последние ресурсы,
        их нужно расположить на своих местах, несмотря на то, что будут загружены не все данные)
      - позиционируется вьюшка по событию изменения соответствующего поля модели `recordSlice`

  * fetchSnapshot
      - вьюшка для загрузки снапшота
      - показывается пока модель `snapshot` не будет "готова" (загружены данные и выставлен признак `inited`,
        это условия для того, чтобы по данным модели можно было отрисовывать вьюшки)
      - тут реализована логика загрузки снапшота:
        а) сначала сходить за данными в локальное хранилище
        б1) если данные есть - восстановить их до актуального состояния
        б2) если данных нет - получить их



Загрузка снапшота
------

1) Получение данных (случай, когда данных в локальном хранилище нет)
   метод `fetchSnapshot` модели `snapshot`

   - сначала нужно проинициализировать снапшот (`operationInitSnapshot`)
   - в результате получим `id` и `revision`
     (эти данные нужны для получения данных снапшота (кластеров) и получения структуры (записей) для каждого кластера)
   - затем можно получить данные снапшота (`operationGetSnapshot`)
     (тут получаем только данные о самих кластерах, структуры каждого кластера по необходимости будут запрошены во вьюшке отдельно)

2) Восставновление данных (случай, когда в локальном хранилище есть данные)
   метод `restoreSnapshot` модели `snapshot`

   - в модели `snapshot` находятся данные из локального хранилища (но пока поле `.inited` равно false)
   - сначала все равно нужно проинициализировать снапшот на сервере (`operationInitSnapshot`)
     (то, что есть в локальном хранилище может быть уже не актуально, например, на сервере этот снапшот может быть уже удален)
   - в результате инициализации получим `id` и `revision`
   - если `id`, которое получили в результате инициализации отличается от того, что был сохранен локально - значит
     сохраненных снапшот уже не актуален - идем за данными (`operationGetSnapshot`)
     (при этом неактуальные данные, которые находятся в модели после получения их из локального хранилища
     не будут отрисованы все это время, благодаря полю `.inited`,
     оно выставляется в true только когда данные в модели `snapshot` готовы к отрисовке)
   - если `id`, которое получили в результате инициализации совпадает с тем, что был сохранен локально -
     значит на сервере все еще живет тот же самый снапшот
     (снапшот после инициализации живет сутки, каждая инициализация - продлевает его жизнь на сутки с момента инициализации),
     в таком случае нам нужно запросить изменения для него (`operationUpdateSnapshot`)
   - в случае ошибки обновления данных (например, снапшот мог быть удален в момент, когда мы за ним пошли),
     запрашиваем данные (`operationGetSnapshot`)



Обновление снапшота (`operationUpdateSnapshot`)
--------

происходит в 2 случаях:
1) обработка пуша про изменения в срезе
2) восстановление данных снапшота, сохраненных в локальном хранилище

   - запрос обновлений снапшота (`getDiff`) выполняется с номером ревизии `.revisionNew`
     (этот номер сначала совпадает с номером ревизии, полученным в результате инициализации снапшота,
     а затем обновляется с каждым новым наложенным на снапшот обновлением)

     таким образом в модели `snapshot` есть 2 поля с номером ревизии:
     `.revision` - с этой версий надо ходить за структурой кластера (записи кластера)
     `.revisionNew` - с этой версией надо ходить за обновлениями

   - изменения снапшота это массив изменений данных от версии к версии
   - изменения могут быть 2 видов:
     - изменения самого снапшота (про кластеры): добавление, удаление, обновление кластера
     - изменения кластера (про записи): добавление, удаление, обновление записи конкретного кластера
       (обновление записи - бывает при переименовании/перемещении - когда на имеющейся позиции `.item_id` меняется id-ник ресурса)

   - изменения про кластеры применяем всегда сразу
     (при добавлении нового кластера, в зависимости от места, куда он был добавлен, он вставляется или только в модель
     `snapshot` или же и в `sliceContent` тоже, в зависимости от того, сколько туда загружено порций)

   - изменения про записи применяются сразу, если структура кластера, в котором произошли изменения загружена
     (то есть есть данные про все записи данного кластера)

   - изменения про записи сохраняются в кластер (в поле`.diffRecords`), если его структура еще не загружена
     (при загрузке структуры, если есть сохраненных изменения - они будут сразу применены)


Примеры запросов данных среза
-----------

  * Инициализация снапшота, получение данных снапшота (запросы на qa)
    ```
    curl -X POST -H 'Authorization:Internal client_id=yadisk-web;client_name=yadisk-web' 'http://api01h.qa.disk.yandex.net:8080/v1/{uid}/disk/photoslice?clusterization_type=geo'

    curl -H 'Authorization: Internal client_id=yadisk-web;client_name=yadisk-web' 'http://api01h.qa.disk.yandex.net:8080/v1/{uid}/disk/photoslice/{id}?cluster_ids=index&revision={revision}&fields=clusters' -v

    ```

  * Уничтожение снапшота (в тестинге и на qa)
    ```
    http://smartcache-worker01h.dst.yandex.net:32470/smartcache/photoslice-drop-snapshot?__uid={uid}

    http://disk-smartcache-worker.smartcache-worker01e.qa.disk.yandex.net:32470/smartcache/photoslice-drop-snapshot?__uid={uid}&__result-type=json

    ```


  * Полезно бывает посмотреть в консоли:
    ```js
    var snapshot = ns.Model.getValid('snapshot', {idContext: '/photo'});

    var sliceContent = ns.Model.getValid('sliceContent', {idContext: '/photo'});

    var clusterSlice = ns.Model.getValid('clusterSlice', {id: '', idSlice: ''});

    var recordSlice = ns.Model.getValid('recordSlice', {id: '', idSlice: ''});

    // xiva-пуши
    ns.Model.get('subscriptionXiva').transport.on('message', function() {console.log(arguments)});
    ```



Хочется в одном документе собрать формальные правила верстки, принятые внутри команды Диска, в соответсвии с  [методологией БЭМ](http://ru.bem.info/method/definitions/).

### Правила именования блоков

В именовании придерживаемся классической нотации, придуманной в Яндексе:

```
block__element_modifier[_value]
```

Составные названия сущностей пишутся через дефис, например, `my-super-block`.

### Линейная структура в именовании элементов

Следует поддерживать линейную структуру в именовании элементов, например, такого имени элемента:

```
tabs__item__title
```

быть не может. Сразу видно, что это попытка перенести вложенность элементов в дом-дереве (очевидно, что этот элемент — текст внутри таба), но этого делать не стоит.

В данном случае, можно написать:

```
tabs__item
tabs__title
```

или, если `tabs__title` уже есть:

```
tabs__title-item
```

### О файловой структуре

Общее правило для положения блоков на файловой системе — блок со всеми своими технологиями реализации (yate, js, css, md и т.д.) живет в отдельной папке. Имя папки совпадает с именем блока.

В Диске блоки хранятся в папках `nanoblocks` или `views`, в последней находятся ns-вьюшки, которые тоже являются блоками в общем смысле.

### О структуре внутри файла стилей

Удобно структурировать стили следующим образом:

```
 // блок
 .block

 // модификаторы блока
 .block_mod1
 ...
 .block_mod2
 ...

 // один элемент
 .block__elem1
    ...
    ...

    // модифицируем элемент, используя каскад с модификатором блока
    .block_mod1_val1 &
    ...
    .block_mod1_val2 &
    ...
    .block_mod2_val1 &
    ...

// модификаторы элементы
.block__elem1_mod1


 // другой элемент
 .block__elem2
    ...
    ...

    .block_mod1_val1 &
    ...
    .block_mod2_val2 &
    ...
    .block_mod2_val1 &
    ...

// модификаторы элементы
.block__elem2_mod1
```

Допустимо использовать модификаторы без значений, если модификатор имеет всего одно значение (обычно это `true` или `yes`, показывая какое-либо состояние).

Например, лучше писать `.block_hovered` вместо `.block_hovered_yes`, но может быть `.block_state_hovered` и `.block_state_pressed`.

### Контекстные переопределения и доопределения блоков

Пусть есть блок `sidebar` и в нем есть блок `button`. Мы хотим задать внешний отступ или как-то спозиционировать кнопку в сайдбаре.

В таком случае, удобно «примешать» к кнопке элемент сайдбара:

```
// где-то в сайдбаре
.nb-button({
    'class': 'sidebar__button'
    'content': 'Привет'
})
```

А стили писать в файле стилей блока `sidebar`:

```css
.sidebar__button
{
    position: absolute;
    left: 10px;
    top: 10px;
}
```

Не стоит переопределять используя каскад:

```css
.sidebar .nb-button
{
    ...
}
```

Интуитивно понятно, что это допустимо в том случае, если по смыслу `nb-button` может встретиться внутри сайдбара один раз, однако, как показывает практика это предположение оказывается неверным — интерфейс живет.

Если хочется переопределить внутренности кнопки, то возможны два варианта:

* что-то пошло не так: возможно, это ошибка дизайна
* это модификатор блока кнопки, эта «новая кнопка в сайдбаре» может встретится не только в сайдбаре

В любом случае, не стоит переопределять внутренности блока используя контекст.

### О специфичности селекторов

Иногда так бывает (хотя, в теории не должно), что правила простого селектор вида `.sidebar__button` не может пересилить библиотечные правила селектора `.nb-button`, в таком случае приходится усиливать специфичность селектора:

```css
.sidebar__button.nb-button
{
    ...
}
```

Если пересилить не удается, не стоит писать `!important`, скорее всего, что-то пошло не так (видимо ошибка в проектировании самого блока, т.е. его собственная специфичность всегда должна быть равно `0000`, стоит разобраться).

### Возможности ЦСС-препроцессора

Stylus позволяет писать чуть короче, используя амперсанд (`&`) и табуляцию.

Запись

```
.block__el
    ...

    .block_mod1 &
        ...
```

эвивалентна

```
.block__el
    ...

.block_mod1 .block__el
    ...
```

Допустимо писать и так и так.

### Префиксы блоков

Традиционно всем блокам ставился префиксы `b-` для избежания коллизий со старой версткой или сторонними сайтами (например, когда верстаем виджет).

По сути, префикс блоков с точки зрения ЦСС — пространство имен, нативной поддержки которого нет.

Однако, отстутсвие какого-либо префикса — само по себе пространство имен, т.к. у нас на проекте все версточные сущности это блоки, то дополнительного уточнения не требуется.

На проекте присутствуют блоки с префиксом `nb-` — это блоки библиотеки `nanoislands`.

### Вынесение элементов в функции

Для понятности кода принято решение выносить большие элементы в функции yate, или, если в конкретном случае это удобней, в отдельные apply. Таким образом можно не вчитываться в большой кусок html кода, а сразу понять что это за элемент из названия функции. В идеале в match блока мы должны видеть его полную структуру.

Запись

```
.match .aside ns-view-content {
    <div class="aside__resource">
        if hasPreview {
            aside__preview(.meta.sizes[ .name == 'DEFAULT' ])
        } else {
            aside__icon(.type)
        }
        aside__title(.name)
        apply . aside__details
    </div>
}
```

Декларация блока, т.е. матчи для `ns-view-content` или `nb`, лучше располагать выше всего, а элементы блока опускать ниже. На сборку яте это не влияет (функции на уровне файлов могут объявляться ниже мест их вызова в матчах).

Если АПИ элемента состоит из нескольких полей, то лучше передавать один аргумент — нодсет с АПИ, чем большое количество аргументов в функцию.

Удобно видеть названия полей сразу при вызове.

```
aside__actions({
    'items': [
        {
            'name': ...
            'size': ...
        }
        {
            'name': ...
            'size': ...
        }
    ]
    'hasPreview': true()
})
```

### Правила именования функций и мод для apply

В yate функции, определенные вне match, глобальны и видны из других шаблонов.
Для того, чтобы обеспечить уникальность имен функций и мод для apply, принято именовать их так же, как мы именуем элементы блоков.

```
block__element_modifier[_value](params)

apply . block__element_modifier[_value]

```

### Реиспользование функций

Использовать функции чужих блоков нельзя. Если в block2 появляется элемент, очень похожий на элемент из block1, то возникает необходимость его реиспользовать. В таком случае следует подумать о том, чтобы вынести его в отдельный блок, т.к. элемент — сущность, которая не существует вне своего блока. Использовать функции вида block1__elem где-то в шаблоне block2 — нельзя .

Если же функция, которую хочется реиспользовать, по сути не является элементом блока, а выполняет какое-то действие, т.е глагольная функция (get-name, calc-value), то следует подумать о том, чтобы создать подходящий external.


### О переопределении поведения вложенных блоков для составных блоков

Зачастую блоки содержат в себе другие блоки.

```
match .my-block nb {
    <div class="my-block" data-nb="my-block">
        apply . nb-main-attrs

        nb-button(...)
    </div>
}
```

Бывает так, что хочется расширять параметры вложенных блоков в местах вызова основного блока. Для этого был придуман следующий интерфейс, который каждый сложный блок должен реализовывать:

```
my-block({
    'class': '...'
    ...
    'extendNested': {
        'button': {
            // АПИ кнопки: переопределение и доопределение
            // тех параметров, что есть внутри блока
            'class': ...
            'attrs': {
                ...
            }
        }
        // декларация других вложенных блоков
    }
})
```
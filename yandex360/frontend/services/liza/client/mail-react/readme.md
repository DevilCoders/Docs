# React + MobX - дивный новый мир
Чем-то напоминает MVC.
Но поскольку в сердце этого подхода MobX - получаем data driven interface:
так же как в redux интерфейсом управляют данные. Изменились данные - происходит перерисовка тех, кто эти данные
использовал при рендеринге. Автоматически. Руками вызывать `component.forceUpdate()` не надо (за нас это делает
MobX).

## model
- модели с данными с сервера (примеры Folder.js, Label.js, SuggestItem.js) - в них лежит
большое observable поле `data` с данными as is, которые пришли с сервера. Файлы моделей лежат в папочке `models/`
- State модели - модели, описывающие состояние интерфейса.
Лежат рядом с компонентом, где они применяются и из которого пробрасываются ниже во вложенные компоненты.

## store
- хранят модели (как правило observable)
- знает только про себя и про свои данные
- не занимается точечной модификацией данных (кроме подновления данных ns моделей по событию `ns-model-changed`)
- тут же удобно держать методы, которые возвращают часть данных из store-ов
(к примеру, `foldersStore.foldersForSearch` возвращает папки для отображения в поисковых фильтрах - все, кроме
исходящих и спама, или `labelsStore.getLabelById(lid)`)
- тут же какие-то computed поля (для производительности, computed поля кэшируются)
- внутренности:
  - сторы подписываются на ns модели и отвечают за то, чтобы подновить свои данные при их (моделей) изменениях

Формат декларации:
```js
import StoreBase from './StoreBase';

export default class LabelsStore extends StoreBase {
    // Вначале указываем данные.
    @observable data;

    // Затем конструктор.
    constructor() {}

    // Под ним уже идёт бизнес логика.

    // Изменения своих данных (приватные action методы).
    @action _changeOwnData() {}

    // Вычисляемые данные, который будут кэшироваться.
    // При вычислениях должны быть использованы observable данные.
    @computed get someComputedValue() {}
}
```

## service (чем-то похож на controller из MVC)
- имеет доступ к store-ам и другим service-ам
- занимается запросами, покладкой в store-ы, модификацией данных в store-ах
- как правило, там `@action` методы

## component
- ui-components - тут лежат внешние UI компоненты (сейчас это DatePicker и обёртки вокруг lego-on-react компонентов)
- components - функциональные компоненты, специфичные для почты
  - в папке компонента есть index.js (чтобы можно было делать `import SearchContainer from './SearchContainer'`)
  - если это HOC (high order component) для каждого подкомпонента делаем подпапку, где, как правило 3 файла:
    index.js, Component.js, Component.styl
  - могут быть State модели
    - State модель создаётся в компоненте Container-е и прокидывает ниже через `Provider`
    - она (State модель) не хранится в store, так мы ограничиваем доступ к state модели компонента (доступ у
    компонента-контейнера и всех желающих вложенных компонентов)
  - через `Provider` прокидываются так же store-ы и service-ы, но как правило, нужно стараться их не использовать
  (хороший пример - `AdvancedParamsFolder`, который использует список папок, который мы прокинули из
  `SearchContainer` и `searchQuery` - модель с текущими поисковыми параметрами)
  - реакции, нужные компоненту, выносим в отдельные файлы и кладём рядом (в ту же папку) с компонентом
  потребителем (пример `searchSuggestReaction`, которая лежит рядом с компонентом `SearchSuggest`)

## reaction
- выносим в отдельные файлы
- есть базовый класс `ReactionBase`
  - реакция активна сразу после создания `this._searchReaction = new SearchReaction(searchStore, routerStore, searchService);`
  - для отмены есть метод `cancel()` - `this._searchReaction.cancel()`
- выносить в отдельный файл реакции хорошо, потому что так их можно будет отдельно тестировать
- naming: `WhatEverReaction.js`
- доки https://mobx.js.org/refguide/reaction.html

## MobX
- `@observable` (mobx) - чтобы MobX узнал о том, что нужно отслеживать какие-то данные нужно их
отметить атрибутом `@observable`. В этом случае при изменении таких данных MobX будет знать про это, автоматически.
- `@observer` (mobx-react) - этим атрибутом помечаются React компоненты, которые должны автоматически перерисовываться
при изменении данных. Каких именно данных? - Тех, что использовались во время выполнения метода `render()` компонента.
MobX сохранит у себя список observable переменных, которые использовались, и как только хотя бы одна из них изменится -
выполнит перерисовку компонента. Конечно, MobX оптимизирует внутри себя перерисовки, об этом заботиться не нужно.
Кроме того, список observable переменных динамический: если компонент отрендерился и список был `[a,b,c]` - слушаем
изменения этих 3 переменных. Допустим изменилась `b` - компонент перерисовывается и уже использовались `[a,c]` -
изменения `b` нас перестают интересовать и перерисовок при изменении `b` не будет.
- `@action` (mobx) - если мы хотим поменять пачку из нескольких observable переменных, но не хотим, чтобы на каждое
изменение выполнялись реакции - можно сгруппировать эти изменения в "транзакцию" - отметить метод, в котором выполняется
массовая модификация атрибутом `@action`
- `@computed` (mobx) - данным атрибутом можно пометить свойство, внутри которого выполняются вычисления с использованием
observable данных. Тогда вычисления выполнятся один раз, значение будет закэшировано и при обращении к свойству
будет отдаваться это закэшированное значение (оптимизация). И так до тех пор, пока не изменится какое-то из
observable значений, тогда кэш сбрасывается и при очередном обращении к свойству снова выполнятся вычисления и
снова закэшируется новое вычисленное значение. Имейте ввиду, что кэширование работает только пока есть активные подписки
на данное компьютед поле (ну т.е. это не просто memoize, тут важно, чтобы кто-то эти данные слушал). Подробнее
https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#computed-values
- `reaction()` (mobx) - позволяет декларативно описать конструкцию "при изменении таких-то данных нужно выполнять
такие-то действия". К примеру, при изменении урла - нужно обновлять title страницы.
- `autorun()` (mobx) - тоже самое, что `reaction()`, только список наблюдаемых данных вычисляется автоматически
во время выполнения тела autorun функции. К примеру, "показать домик, если пользователь не авторизован".
Проверяем авторизацию пользователя (подписываемся на нужные поля), если нужно - показываем домик.
Авторизация изменилась - запускается autorun (потому что мы MobX подписался на изменения полей) - снова проверяем
и снова если нужно показываем домик.
- `Strict` mode - режим работы MobX, при котором нужно обязательно заворачивать изменения observable данных в action.
Мы его тоже включили, чтобы явно понимать, где изменяются данные.
Подробнее тут https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#usestrict

## Особенности React + MobX
- `ref`-ы: если у компонента стоит атрибут `@observer` - MobX создаёт обёртку вокруг React компонента.
В обертке по умолчанию задается `React.forwardRef` на обернутый компонент, поэтому в рефах доступны сразу настоящие компоненты
- `runInAction` - используем, когда нужно выполнить асинхронно несколько раз изменение одного и того же поля стора (
например, после действия - функция возвращающая промис). Если в этом случае его не использовать, то состояние не проставится
 как нужно. Например:
```js
import {  runInAction } from 'mobx';
...
try {
      await doAction.call(this, currentAction.params);
           runInAction(() => { currentAction.status = 'done'; });
} catch (error) {
           runInAction(() => { currentAction.status = 'error'; });
           return Promise.reject(new Error('Error: ' + error));
}
```
Подробнее https://mobx.js.org/best/actions.html#the-runinaction-utility

## Тесты React + Mobx
- [тесты](testsReact.md)

## Как уживаемся с noscript
- ns.request => transport.request
- ns.forcedRequest => transport.forcedRequest
- не должно быть обращений к `ns.*` (`ns.Model`, `ns.request`, `ns.page`), кроме store-ов и service-ов, ещё можно в
utils, но очень очень очень осторожно. Стремимся к тому, чтобы обращений к `ns.*` было минимально.
- про модели `ns.Model`
  - наружу их не выставляем / не отдаём (не делаем так: searchService.getSuggest() => Array.<ns.Model>)
  - данные их ns моделей перекладываем в новые модели (можно сказать, MobX модели)

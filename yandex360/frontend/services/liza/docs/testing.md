# Yandex Mail Tests

## Введение

- Первое, пишите тесты!
- Второе держите тесты как документацию к вашему коду. Не надо
привносить ненужную логику в виде динамической генерации тестового кода
и беспощадного соблюдения DRY!!!
- Третье, тесты должны быть простыми.

**Перед написанием тестов, настоятельно рекомендую
прочесть документацию по chai.js и sinon.js,
чтобы знать какие возможности уже есть.**

Тесты являются важной и **неотъемлемой** частью процесса разработки программного
обеспечения. Большой и здоровый проект не может существовать без тестов, это доказано.
Хорошо написанный тест позволяет:

 + Улучшить качество кода
 + Автоматически протестировать поведение/контракт
 + Описать как пользоваться вашим модулем

Если следовать методологии TDD/BDD, то сначала пишется тест, а потом уже код.
Когда вы начинаете писать тест, то автоматически становитесь первым пользователем
который использует ваш модуль, при этом **ничего не зная о реализации!**
Это очень важный момент, который отличает написание тестов до и после.

Такой подход позволяет вносить только то, что необходимо
в данный момент. Так как код необходимо протестировать
то вы волей-неволей будете разбивать его на изолированные части
для более удобного тестирования (модульность).

Пока вы ничего не знаете о реализации, вы будете тестировать
поведение. Это хороший подход для написания тестов, так
как он позволяет писать более устойчивые/крепкие тесты.

Если вы будете тестировать внутреннюю логику вашего модуля,
тесты будут быстро распухать, становиться хрупкими и при малейшем
изменении поведения внутри модуля вами придется переписывать тесты,
это **не правильно и это раздражает!**.

**Всегда старайтесь тестировать поведение!**

Поведение - это то, что вы предоставляете конечным пользователям вашего модуля, публичный API и контракт.

## Структура

По историческим причинам, используем зеркальную структуру тестов.
Это позволяет быстро сопоставить тесты с исходными файлами и наоборот.

- `mail/modules`
    - `**/actions/**/*.js`
    - `**/views/**/*.js`
    - `**/models/**/*.js`
    - `**/js/**/*.js`
- `test/unit`
  - `mail/modules`
    - `**/actions/**/*.js`
    - `**/views/**/*.js`
    - `**/models/**/*.js`
    - `**/js/**/*.js`


## Инструментарий

Для написания тестов мы используем:
- [karma](karma-runner.github.io) - Инструмент для запуска тестов
- [mocha](https://mochajs.org/) - Фреймворк для написания тестов
- [sinon](http://sinonjs.org/) - Библиотека для подмены и слежения за функциями
- [chai](http://chaijs.com/) - Библиотека assert'ов

Karma - это замечательный *test runner*, который позволяет избавиться от файла index.html(файл index.html нарушает принцип DRY),
дает возможность запускать тесты на [CI](http://en.wikipedia.org/wiki/Continuous_integration), в нашем случае это Trendbox,
скорость, гибкость и простоту. Так как karma запускает собственный web сервер, то
тесты можно прогонять на бесконечном числе браузеров, надо просто зайти на host,
где запущена karma (по умолчанию это http://localhost:9876/) через браузер, на котором вы хотите запустить тесты.
Более подробно про karma вы можете прочитать на их [сайте](http://karma-runner.github.io/0.10/index.html).

### Установка

Необходимо выполнить `make` внутри проекта.

### Запуск

В общем виде карма запускается так:

```
$ karma start
```

Опции:
 * `--port 9878` - запустить на указанном порту
 * `--single-run=false` - запустить в режиме watch. В этом режиме можно зайти из браузера на `https://mailfront2.yandex.ru:<port>`.
 debug-режим доступен на `https://mailfront2.yandex.ru:<port>/debug.html`

Для запуска всех тестов и линтеров в консоли, необходимо внутри папки проекта выполнить команду `npm test`.

```bash
  npm run-script karma-test
```
или

```bash
  ./node_modules/karma/bin/karma start karma.conf.js
```

Тесты со сборкой и обновлением субмоделей
```bash
npm run-script unit-test
```

**Замечание:** _желательно, чтобы перед запуском тестов шаблоны были скомпилированы, а submodules обновлены_.

Если вы хотите, чтобы тесты прогонялись каждый раз при изменении файлов (файлов, которые указаны в `karma.conf.js`)
то необходимо выполнить следующую команду:

```zsh
  npm run-script karma-watch
```

```zsh
  ./node_modules/karma/bin/karma start karma.conf.js --single-run=false
```

Для выхода из режима `watch` достаточно нажать <C-c>.

Также последний пример показывает, как можно переписать настройки karma, выставленные по умолчанию,
необходимо просто передать их в виде опций, как в примере `--single-run=false`

### Проблемы

1. Karma запускает свой сервер, поэтому порт, указанный по умолчанию, может быть занят (это очень актуально для mailfront2).
Чтобы решить эту проблему, достаточно выполнить команду:

```zsh
  ./node_modules/karma/bin/karma start karma.conf.js --port=<PORT>
```

Вместо <PORT> необходимо указать номер свободного порта.

2. Могут быть проблемы с установкой **phantomjs** на mailfront2.
В этом случае нужно обратится к разработчикам за помощью. Они с радостью помогут!
По умолчанию phantomjs идет вместе с karma-phantomjs-launcher.
Поэтому, отдельно его ставить не надо.

## Создание теста

  * Если тестируемый функционал, определен в одном файле (вид, модель, модуль и т.д.),
  то файл теста должен быть назван так же и должен располагаться по тому же пути относительно папки `/test/unit`.

    Например, есть файл `/mail/modules/mail/js/components/geolocation.js`.
    Файл с тестом должен быть таким: `/test/unit/mail/modules/mail/js/components/geolocation.js`.


### Тестируемый файл

Чтобы добавить новый тестируемый файл, путь к нему необходимо
добавить (через borschik) в один из добавленных в karma.config.js файлов
или же добавить файл напрямую в karma.config.js (поле *files*).


### Шаблон тестового файла

Так как мы считаем, что отдельный файл это модуль, то внутри тестового файла должен быть один общий
на весь файл `describe`.
В качестве описания используйте название файла (без расширения).
Так проще понять какой тест упал.

Пример тестового файла для example.js
```javascript
describe('example', function () {
  ...
})
```

**При написании тестов следует соблюдать правила, которые используются в проекте:**
* [Общие правила](https://github.yandex-team.ru/Daria/codestyle/blob/master/README.md)
* [Правила для тестов](https://github.yandex-team.ru/Daria/codestyle/blob/master/js-test.md)


## Использование Sinon

  Стабим по умолчанию:
    * `_.debounce`
    * `_.throttle`
    * `_.defer`


### sinon.sandbox(this.sinon) vs sinon

Внутри любого теста есть переменная окружения `this.sinon`.
`this.sinon` - это песочница, которая восстанавливает функции после
каждого теста, поэтому вам **не надо писать `restore` после каждого теста**
если вы используете `this.sinon`. Доступ к глобальному `sinon` оставлен,
но рекомендуется использовать `this.sinon`

Пример кода с использованием `this.sinon`
```javascript
beforeEach(function() {
    this.sinon.stub(Daria, 'now').returns(1000);
});

it('Должен вернуть 1000', function() {
    expect(Daria.now()).to.be.equal(1000);
});
```

Во втором примере вам не надо восстанавливать Daria.now после каждого теста.
`this.sinon` снижает количество кода не относящегося к тесту
и снижает шанс ошибки что вы забудите восстановить функцию.

`this.sinon` определен в файле **test/helpers/unit_helpers.js**


### this.sinon.stub

Порой функция или метод, который вы тестируете зависит от других функций, объектов и методов,
если вы хотите разорвать эту зависимость, то вам надо использовать `sinon.stub`.

`sinon.stub` **заменяет оригинальную функцию на пустую** и позволяет
вам контролировать что вернет эта функция. Также `sinon.stub` позволяет
проверить с какими параметрами была вызвана stub функция.

Пример:

Тестируем метод `afterBlockInitialize` класса `Jane.Block.Messagesitem`.
Наш метод зависит от двух других методов этого-же объекта, но
мы не хотим тестировать эти методы в тестде для afterBlockInitialize, мы
хотим показать только связь тестируемого метода с завимостями

```javascript
describe('Jane.Block.Messagesitem.afterBlockInitialize', function() {
    var MessagesItem = Jane.Block.MessagesItem;

    beforeEach(function() {
        this.sinon.stub(MessagesItem, 'changeBlockClass');
        this.sinon.stub(MessagesItem, 'insertBlockToDocument');
    });

    it('Должен вставить блок в документ', function() {
        MessagesItem.afterBlockInitialize();

        /*
         * Код внутри функции insertBlockToDocument не выполняется
         * Но мы можем показать что функция insertBlockToDocument должна
         * быть вызвана в нашем методе
         */
        expect(MessagesItem.insertBlockToDocument).to.have.callCount(1);
    });

    it('Должен изменить основной класс блока', function() {
        MessagesItem.afterBlockInitialize();

        expect(MessagesItem.changeBlockClass).to.have.callCount(1);
    });
});
```


### Заметки

**sinon.stub** по умолчанию заменяет функцию на пустую,
поэтому запись вида `this.sinon.stub(Daria, 'now', $.noop)` избыточна,
можно просто записать `this.sinon.stub(Daria, 'now')`.

-------------

Запись вида `Daria.now = this.sinon.stub()` **не восстановит функцию** после исполнения тестов.
В этом случае, *sinon* не знает ничего про оригинальную фукнцию и объект, которому она принадлежит.
 **Для правильной работы** всегда надо использовать запись вида `this.sinon.stub(Daria, 'now')`.

-------------

**sinon.stub** позволяет заменять не только методы, но и свойства
объекта. Например, мы хотим изменять в нашем тесте свойство *Daria.Config.locale*,
для этого мы можем написать такой код:

```javascript
describe('Промо', function(){
    beforeEach(function() {
        this.sinon.stub(Daria, 'locale', '2pane');
    });

    it('Не должен показывать промо в трех-панельной почте', function() {
        Daria.Config.locale = '3pane';

        expect(myPromo.check()).to.be.eql(false);
    });
});
```

Перед вызовом каждого теста `Daria.Config.locale` будет равно *2pane*.
Внутри тестов мы можем спокойно менять его значение, не боясь
что это повлияет на другие тесты. После завершения теста *sinon*
будет восстанавливать значение Daria.Config.locale на оригинальное(какое оно было перед тестом).

Пример демонстрирующий работу `sinon.stub`:
```javascript
describe('Промо', function(){
    var originalLocale = Daria.Config.locale;

    beforeEach(function() {
        Daria.Config.locale = '2pane';
    });

    afterEach(function(){
        Daria.Config.locale = originalLocale;
    });

    it('Не должен показывать промо в трех-панельной почте', function() {
        Daria.Config.locale = '3pane';

        expect(myPromo.check()).to.be.eql(false);
    });
});
```


### [Тестирование ns.layout](https://github.yandex-team.ru/Daria/liza/blob/master/test/helpers/assert-nslayout.js)

```js
it('1', function() {
    var layout = ns.layout.page('message', { ids: '1' });
    expect(layout).to.have.nsLayout({
        'message': {
            'message-body': {}
        }
    });
});
```


### Асинхронные тесты

Возможно использование двух способов создания асинхронных тестов:
  1. Вызов функции завершения выполнения теста.
     В этом случае обязательна обработка исключений! В противном случае тест завершится с ошибкой превышения таймаута.
  2. Тест возвращает промис.

```js
it('Асинхронный тест с вызовом функции завершения выполнения теста', function(done) {
    try {
        // ...
        done();

    } catch(e) {
        done(e);
    }
});

it('Асинхронный тест с возвратом промиса', function() {
    var promise = Vow.promise();
    // ... promise.fulfill() или promise.reject()
    return promise;
});
```

## Часто задаваемые вопросы

* Как запустить один тест?

  Используйте метод `only` функций `describe` и `it`.
  ```javascript
  describe.only('Запустить только этот тест', function() {
    ...
  })
  ```
  или
  ```javascript
  it.only('Запустить только это утверждение', function() {
    ...
  })
  ```
  После написания тестов **не забудьте** удалить `only`!

* Раньше я мог отлаживать тесты в браузере как теперь быть?

  Такая возможность осталась. Karma настолько мощный инструмент,
  что помимо вывода в терминал сообщений из `console.log` позволяет
  вам открыть тесты в браузере.
  Для этого необходимо запустить karma в режиме `watch`(описано выше как это сделать)
  и найти в терминале сообщение вида:

  ```bash
  INFO [karma]: Karma v0.10.2 server started at http://localhost:9876/
  ```
  В этом сообщение указано на каком host-е и порту запущен сервер karma.
  В моем примере на http://localhost:9876/ (учтите на daria2 localhost - это username.daria2.yandex.ru)
  Открываем в браузере страницу вида http://localhost:9876/debug.html и отлаживаем тесты в браузере.

* Можно запустить тесты локально?

  Да! Нынешние тесты не зависят от сервера и могут быть запущены локально.
  Единственное ограничение, это перед **первым запуском** тестов необходимо собрать
  некоторые зависимости (это пока что не обойти), для этого необходимо запустить `npm run-script unit-test`.

* Можно использовать, что-то кроме phantomjs?

  Да. Вы можете использовать любой браузер. Для того, чтобы
  выполнить на нем тесты, необходимо зайти на страницу где запущена *karma*.

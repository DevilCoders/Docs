# ns.View

## Декларация вида
```js
/**
 * @class Daria.vMyView
 * @augments ns.View
 */
ns.View.define('my-view', {

    events: {
        'ns-view-init': 'onInit',
        'ns-view-htmlinit': 'onHtmlInit'
        'ns-view-show': 'onShow',
        'ns-view-touch': 'onTouch',
        'ns-view-hide': 'onHide',
        'ns-view-htmldestroy': 'onHtmlDestroy',
        'ns-view-destroyed': 'onDestroy',
    },

    models: [],

    params: {
    },

    yateModule: 'left',

    ctor: function() {
    },

    /** @lends Daria.vMyView.prototype */
    methods: {
        onInit: function(){},
        onHtmlInit: function(){},
        onShow: function(){},
        onHide: function(){},
        onHtmlDestroy: function(){},
        onDestroy: function(){},
        onTouch: function(){},

        myMethod: function(){}
    }
})
```

Декларация вида (js) и его шаблон (yate) должны лежать в одной папке в папке `/mail/modules/<module>/views`.
Не стоит класть в одну папку много видов "потому что они вроде бы похожи", это затрудняет поиск и ваша логика объединения может быть непонятна коллеге.
Из этого правила есть исключение - это наследуемые виды, которые имеют один и тот же шаблон, их можно класть в одну папку.

Декларация вида **обязательно** должна включать в себя следующий jsdoc:
 - **@class Daria.vMyView** задает имя класса.
 Его потом можно использовать при поиске по символу в WebStorm (Cmd + o).
 - **@augments ns.View** задает родителя вида.
 Статический анализатор кода подхватывает эту конструкцию и начинает понимать конструкции типа ```this.getModel```, позволяя при необходимости перейти к определению этого метода.
 - **@lends Daria.vMyView.prototype** говорит, что в нижеописанном объекте лежат методы, которые потом попадут в прототип созданной вьюшки.
 Если из наследуемой вьюшки вы будете использовать метод, описанный в родителе, то опять же сможете правильно перейти к его определению.

Обратите внимание, что `events`, `models` и `params` расположены по алфавиту в самом начале декларации. Методы `methods` находятся после них. Сделано это для того, чтобы специфика вида (события, модели, параметры) была видна сразу на одном экране.

Этот формат является рекомендаций, а не строгим правилом, т.к. бывают случаи, когда надо динамическое определение.

### Декларация событий вида

Подписка событий декларируется в следующем порядке:
 1. Собственные события ns: `ns-view-show`, `ns-view-hide`, ... При этом имена функций-обработчиков этих событий должны быть **точно такими же**, как в сниппете кода выше.
 2. Собственные события Дарьи (кастомные события): `daria:vDariaView:some-event@show`, ...
 3. DOM события: `click .some-selector`

Остальные желательно по алфавиту.

Для кастомных событий обязательно надо указывать на что они вешаются, чтобы избегать разночтений и проблем.
В большинстве случаев это будет `@show`, т.е. вид подписывается при показе и отписывается при скрытии, иначе много инстансов вида (например, письмо) отреагируют на событие не себе (должен поймать только видимый вид).

### Декларация обработчиков событий
Все обработчики событий должны быть задекларированы как методы прототипа.
**ЗАПРЕЩАЕТСЯ** использовать анонимные функции.

Причины:
 1. функции раздувают декларацию и ухудшают читаемость
 2. методы прототипа удобнее тестировать

### Именование событий

События Дарьи обязательно имеют префикс `daria:`. Дальше можно указывать получателя и название. Например,
```
ns.events.trigger('daria:vMessageNearest:updateLinks', params);
```

### Именование методов

Т.к. прямой доступ к виду получить очень сложно, получилось что не имеет смысла разделять методы на приватный и публичные.
Поэтому для упрощения приняли решение не использовать `_` в названии методов, а делать их все публичными. Это правило касается только декларации видов!

## Типичные задачи

### Обновление модели и перерисовка
```js

ns.View.define('folders', {
    events: {
        'click .js-toogle-folder': 'toggleFolder'
    },

    models: ['folders'],

    params: {},

    methods: {
        toggleFolder: function() {
            // меняем данные в модели
            // модель должна поменять данные через .set(), .setData() или руками (в этом случае потом надо сделать .touch())
            this.getModel('folders').toggle();

            // просто вызываем переписовку всего, ns.Update сам решит что перерисовывать
            ns.page.go();
        }
    }
})

```

### Динамическое создание и отрисовка
Например, мы хотим, чтобы попап был видом. Но в layout он не попадает и должен отрисовываться on-demand.

Для этого есть метод `ns.View#update`. Работает он так

```js
// декларируем вид
ns.View.define('my-popup', {
    // ...
});

var vMyPopupInstance = ns.View.create('my-popup', myParams);
// запускаем создание, запрос моделей, события и т.п.
vMyPopupInstance.update().then(function() {
    // показываем попап с полностью инициализированным и отрисованным видом
    showPopup(vMyPopupInstance.node);
});

```

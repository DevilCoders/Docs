# `lib/resolve`

Система моделей похожа на flux-архитектуру — модель предоставляет доступ к данным на чтение
и основу реактивного состояния с помощью mobx.
Базовый тип модели как таковой отсутствует, вместо этого используются миксины,
отвечающие за отдельные аспекты поведения моделей.

## Миксины

Миксины реализованы как символьные свойства, т.е. для соответствия контракту того или иного
миксина тип (модель) должен получить символьное свойство с объектом определённого интерфейса.
Условно
```typescript
const MyMixinSymbol = Symbol.for('MyMixin');

interface MyBehavior {
    doSomeThing(): void;
}

class SomeBehavior implements MyBehavior {
    doSomeThing(): void {
        // ...
    }
}

interface MyMixin {
    [MyMixinSymbol]: MyBehavior;
}

class ModelWithSomeBehavior implements MyMixin {
    [MyMixinSymbol] = new SomeBehavior();
}
```

Как именно конкретная модель получает набор нужных миксинов в общем случае не определено,
но в текущей реализации для этого служат декораторы конкретных реализаций моделей, таких,
как [`lib/noscript/NsModel`](../noscript) или [`lib/mobx/StaticModel`](../mobx/).
Подробнее о них можно почитать в документации этих модулей.

Реализация через декораторы обусловлена тем, что позволяет скрыть детали реализации конкретного
миксина от пользовательского типа — свойство миксина в нём просто недоступно
и появляется только в декорируемом типе.

## `Stated`
Миксин `Stated` отвечает за аспект хранения состояния модели. Конкретная логика работы
с состоянием определяется в типе, реализующем интерфейс `ModelStateApi` или `WritableStateApi`, если состояние должно быть изменяемым.
Примеры реализации состояния можно посмотреть в [lib/mobx/MobxModelState](../mobx/MobxModelState.ts).
Состояние модели описывается как объект с полями
- `state` возвращает "статус" текущей модели (`Initial`, `Loading`, `Resolved`, `Error`)
- `error` в случае ошибочного статуса содержит информацию об ошибке.

Поле `state` будет использоваться логикой построения плана запроса для определения,
какие модели уже получили свои данные, а какие нет и HoC'ом `withResolve()`
для определения состояния связанной с набором моделей вьюхи.

## `Resolvable`
Миксин `Resolvable` определяет тип объекта `Resolver`, отвечающего непосредственно за
построение плана запроса. Так резолвер "низкоуровневой" модели, связанной с данными
сервера или внешнего хранилища будет описывать как получить данные этой модели,
а резолвер "высокоуровневой" модели, служащей для агрегации данных других моделей,
будет описывать логику группировки резолверов дочерних моделей.

### `Resolver`
Тип `Resolve` определяет методы
- `resolve()` — будет вызваться каждый раз, когда вьюха, созданная с помощью
HoC'а `withResolve()` запрашивает данные (если модель объявлена как зависимость вьюхи) или
когда происходит `resolve()` верхнеуровневой модели (если модель объявлена как зависимость модели).
Предполагается, что этот метод вернёт `Resolution`, если требуется получение данных модели или пустой набор действий `[]`, если нет.
- `forceResolve()` — будет вызван, когда необходимо обновление данных модели вне зависимости от того, были ли они получены ранее. Предполагается, что этот метод в любом случае вернёт нужный `Resolution`

### `Resolution`
Тип `Resolution` описывает, откуда модель собирается получать свои данные или как именно
будут сгруппированы `Resolution`'ы дочерних моделей.

Так `Resolution` "низкоуровневой" модели скорее всего будет описан типом
```typescript
type SingleResolution = Map<Source, ModelRequest[]>;
```
где ключом будет тип источника `Source` откуда модель собирается получать свои данные,
а значением — набор параметров этого источника `ModelRequest[]`.

`Resolution` "верхнеуровневой" модели будет описан как массив из `SingleResolution[]`.
Группировка "дочерних" resolution'ов описывает логику разбиения запроса на отдельные bulk'и.
Каждый экземпляр `SingleResolution` внутри этого массива будет приводить к отдельному
групповому запросу к каждому источнику из ключей объекта `SingleResolution`.

> **TL;DR** Очень мудрёную фигню проще разобрать на примерах из
> [тестов на резолверы](./Resolver.spec.ts).

### `Source`

Как написано выше, `Source` определяет, откуда именно будут получены данные для модели.
Примером такого источника может служить [`NsSource`](../noscript/NsSource.ts), используемый
для интеграции с данными noscript-моделей, пока noscript-модели являются источник правды для данных приложения.
Впоследствии предполагается уйти от его использования и реализовать отдельный транспортный
уровень в виде некоторого `NetworkSource`.
Также примерами источников данных для моделей могут служить `localStorage` или `indexedDB`.
На данный момент типов `Source` для работы с ними не реализовано, но написать их в будущем будет несложно.

## `withResolve()`

> Предпочтительно использовать `withSafeResolve()`, поскольку тот не даёт просовывать MobX-сущности
> в глупые компоненты, ограждая от ошибок

HoC `withResolve()` используется для объявления зависимостей вьюхи.
Под капотом он будет использовать [`withInject`](../inject/Readme.md#инжектим-зависимости-в-компонент)
для получения экземпляров объявленных зависимостей из инжектора, а также запустит механизм
резолва всех зависимостей, удовлетворяющих контракту `Resolvable`.

Этот HoC создаст компонент, который подпишется на все данные, используемые в render-функциях
соответствующих состояний с помощью mobx-механики `@observer`'а.

> **ВАЖНО!** Поскольку предполагается, что никакие компоненты приложения ничего не знают про mobx
> и `withResolve()` является единственным местом, где явно используется `@observer`, то всю работу
> с данными модели необходимо описать внутри render-функций состояний, иначе не произойдёт
> подписки на нужные getter'ы, а соответственно, и реактивных обновлений компонентов при изменении данных.

## `withSafeResolve()`

> TODO

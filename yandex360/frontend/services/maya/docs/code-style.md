Здесь "высекаются в камне" все соглашения по коду, к которым мы приходим после обсуждений.  

- Соглашения нужны для единообразия.
- Единообразие часто важнее конкретных решений.
- Если это возможно, то соглашение должно быть автоматизированно (напр. через правило линтера).
- Если соглашение принято, но соблюдается не везде (или нигде), то нужно завести отдельную задачу для приведения проекта к единообразному виду.

---

### Форматирование

Форматирование js и css контроллируется линтером.

В данный момент все правила форматирования js приходят из `prettier`.

### Бизнес-логика

Для управлением состояния приложения мы используем `redux` + `redux-saga`.

- Большая часть логики приложения должна быть сконцентрированна в сагах. Саги нам нужны потому что их легко тестировать. В свою очередь UI логика должна оставаться в UI компонентах.
- Каждая сага должна быть определена в отдельном файле.

### Тестирование бизнес логики

Для тестирования саг используется `redux-saga-test-plan`.

- При тестировании саг нужно отдавать предпочтение `expectSaga`, вместо `testSaga`.  
`expectSaga` позволяет делать сфокусированные, менее хрупкие тесты.

### UI компоненты

Для сознания UI компонентов используется `react`.

- При создании hoc'ов, нужно убедиться что свойства которые hoc подмешивает декорируемому компоненту были либо иммутабельны (bool, number, func, immutablejs, тд), либо не менялись без причины. Иначе изменчивые свойства могут приводить к лишним перерисовкам декорируемого компонента.
- По умолчанию используем `PureComponent` (вместо `Component`), т.к. это самый дешевый способ избавиться от лишних перерисовок компонента и улучшить производительность UI.  

  Возможные случаи когда придётся использовать обычный `Component`:
  - Компонент получает react элементы через `this.props.children`.  
    Тут проверки `PureComponent` излишни, т.к. на каждой перерисовке всё равно будем получать новые элементы.
  - Компонент получает react элементы через [render prop](https://reactjs.org/docs/render-props.html).  
    Тут `PureComponent` может заблокировать перерисовку элементов, т.к. получаемая render prop функция не меняется.


### Контейнерные компоненты

Для подключения UI компонентов к состоянию используется `react-redux` hoc `connect`.

- Компонент `X` должен подключаться к состоянию в отдельном файле `X.connect`
- Подключение производится с помощью hoc'а `connect`, либо кастомных hoc'ов (напр. `withRouter`)
- Если встаёт дилема прокидывать данные состояния через родительский компонент, либо свой `.connect`, то нужно отдавать предпочтение своему `.connect`'у.

### Репозиторий (Git/Github)

- для code review заводится git ветка, и через Github создаётся PR
- имя ветки - `<код тикета>` (большими буквами), напр. 'origin/MAYA-842'.
- имя PR'а - `<код тикета>: <имя тикета>`, напр. 'MAYA-842: Сделать что-то полезное'
- в описание PR'a желательно добавить информацию о том, что конкретно было сделано
- описание commit'а
  - `<код тикета>: <имя тикета>` - когда commit один
  - `<код тикета>: <что именно сделано>` - когда commit'ов много

### Другое

- импорты модулей.  
Разделяем импорты на 2 группы: third-party модули - пустая строка - наши модули.  
Внутри наших модулей сортировка от общего (напр. `utils/...`, `features/...`) к частному (напр. `./Component.styl`).
# Разработка серверного кода

В качестве сервера на прокте используется [Duffman](/packages/duffman), являющийся, по существу, 
абстракцией над express с добавлением продвинутого http-клиента и некоторого числа дополнительных 
плюшек (интеграциями с системами мониторингов, логированием и так далее).

Рекомендуется перед продолжением ознакомиться с документацией к самому [Duffman](/packages/duffman).

На сервере используется `module-alias`, поэтому пути в `require` задаются относительно папки `server` 
через `@`, (например, `const Core = require('@/lib/core)`).

## Роутинг

Серверные роуты настраиваются в двух местах, в [конфиге](../../server/duffman/index.js) и на уровне 
обработчиков роутов, указанных в конфиге ([пример](../../server/routes/index/index.js)). 

## Выдача шаблонизированных страниц

Для выдачи страниц используются обаботчики путей, возвращающие промис, резолвящийся со строкой 
с html ([пример](../../server/routes/index/handler.js)).

В саму страницу, помимо разметки, подкладываются скрипты со статикой (точки входа в клиентский код, остальное подключает webpack), 
скрипты используемых библиотек вроде клиентского логирования и метрики, а также несколько json-подобных
скриптов с конфигурацией приложения, которые подкладывают разлиные данные в `window`.

Среди вещей, которые стоит отметить отдельно, в конфиге фигурирует пользовательская локаль, uid и [ckey](#ckey), 
которые впоследствии передаются в виде хедеров на сервер при запросе моделей.

## Клиент-серверное взаимодействие

Для взаимодействия между клиентом и сервером используем JSON RPC.

Все запросы за моделями с клиента отправляются по адресу `/api/models` методом POST с query-параметром `_models`, 
в который передаётся список запрашиваемых моделей, полезная нагрузка запроса передаётся в теле в виде json. 
Примерный формат тела запроса:
```json
{
  "models": [
    { "name": "model-name-1", "params": { "modelPayload": 1 } },
    { "name": "model-name-2", "params": { "modelPayload": 2 } }
  ]
}
```
Также для передачи информации используются хедеры со служебными полями, через которые передаётся uid 
текущего пользователя, [ckey](#ckey), [connectionId](#connectionid) и локаль пользователя.

На стороне клиента этим занимается абстракция над транспортным уровнем [ModelsApi](../../client/api/ModelsApi.js).
На стороне сервера запрос обрабатывается [хендлером моделей](../../server/routes/api/handler.js),
который инициализирует экземпляр [Core](../../server/lib/core.js) с заранее известным списком сервисов (`server/services`) 
и моделей (`server/models`). Название модели определяется именем файла с функцией-обработчиком 
самой модели.

Для того, чтобы не все модели были доступны с клиента, существуют [PrivateCore](../../server/lib/private-core.js) 
и `server/private-models`, в частности, через них работает авторизация.

После получения списка моделей они начинают параллельно обрабатываться, затем формируется ответ
клиенту. Примерный вид ответа:
```json
{
  "models": [
    {
      "name": "model-name-1",
      "status": "ok",
      "data": { "modelResponse": 1 }
    },
    {
      "name": "model-name-2",
      "status": "error",
      "error": { "message": "Server fault (500)" }
    }
  ],
  "uid": "123456",
  "ckey": "some_ckey_value",
  "timestamp": 1575919040108,
  "cookieRenew": false,
  "reqid": "0bee6dcfbd43850a6f72fa4806180f26"
}
```

В ответе, помимо ответа от каждой модели, содержится информация о необходимости обновления 
куки (`cookieRenew`), [ckey](#ckey), `timestamp`, `uid` и [reqid](#reqid).

## Термины

### connectionId

Не несущий глубинного смысла параметр, id пользовательской сессии. Позволяет, например, 
отличать друг от друга несколько открытых одним пользователем в одном браузере вкладок с приложением.
Используется для генерации [ckey](#ckey). Генерируется в момент выдачи индексной страницы и затем подкладывается в каждый запрос.

### ckey

XSRF-токен, генерируется в момент выдачи индексной страницы и затем подкладывается в каждый запрос.

### reqid

Также `x-request-id`, `request-id`. Случайный хеш, генерируемый nginx на уровне балансера и пробрасываемый везде, 
куда идут запросы. Требуется для дальнейшей трассировки запросов.


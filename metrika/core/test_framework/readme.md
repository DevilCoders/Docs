# Тестовый фреймворк для тестов движка в рамках Аркадийного подхода
## Введение
Предполагается, что тест построен на трёхслойной архитектуре.

_Тут будет схема_

На верхнем уровне находится тестовый сценарий, реализованный через вызовы "шагов теста" - степов.

На среднем уровне находятся степы, которые представляют собой осмысленные действия в терминах тестируемой системы - предметной области тестов.
Верхнеуровневые степы, из которых построены тестовые сценарии остаются не изменными при изменении деталей реализации, вызванных изменениями в устройстве
тестируемой системы. На этом же уровне осуществляется сбор информации для построения Allure-отчётов. Степы могут быть разных уровней - от очень общих вида
`Провести обработку чего-либо` до достаточно конкретных вида `Поместить n хитов на вход демона такого-то`.

На нижнем уровне находятся клиенты и клиентские степы. Клиенты - представляют собой клиентские библиотеки ко внешним системам. Клиентские степы - степы,
явлюящиеся обёртками над, как правило, одной клиенсткой библиотекой.

Степы данного уровня отвечают за инициализацию клиента в условиях теста, предоставление
функций этого клиента другим степам, предоставление информации о внешней системе - хосты, порты и т.п.

Клиентские степы как правило содержат также и низкоуровневые шаги теста, дополняя и комбинируя вызовы клиентской библиотеки и подробное протоколирование.

Инициализация клиента в условиях теста бывает двух видов. Если внешняя система запускается посредством рецепта, то клиентские степы извлекают необходимую
информацию для инициализации клиента из соответствующих переменных окружения. В другом случае сами клиенсткие степы отвечают за запуск и останов внешней системы.

Степы более верхнего уровня могут содержать в себе степы более нижнего уровня, но не наоборот. На каждый проект тестов обычно существует свой агрегатор степов
самого верхнего уровня, который содержит в себе все остальные, необходимые данным тестам степы. Тестовые сценарии реализуются через этот агрегатор степов
самого верхнего уровня.

## Протоколирование
Для протоколирования хода работы тестов используется [Allure-отчёт](https://docs.qameta.io/allure/).

Шаги тестов напрямую отображаются в этом отчёте. Кроме того там может отображаться любая сопутствующая информация
в виде прикреплённых файлов.

## Реализация
Тесты реализованы посредством библиотеки [pytest](https://docs.pytest.org/en/4.0.1/),
[внутренняя документация](https://wiki.yandex-team.ru/yatool/test/#python).
Степы реализованы посредством [фикстур](https://docs.pytest.org/en/4.0.1/fixture.html#fixture).

Каждый вид степов представляет собой класс, реализующий данные степы и фикстуру, которая отвечает за жизненный цикл степов - создание объекта,
его инициализацию и деинициализацию.

Фикстура своими параметрами задаёт те степы от которых зависят данные степы. На этапе запуска
теста pytest производит разрешение этих зависимостей. Т.е. зависимости здесь описываются декларативно.

Для тех степов, которые располагаются в тестовом фреймворке все их фикстуры описаны в файле ```conftest.py```, который располагается там же.
Явно импортировать их в проекте тестов не нужно.

Для тех степов, которые специфичны для данного проекта тестов фикстуры должны быть описаны в соответствующем файле ```conftest.py```

### Проверки
Проверки в тестах могут быть двух видов - традиционные утверждения (ассерты, asserts) и сравнение с каноническим значением, канонизация.

#### Ассерты
Ассерты бывают двух видов - мягкие и жёсткие.

Жёсткие - их ещё можно назвать ожиданиями - представляют собой контрольные точки,
через которые тестовый сценарий должен пройти успешно что бы продолжить своё выполнение. Например, демон отвечает на ручку `ping`,
таймаут на ожидание асинхронного события (исчезновение recount request'а из очереди) не истёк, внешняя система проинициализирована
нужным образом и т.п.

Мягкие - проверка соответствия характеристик, полученных на определённом этапе тестового сценария определённым условиям.
Например, количество вызовов http-ручки мока, размеры нескольких выходных очередей и т.п.
Нарушение этих условий ведёт к провалу теста только после завершения тестового сценария, что позволяет проверить более чем
одну такую характеристику и соблюсти правило наличия одного ассерта на один тест. С практической точки зрения мягкие ассерты
представляют собой сбор характеристик по ходу выполнения сценария и проверку их всех разом на последнем шаге сценария.

##### Жёсткие ассерты
Жёсткие ассерты реализованы в виде функции `assume_that` которая принимает три аргумента:
1. сообщение - представляет собой строку, которая отображается в протоколе теста и должна быть составной частью фразы "Предполагаем, что ...";
1. актуальное значение
1. ожидаемое значение или [матчер](https://pyhamcrest.readthedocs.io/en/v1.9.0/library/)

##### Мягкие ассерты
Мягкие ассерты реализованы в виде степов `verification_steps`.

Зафиксировать характеристику для проверки можно двумя способами:
1. с помощью степа `assert_that`, который принимает три аргумента:
   1. сообщение - представляет собой строку, которая отображается в протоколе теста и должна быть составной частью фразы "Проверяем, что ...";
   1. актуальное значение
   1. ожидаемое значение или [матчер](https://pyhamcrest.readthedocs.io/en/v1.9.0/library/)
1. с помощью операции вызова функции - скобочки прямо на самих степах `verification_steps`, которая принимает два аргумента:
   1. актуальное значение
   1. ожидаемое значение или [матчер](https://pyhamcrest.readthedocs.io/en/v1.9.0/library/)

Первый способ предпочтительнее и повсеместно рекомендуется к применению, второй способ позволяет не задавать сообщения и
не рекомендуется к применению, но в некоторых случаях он может быть более практичным.

Проверка зафиксированных характеристик выполняется посредством степа `verify`, который нужно явно вызвать в конце тестового сценария.

Хорошей практикой является вынесение ассертов из тестового сценария в степы, например, `steps.verify...` или `steps.assert_that_something`.

#### Канонизация
Функция, реализующая тестовый сценарий может иметь возвращаемое значение. После успешного завершения теста это возвращённое значение сравнивается с
каноническим значением, которое лежит в `canondata/result.json`. Следует отметить, что сравнение с каноническим значеним выполняется
после успешного завершения теста.

Официальная документация может быть найдена [тут](https://wiki.yandex-team.ru/yatool/test/#python-canonization).

В качестве средства сравнения канонических файлов содержащих табличные данные рекомендуется использовать [табкранч](https://a.yandex-team.ru/arc/trunk/arcadia/metrika/qa/tab-crunch).

## Модель объекта тестирования
В рамках данного подхода объект тестирования - отдельный демон - представляется как "чёрный ящик" с некоторым набором входов и выходов, которые нужно в
каждом случае идентифицировать, явно выделить и предоставить соответствующие степы для работы с ними в рамках тестового сценария.

Асинхронные действия объекта тестирования здесь представляются как его выходы и отдельно не обрабатывются.

Примеры входов:
1. http-ручка, запросы в которую демон обрабатывает слушая соответствующий порт
1. recount request, который демон читает, возможно удаляя после прочтения
1. таблица в ClickHouse, MySQL откуда демон читает данные, возможно удаляя её после прочтения
1. файл на диске, который демон читает

Примеры выходов:
1. http-ручка, в которую демон отправляет запросы, соединясь с соответсвующим портом, который слушает внешняя система
1. recount request, который демон формирует для другого демона
1. таблица в ClickHouse, MySQL куда демон пишет данные
1. файл на диске, куда демон пишет

Теперь можно степы верхнего уровня разделить на группы - входные, выходные, смешанные, управления жизненным циклом объекта тестирования.

## Состав фреймворка
### utils
Содержит вспомогательные средства, например утилиты для работы со сгенерированными классами протобуфов.

### steps
Здсь расположены непосредственно степы, сгруппированые в несколько модулей.

`calc_cloud.py` - степы для работы с calc cloud'ом. Их не представляется возможным однозначно отнести к входным или выходным. В их состав входят функции для
 работы с чанками данных в ClickHouse, очередями recount request'ов в Zookeeper'е.

`daemon_run.py` - степы для управления жизненным циклом конкретного демона.

`http.py` - входные степы для взаимодействия по http - клиент http, выбор порта, на котором будет слушать объект тестирования и выходные степы -
сервер http на основе [Flask](https://flask.palletsprojects.com/en/1.0.x/) и
[pytest localserver](https://a.yandex-team.ru/arc/trunk/arcadia/contrib/python/pytest-localserver), выбор порта на котором он будет слушать входящие запросы.

`stable_random.py` - данная фикстура предоставляет степы так называемого "стабильного рандома", это обёртка над функциями генерации случайных чисел, строк с заданными
свойствами. Предназначеие в том, что бы для каждого теста случайная последовательность была одной и той же и не зависела от порядка запуска тестов. Для этого
seed инициализируется полным именем тестового сценария. Следует иметь в виду, что при переименовании тестов случайная последовательность изменится.

`verification.py` - степы проверки утверждений и ожиданий.

#### clients
`clickhouse.py` - степы для работы с ClickHouse'ом, который запущен посредством рецепта. Здесь же реализована канонизация таблиц ClickHouse.

`mysql.py` - степы для работы с MySQL, который запущен посредством рецепта.

`zookeeper.py` - степы для работы с Zookeeper'ом, который запущен посредством рецепта.

## Каркас теста
### ya.make
Тест представляет собой модуль `PY3TEST`, рекомендуется размер `SMALL` или `MEDIUM`.

Обязателен `PEERDIR(metrika/core/test_framework)` - на данный тестовый фреймворк.

`DEPENDS` должен содержать объект тестирования - тестируемый демон.

Если в тесте используется канонизация и для сравнения используется Tab-crunch, то должен быть такой фрагмент:
```
DEPENDS(
    metrika/admin/jdk
    metrika/qa/tab-crunch
)
```

Файлы с тестовыми сценариями, степы и `conftest.py` перечисляются в макросе `TEST_SRCS`.

### Тестовые сценарияя
Файлы с тестовыми сценариями должны иметь префикс в имени `test_` и расширение `.py`. Они содержат функции - тестовые сценарии, которые в имени
тоже имеют префикс `test_` и аргумент `steps` в который передаётся экземлпяр степов. Подробнее, как это работает описано
[тут](https://docs.pytest.org/en/4.0.1/fixture.html#fixtures-as-function-arguments).

Пример:
```
def test_some_test_case(steps):
    steps.prepare()

    steps.daemon_run.start()

    steps.put_input_for_daemon()

    steps.input.wait_for_input_queue_empty()

    steps.daemon_run.stop()

    steps.verify_output()
```

В данном примере предполагается, что в `steps.verify_output()` производится получение значений выхода демона и ассерт относительно них.

Пример с канонизацией:
```
def test_some_other_test_case(steps):
    steps.prepare()

    steps.daemon_run.start()

    steps.put_input_for_daemon()

    steps.input.wait_for_input_queue_empty()

    steps.daemon_run.stop()

    return steps.output()
```

В данном примере предполагается, что в `steps.output()` производится получение значений выхода демона и возврат подходящего для канонизации
значения, например `CanonicalFile` с табкранчем для сравнения содержимого.

### Степы
Для каждого проекта тестов рекомендуется организовать следующую простейшую структуру степов:

#### Модуль степов `steps.py`
##### Агрегатор степов верхнего уровня `Steps`
Пример:
```
class Steps:
    def __init__(self, input_steps, output_steps, verification_steps, ...):
        self.input = input_steps
        self.output = output_steps
        self.verification = verification_steps

    def cleanup(self):
        ...

    det make_somethig_specific(self):
        self.input.put_something()
        self.output.get_something()

    def verify_output(self):
        self.verification.assert_that("выходная очередь содержит рекаунт реквест", self.output.get_queue(), has_length(equal_to(1)))
        self.verification.verify()
```

Представляет собой класс, в который передаются экземпляры степов нижележащих уровней.

Предполагается, что в нём описаны конкретные, специфичные для данного объекта тестирования шаги, через которые реализуются тестовые сценарии.
А сами шаги реализованы через степы нижележащих уровней.

#### Входные степы `InputSteps`
Пример:
```
class InputSteps:
    def __init__(self, calc_cloud_steps):
        self.calc_cloud = calc_cloud_steps

    def put_something(self)
        self.calc_cloud.put_chunk(....)
```

#### Выходные степы `OutputSteps`
Пример:
```
class OutputSteps:
    def __init__(self, calc_cloud_steps):
        self.calc_cloud = calc_cloud_steps

    def get_queue(self):
        return self.calc_cloud.get_queue_items(...)

    def get_specific_canonincal_data(self):
        return self.calc_cloud...
```

#### Степы генерации входных данных `GenerationSteps`
Пример:
```
class GenerationSteps:
    def __init__(self, generator):
        self.rnd = generator

    def get_some_input_data(self):
        return self.rnd.next_int()

```

### conftest.py
Данный файл содержит импорты классов степов и объявления фикстур, необходимых в данном тесте.

Типовой пример:
```
from .steps import Steps, GenerationSteps, InputSteps, OutputSteps

@pytest.fixture()
def steps(input_steps, output_steps, verification_steps, ...):
    s = Steps(input_steps, output_steps, verification_steps, ...)
    yield s
    s.cleanup()


@pytest.fixture()
def input_steps(calc_cloud_steps):
    return InputSteps(calc_cloud_steps)


@pytest.fixture()
def output_steps(calc_cloud_steps):
    return OutputSteps(calc_cloud_steps)


@pytest.fixture()
def generation_steps(random):
    return GenerationSteps(random)


@pytest.fixture()
def daemon_descriptor(calc_cloud_steps):
    return DaemonDescriptor(
        binary_path="<путь в Аркадии к объекту тестирования>",
        config_template_path="<пусть к шаблону конфига>/config.xml.jinja2",
        config_context={
            "clickhouse": {
                "host": calc_cloud_steps.clickhouse.host,
                "port": calc_cloud_steps.clickhouse.port_native,
                "http_port": calc_cloud_steps.clickhouse.port_http
            },
            "zookeeper": {
                "host": calc_cloud_steps.zookeeper.host,
                "port": calc_cloud_steps.zookeeper.port,
                "root": "/"
            },
            "recount_requests_root_path": "/recount-requests-root",
            "recount_requests_table_name": "recount_requests",
            "output_database": "merge",
        }
    )
```

Последняя фикстура - зависимость степов управления жизненным циклом объекта тестирования. Представляет собой
некоторый описатель демона, содержащий следующую информацию: путь в Аркадии до бинаря демона, путь в Аркадии
до шаблона конфигурационного файла и словарь с контекстом, который используется для рендеринга шаблона
конфигурационного файла.

Видно, что данная фикстура содержит некоторые конфигурационные константы, которые при необходимости могут быть получены
в степах, например, имя выходной БД, пути в Zookeeper.

Кроме того, следует отметить, что первый элемент информации постоянен, а два других - могут меняться,
если это нужно для тех или иных сценариев. Для этого нужно объявить этот дескриптор зависимостью соответствующих
степов и реализовать степ, который выставляет нужные значения и выполняет запуск объекта тестирования.


Подробнее о фикстурах и приёмах их применения можно почитать в документации
[тут](https://docs.pytest.org/en/4.0.1/fixture.html#fixtures-a-prime-example-of-dependency-injection)
и [здесь](https://docs.pytest.org/en/4.0.1/fixture.html#modularity-using-fixtures-from-a-fixture-function).

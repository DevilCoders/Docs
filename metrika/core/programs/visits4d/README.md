Visits4d и история пользователей
=====

### Требования
1. По набору событий надо формировать визиты с информацией о пользователе.
2. В течение 24 часов (```data_lifetime```)/10 дней (```special_data_lifetime```) добавляются события. При этом надо обновить визит, которому принадлежит событие,
и историю пользователя в визитах, начиная с этого.


### Концепт
```
aggregated history|| |--visit 1-|  |--visit 2-| |--visit 3-|
--------------------------------------------------------------> timeline
```

- Для ключа (```CounterID```, ```UserID```) храним набор событий и аггрегированную историю.
Налету собираем визиты и историю пользователя для каждого визита.

- Когда визит больше не может быть обновлён, он перемещается целиком в аггрегированную историю.
Обычный визит не может быть обновлен, если последнее событие в нем старше 24 часов плюс максимальное время между последовательными событиями,
принадлежащими одному визиту (```max_offline_visit_threshold```). ```max_offline_visit_threshold``` обычно 6 часов. Правила обновления для визита с кликом такие же, только порог 10 суток.
```
 aggregated history|| |--visit 1-|     |--visit 2-|         |--visit 3-|          max_event_time
-----------------------------------------------------------------------------------------------------> timeline
                                  ←  больше 24 + 6 часов или 10 суток + 6 часов  →

          new aggregated history||     |--visit 2-|         |--visit 3-|
---------------------------------------------------------------------------> timeline
```
- Новые события не могут попадать за границу обновления
Граница обновляения примерно равна ```max_event_time - data_lifetime``` или ```max_event_time - special_data_lifetime```.

пример:
событие ```new event``` игнорируется
```
new events:                         ↓ new event    || update_border
old events: aggregated history|| |--visit 1-|  |--visit 2-| |--visit 3-|

---------------------------------------------------------------------------> timeline
```
- Формирование лога

Собираем визиты только из старых событий, а также визиты из старых и новых событий.
Если визиты отличаются, формируем лог изменения визитов.

пример:
приходит событие ```new event```, обновляющее ```visit 2```. Все последующие визиты должны быть обновлены, если изменилась ```user history```.
```
new events:                                       ↓ new event
old events: aggregated history|| |--visit 1-|  |--visit 2-| |--visit 3-|
---------------------------------------------------------------------------> timeline

old log: |--visit 1/user state 1-|  |--visit 2/user state 2-| |--visit 3/user state 3-|
new log: |--visit 1/user state 1-|  |--visit 2 new/user state 2 new-| |--visit 3/user state 3 new-|
diff log:
- |--visit 2-|
+ |--visit 2 new-|
- |--visit 3/user state 3-|
+ |--visit 3/user state 3 new-|
```
### Реализация
1. Аггрегированная история хранится как обычное событие. С временем события равным времени последнего сагрегированного события.

  ##### RepairLog:
  - добавление, если новый пользователь
  - замена, если после сборки визита аггрегированая статистика изменилась
  - удаление, если от первого визита в ```history``` до ```aggregated history``` больше 90 дней

  ##### MemTable:
  - обновляется после сборки визитов

  ##### SolidTable:
  - при мёрдже если от первого события в ```history``` до ```aggregated history``` больше 90 дней - удаляется

2. Сборка визитов
  - В конструктор визита передаём ```aggregated history``` с состоянием до начала этого визита. На выходе получаем новую ```aggregated history``` и передаём её следующему визиту.

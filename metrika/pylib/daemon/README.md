# Зачем?
Что бы наши демоны имели набор каких-то общих компонент (статус-ручки, получение простейших команд), и не нужно было бы их реализовывать в каждом отдельном случае.

Текущая версия - __скорее концепт__, чем полностью рабочее, проверенное решение.

# Общее описание
Библиотека содержит в себе классы Master (условно, главный процесс) и Slave (треды, делающие полезную работу).
Реализован приём событий по HTTP/UDP и получение статуса по HTTP. Настроено логирование. Унифицирован запуск дочерних тредов.

# Как использовать

В простейшейм виде
```python
import time

from mtutils.daemon.master import Master
from mtutils.daemon.slave import Slave

class MyDaemon(Master):
    def run(self):
        self.run_slave(MyWorker)
        while not self.shutdown.is_set():
            self.logger.info("I'm running")
            time.sleep(5)

        self.logger.info("I'm done")

def main():
    daemon = MyDaemon()
    daemon.start()

if __name__ == '__main__':
    main()
```

В результате запуска будет выполнен метод ```run()``` класса ```MyDaemon```.
По-умолчанию демон запустит HTTP и UDP сервера по адресу ```[::]:5151```
(Можно изменить в [конфиге](#config). Значения по-умолчанию можно посмотреть в [defaults.py](https://a.yandex-team.ru/arc/trunk/arcadia/metrika/pylib/daemon/defaults.py).
HTTP сервер используется для приема [событий](#events) и получения [статуса](#status) демона.
UDP сервер используется только для приема событий.

После запуска в stdout будет примерно следующее
```
2018-01-26 17:39:28,062 MainThread              MyDaemon                        WARNING     Config file is not specified
2018-01-26 17:39:28,062 MainThread              MyDaemon                        DEBUG       Starting
2018-01-26 17:39:28,064 MainThread              MyDaemon                        INFO        I'm running
```

# <a name="config"/> Конфиг
При инициализации инстанса класса Master есть возможность передать путь к конфигурационному файлу.
Формат файла - [YAML](http://yaml.org/).

После загрузки конфига у инстанса будет 2 аттрибута: ```master_config``` и ```config```.
В них соответственно находятся конфигурация для мастера, и пользовательская конфигурация, специфичная для конкретного демона.

## Конфиг мастера
Список опций:
* ```host``` *string* - на каком адресе запускать сервер событий и статус сервер (**IPv6 ONLY**)
* ```port``` *int* - на каком порту запускать сервер событий и статус сервер
Обе опции передаются в ```listen()``` в том или ином виде

* ```hidden_opts``` *list* - какие опции конфига нужно скрывать в ручке статус сервера.
Опции из данного списка при запросе статуса будут заменены на ```*** HIDDEN ***```.
Работает только для опций на верхнем уровне.
Это означает, что для вот такого [конфига](#config-example) будут скрыты опции ```yt_token```, и ```other_tokens```.

Если же ```hidden_opts``` будет иметь значение ```['yt_token', 'password']```, это не сработает, т.к. ```password``` находится на уровень ниже.

## Пользовательские опции
В пользователских опция на верхнем уровне конфига не может быть использован ключ %%master%%, так как он зарезервирован для использования библиотекой.
В остальном в аттрибуте %%config%% будет содержаться всё, кроме секции %%master%% конфига.

## <a name="config-example"/> Пример конфига
```yaml
master:
    port: 3322
    host: '::'
    hidden_opts: ['yt_token', 'other_tokens']

yt_token: AAAA-123123hh22igg2g23g2323j332k
other_tokens:
    hello: AAAA-asdasdasd
    password: oadsfkdjhdh
```

# <a name="events"/> Сервер событий
Используя HTTP или UDP интерфейсы можно отправить демону событие в формате JSON.
Внутренний формат события не важен для демона. Ему важно только получить валидный JSON.
После валидации JSON-а событие попадает в очередь из которой его читает ```EventProcessor```.
Для каждого полученного события ```EventProcessor``` вызывает метод ```process_event```
мастера. Таким образом, что бы выполнять свою обработку событий, пользователю нужно
переопределить метод ```process_event``` в своём коде.

По-умолчанию ```process_event``` только логирует событие.

#### HTTP
Событие можно отправить в HTTP сервер в ручку ```/events```. Само событие должно находиться
в теле запроса.

Отправить можно, напирмер, вот так:

```curl -v -g -6 '[::1]:5151/events -X POST -d '{"Hello": "World"}'```

Ответ сервера
```json
{
    "message": "Event received",
    "result": true
}
```

Обязательно наличие заголовка ```Content-Length```.

## UDP
В случае UDP достаточно записать данные в сокет:

```echo -n '{"Hello": "World"}'|nc -6u ::1 5151 -w 0```

# <a name="status"/> Статус сервер
Статус сервер по-умолчанию запускается на ```[::]:5151``` (Можно изменить в [конфиге](#config)). 

## /status
Запросить статус можно в ручке ```/status```. Формат ответа: [JSON](https://www.json.org/). Запустив демон с 
[конфигом из примера](#config-example) можно получить примерно такой результат:

Запрос:

```curl -v -g -6 '[::1]:5151/status'```

Ответ сервера
```json
{
    "message": {
        "config": {
            "other_tokens": "*** HIDDEN ***",
            "yt_token": "*** HIDDEN ***"
        },
        "events_queue": 0,
        "master_config": {
            "hidden_opts": [
                "yt_token",
                "other_tokens"
            ],
            "host": "::",
            "port": 3322
        },
        "name": "MyDaemon",
        "slaves": [
            {
                "name": "MyWorker",
                "started": "2018-02-01 18:41:37.876631"
            }
        ],
        "started": "2018-02-01 18:41:37.872030",
        "uptime": 3.771203
    },
    "result": true
}
```

Статус формируется вызовом метода ```status``` у мастера и каждого из слейвов. Таким образом, если
правильно переопределив эти методы, можно возвращать в статусе любые нужные данные.

Рекомендуемый метод переопределения метода ```status```
```python
def status(self):
    status = super(MyClass, self).status()
    status['awesome_status'] = 42
    return status
```

## /ping
Ручка ```/ping``` может быть использована при деплое или мониторинге извне, чтобы определить, что демон в настоящий момент работает корректно. Для реализации собственной ручки ```/ping``` необходимо переопределить метод ```ping``` в мастере.

Пример реализации
```python
from mtutils.daemon.exceptions import PingError
def ping(self):
    if self.i_am_ok():
        return 'OK\n'
    else:
        raise PingError("I f*c**d up!", 500)
```

# Мониторинг
Для отправки события в [Juggler](https://wiki.yandex-team.ru/sm/juggler/) используется метод ```send_event_to_juggler``` (и у мастера, и у слейвов). Принимает 4 аргумента: ```host, service, status, description```.

# Зачем Вебвизор 2.0?

## Вебвизор 1.0 устарел
С 2011 года, когда Яндекс запустил Вебвизор в составе Метрики, технологии в Веб и, в частности, в браузерах шагнули далеко вперед и, на данный момент, тот способ записи-воспроизведения «видео» Вебвизора безвозвратно устарел и имеет ряд проблем, связанных с этим.

## Принцип работы и проблемы Вебвизор 1.0
Первая версия Вебвизора использует для работы iframe и загруженную в нем текущую версию отображаемого сайта. Воспроизведение всех событий происходит посредством передачи данных коду счетчика внутри iframe. Такой подход порождает большое количество проблем как с воспроизведением в целом, так и с безопасность данных, в частности, выполнение скриптов в доменных зонах Яндекса.

#### Актуальность данных
Так как Вебвизор показывает записи используя текущую версию сайта, это может нарушать актуальность данных, т.к. с момента записи до момента воспроизведения сайт мог измениться и показать ту версию, которую видел пользователь, будет невозможно. Так же сайт может изменяться посредством Ajax запросов, local/session storage, что тоже невозможно контролировать.

#### Динамический контент и SPA
С того момента, как начала популяризоваться технология Ajax, основанная на XHR, обратного пути уже не было. Все больше сайтов начинали использовать такой механизм отображения контента. Позже, с появлением новых возможностей в браузерах и сменой тенденций в вебе, стали появляться полностью динамические сайты (все помнят твиттер с их хэш-бэнгами). Даже в 2011 году таких сайтов было довольно много, а значит технология Вебвизора начала устаревать уже тогда. На 2017 год сайтов, работающих по принципу SPA и аналогичных, уже миллионы. Вебвизор ничего этого отображать толком не умеет или отображает крайне плохо, так как принцип его работы состоит в показе текущей версии сайта в iframe, и, к примеру, если нормально эмулировать клики еще как-то можно (для запуска событий, на которые привязаны обработчики, обновляющие или изменяющие контент сайта), то, к примеру, наведение курсора на элемент эмулировать невозможно, а значит динамический контент, который отображается таким образом, отображаться в записи Вебвизора просто не будет.

#### Мобильные устройства
Помимо динамического контента популярность так же набрали всякого рода мобильные устройства: планшеты, смартфоны. Вебвизор умеет показывать записи, сделанные на таких девайсах, но это лишь базовая информация. К примеру, Вебвизор не умеет отображать корректно работу с жестами, pinch-to-zoom и другие. Так же имеются проблемы с отображением изменения ориентации устройств.

#### Точность записи
На данный момент, с учетом выше описанных проблем, точность записи Вебвизора очень страдает. Особенно на сайтах, создающих динамический контент и в записях, сделанных с мобильных устройств.

#### Отсутствие привязки к сайту
Одна из самых главных проблем Вебвизора, которая породила массу разнообразных костылей – принцип воспроизведения. Вебвизор просто загружает в iframe текущую версию сайта. Это создает сложности и для реализации, и для воспроизведения как такового. К примеру, если сайт изменился или вообще упал, то запись не воспроизведется. Если пользователь на сайте авторизовался и использует какие-то фичи сайта, связанные с авторизацией, Вебвизор не сможет этого отобразить в записи. К тому же такой способ порождает проблемы с безопасностью, так как далеко не все еще перешли на https.

#### Ряд более минорных проблем
Существуют, также, другие проблемы, связанные с реализацией ВВ1: клиентам необходимо настраивать политики CORS, X-Frame-Options и Content Security Policy для корректной работы Вебвизора. Если пользователи сайта пользуются user-скриптами или расширениями, модифицирующими страницу, то это также может сказываться на качестве записи. Помимо этого есть ряд потенциальных проблем, связанных с выполнением скриптов в контексте доменов Яндекса.

#### Решение
Вебвизор 2.0 лишен почти всех этих проблем. Если конкретнее, то, из перечисленного ранее, проблемы вызывают только мобильные устройства. Принцип работы ВВ2 – запись мутаций DOM-дерева и дальнейшее их воспроизведение. Вебвизор 2.0 делает снапшот HTML страницы, сохраняет его (решает проблему с iframe) и к этой структуре применяет записанные мутации дерева (решает проблему с динамическим контентом). Любое изменение структуры страницы порождает «мутацию» – информацию о том, что изменилось в DOM, будь то добавление или удаление блока, изменение порядка блоков или изменение атрибутов. Это корректно работает как с HTML, так и с SVG. То есть воспроизведение больше не привязано к сайту, на котором велась запись. Это позволяет, к примеру, записывать страницы, которые видно только для авторизованных пользователей, корректно записывать SPA любой сложности. Все это способствует устранению перечисленных ранее проблем и значительно повышает точность записи.

Единственным минусом этого способа, пожалуй, является тот факт, что ВВ2 генерирует огромное количество данных, которые приходится передавать через сеть, хранить, анализировать и так далее.
Конкуренты и вдохновение

На момент старта проекта из наиболее близких решений к тому, что нам хотелось получить, были Hotjar, Mouseflow и Getsmartlook. Все три системы реализуют один и тот же функционал записи сессий по тому принципу, что избрали и мы – записывать мутации.

Помимо этого, к примеру, Mouseflow и Getsmartlook используют проксирование внешних ресурсов, а у Hotjar транспорт реализован через вебсокеты, что мы тоже хотим попробовать сделать.

Однако даже на стадии прототипа мы смогли заметить, что точность записи динамического контента у Вебвизора значительно лучше. К сожалению, невозможно точно сказать, по каким причинам это так, так как отсутствует точная информация о механике работы данных ресурсов.

В целом, сервисы конкурентов лишь подтвердили, что данный механизм работает и его вполне можно использовать. Впрочем, никаких особых фич, о которых мы не подумали бы сами, у этих сервисов не нашлось. Единственное, что мы взяли на вооружение – схожий с Hotjar формат данных.

# Общая структура ВВ 2.0

#### Модуль npm
Вебвизор 2.0 является отдельным модулем и не входит в состав интерфейса и счетчика. Вместо этого для этих компонентов Вебвизор поставляется как npm-модуль. Причиной такого решения стало то, что кодовая база Вебвизора (на данный момент) довольно обширна, содержит в себе очень много специфических именно для него участков кода и смешивать кодовую базу ВВ2 с продуктами, в которых он задействован, совершенно неудобно с точки зрения разработки и поддержки.

#### Компоненты ВВ2: Ядро, Рекордер, Плеер, Индексатор
Основой Вебвизор 2.0 являются Ядро, Рекордер, Плеер и Индексатор.

Ядро, как понятно из названия, это набор утилит и модулей, которые используются во всех остальных частях Визора. Так же ядро предоставляет набор полифилов для браузеров, у которых нет нативной поддержки некоторых используемых JS API.

Рекордер встраивается в код счетчика и обеспечивает запись действий пользователя. Все события и мутации записывает именно он.

Плеер – модуль, встраиваемый в интерфейс метрики и занимается он воспроизведением того, что записал Рекордер.

Индексатор – это, пожалуй, один из самых интересных модулей. Он является частью и Плеера, и Рекордера. Индексатор нужен для корректного хранения текущего состояния вирутального дерева. Каждая мутация, происходящая во время записи, проходит через Индексатор чтобы сохранить текущее состояние DOM и гарантировать корректность воспроизведения.

# Счетчик

#### Устройство Рекордера
Рекордер работает по следующему принципу:

1. Создает кэш для временного хранения данных (до их отправки)
2. Запускает `DOMIndexer`, который проведет начальную индексацию и создаст снапшот страницы
3. Запускает `MutationObserver`, который будет слать изменения дерева в `DOMIndexer`
4. Вешает набор хендлеров на различные события на странице (движения мыши, ввод текста и пр.) – они называются Captor'ы
5. Начинает собирать данные и пересылать их через middleware в место хранения

Рекордер использует таймер, который запускается в момент начала записи. Этот таймер дает возможность до миллисекунды определять время возникновения события или мутации и, в дальнейшем, их воспроизвести в точности с тем, как они происходили на самом деле.

Captor’ы – сборщики данных, которые привязываются к событиям на странице и отслеживают их до тех пор, пока визит не завершится. Отдельный Captor отвечает за сбор мутаций. Он, по сути, цепляется к событиям модуля `MutationSummary` и собирает данные от него. Все данные, полученные от Captor’ов сохраняются в локальный кэш Рекордера и, при наступлении определенных условий, отправляются счетчику через middleware интерфейс. Условий для очистки кэша и отправки три:

- вне зависимости от количества накопившихся данных они будут отправляться счетчику каждые 10 секунд
- если менее чем за 10 секунд набралось больше 500 единиц данных (событий или мутаций), то данные отправятся по достижении этого лимита
- если менее чем за 10 секунд набралось больше 512 кб данных, они так же отправятся счетчику

Для упрощения всей этой механики все события и мутации были приведены к единому формату данных: у каждого блока информации есть время возникновения данных, тип и набор метаданных, специфичных для конкретного типа. Для событий, так же, есть target – идентификатор ноды, с которой связано событие.

#### MutationObserver и DOMIndexer
`MutationObserver` – это основа основ Рекордера и именно благодаря ему мы можем в точности записывать все, что происходит со страницей, когда пользователь взаимодействует с ней. При любом изменении DOM MutationObserver дает пачку данных, в которой содержится все информация о том, что именно произошло. Он умеет отслеживать добавление/удаление нод, изменение контента текстовых нод и изменение атрибутов. Все эти данные нормализуются и приводятся к единому формату, отдаются на индексацию, а затем отправляются в кэш Рекордера, откуда уйдут в счетчик и далее на сервер.

Важной особенностью работы этого API является то, что в некоторых случаях несколько мутаций могут происходить в один и тот же момент времени (в одну миллисекунду) и это порождает нарушение порядка мутаций, а следовательно, путаницу при их воспроизведении. Несколько мутаций одновременно могут возникать из-за добавления элементов в дерево, к примеру, через `#document-fragment`, когда сначала создается виртуальный блок, в который добавляются ноды, а затем этот блок вставляется в DOM. Также эта проблема возникает при использовании `innerHTML` и вставке кусков HTML из строки. В таких случаях `MutationObserver` пришлет иформацию о том, что добавилось сразу несколько нод. В качестве решения для мутаций были введены индексы. Если в какой-то момент времени одновременно пришло несколько мутаций, то каждой из них будет дан индекс в соответствии с тем порядком, в котором их отдал MutationObserver. Это позволяет не полагаться на способ передачи и хранения данных, и нормализовать их уже на стороне плеера перед воспроизведением.

DOMIndexer занимается хранением виртуального зеркала реального DOM дерева и утилизирует функционал `MutationObserver`. У данного класса есть две основных задачи:

1. проиндексировать начальное сосотояние дерева и создать снапшот страницы, который будет использован в качестве скелета
2. проиндексировать каждое изменение сосотояния дерева (добавление/удаление элементов, изменение атрибутов, текста)

На старте Индексатор в синхронном режиме обходит весь DOM и собирает снапшот начального состояния страницы (в момент загрузки счетчика на странице и инициализации Рекордера). Идя по дереву он дает каждому его элементу, будь то обычный html-элемент, комментарий или текстовая нода, уникальный идентификатор. Вместе с этим Индексатор записывает себе во внутренний кэш все данные о проиндексированных нодах. По сути, Индексатор, на первом этапе, строит «зеркало» DOM дерева в JSON формате. Этот снапшот будет являться скелетом страницы во время воспроизведения. Идентификаторы, которые дает Индексатор, передаются на сервер вместе с структурой страницы. Именно благодаря этим айдишникам можно гарантировать, что дерево будет точь-в-точь соответствовать оригиналу во время воспроизведения. После этого Индексатор просто ждет, когда его попросят проиндексировать что-то еще. Этим занимается модуль `MutationSummary`. Он разбирает на запчасти каждую мутацию и передает данные об изменениях Индексатору. Для добавленных нод задаются новые идентификаторы (которые тоже отправляются на сервер вместе с остальными данными), удаленные ноды удаляются и из индекса для сохранения актуальности «зеркала». То же самое происходит с текстовыми нодами, комментариями и атрибутами.

Вторую часть индексатор выполняет по требованию `MutationObserver`, если в дереве произошли какие-то изменения. Процесс индексации добавляемых нод аналогичен индексации при инициализации класса: каждая добавленная нода записывается в кэш и ей дается идентификатор.

DOMIndexer использует TreeWalker для обхода дерева, так как это API умеет быстро обходить DOM предоставляя его, при этом, в плоском виде, то есть без вложенности, а значит не приходится использовать вложенные циклы или рекурсивные функции.

Отдельно следует отметить необходимость индексировать абсолютно все ноды без исключения. Дело в том, что мутации, при поступлении, содержат информацию о том, какая нода куда добавилась, а также информацию о том, какие ноды ее окружали в момент добавления (`previousSibling`, `nextSibling`). Таким образом, если нода добавляется в дерево после HTML-комментария, то в информации о мутации эта нода с комментарием будет присутствовать в качестве `previousSibling` и нужно опираться на это при воспроизведении для сохранения корректного порядка элементов дерева.

#### Оптимизация трафика
Так как Вебвизор 2.0, в силу специфики работы, генерирует большое количество данных, пришлось думать над тем, как это количество уменьшить. Для этого в течение года структура данных, которые поставляет Рекордер, значительно изменилась и стала максимально компактной, а также было решено использовать бинарное сжатие через Protobuf. Protobuf был выбран как наиболее универсальный инструмент, для которого есть реализации почти на любом языке, плюс он предоставляет возможность иметь единую схему для данных, то есть мы можем сжать данные на клиенте, отправить их на сервер и распаковать там, используя ту же схему. Это довольно удобно, с учетом того, что нам необходимо анализировать некоторые из данных, поставляемых Рекордером.

Для статистики: на стадии PoC Вебвизор генерировал порядка 25 мегабайт данных для одного просмотра (запись одной страницы). Переход на JSON формат данных и его оптимизация вместо передачи строк с HTML дал возможность сократить количество трафика в несколько десятков раз – до средних 1.5 МБ на страницу. Protobuf дает еще, в среднем, -30% данных. Помимо этого сейчас мы экспериментируем с HTTP2 и его возможностью эффективно сжимать заголовки. Это, потенциально, тоже может помочь сэкономить трафик.

#### Оптимизация записи
Еще одной проблемой нового Вебвизора стало то, что на объемных, с точки зрения количества HTML, сайтах все жутко тормозило, так как постоянное итерирование многотысячных массивов на клиенте – то еще занятие. Дело в том самом снапшоте, который создает Индексатор после инициализации, так как ему необходимо обойти все дерево и собрать данные о нодах. На первых порах Вебвизор мог намертво зависает на сайтах, с объемом дерева около 10-15 тыс. элементов (блоки, комментарии, текстовые ноды и т.п.). Первым шагом оптимизации стал выбор более быстрого способа обхода дерева. Им стал `TreeWalker`.

`TreeWalker` это довольно старый, но, тем не менее, не особо известный API, который позволяет очень быстро итерировать DOM дерево, при этом `TreeWalker` позволяет выбирать любые ноды, в том числе текстовые и комментарии, чего не может `querySelector[All]`. Так же в API `TreeWalker` встроена возможность фильтрации нод по заданным критериям. Это снижает скорость обхода, но довольно удобно при работе с небольшими участками DOM. Без фильтрации `TreeWalker` способен, к примеру, обойти 25 000 DOM нод меньше чем за 100 мс. При этом `TreeWalker` игнорирует вложенность элементов и отдает их "плоским" списком, что значительно упрощает обход сложного HTML с большой вложенностью.

Благодаря переходу на него, вместо классического уже `querySelector[All]`, удалось увеличить скорость обхода дерева почти на 40% и, бывшие проблемой, сайты с 10-15 тысячами элементов перестали доставлять такие неудобства, как прежде. Однако оказалось, что сайтостроителей-маньяков значительно больше и делают они вещи значительно более дикие, чем мы думали. Так, например, одна из страниц документации всеми любимого Кликхауса состоит из почти 40 тысяч нод и это стало новой проблемой. Также было найдено еще несколько любопытных кейсов с примерно теми же объемами. Это стало проблемой еще по той причине, что Рекордер работает синхронно для максимальной точности записи и асинхронная модель на нем без костылей просто не заводится. Здесь на помощь пришли уже микро оптимизации и удаление всего лишнего из циклов. Выяснилось, например, что эмуляция Set’ов через классические массивы работает почти в 10 раз быстрее нативных. Отказ от циклов for..of в пользу обычного for с кешированием длины массива вместе с эмуляцией Set’ов и рефакторингом индексатора дали прироста почти на 90%. К примеру, ранее озвученный сайт документации Кликхауса стал индексироваться за 140 миллисекунд вместо 26 секунд. Индексация мутаций стала вообще незаметной и тайминги там от 0 до 2мс в зависимости от объема.

# Плеер

Интерфейс плеера был нарисован и написан с нуля, как и все остальное. За работу UI отвечают React+Redux, для воспроизведения используется одноименный модуль – Player.

Воспроизведение ведется в `iframe`, так же, как и в первой версии Вебвизора, но здесь он выполняет роль вьюпорта и песочницы. Контент, отображающийся внутри фрейма, строится самим плеером, а не загружается снаружи. Как раз здесь используется тот снапшот, который записывает при инициализации Рекордер.

Плеер является, по сути, контроллером и может быть интегрирован с любым UI. Даже сейчас UI и воспроизводящая часть разделены и интерфейс использует API и события Плеера.

Под капотом используются несколько модулей для воспроизведения мутаций, событий, построения дерева из данных от Рекордера.

Основной для воспроизведения является Проектор – модуль, отвечающий за тайминг. Он отсчитывает время от 0 до абстрактного duration – длительности воспроизведения, и дает «фреймы» – наборы из мутаций и событий, которые произошли в определенный момент времени. Таким образом, при воспроизведении мы можем в точности показывать, что и когда делал пользователь.

За отображение событий отвечает модуль ActionProcessor, у него есть набор подмодулей, каждый из которых отвечает за отображение того или иного события, будь то клик, движение мыши, скролл или тач события.

Построение скелета и мутации дерева производятся с помощью Индексатора и Мутатора. Индексатор имеет второй режим работы: ему можно скормить уже готовое дерево с заранее заданными айдишниками нод, это нужно лишь для того, чтобы не ходить по реальному DOM. В этом режиме Индексатор, так же, хранит удаленные ноды в отдельном кэше для возможности их быстрого восстановления на странице, а не генерации.

Мутатор же отвечает, как понятно из названия, за применение мутаций, которые ранее записал Рекордер. При этом Мутатор может применять мутации в их прямом порядке, так и откатывать в обратную сторону. Это было необходимо для возможности перемотки воспроизведения. Мутатор отвечает только за изменение нод на странице, но для создания новых используется отдельным модуль, который умеет создавать ноды из данных Рекордера. Данный модуль, помимо создания нод, умеет вести валидацию атрибутов и самих элементов, так как мы, например, не ведем запись некоторых элементов, например, `iframe`, `video`, `audio`. В этих случаях нужно заменять эти элементы на заглушки, чтобы у смотрящего запись было хотя бы примерное понимание того, что было в той или иной части страницы.

Отдельно хочется рассказать, как устроена работа с адресами на внешние ресурсы, например, CSS, картинки и шрифты.  Так как Вебвизор, на данный момент, не может сохранять себе абсолютно все ресурсы, встреченные на сайте, часть из них загружается, непосредственно, с записанного сайта. Так работают изображения, таблицы стилей, шрифты. Однако существуют несколько проблем: не все сайты умеют HTTPS, часто встречаются относительные URL, шрифты вообще нельзя загрузить снаружи из-за CORS, а таблицы стилей могут содержать точно такие же относительные URL (для картинок и import’ов, например).

Проблема с относительными URL решается довольно просто: нужно исправить их заранее, в момент записи. Так появился `URLPatcher` – модуль, ответственный за исправление адресов внешних ресурсов. Он умеет узнавать любые строки, похожие на URL или его часть и модифицировать их таким образом, чтобы получать на выходе абсолютные адреса. При этом он не ломает, к примеру, `data-url` и умеет работать с тегом base.

Для исправления остальных проблем решено было использовать прокси. Мы пробрасываем все ресурсы, которые загружаем снаружи, через нее и можем контролировать наличие HTTPS и политики CORS на своей стороне. Так же, благодаря прокси, мы можем исправлять адреса внутри таблиц стилей (используя тот же `URLPatcher`), подменяя их на проксированные абсолютные адреса. 

#### Сборка
На стадии PoC и примерно весь первый год существования Вебвизор 2.0 собирался через **Gulp** с использованием **Webpack** и **Babel**, но позже появилось ощущение, что есть лишний слой, который лишь мешает и замедляет сборку. Было решено отказаться от Gulp в пользу собственного решения, которое оказалось быстрее и заточено специально под сборку этого проекта.

Собственный сборщик представляет из себя набор конфигов, каждый из которых отвечает за отдельный модуль, будь то JS бандл, CSS, HTML или что-то еще. Он использует так называемые хендлеры, каждый из которых делает свой кусочер работы: запускает вебпак или стилус. Так же есть возможность комбинировать несколько хендлеров для сборки более комплексных модулей. Например, сборка интерфейса плеера делается в 3 этапа:

* Сборка CSS плеера (делает хендлер `stylus`)
* Сборка SVG файлов: объединение их в один файл и вырезание из них всего лишнего (делает хендлер `svg`)
* Сборка JS библиотеки плеера (делает хендлер `webpack`)

Или, к примеру, сборка продакшн версии Вебвизора состоит из 4 шагов:

* очистка build директории
* сборка Рекордера
* сборка Плеера
  * сборка CSS
  * сборка SVG
  * сборка библиотеки
* дополнительное копирование файлов в отдельную директорию, на которую смотрят, в дальнейшем, и счетчик, и интерфейс метрики, при их сборке

Это позволило собираться быстрее (в 2 с небольшим раза: при включенном кэшировании 6-8 секунд вместо 30) и отказаться от излишнего функционала, который дает Gulp. Также это позволило добавить возможность сборки SVG и HTML файлов для использования в качестве ES6 модулей, это реализуется отдельными хендлерами для сборщика.

#### Тестовая среда и локальная разработка
Так как Вебвизор разрабатывается в отрыве от метрики, необходимо каким-то образом тестировать его перед тем, как отдавать на растерзание QA. Вебвизор разрабатывается локально и для удобства разработки был создан отладочный сервер на базе Node JS и MongoDB, а, так же, расширение для хром-подобных браузеров и Firefox. Расширение позволяет встроить Рекордер на любую посещаемую страницу, при этом не используется обвязка в виде кода счетчика, то есть проверяется непосредственно сам Рекордер. Он записывает данные и отправляет их на локальный сервер, где есть плеер. Плеер точно так же работает без обвязки в виде интерфейса Метрики, что позволяет тестировать только само воспроизведение и поведение UI.

На базе этого расширения, кстати, появилось расширение для внешних тестировщиков (асессоров).

А тестов у нас нет. Но очень хочется.

Это вообще отдельная проблема, так как тестировать автоматически в Вебвизоре можно только какие-то отдельные куски и, со скрипом, можно прикрутить юниты и функциональное тестирование. Однако это только полбеды, так как есть еще плеер и воспроизведение, которые тестировать автоматически вообще не очень понятно как.
Мобильные устройства

Запись мобильных визитов тоже стала челленджем, так как это совершенно иная специфика сбора данных. Проблемы вызваны особенностями работы мобильных браузеров, в частности работа с вьюпортом на iOS и работа с тач-событиями на Android.

Дело в том, что экраны мобильных устройств ведут себя несколько иначе, нежели десктопные. На iOS, к примеру, не всегда есть возможность определить настоящие размеры вьюпорта из-за особенностей Safari, который зачем-то пересчитывает размеры страницы при зуммировании и без него. Из-за этого невозможно узнать настоящие размеры, а значит и отобразить в плеере корректный вьюпорт. Android тоже отличился. К примеру, Хром на Андроиде начинает троттлить тач события, если они возникают в скроллящейся области. Скролл, кстати, тоже троттлится. Чтобы иметь хоть сколько-то плавный плейбек таких событий, пришлось предварительно рассчитывать тайминги и расстояние между точками касаний, а затем анимировать перемещение индикаторов тача программ
но.

Отдельно стоит рассказать про тестирование Вебвизора на мобильных устройствах. Если на десктопе нам доступна обычная подмена счетчика, то тестировать так мобильные устройства невозможно было вообще. Первой итерацией на пути к радости тестирования стало приложение под iOS, которое представляло из себя простейший браузер, который умел встраивать код Рекордера в любые посещаемые страницы и отправлять оттуда данные на локальный сервер с монгой. Так мы смогли начать тестирование iOS. Позже доблестные ребята из QA придумали хак, чтобы иметь возможность тестировать вебвизор на мобильных устройствах. Хак довольно простой, был добавлен параметр URL, который позволяет подменить номер счетчика на сайте, где есть код метрики с ВВ2.
Текущие проблемы и планы развития

# Текущие проблемы:
На данный момент Вебвизор не умеет записывать `canvas`, `iframe`, `video`, `audio`.

С `canvas` мы проводили эксперимент, пробуя вклиниваться в его API и перехватывать вызовы методов. Способ сработал, но оказалось, что даже самое простое приложение с canvas генерирует десятки тысяч вызовов методов API, что полностью забьет нам дисковое пространство и будет ужасно тормозить как запись, так и воспроизведение.

`Iframe` записывать, потенциально, возможно, но это казалось не критичной фичей и было отложено до лучших времен. Впрочем, по записи `iframe` тоже возникают вопросы. Например, не совсем понятно каким образом хранить для него данные: ассоциировать их с хитом родительского окна или записывать отдельно. Надо ли пробрасывать данные из iframe наверх, в основной Рекордер или писать их параллельным потоком?

Медиа элементы `audio` и `video` не имеют событийной модели, а значит принцип работы с ними должен быть такой же, как и с `canvas`, однако это не всегда корректно работает, а также существует возможность, например, создавать виртуальные `audio`, которых нет в DOM и за ними следить невозможно в принципе.

Отдельным пунктом идут мобильные устройства, о которых рассказано ранее и проблемы с ними до сих пор не решены до конца. Но работа с ними идет и вскоре их запись тоже будет возможна в полной мере.

# Планы на будущее (возможно, ближайшее):
Среди хотелок на будущее наиболее интересными, пожалуй, являются мультиоконность и стримминг, которые позволят выделить Вебвизор среди конкурентов, потому что ничего подобного ни у кого еще нет.

Мультиоконность (оно же «запись вкладок») позволит видеть переключение пользователя между разными вкладками одного и того же сайта, что повысит понимание происходящего на страницах сайтов клиентов. На данный момент это лишь абстрактная хотелка и никакой конкретики по реализации данного функционала пока, к сожалению, нет.

Стримминг это просто запись/воспроизведение в реальном времени. Можно будет наблюдать за тем, что делает пользователь прямо сейчас. В теории решается использованием WebSocket транспорта для доставки данных и обхода всех аналитических обработчиков, стоящих между Рекордером и Плеером. То есть такие визиты тоже будут обрабатываться бэкендом метрики, но воспроизводить их можно будет прямо во время записи.

Хочется, так же, научиться записывать `canvas`, так как этого тоже ни один из конкурентов не умеет, а технология сейчас довольно популярная, чтобы уделить ей внимание. Как вариант, можно делать скриншоты canvas’ов со сниженным фреймрейтом (например, 24 кадра, вместо 60) и использовать WebAssembly для сжатия данных каким-нибудь нативным (на C++ или Rust) модулем, а затем хранить бинарно каждый кадр в пределах какой-то квоты, чтобы не забить диски. По этому поводу планируются эксперименты в ближайшее время.

# Заключение
Вебвизор 2.0 рулит, а скоро будет рулить еще сильнее. Пам-пам.

# DIFF

### Предисловие

Тут мы постараемся описать как происходит создание диффа по поджойненым логам. Это одна из сложных
частей происходящего, именно поэтому ей посвящен отдельный файлик с описанием. Важно понимать общую идею происходящего
и базовые принципы хранения и обновления информации о визите.

Для обновления визиты существую версия. Пусть есть визит версии **1** и состоянием **X**. Для того чтобы его обновить создаётся
версия **-1** состоянием **X** и версия **2** с состоянием **Y**. Теперь представим что у нас есть 2 поставщика обновлений.
Первый поставщик нацелен на максимальную эффективность, скорость и пропускную способность, по этому ~~тупой как пробка~~ не заморачивается
насчёт дополнительных сложностей и работает по описанной выше схеме. Второй поставщик обновлений
нацелен на то, чтобы обновлять "медленную информацию" в визите (конверсии, деньги и тд.), поэтому хранит очень большой стэйт и лог обновлений
и дополнительно компенсирует все обновления созданные быстрым поставщиком. Это ключевая обязанность данного медленного поставщика
и в деталях будет разобрана далее. Здесь лишь скажем версия визита, обновлённого медленным поставщиком,
представляется в виде `M * S + F`, где `F` версия от быстрого поставщика, `S` от медленного, а `M` - множитель для медленной версии.

Для того чтобы в полной мере понять что происходит при диффе нужно, осознавать что происходило с логами
на предыдущих стадиях их жизни. Ну или как минимум понимать какие входные параметры и данные есть у данной операции.
Здесь, для простоты, без потери общности, опишем только входные параметры, но в самом общем случае.

Пусть у нас есть схема в которой обрабатываются визиты и N побочных логов. В таком случае входными параметрами будут
являться следующие сущности:

- _Таблица состояния_: динамическая таблица в которой хранятся все когда-либо пропатченные визиты (в нашем случае у нас
есть TTL для записей в этой таблице, но кажется это сейчас не важно)

- _Набор чанков поджойненых визитов_: набор статических таблиц, в которых находятся новые визиты, к которым
приджойнены все побочные логи. Таким образом к новым визитам (из движка) мы добавляем информацию из всех побочных логов сразу

- _N наборов чанков пождойненых побочных логов_: каждый из N наборов содержит новую информацию из побочных логов, к которой
приджойнена информация о соответствующих визитов. Несмотря на то, что каждый из таких наборов гомогенен,
но разные наборы имеют разные схемы, так как (в отличие от пождойненных чанков визитов) содержит информацию только из
конкретного одного побочного лога.

- todo: Написать про удалённые визиты

Так как в каждом из выше описанных наборов данных так или иначе есть информация о визитах то там также содержится номер
самой последней версии (**y_VisitVersion**).

### Как происходит Diff в целом?

Для простоты опишем поверхностно механизм создания диффа и после этого более полно раскроем необходимые пункты данного процесса

1. (**diff\_log\_0\_state**) Для всех поджойненых чанков (как визитов, так и побочных логов) из таблицы состояния вычитывается информация о всех
обновляемых визитах. Это необходимо, так как напрямую джойниться на такую большую таблицу сложно (она еще и Optimized for lookup).
Эта информация называется (здесь и далее) старой, так как именно её мы и будем обновлять. Она является входом данного этапа

2. (**diff\_log\_{1..N+1}\_...**) В некотором заранее определённом порядке (определённость тут нужна скорее для скорости, нежели чем корректности, так что это тут попустим)
каждый из наборов чанков обновляет данное старое состояние.

	Входами данной операции являются набор обновлений визитов соответствующего типа и предыдущее их состояние.
Так как эти все изменения применяются итерационно и последовательно, то предыдущим состоянием будет результат предыдущего обновления данных полученного в ходе обратки
и создания диффа некоторого другого набора чанков с другой информацией (см последний пункт списка ниже - **visits_patched**).

	Это будет так для всех итераций, кроме первой в упомянотой выше последовательности, он на вход
в качестве старого состояния получит просто то, что содержалось в Таблице состояния.

	Выходами данной операции являются 3 набора данных

	- (**processing/%{table}\_<тип лога>/visit\_log\_slow**) Собственно сам дифф, который после будет сложен в ClickHouse.
    Он содержит все необходимые компенсации версий и состояний в плюс и минус и так далее.
    Это как раз одна из тех частей, которая требует дополнительного разъяснения и будет описана позже

	- (**processing/%{table}_<тип лога>/visits_patched_new_only**) Только новые состояния визитов с увеличенной `S` версией

	- (**%{tableFolder}/visits\_patched**) Объединение обновлённых визитов и того что пришло на вход в качестве предыдущего состояния,
    для того чтобы последующие операции могли получить их на вход и применить свои обновления и создать свои диффы

3. Записываем новые состояния визитов в таблицу состояний

Вот в целом и всё. Дальше в полученный дифф приводиться в "широкое" состояние (то есть к нему приклеиваются
все те колонки которые от него были оторваны за ненадобностью при всех данных и предыдущих процедурах) и он отправляется на запись в ClickHouse

### Как конкретно генерируется Diff

Тут мы подробно опишем как генерируется Diff для различных случаев и поймём как и каким он формируется (**processing/%{table}\_<тип лога>/visit\_log\_slow**)

Как уже говорилось у нас есть:

 - старое состояние (`old`)
 - обновление состояния (`new`)
 - старая `old_F` (**old.y_VisitVersion**) и новая `new_F` (**new.y_VisitVersion**) быстрые версии (возможно одинаковые)
 - старая медленная версия  `old.S` (**old.SlowVersion**)

Плюс или минус у версии будем описывать отдельно как +1 или -1 (**Sign**). Также предполагается что у нас некая операция `+` способная смёржить `old` и `new`

Дифф состоит из 6 блоков. У каждого из блоков есть условие на попадание в него и формула для вычисления состояния, версий и Sign.
Каждый визит может попадать в несколько блоков (это ничему не противоречит).

|N   | Sign | S                 | F                  |  Состояние                   | Условие               |
|:---|:-----|:------------------|:-------------------|:-----------------------------|:----------------------|
|1   |   -1 | `old_S ?? 0`      | `old_F ?? new_F`   | `old ?? {}`                  | `old_F <= new_F`      |
|2   |    1 | `1 + (old_S ?? 0)`| `new_F ?? 0`       | `(new ?? {}) + (old ?? {})`  | `old_F <= new_F`      |
|3   |   -1 | `0`               | `new_F ?? 0`       | `{}`                         | `old_F < new_F`       |
|4   |    1 | `0`               | `old_F ?? 0`       | `{}`                         | `old_F < new_F`       |
|5   |    1 | `1`               | `new_F ?? 0`       | `new ?? {}`                  | `old_F is null`       |
|6   |   -1 | `0`               | `new_F ?? 0`       | `{}`                         | `old_F is null`       |



Группы блоков диффов

1. `old_F <= new_F ⟷` визит известен медленному поставщику и уже встречался у него
2. `old_F < new_F ⟷` визит известен медленному поставщику и был обновлён быстрым поставщиком обновлений
3. `old_F is null ⟷` визит не известен медленному поставщику


Рассмотрим отдельно 3 варианта

-  `old_F = new_F`
    Медленный поставщик обновляет то, что быстрый поставщик не трогал
    В такой ситуации создаться только первая группа диффов (`old_F <= new_F`)
    __Пример__:
    Пусть у нас старое состояние **X**, новое состояние **Y**. Старая и новая быстрые версии равны пусть **2**, а старая медленная версия **1**
    Было уже в diff от быстрого поставщика:

    ```
    Sign:+1  F:1      State: A             Итоговая версия: +1
    Sign:-1  F:1      State: A             Итоговая версия: -1
    Sign:+1  F:2      State: B             Итоговая версия: +2
    ```
    Было уже в diff от медленного поставщика:

    ```
    Sign:-1  F:2  S:0 State: B             Итоговая версия: -2
    Sign:-1  F:2  S:1 State: B + o = X     Итоговая версия: +1002
    ```
    Тогда мы сгенерируем следующий Diff:

    ```
    Sign:-1  F:1  S:1 State: X             Итоговая версия: -1002
    Sign:+1  F:2  S:2 State: X + Y         Итоговая версия: +2002
    ```

    Было : `+1 -1 +2 -2 +1002 = +1002` - корректно.
    Стало: `+1 -1 +2 -2 +1002 -1002 +2002 = +2002` - корректно

- `old_F < new_F`
    Медленному поставщику нужно обновить то, что обновил быстрый поставщик.
    В такой ситуации создаться первая и вторая группы диффов (`old_F <= new_F` и `old_F < new_F`)
    Пусть у нас старое состояние **X**, новое состояние **Y**. Старая быстрая версия равна пусть **2**, новая быстрая версия пусть 3, а старая медленная версия **1**

    __Пример__:
    Было уже в diff от быстрого поставщика:

	```
    Sign:+1  F:1      State: A             Итоговая версия: +1
    Sign:-1  F:1      State: A             Итоговая версия: -1
    Sign:+1  F:2      State: B             Итоговая версия: +2
    Sign:-1  F:2      State: B             Итоговая версия: -2
    Sign:+1  F:3      State: С             Итоговая версия: +3
	```
    Было уже в diff от медленного поставщика:

    ```
    Sign:-1  F:2  S:0 State: B             Итоговая версия: -2
    Sign:-1  F:2  S:1 State: B + o = X     Итоговая версия: +1002
    ```
    Тогда мы сгенерируем следующий Diff:
    Первыя чать у нас из предыдущего пункта так как `old_F < new_F → old_F <= new_F`

    ```
    Sign:-1  F:1  S:2 State: X             Итоговая версия: -1002
    Sign:+1  F:2  S:3 State: X + Y         Итоговая версия: +2003
    ```

    Было   : `+1 -1 +2 -2 +3 -2 +1002 = +3 -2 +1002` - не корректно.
    Сейчас : `+1 -1 +2 -2 +3 -2 +1002 -1002 +2003 = +3 -2 +2003` - всё еще корректно

    ```
    Sign:-1  F:0  S:3 State: 0             Итоговая версия: -3
    Sign:+1  F:0  S:2 State: 0             Итоговая версия: +2
    ```
    Было   : `+1 -1 +2 -2 +3 -2 +1002 = +3 -2 +1002` - не корректно.
    Сейчас : `+1 -1 +2 -2 +3 -2 +1002 -1002 +2003 -3 + 2 = +2003` - корректно

- `old_F is null`
    Медленному поставщику нужно обновить неизвестный ему визит.
    Пусть у нас старое состояние неизвестно, новое состояние **Y**. Старая быстрая версия отсутствует, новая быстрая версия **1**,
    а старая медленная версия **0** так как медленный поставщик его видит впервые.
    Важно понимать что данное условие имеет пустое множество пересечения со предыдущими двумя

    __Пример__:
    Было уже в diff от быстрого поставщика:

    ```
    Sign:+1  F:1      State: A             Итоговая версия: +1
    ```
    Было уже в diff от медленного поставщика:

    ```
    ```
    Тогда мы сгенерируем следующий Diff:

    ```
    Sign:-1  F:0  S:2 State: X             Итоговая версия: -2
    Sign:+1  F:1  S:2 State: X + Y         Итоговая версия: +1002
    ```
    Было : `+1 -1 +2 -2 +1002 = +1002` - корректно.
    Стало: `+1 -1 +2 -2 +1002 -1002 +2002 = +2002` - корректно

    Заметим что это очень похоже первый случай

#### _Замечание насчёт состояний из быстрого поставщика:_
В действительности ситуация сложнее. Как уже писалось выше к дифф в конце приклеиваются колонки которые были отброшены для оптимизации работы.
По факту в большинстве случаев именно они содержат стэйт от быстрого поставщика. А в тех случаях когда они пересекаются в этом сесте их надо дополнительно склеивать.
Именно по этому когда медленный поставщик компенсирует изменения быстрого он может оставлять стэйт пустым и ничего не сломается.

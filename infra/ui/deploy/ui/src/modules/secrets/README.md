# Модуль секретов

TODO описать принцип работы

## Механизм переименования алиаса

В модели `DeployUnitSecretVersion`, которая отражает версию секрета, используемую в конкретном DU после редактирования, появляется значение в поле `newAlias`.

Это значение почти не используется до момента сохранения стейджа. Разве что в валидации уникальности, чтобы избежать конфликтов.

При сохранении, если это поле есть, то старая запись в "хранилище" меняет ключ (алиас) на новый (`DeployPatcher.patchSecrets`)

---

Сложнее дело обстоит с патчингом всех мест использования версии с новым алиасом.

После нескольких неудачных вариантов остановился на следующем: появился хелпер-патчер `patchSecret`, и во всех местах вместо патчинга отдельно `id` (`key`) и `alias` через `patchString` должен вызываться `patchSecret`. В этот `patchSecret` дополнительно передается текущий `stageId` и `duId`, а также сервис `this.visitor.secretResolver`.

Внутри `patchSecret` и происходит "магия" при взятии актуального алиаса из секрета (`SecretResolver` содержит текущий стейт и владеет этой информацией, но для работы ему нужно знать родительский контекст (`stageId`, `duId`)).

Для всех патчеров (`StagePatcher`, `DeployUnitPatcher`, `BoxPatcher`, `WorkloadPatcher`) было добавлено поле `parentNodeIds`, где хранятся `id` родителей текущего узла. Значения из этих `parentNodeIds` и передаются в `patchSecret`. Подразумевается, что `parentNodeIds` может пригодиться и для других кроссузловых сущностей, например Volumes.


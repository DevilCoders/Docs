# Эксперименты. Конструктор

**Базовые правила**

1. Новые блоки должны заводиться сразу на общих конструкторских уровнях (даже если они добавляются только для эксперимента). Не нужно хотеть переопределять блоки на экспериментальных уровнях, потому что они пропадают из зоны видимости (не отображаются в документации). Команд в СЕРПе много и так блоки будут видны всем.
2. Если нужно кардинально изменить логику/поведение блока - лучше сделать рядом новый блок и после эксперимента выпилить старый
3. Все эксперименты и доработки блоков должны покрываться тестами

**Типы экспериментов**

1. [Внедрить новую, ранее не существовавшую фичу (колдунщик, например)](#Внедрить-новую-ранее-не-существовавшую-фичу)
2. [Внедрить редизайн существующей фичи/блока](#Внедрить-редизайн-существующей-фичиблока)
3. [Изменить клиентские сценарии или поведение/логику блока](#Изменить-клиентские-сценарии-или-поведениелогику-блока)

**Использование экспериментальных уровней**

- [Особенности использования](#Особенности-использования)
  - [Подключение статики эксперимента](#Подключение-статики-эксперимента)
  - [Условия срабатывания](#Условия-срабатывания)
  - [Ограничения](#Ограничения)
  - [Служебные свойства priv-функций](#Служебные-свойства-priv-функций)
- [FAQ](#FAQ)
  - [Как поменять внешний вид блока под экспериментом](#Как-поменять-внешний-вид-блока-под-экспериментом)
  - [В юнит-тестах на base.__expVal() всегда возвращает 1](#В-юнит-тестах-на-base__expVal-всегда-возвращает-1)
  - [Можно ли в эксперименте завязаться на другой экспериментальный флаг](#Можно-ли-в-эксперименте-завязаться-на-другой-экспериментальный-флаг)
  - [Как решаются конфликты между экспериментами](#Как-решаются-конфликты-между-экспериментами)
  - [Как подключаются `priv.js` файлы из экспериментального уровня](#Как-подключаются-privjs-файлы-из-экспериментального-уровня)
  - [Как подключаются `css/js` файлы из экспериментального уровня](#Как-подключаются-cssjs-файлы-из-экспериментального-уровня)
  - [Как экспериментальные уровни встраиваются в другие уровни проекта](#Как-экспериментальные-уровни-встраиваются-в-другие-уровни-проекта)

## Типы экспериментов

### Внедрить новую, ранее не существовавшую фичу

В большинстве случаев новые фичи собираются на существующих данных и дело сводится к простому написанию адаптера с правильным названием под поле `type` в данных. Например, для `type: 'new_feature'` адаптер должен называться `adapter-new-feature` (подробнее можно почитать в [разделе про адаптеры](../adapters/deprecated-priv.md)).
Адаптер нужно положить на экспериментальный уровень, чтобы он мог включаться/отключаться флагом.

Не забудьте покрыть экспериментальную фичу тестами!

Если же для новой фичи недостаточно существующих блоков и должен быть написан новый блок/блоки, тогда эти блоки следует добавлять сразу на общие конструкторские уровни (в папку `construct/`) и покрыть тестами. Адаптер пишем на экспериментальном уровне, как и в предыдущем варианте.

**Важно:** Экспериментальный блок на общих уровнях нужно обязательно разметить соответствующими тэгами:
* абсолютно новый блок - тэгом `exp-block`
* блок с экспериментальным модификатором и АПИ - тэгом `exp-api`
Также для таких блоков необходимо добавить описание о том, что блок экспериментальный в `jsdoc` в шапке основного прива блока (чтобы в коде тоже сразу было видно) и описание `typedef`
Пример:

```js
/**
 * Витрина
 * Эксперимент: в рамках блока проводится эксперимент с внешним видом стрелочек
 *
 * @param {Context} context
 * @param {Showcase|ShowcaseItem[]} dataset
 *
 * @returns {Bemjson|undefined}
 */
blocks['scroller'] = function(context, dataset) {
    if (!dataset) return;
    // ...
}
```

Для экспериментальных свойств АПИ - добавить в описание свойства информацию о том, что оно экспериментальное!
Пример:

```js
/**
 * Скроллер контента. Используется как базовый блок для скролла в `showcase` и `gallery`.
 * Умеет отображать контролы в виде стрелок влево-вправо. Работает на всех платформах.
 *
 * @typedef {Object} Scroller
 *
 * @property {Block[]} items - контент скроллера
 * @property {String|ScrollerControls} [controls=^translucent|arrow|none] - Отобразить контролы в виде стрелок влево-вправо
 * @property {Counter} [counter] - Параметры счётчика
 */
```

### Внедрить редизайн существующей фичи/блока

Если нужно провести редизайн внешнего вида фичи, то это как правило означает изменение внешнего вида одного или нескольких блоков.
Как правило изменения блока затрагивают другие фичи, а это значит, что нужно внедрить консистентный редизайн блока во всех фичах. Как это лучше сделать?
1. Согласовать внедрение с владельцами других фич. Все владельцы таких фич могут захотеть провести отдельные эксперименты с новым видом блока в своих фичах, либо принять результаты экспериментов в других затрагиваемых фичах.
2. Занести новый вид блока под модификатор и добавить новое свойство в АПИ блока, позволяющее включать/выключать этот модификатор (тем самым переключая блок со старого вида на новый и наоборот).
3. После влития этого модификатора команды могут запустить свои эксперименты, добавив в нужный адаптер включение нового вида через свойство блока под флагом своего эксперимента (на экспериментальном уровне).
4. После принятия всеми командами экспериментов (либо соглашения с результатами экспериментов других команд) можно раскатывать модификатор блока, делая его дефолтным внешним видом. В таком случае свойство АПИ отрывается вместе со старым кодом и все эксперименты так же отрываются.

Если есть желание оставить старый внешний вид под флагом для обратного эксперимента, тогда код блока инвертируется (новый вид выносится из-под модификатора, а старый вид заносится под модификатор). В таком случае все эксперименты сливаются под 1 флаг для обратного эксперимента, который будет включать во всех адаптерах через то же свойство АПИ (название можно поменять) модификатор со старым видом.

**Важно:** Любые изменения в блоках так же должны покрываться тестами!
**Важно:** Любые экспериментальные правки блоков нужно отмечать тэгами и комментариями как описано выше!

### Изменить клиентские сценарии или поведение/логику блока

Бывают случаи, когда нужно кардинально поменять логику блока или его клиентское поведение. В таких случаях тяжело вынести под модификатор весь новый код. Тут лучше всего будет сделать рядом новый блок с таким же названием с пометкой в конце (например `showcase2`). Новый блок нужно обязательно покрыть тестами!
После этого, как и в предыдущем варианте, достаточно провести эксперименты во всех фичах, где он используется (или хотя бы в основных при условии, что другие примут эти результаты), переопределив под флагами на экспериментальных уровнях адаптеры фич (вызвать там новый блок вместо старого). Написать тесты на адаптеры под флагом.
После принятия экспериментов можно просто удалить старый блок, а в новом изменить название на старый (придется погрепать в коде). После чего код экспериментов можно просто оторвать.

В случае, когда надо провести обратный эксперимент для подстраховки, придется собрать все адаптеры из экспериментов под 1 флаг и инвертировать в них название блока (вызывать старый) и во всех адаптерах на общих уровнять заменить название блока на новое.

**Важно:** после принятия и раскатки эксперимента обязательно нужно привести в порядок тесты (экспериментальные перенести как дефолтные и наоборот в случае обратного эксперимента)
**Важно:** Новые экспериментальные блоки нужно отмечать тэгами и комментариями как описано выше!

## Особенности использования

### Подключение статики эксперимента
Если эксперимент содержит priv-код, то его бандл будет запушен автоматически после вызова любой его функции.
Если в эксперименте меняются только стили/скрипты, то для подключения статики нужно будет добавить наиболее близкий
priv-блок, который может быть вызван, и тогда также сработает автоматическое добавление бандла со статикой.
Пример: мы поменяли стили блока video2. Добавляем пустой вызов блока video2 в priv, чтобы статика запушилась.
```js
blocks['video2'] = function bl() {
    return bl.__base(...arguments);
};
```

Автоматический пуш бандла эксперимента не выполняется (нужно пушить вручную через pushBundle или pushAssets), если в файле `.config.json` в корне эксперимента задана настройка `"bundleAutoPush": false`
```json5
// experiments/touch-green-url-dark/.config.json
{
    // если необходимо ручное управление пушем статики
    "bundleAutoPush": false
}
```

**Важно!** Стили и скрипты для экспериментальных уровней приезжают на страницу в `post-search` с помощью PushBundle. Поэтому, если вы хотите в рамках эксперимента изменить стили блока, который приезжает на страницу в `pre-search` (лого, поисковая стрелка, авторизация и т.д.), стоит учесть несколько важных моментов:

1. Переопределенные стили применятся в `post-search`, из-за чего блок будет мигать/дергаться.
2. Поэтому рекомендуем в таких случаях использовать не PushBundle, а вставку инлайн стилей внутрь блока, напр:
```js
// на уровне experiments инлайним файл вне deps.js
return {
    block: 'b1',
    content: [
        {
            tag: 'style',
            content: 'borschik:include:b1.inc.scss' // относительный путь до файла
        },
        //...
    ]
}
```
3. Для экспериментов, затрагивающих pre-search, нужно **обязательно** создать конфиг с опицией "bundleAutoPush": false,
чтобы исключить автоматическое попадание статики в pre-search. Если вы забудете это сделать, скорее всего увидите в консоли: `Стили или js эксперимента ${bundleName} приезжают за ajax-дозапросом!`

Что происходит: Некоторые ручки отвечают так, что мы присылаем стили и js экспериментов в ответе, при условии что в эксперименте есть какие-либо блоки, лежащие в пресерче (шапка, b-page и т.д). Из-за чего на страницу могут приехать стили,
 которые там или вообще не нужны, или которые уже есть. (https://st.yandex-team.ru/SERP-99896)

Что можно с этим сделать:
1) `borschik:include` Стили и js пресерча вынести в отдельные файлы, которые будет подключаться через borschik руками.
2) Сделать `"bundleAutoPush": false`, и в каком-нибудь блоке, например в футере сделать `data.pushBundle('exp_name');`.
3) Дописать стили в какой-нибудь блок, который уже есть на странице, например в футер.

**Важно!** Обособленность эксперимента не освобождает от написания тестов на Ваш эксперимент! Не забывайте писать Hermione на эксперименты, иначе нельзя гарантировать их целостность по истечении времени.

### Условия срабатывания

Код из экспериментального уровня выполняется, если соответствующий эксперимент активен и его значение не равно строке `'null'`.
При передаче `'null'` в качестве значения эксперимента, соответствующий экспериментальный уровень не активируется.
Это поведение удобно использовать для проведения обратных экспериментов.

### Ограничения

* `defBlock` не работает, так как `__base` по умолчанию доступен в любой функции:

    ```js
    blocks['my-block'] = function bl() {
        var block = bl.__base.apply(this, arguments);
        // ...
    };
    ```
* Писать bemhtml в экспериментальном уровне **нельзя** (https://st.yandex-team.ru/SERP-44749)
* Клиентские тесты не работают на экспериментальном уровне (https://st.yandex-team.ru/SERP-44839)

### Служебные свойства priv-функций

 * `{Result} __base(params...)` — функция для вызова базового метода, переопределённого в экспериментальном уровне;

    Пример использования:

    ```js
    function bl() {
        var result = bl.__base.apply(this, arguments);
        // ...
    }
    ```

 * `{String} __expVal()` — функция для доступа к значению флага текущего экспериментального уровня.

    Пример использования:

    ```js
    function bl() {
        var flag = bl.__expVal()

        if (flag === '0') {
            return block;
        }

        if (parseInt(flag) > 10) {
            block.mods['exp-case'] = flag;
        }
        // ...
    }
    ```

## FAQ

### Как поменять внешний вид блока под экспериментом?

Если нужно менять только стили, то всё, что нужно сделать - это создать свой эксперимент и положить туда стили, которые вы переопределяете.

Если нужно перевёрстывать, то можно до(пере)определить необходимый блок.

### В юнит-тестах на base.__expVal() всегда возвращает 1?

Да, сейчас юнит-тесты для блоков на экспериментальном уровне работают так, что в качестве значения флага там всегда находится "1". Обойти это можно, записав значения ваших флагов напрямую в `experimentarium._flags`, например: `experimentarium._setFlags({ 'direct-dynamic-add-info': 1 })`.

### Можно ли в эксперименте завязаться на другой экспериментальный флаг?

**Общие рекомендации:** Этот кейс плохой, потому что пересечения экспериментов никто не тестирует, и о них в общем случае никто не знает. Об этом нужно договариваться отдельно. Так же за такими переопределениями сложно следить независимо от используемой технологии. Не делайте так :)

**Если вам всё же это понадобилось:** Вы можете сделать это в новых уровнях переопределения в ручную проставив дополнительный if в привах либо любым другим удобным способом. В комментариях к флагу стоит указать с каким другим флагом и почему он связан.

Весьма вероятно, что на самом деле у вас есть один эксперимент с несколькими возможными вариантами значений.

Пример из жизни:
- есть флаг "show_url_menu"
- хотим добавить:
  - "show_frozen_url_menu", аналогично урл меню, только ссылки некликабельные. (кликабельный - только url целиком)
  - "show_short_url", по которому оставлять в гринурле только хост
  - "hide_url", по которому убрать гринурл совсем (ухудшающий)

На самом деле можно сделать все через один флаг "url_menu" с разными значениями:
- url_menu=frozen
- url_menu=short
- url_menu=normal
- url_menu=hidden

### Как решаются конфликты между экспериментами?

Эксперимент A красит ссылку в блоке MyBlock в красный цвет, а эксперимент B - в зелёный. Если включить оба эксперимента одновременно, какой из них победит?

Может победить любой. Эксперименты применяются в алфавитном порядке :)

Такое одновременное включение экспериментов инвалидирует метрики, собранные по каждому из экспериментов, потому что пользователь видит не то, что в эксперименте предполагается. Это продуктовая проблема, которая технически не решается. Стало не хуже, ситуацию можно сделать лучше чем было, если ввести в админке понятие приоритета эксперимента. Мы сможем централизовано поддержать приоритеты в фреймворке.

Чтобы эксперименты над одной и той же функциональностью правильно работали, нужно предусмотреть в коде совместную работу соответствующего кода. Можно сделать так, чтобы получить корректное поведение.

### Как подключаются `priv.js` файлы из экспериментального уровня?

Все `priv.js` файлы из экспериментального уровня собираются вместе с остальными в `all.priv.js`. Каждый экспериментальный `priv.js` оборачивается в дополнительную обёртку, которая регистрирует каждый эксперимент, сохраняя его в объекте `Experimentarium`.
В момент формирования ответа/страницы происходит активация всех включённых экспериментов – заменяются методы оригинального блока на методы экспериментального блока. И сразу после сформированного ответа, деактивируются, заменяются обратно.

**Важно!** Во время активации экспериментов цепочка переопределений блока сохраняется и предыдущий экземпляр блока доступен в `my-block.__base`.

Код, позволяющий заменять методы блоков, лежит в `.enb/assets/experimentarium.js`.

### Как подключаются `css/js` файлы из экспериментального уровня?

Для каждого эксперимента автоматически во время сборки создаётся свой бандл, в своей же папке `experiments/name-of-my-exp/.bundle/`.

Если на каком-то из уровней `blocks-{desktop,touch-phone}` нет изменений, то пустой бандл не собирается.
Файлы в бандле называются в соответствии с уровнем переопределения, например `.bundle/touch-phone/touch-phone.bemdecl.js` – так и должно быть. Если вы видите в этом проблему - свяжитесь с нами!

Если в эксперименте переопределяется только стиль модификатора (например, `blocks-common/block/_mod/block_mod_val.scss`), и другие переопределения отсутствуют, то для его сборки в бандл эксперимента надо выполнение одного из условий:
* должен быть priv `blocks-common/block/block.priv.js`, хотя бы даже состоящий из одного комментария
* или должен быть файл стиля для блока без модификатора `blocks-common/block/block.scss`, хотя бы даже состоящий из одного комментария
* или должен быть deps `blocks-common/block/block.deps.js`, в котором в `shouldDeps` указан этот модификатор
    ```js
    ({
        shouldDeps: {
            mods: { mod: 'val' }
        }
    });
    ```

**Важно!** Так как уровнем переопределения для бандла является только папка эксперимента, то в бандл попадают изменения (css/js) только из этого эксперимента (из `experiments/name-of-my-exp/`). Если в экспериментальном уровне Вам понадобится внешний по отношению к эксперименту блок, которого нет в зависимостях страницы (и на странице), и нет своего бандла, то стили этого блока скорей всего не подтянутся.

**Важно!** В `.sources.js`, в качестве названия бандла, пишется название эксперимента (`name-of-my-exp`). Так мы можем пушить на страницу необходимый экспериментальный бандл и генерировать его уникальный хэш.

**Важно!** Для экспериментального уровня вычитание зависимостей из файла `search.deps.js` не имеет смысла, поэтому оно выключено.

Собранные бандлы попадают на страницу с помощью pushBundle в `b-page__foot-js` автоматически, когда
был вызван их priv-код при формировании выдачи (до вызова `b-page__foot-js` соответственно).

Автоматический пуш бандла эксперимента не выполняется (нужно пушить вручную):
* для экспериментов без priv-кода
* если в файле `.config.json` в корне эксперимента задана настройка `"bundleAutoPush": false`

Если priv-ы эксперимента целиком отрабатывают в pre-search (как у саджеста), то всегда используем автоматический пуш, так как в post-search нельзя узнать, был вызван блок в pre-search или нет.

Для экспериментального уровня вычитание зависимостей из файла `search.deps.js` не имеет смысла, поэтому оно выключено.

Для сборки экспериментальных уровней используются технологии `extra-bundle` и `exp-bundle`.

### Как экспериментальные уровни встраиваются в другие уровни проекта?

Последовательность в `all.priv.js` выглядит примерно так:

```
blocks-common block['serp-url'] /* оригинальные блоки */
blocks-desktop block['serp-url'] /* оригинальные блоки */
...
blocks-common block['serp-url'] /* блоки эксперимента A */
blocks-touch-phone block['serp-url'] /* блоки эксперимента A */
...
blocks-common block['serp-url'] /* блоки эксперимента Б */
blocks-touch-phone block['serp-url'] /* блоки эксперимента Б */
```

Если вы в priv.js экспериментальных уровней переопределяете элементы/модификаторы, которые в обычном коде разложены по отдельным файлам,
в эксп уровне их тоже нужно разложить по аналогичным файлам. Это обеспечит гарантированно правильный порядок сборки.

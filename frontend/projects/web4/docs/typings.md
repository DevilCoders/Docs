# Организация типов

## В модулях

Под определение модуля попадают любые адаптеры, визуальные компоненты, хелперы и т.д. Типы и интерфейсы, используемые в модулях должны быть определены непосредственно в коде самого модуля и экспортированы наружу для использованиях другими модулями, если это необходимо. Для примера можно взять код адаптера.

``` ts
import { Adapter } from '../../vendors/taburet';

export interface IFeatureNameSnippet {}

export interface IFeatureNameResult {}

export class AdapterFeatureName extends Adapter<
    IFeatureNameSnippet,
    IFeatureNameResult
> {
    //...
}
```

Такая организация сильно упрощает понимание связи между типами и кодом, который их использует.

## Общие типы

Есть типы и интерфейсы, которые используются в большом количестве модулей, например определения: поискового сниппета, документа или конструкторского API. Для таких типов выделена специальная директория `/src/typings`. Если вы хотите добавить туда новый интерфейс или тип, посмотрите на уже существующие файлы. Файлы в директории `/src/typings` группируют типы по смыслу, так их проще искать и понимать принадлежность. Только если нужной группы не нашлось, создайте новую в виде файла с понятным не только вам названием.

## type и interface

Существует больше одного способа сделать одно и тоже, у каждого из этих способов есть плюсы и минусы. Например, определение расширяемого типа.

Скажем, вы хотите определить общий тип, который можно будет расширять через [generic](https://www.typescriptlang.org/docs/handbook/generics.html).

``` ts
type MyDocument<D> = D & {
    field: string;
};
```

Определение такого типа позволяет декларировать новые типы, которые будут наследовать какие-либо общие параметры.

``` ts
type MomDoc = MyDocument<{
    custom: number;
}>;
```

Тип `MomDoc` будет обладать уже двумя параметрами: `field` и `custom`.

__Почему так не надо делать?__

1. Несмотря на кажущееся удобство, компилятор не будет считать производный тип как нечто существующее. На самом деле это `type alias`. То есть компилятор и редактор разберут этот тип до конечных примитивов и не имеет значение снабжаете вы документацией их или нет, разбираться в производных типа и коде, который на них основан, достаточно неудобно.
2. Автоматически собираемся документация по коду, API Reference, руководствуется теми же правилами, что и компилятор во время разбора `type alias`. А все потому, что напрямую разбирает полученный из кода AST. В итоговой документации тип `MyDocument` будет выглядеть как `D & object`, независимо от количества параметров внутри.

__Как надо:__

``` ts
interface IMyDocument {
    field: string;
}

interface IMomDoc extends IMyDocument {
    custom: number;
}
```

Результат при валидации типов будет тем же. Но описание всех полей и полная цепочка наследования будет сохранена и в редакторе, и компилятором, и в итоговом API Reference.

## Соглашение по именованию интерфейсов

Все интерфейсы должны начинаться с `I`:

* Общие интерфейсы: `ISnippet`, `IDocument` и т.д.
* Проектнозависимые производные: `ISerpDocument`, `ISerpContext` и т.д.
* Производные адаптеров: `IFeatureNameResult`, `ITimeSnippet`, `IFeatureNameContext` и т.д.

## Документирование

Каждый интерфейс или тип должен быть задокументирован. Это сослужит вам и вашим коллегам хорошую службу при разборе кода. Для документирования используется стандартный JSDoc.

Особенное внимание надо уделять документированию [generic](https://www.typescriptlang.org/docs/handbook/generics.html).

Правильный пример:

``` ts
/**
 * Параметры конструктора класса Adapter.
 *
 * @template C контекст адаптера
 * @template S поисковый сниппет для адаптера
 * @template D поисковый документ
 */
export interface IAdapterOptions<C, S, D> {
    context: C;
    snippet: S;
    document: D;
}
```

> Если все дженерики не получается назвать первой буквой соотв. аргумента, то нужно использовать длинные имена, как у обычных типов.

## Указание типов при объявлении и type assertions

Типы для сущностей нужно указывать при объявлении сущности.

Правильный пример:

```(typescript)
let a: MyTypeForA = {};

function myFunc(): ReturnTypeOfMyFunc { return {}; }
```

Неправильный пример:

```(typescript)
let a = {} as MyTypeForA;

function myFunc() { return {} as ReturnTypeOfMyFunc; }
```

Приведением типов нужно пользоваться только в случаях, когда TS не может никак узнать, с чем вы работаете. Например, для подсказывания типа аккумулятора в `reduce`.

Подробнее в [документации по TS](https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions).

## Расширение в экспериментах

### Простая подмена свойств

Можно воспользоваться хэлпером [`Overwrite`](../src/typings/Overwrite.ts). Пример см. в jsdoc.

### Подмена методов адаптера

Можно сделать в несколько шагов:

1. Получаем нужный экпериментальный тип с помощью `Overwrite` и/или `extends`:

```(typescript)
interface IWarningExp extends Overwrite<IWarning, {
    type: 'w1exp' | 'w2exp';
}> { /* ... */};
```

2. Добавляем перегрузку для экспериментального метода и говорим, что в экспе предыдущий возвращаемый тип метода недостижим, чтобы избежать ошибок про несовместимость:

```(typescript)
meth(): never;
meth(): IWarningExp { /* ... */ }
```

Полный пример с аннотациями: https://nda.ya.ru/t/Kt15npDu3W4siR

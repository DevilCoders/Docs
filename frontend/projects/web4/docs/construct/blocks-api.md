# Блоки. API

API блока – это объект с определенным, задокументированным набором полей, который передается в блок вторым аргументом. В зависимости от этого набора блок рисуется в том или ином виде.

### У API есть полная и краткая форма

API блока в полной форме записи — **объект**. Всегда. Исключений нет. Это сделано для того, чтобы любой блок был потенциально легко расширяемый. Да, да, - это относится даже к вашему блоку!

Краткая форма записи есть у любого блока по умолчанию, **если у него НЕ БОЛЕЕ одного обязательного поля**. Это значит, что вместо объекта с самим блоком, в API можно передать содержимое того самого обязательного поля, если ничего кроме этого поля не используется.

Например блок:
```js
/**
 * @typedef {Object} MyBlock
 *
 * @property {Text} text
 * @property {Boolean} [important=false] - если true, текст помечается ярко красным, и всё взрывается
 */
```

Обязан уметь корректно работать, если ему в `dataset` придёт любой из нижеперечисленных вариантов:
  1. `{ text: 'тут что-то написано' }`
  2. `'тут что-то написано'`

Это сильно упрощает использование простых блоков, без ущерба их расширяемости, хотя и несколько осложняет разработку.

В `typedef` подобных блоков нужно указывать в перечислениях основных типов тип `Object` (тут мы имеем ввиду объект с каким-то единственным обязательным  свойством) и тип, который можно передать непосредственно, не оборачивая в объект. Например, для текстового блока `typedef` может выглядеть так:
```js
/**
 * ...
 * @typedef {Object|Text} Paragraph
 *
 * @property {Text} [text] - Текст параграфа.
 * ...
 */
```

Для полей, которые чаще всего выступают в роли единственно обязательных, есть хелперы, которые нормализуют приходящий в блок объект.

  1. Хелпер для поля `items` — [см. Construct.prepareItems](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/src/lib/Construct/index.ts)
  2. Хелпер для поля `text` — [см. Construct.prepareText](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/src/lib/Construct/index.ts)

**Даже если в вашем API строго одно поле, вы всё равно должны поддерживать полную и краткую формы.**

Это сделано для того, чтобы все блоки вели себя единообразно, и пользователи не путались (практика показала, что есть люди, которые всегда используют полную форму). Кроме того, это позволяет свободно добавлять, а в последствии и убирать обратно какие-то поля, без значительного изменения API блока.

## Структура API

При формировании API **не надо ровняться на структуру из данных**.

Необходимо спроектировать максимально понятную, удобную и расширяемую структуру для дальнейшего использования в различных адаптерах и блоках.

**Не стоит быть уверенными, что этот блок нужен только вам**. Наверняка кто-то в этот самый момент на другом краю Серпа уже рисует схожий. Давайте упрощать разработку друг другу :)

**Чтобы убедиться в удобстве API вашего блока**, попробуйте, для примера, его использовать в другом адаптере. Если его можно вызвать без лишних дополнений и правок, и всё предполагаемое из документации блока поведение можно контролировать с помощью его API, то скорей всего вы сделали хороший отчуждаемый и независимый компонент.

## Нейминг в API

Договоренности по неймингу полей способствуют консистентности API блоков, и в некоторых местах это упрощает вам жизнь благодаря готовым хелперам.

Существуют как просто договоренности, так и инструментально закрепленные решения.

### Договоренности

Эти поля не закреплены инструментально, но в конструкторе используются повсеместно.

- `items` - дочерние элементы блока

**пример:**
```js
{
    size: 's',
    items: [
      /* Дочерние элементы */
    ]
}
```

- `text` - текстовое поле(я) в блоке, (не `content`,`string`, `description` и тд). Если необходимо разделить текст в API, то лучше создайте поле с идентифицирующем названием и в него положите поле `text`.

**пример:**
```js
{
    text: 'Пс, пс, парень...'
}
```
или
```js
{
    description: {
        text: 'Пс, пс, парень...'
    }
}
```

### Зафиксированные инструментально (см. Supply)

Это те поля, которые мы добавляем к API блоков, чтобы расширить их функциональность. Например, чтобы ссылки были аяксовыми или прямоугольный блок соблюдал переданные пропорции. Подробнее о том, [как они устроены](./supply.md) и [какие поля существуют](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/construct/blocks-common/supply).

## В API есть поля со сложным поведением

### Текстовые

**Любое текстовое поле**, отриcованное на конструкторе, по умолчанию должно уметь принимать в себя не только строку, а всё, что подразумевает его `typedef` `Text`.

**Например:**
```js
/* adapters/blocks-common/adapter-my-feature/ */
...
{
    block: 'some-new-block',
    fact: {
        text: 'Текст какого-то факта, например',
        url: 'yandex.ru',
        ...
    },
    ...
}

/* construct/blocks-common/my-block/ */
...
@typedef {Object} MyBlock

@property {MyBlockFact} fact - вся информация о факте

...
@typedef {Object} MyBlockFact

@property {Text} text - текст факта
```

Это сделанно для того, чтобы в любом текстовом поле можно было нарисовать цену, регион и некоторые другие объекты, которые, хотя и выглядят для пользователя как текст, но текстом не являются.

Для упрощения этой задачи у нас есть хелпер [blocks\[construct__text-blocks\]](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/construct/blocks-common/construct/construct.priv.js).

Если вам необходимо **расширить виды текстовых блоков**, которые приходят в ваше текстовое поле, или изменить дефолтный блок, который будет отрисовывать ваш текст – достаточно это передать в параметрах:

```js
blocks['construct__text-blocks'](context, dataset, {
    defaultBlock: 'bold',
    allowed: ['serp-meta']
});
```

### Вариативные

В некоторые поля вам могут приходить различные виды объектов.

**Например:**
```js
@typedef {Object} MyBlock

@property {Video|Thumb} thumb - видео тумба, либо обычная.
```
В коде для таких случаев есть хелпер — [blocks\[construct__block\]](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/construct/blocks-common/construct/__block/construct__block.priv.js).

Также могут быть поля, в которые должен приходить массив из блоков различных типов. Частный случай этого поведения — текстовые поля.

**Например:**
```js
@typedef {Object} MyBlock

@property {Array.<Button|CheckButton>} items - обычные кнопки или кнопки с состоянием.
```

В коде такое поведение обеспечивается с помощью хелпера [blocks\[construct__blocks\]](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/construct/blocks-common/construct/construct.priv.js).

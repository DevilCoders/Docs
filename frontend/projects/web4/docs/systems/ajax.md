# Ajax

React-компонент (или i-bem реализация блока Конструктора) может отправить ajax-запрос в шаблоны и получить в ответе данные, шаблонизированную верстку и статику для нее. Для генерации ответа на сервере могут быть вызваны: TypeScript-адаптер и React-компоненты (или priv-адаптер, или блоки Конструктора).

Все виды ajax-а реализованы в [примере](../../src/experiments/learn_serp_bem-ajax-react/README.md).

__Как реализовать ajax на СЕРПе:__

- [Как отправить запрос с клиента](#Как-отправить-запрос-с-клиента)
  - [Из React-компонента](#Из-React-компонента)
  - [Из i-bem реализации блока Конструктора](#Из-i-bem-реализации-блока-Конструктора)
- [Как обработать запрос на сервере](#Как-обработать-запрос-на-сервере)
  - [В TypeScript-адаптере](#В-TypeScript-адаптере)
  - [В priv-адаптере](#В-priv-адаптере)
- [Полезные ссылки](#Полезные-ссылки)

## Как отправить запрос с клиента?

### Из React-компонента

Для отправки ajax-запросов из React-компонента используется библиотека [AjaxUpdate](../../src/lib/AjaxUpdate).
Используется библиотека так:
- в серверном коде адаптера происходит инициализации библиотеки через [AjaxUpdate/setup](../../src/lib/AjaxUpdate/setup.ts)
- сама отправка запрос в React-компоненте делается через один из методов: `ajaxUpdate` или `ajaxRender`

Метод `ajaxUpdate` подразумевает вызов метода "ajax" некоторого адаптера на сервере с ответом в виде данных (реже — данных и верстки из конструкторских блоков), а метод `ajaxRender` подразумевает стандартную работу адаптера с ответом в виде шаблонизированной React-ом или Конструктором верстки.

### Из i-bem реализации блока Конструктора

Если конструкторский блок будет оправлять ajax-запросы с клиента, в его priv-коде должен быть использован специальный supply:

```js
blocks['my-block'] = function(context, dataset) {
    /* ... */
    return blocks['supply'](context, dataset, ['ajax-updater'], {
        block: 'my-block'
        /* ... */
    });
}
```

После этого в клиентском коде вашего блока станут доступными ajax-update-события, через которое можно делать запросы и контролировать их выполнение.

Минимальный клиентский код выглядит так:

```js
// Подписка на события запроса
this.on({
    'ajax-update-succeed': function(e, data) {
        // Успех
        // data.html - строка с разметкой сгенерированной из block__ajax
        // data.js - js параметры проброшенные с клиента
    },
    'ajax-update-failed': function(e, error) { }, // неудача error.status - код ошибки error.statusText - текст
}, this);

// Отправка запроса
this.trigger('ajax-update', { /* параметры запроса */ });
```

## Как обработать запрос на сервере?

Любой ajax-запрос (из React-компонента или из i-bem код) всегда содержит поле "adapter", указывающее на адаптер, который будет отвечать на запрос на сервере. Реализация ajax-ответа в адаптере зависит от вида адаптера.

### В TypeScript-адаптере

Ajax-запрос в адаптере обрабатывает цепочка методов: `getSnippetForAjax` и `ajax` (см. пример из [Адаптеры/Ajax](../adapters/howto.md#4-Добавляем-ajax)). Результатом работы адаптера являются данные, построенные на основе параметров запроса и/или данных с бекенда.

Если ajax-запрос был отправлен из React-компонента методом `ajaxRender`, то в адаптер выполнит стандартную работу — вызовет метод `render` или `transform`, в зависимости от того, какой из них реализован.

**Внимание:** имя адаптера и его subtype нужно указывать так как он задекларирован в `src/features/.registry`, (либо в `src/experiments/.registry`)
например колдунщик картинок `adapter: 'images'` с маленькой буквы, а `adapter: 'LearnSerpAjax'` с большой буквы.


### В priv-адаптере

Для ответа на ajax-запрос в priv-адаптере пишется отдельный метод:

```js
blocks['adapter'] = function(context, snippet) {
    /* основная часть адаптера */
}

blocks['adapter__ajax'] = function(context, data) {
    /*
     * Обратите внимание что на вход адаптер получает полный объект data
     * к сожалению на данный момент нет способа автоматически узнать, из какой части data
     * нужно брать сырые данные для фичи. Параллельно мы работаем над унификацией ручек,
     * так что скоро возможно это изменится
     */
    var snippet = _.prop(data, 'wizplaces.carousel.0.data.parent_collection');
    return {
        ajax: {
            url: 'https://ya.ru' // урл при котором нужно ходить при следующем ajax запросе
        },
        text: snippet.title
    };
}
```

Нужно обратить внимание на следующие вещи:
- На вход аякс-адаптер получает `context` и `data`
- На выходе он всегда может вернуть поле "ajax", в котором передаются данные

При отправке запроса из i-bem кода конструкторского блока можно указать в параметре "block" имя блока, который реализует серверную шаблонизацию, используя данные от адаптера.

У этого блока должен быть метод "ajax", который и будет вызван:

```js
// Отправка запроса из i-bem
this.trigger('ajax-update', { block: 'my-block', /* другие параметры запроса */ });

// Серверный код
blocks['my-block__ajax'] = function(context, dataset) {
    // dataset — это результат работы адаптера
    return  {
        block: 'my-block__items',
        js: {
            // Данные, которые нужно отправить на клиент (если такие есть)
        },
        content: [
            { elem: 'item', content: '1' },
            { elem: 'item', content: '2' }
        ]
    });
}
```

__Важно:__ Данный механизм не работает для запросов, отправленных из React-компонентов. Если там необходима шаблонизация конструкторскими блоками, то следует использовать связку `ajaxRender` + метод `transform` в адаптере.

## Полезные ссылки

- транспорт — [i-request_type_ajax](../../blocks-common/i-request/_type/i-request_type_ajax.js)
- базовая конструкторская реализация — [ajax-update](../../construct/blocks-common/ajax-updater)
- транслирование событий шины в конструктор — [i-react-ajax-update](../../blocks-common/i-react-ajax-update)
- [AjaxUpdate](../../src/lib/AjaxUpdate)

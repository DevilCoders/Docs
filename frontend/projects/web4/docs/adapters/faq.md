# FAQ по адаптерам

- [Как правильно писать адаптеры](#Как-правильно-писать-адаптеры)
- [Как раскладывать реализацию адаптера по уровням переопределения](#Как-раскладывать-реализацию-адаптера-по-уровням-переопределения)
- [Как экспериментировать с адаптерами](../experiments/adapters.md)
- [Что есть в контексте](#Что-есть-в-контексте)
- [Как для данных выбирается адаптер](#Как-для-данных-выбирается-адаптер)
- [Если для документа сработает несколько адаптеров, какой "победит"](#Если-для-документа-сработает-несколько-адаптеров-какой-победит)
- [Как использовать React-органику](#Как-использовать-React-органику)
- [Конструктор еще можно использовать](#Конструктор-еще-можно-использовать)
- [Как подсветить слова запроса "жирным"](#Как-подсветить-слова-запроса-жирным)
- [Если в адаптере реализованы оба метода "render" и "transform", какой вызовется](#Если-в-адаптере-реализованы-оба-метода-render-и-transform-какой-вызовется)
- [Можно ли звать в TypeScript-адаптерах код из priv-мира](#Можно-ли-звать-в-TypeScript-адаптерах-код-из-priv-мира)
- [Как написать типы сконвертированному на TypeScript адаптеру](#Как-написать-типы-сконвертированному-на-TypeScript-адаптеру)
- [Куда лучше вынести общий код нескольких адаптеров](#Куда-лучше-вынести-общий-код-нескольких-адаптеров)
- [Можно писать адаптер для того, что не является поисковым результатом](#Можно-писать-адаптер-для-того-что-не-является-поисковым-результатом)

### Как правильно писать адаптеры?

Разработка фичи на подразумевает написание одного или нескольких адаптеров.
Основные правила написания адаптеров:

1. Адаптер преобразует данные в view-ориентированный формат, сразу прислать нужный формат с бекенда не надо. Бекенд не должен оперировать предметной областью шаблонов
2. Для разных фичей должны быть разные адаптеры
3. Адаптеры полностью независимы друг от друга. Адаптеры не должны вызывать внутри себя другие адаптеры

### Как раскладывать реализацию адаптера по уровням переопределения?

Реализация адаптера может состоять из одного или нескольких файлов. Если код адаптера для всех платформ, на которых представлена фича, одинаковый, то достаточно одного файла:

```diff
src/features/
  ├── MyFeature/ — папка фичи
+ │   └── MyFeature.server.tsx — реализация адаптера
```

Если между платформами есть различия, создается несколько файлов — по одному на каждый [уровень переопределения](../../README.md), на котором есть различия. Например, если между платформами "desktop" и "touch-pad" нет различий, но есть "touch-phone" в чем-то отличается, то файловая структура может быть такой:

```diff
src/features/
  ├── MyFeature/ — папка фичи
- │   └── MyFeature.server.tsx
+ │   ├── MyFeature@common.server.tsx — общий код
+ │   ├── MyFeature@desktop.server.tsx — код только для desktop
+ │   └── MyFeature@touch-phone.server.tsx — код, который будет использован только на touch-phone
```

Связи между реализациями с разных уровней осуществляется через механизм наследования:

- класс адаптера из "MyFeature@desktop.server.tsx" наследует от "MyFeature@common.server.tsx"
- класс из "MyFeature@touch-phone.server.tsx" так же наследует от "MyFeature@common.server.tsx"

```ts
/**
 * MyFeature@desktop.server.tsx
 */

import { AdapterMyFeature as Common } from './MyFeature@common.server';

export class AdapterMyFeature extends Common {
    // ...
}
```

### Что есть в контексте?

Через `this.context` внутри адаптера можно получить доступ к данным о запросе (reqid, текст запроса), о пользователе (yuid, регион, язык, браузер), об активных экспериментах.

Подробности см. в [lib/GlobalContext](../../src/lib/GlobalContext/README.md).

### Как для данных выбирается адаптер?

В шаблоны Серпа данные для поисковой выдачи приходят в виде большого JSON-а. Его можно увидеть внутри Яндекс-сети одним из способов:
1. добавить `&dump=1` в параметры запроса к Поиску, тогда внизу выдачи появится `div class="b-dumper-wrap"` с интерактивным представлением данных
2. добавить `&json_dump=1` в параметры запроса к Поиску, тогда загрузится только данные в виде `application/json`

#### Стандартный автоматический режим

Основная часть данных — это массив документов в центральной колонке, доступный по пути `searchdata.docs`. Увидеть данные можно, используя один из флагов `&dump=searchdata.docs` или `&json_dump=searchdata.docs` (кроме значения "1" можно писать путь, тогда будут показаны данные по запрашиваемому пути).

Каждый документ — это объект, в котором по разным "слотам" лежат данные для поискового результата:
- основной слот — массив данных `construct`
- "доконструкторские слоты" — данные в `snippets.(pre|inline_pre|main|post|full)`, которые перекладываются в конец массива "construct" хелпером "serp-item__move-snippets-to-construct" (priv-код)

Для каждого элемента массива "construct" рантайм шаблонов вызывает соответствующий ему адаптер. Сначала выполняет поиск по реестру TypeScript-адаптеров на точное совпадение полей `type/subtype` из данных и записи в реестре. Если ничего не найдено, выполняется поиск среди priv-адаптеров — сначала по паре `type/subtype`, потом по одному полю `type` (fallback).

#### Ручной режим

**Редкий случай, широко этот способ использовать НЕ НАДО.**

В некоторых "доконструкторских местах" рантайм адаптеров вызывается руками. Выглядит это так:

```js
blocks['main__serp-auth'] = function(data) {
    /* подготовка контекста и данных на основе всего JSON-а бекенда */

    // Блок 'construct' — это актуальный рантайм шаблонов,
    //   который включает в себя TypeScript- и priv-адаптеры
    return blocks['construct'](
        // Будет вызван адаптер для типа "user-auth"
        blocks['construct__dataset'](context, { type: 'user-auth' })
    );
};
```

### Если для документа сработает несколько адаптеров, какой "победит"?

**ВНИМАНИЕ: сложная техника, обычно у фичи один адаптер**

Алгоритм работы рантайма адаптеров:
1. Найти все адаптеры, подходящие для данных поискового результата (см. подробности в [Как для данных выбирается адаптер](#Как-для-данных-выбирается-адаптер)), и вызвать их
2. Если результат адаптера имеет пометку [godMode](./deprecated-priv.md#Режим-godMode) или это был TypeScript-адаптер с шаблонизацией через React-компоненты (godMode там включается автоматически), то возвращается этот результат. Остальные адаптеры не вызываются
2. Если "godMode" не было, то возвращается первый непустой результат, а результаты работы других адаптеров делаются доступными через [construct__multiple-adapters](../construct/faq.md#Как-в-блоке-получить-данные-сразу-от-нескольких-адаптеров)

### Как использовать React-органику?

Скорее всего, имеется в виду наличие тайтла и гринурла. Органика — React-компонент, а его использование максимально простое:
- сформировать данные
- вызвать компонент

В адаптере формируем props-ы для компонента `Organic`:

```diff
export class AdapterMyFeature extends Adapter<IMyFeatureSnippet> {
    getInitialProps() {
-        // Преобразование данных и передача их в React-компонент
+        return {
+            // Преобразование данных и передача их в React-компонент
+            organic: {
+                title: 'Поисковый результат',
+                url: 'https://ya.ru',
+                path: [{
+                    url: 'https://ya.ru',
+                    text: 'Яндекс.Поиск',
+                }],
+            },
+        };
    }

    render() {
        return <App {...this.getInitialProps()} />;
    }
}
```

В корневой компонент фичи добавляем вызов компонента `Organic`:

```diff
import React from 'react';
import { cnMyFeature } from './MyFeature';
+ import { Organic, IOrganicProps } from '../../components/Organic/Organic@desktop';

export interface IMyFeatureProps {
    // Собственные props-ы корневого компонента
+    organic: IOrganicProps;
}

export const MyFeature: React.FC<IMyFeatureProps> = props => (
    <div className={cnMyFeature()}>
+        <Organic {...props.organic} />
        // Собственный контент корневого компонента
    </div>
);
```

Если органика нужна, а данных для нее нет, можно использовать [baseResponseData-хелперы](../../src/vendors/taburet/Adapter/baseResponseData). В адаптер подключается `withBaseResponseData`-хок, который добавляет в адаптер методы `get*` для формирования данных органики. Можно запросить конкретное поле, например `getTitle()`, или все поля сразу через `getOrganic()`:

```diff
+ import { withBaseResponseData } from '../../vendors/taburet/Adapter/withBaseResponseData@desktop';

export class AdapterMyFeature extends withBaseResponseData(Adapter)<IMyFeatureSnippet> {
    getInitialProps() {
        return {
            // Преобразование данных и передача их в React-компонент
-            organic: {
-                title: 'Поисковый результат',
-                url: 'https://ya.ru',
-                path: [{
-                    url: 'https://ya.ru',
-                    text: 'Яндекс.Поиск',
-                }],
-            },
+            organic: this.getOrganic(),
        };
    }

    render() {
        return <App {...this.getInitialProps()} />;
    }
}
```

### Конструктор еще можно использовать?

Короткий ответ "Да, если есть объективные причины не использовать React".

Если в адаптере вместо метода `render` реализовать метод `transform`, то внутри него моно будет вернуть данные для конструкторских блоков. Подробности см. в [значение priv-адаптера](./deprecated-priv.md#Возвращаемое-из-адаптера-значение).

Необходимые для работы с конструкторскими блоками типы следует искать в [src/typings/construct](../../src/typings/construct). Если там чего-то не хватает, смело добавляйте.

### Если в адаптере реализованы оба метода "render" и "transform", какой вызовется?

Сначала вызовется `render`. Только если он вернул пустой результат, вызовется `transform`.
Шаблонизация через React имеет больший приоритет, чем через Конструктор.

### Как подсветить слова запроса "жирным"?

Если вам из данных приходит текст, в котором нужно подсветить (выделить жирным) слова из поискового запроса или название релевантного Яндекс-сервиса, то в зависимости от формата данных нужно выбрать один из способов.

Для шаблонизации через React-компоненты:

- если в данных текст уже размечен "семерками" (юникодовые символы `\u0007[ \u0007]`), тогда надо обернуть текст в компонент [Markup](https://depot.yandex-team.ru/components/?storybook=%2Fstory%2Fserp-components-markup--default). Некоторые компоненты сами используют `Markup` внутри, например `OrganicTitle` (заголовок органического сниппета)
- если в данных пришла HTML-разметка с `<b></b>`, то нужно будет использовать тот же компонент `Markup` с переопределением стандартных маркеров начала/конца выделенной фразы `<Markup start="<b>" end="</b>">{textWithB}</Markup>`
- если в данных разметки не было, то можно разметить фразы руками через JSX: `обезжиренный <b>жирненький</b>`

Для шаблонизации через Конструктор:

- если в данных текст уже размечен "семерками", то Конструктор все сделает автоматически
- если в данных пришли `<b></b>`, то придется этот текст руками оборачивать в блок "html", чтобы избежать экранирования тегов
- если в данных разметки не было, предлагается использовать блок "bold" по месту

**НАСТОЯТЕЛЬНО рекомендуется просить бекенд присылать "семерки".** Обычно им это сделать несложно.

### Можно ли звать в TypeScript-адаптерах код из priv-мира?

Нет, priv-код нужно переписать на TypeScript и перенести в [src/lib](../lib.md).
Сделать его доступным в priv-мире можно через `RequestCtx` (см. [templateRunner()](../../src/lib/taburet/packages/template-runner/index.ts)) или через [GlobalContext](../../src/lib/GlobalContext).

Есть альтернативный и **крайне нежелательный способ** — добавить хелпер в [privExternals](../../blocks-common/priv-externals/priv-externals.priv.js). Если вы были вынуждены им воспользоваться, заведите задачу, в которой планируете в среднесрочной перспективе "сделать хорошо".

### Как написать типы сконвертированному на TypeScript адаптеру?

Если вы работаете с кодом адаптера, сгенерирован из priv-версии автоматикой, то в начале его файлов будет такой комментарий:

```js
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
Адаптер был сгенерирован автоматически, если есть вопросы по конвертации
FAQ в эпике:
https://st.yandex-team.ru/SERP-93568
*/
```

В таких адаптерах нет настоящих типов, почти везде используются `any`.

Чтобы получить профит от TypeScript-а — допускать меньше ошибок/опечаток, получить подсказки от IDE, нужно написать честные типы и избавиться от "eslint-disable"-комментария. Алгоритм написания типов для сконвертированного в TypeScript адаптера находится на [wiki/howto-replace-any-in-adapters](https://wiki.yandex-team.ru/search-interfaces/architecture/howto-replace-any-in-adapters/).

### Куда лучше вынести общий код нескольких адаптеров?

Если общий код используется в адаптерах "родственных фичей" (например, разных видов одного колдунщика), то можно:
- вынести код в базовый адаптер, от которого наследовать адаптеры подтипов фичи
- вынести код в [миксины](../patterns/adapters/mixins.md) или [хелперы](../patterns/adapters/helpers.md)

```bash
src/features/
  ├── MyFeature/ — папка фичи
  |   ├── _subtype/ — реализация подтипа фичи
  |   |   └── MyFeature_subtype.server.ts
  |   ├── MyFeature.helpers/ — хелперы/миксины для адаптеров
  │   └── MyFeature.server.ts — базовый адаптер
```

Если общий код используется в адаптерах несвязанных фичей, то его следует сделать [библиотечным](../lib.md).

### Можно писать адаптер для того, что не является поисковым результатом?

Обычно адаптер фичи наследуется от класса `Adapter` (базовый адаптер Табурета). Это дает нам возможность из методов адаптера обращаться к данным (`this.snippet`), контексту запроса (`this.context`) и поисковому документу (`this.document`).

Но адаптер можно писать не только для обычных поисковых ответов в центральной и правой колонках, но и для "большой карусели", попапов и других фрагментов поисковой выдачи. При этом доступа к конкретному документу может не быть, например, потому что фрагмент интерфейса общий на всю страницу. Чтобы проверка типов учитывала необязательность наличия "объекта документа", следует такого типа адаптеры наследовать от специального класса `AdapterForWizard` (см. реализацию в [vendors/taburet](../../src/vendors/taburet/Adapter/index.ts)).

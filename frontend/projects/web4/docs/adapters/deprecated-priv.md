# Адаптеры на priv.js

**Priv-реализация адаптеров является устаревшей. Новые адаптеры запрещено писать на priv.js (есть линтер)**

- [Общая информация](#Общая-информация)
- [Возвращаемое из адаптера значение](#Возвращаемое-из-адаптера-значение)
- [Типы/Подтипы](#ТипыПодтипы)
- [Ajax](#Ajax)
- [Переводы](#Переводы)
- [Специальные адаптеры и режимы](#Специальные-адаптеры-и-режимы) (Test, Legacy, preventLegacy, GodMode)

### Общая информация

Все priv-адаптеры лежат в отдельной папке проекта:

```bash
adapters/
 ├── blocks-common
 ├── blocks-deskpad
 ├── blocks-desktop
 ├── ...
```

Код конкретного адаптера хранится в папке этого адаптера:

```bash
adapters/
 ├── blocks-common/
 |   ├── adapter-example
 |   |   ├── __helpers/ — вспомогательный код, вынесенный в отдельные файлы
 |   |   ├── _type/ — подтипы адаптера
 |   |   └── ...
```

Сам код пишется на JavaScript в `.priv.js`-файлах в формате:

```js
/**
 * Аргументы — прямые аналоги свойств TypeScript-адаптеров:
 *   context — это this.context
 *   snippet — это this.snippet
 *   doc — это this.document
 */
blocks['adapter-example'] = (context, dataset, doc) => {
    // основной код адаптера "example"
};

/**
 * У вспомогательных функций может быть любая сигнатура
 */
blocks['adapter-example__helper-function'] = (arg1, arg2) => {
    // вспомогательные код
};
```

### Возвращаемое из адаптера значение

Результатом основной функции адаптера может любая из форм:

- Данные любого конструкторского блока с обязательным полем `block: 'name-of-block'`. Чаще всего используется блок [composite](../construct/blocks/composite.md)
- Произвольные данные, которые потом будут получены в блоках конструктора через [construct__multiple-adapters](../construct/faq.md#Как-в-блоке-получить-данные-сразу-от-нескольких-адаптеров)
- Поля органической части поискового результата (`title`, `subtitle` и проч.), то что шаблонизируется блоком "organic"

Для формирования одного результата поиска могут вызываться несколько адаптеров. Это происходит, если в `doс.construct` пришел массив с несколькими наборами данных.
Это сделано потому, что данные для отрисовки одного результата поиска могут приходить из нескольких несвязанных источников. Кроме того для всех "не колдунщиков" всегда
вызывается "legacy-адаптер" (о нём чуть ниже);

Результат поиска формируется по следующим правилам:
1. Блок, которым будет отрисован результат, берется из первого адаптера, в котором указано поле `block` (если такого поля нет, то пытаемся найти его в следующем и т.д.)
Если ни в одном адаптере блок не указан, будет вызван блок `default-result`.
2. Каждое поле блока, в случае если они поддерживает работу с несколькими адаптерами, будет работать с теми данными, которые пришли из первого адаптера, где соответствующее поле встречается.
Если ни в одном адаптере нужных данных нет, поле отрисовано не будет.

__Важно:__ В любом из адаптеров есть возможность указать, что какое-то из полей нужно оставить пустым, тогда значения этого поля из всех адаптеров, вызванных позже (включая legacy) будут игнорироваться.
Для этого в значении этого поля нужно указать `null`.

Пример:

```js
blocks['adapter-without-title'] = function(context, snippet) {
    return {
        /* ... */
        title: null, // Значение заголовка из последующих адаптеров будет игнорироваться.
        /* ... */
    }
};
```

### Типы/Подтипы

По умолчанию адаптер выбирается по значению поля `type` в данных. Если в данных сниппета пришло `{ type: 'example' ... }`, будет вызван адаптер "adapter-example".

Если поисковый результат может иметь несколько представлений и для каждого представления приходит свой формат данных, то кроме основных адаптеров можно реализовать адаптеры для подтипов. Например, для подтипов "foo" и "bar"  следует создать адаптеры с именами `adapter-example_type_foo` и `adapter-example_type_bar` соответственно.

Чтобы был выбран адаптер для подтипа "foo", в данных должно прийти `{ type: 'example', subtype: 'foo ... }`.

__Важно:__ Вообще, адаптер выбирается по наилучшему совпадению. Если есть адаптер для подтипа, то вызовется он. Если адаптер для подтипа не найден, вызовется основной адаптер.

### Ajax

Если кроме шаблонизации поискового результата, адаптер должен уметь обрабатывать ajax-запросы с клиента, нужно реализовать специальную функцию:

```js
blocks['adapter-example__ajax'] = function(context, data) {
    /*
     * Обратите внимание что на вход функция получает полный объект data
     * к сожалению на данный момент нет способа автоматически узнать, из какой части data
     * нужно брать сырые данные для фичи. Параллельно мы работаем над унификацией ручек,
     * так что скоро возможно это изменится
     */
    var snippet = _.prop(data, 'wizplaces.carousel.0.data.parent_collection');

    return {
        ajax: {
            // данные, которые будут отправлены на клиента
        },
        // данные для шаблонизации части ответа через конструкторский блок
    };
}
```

Подробнее про шаблонизацию в ajax-ответе см. в [Системы/ajax](../systems/ajax.md).

### Переводы

Для работы с переводами в адаптерах используется специальный конструкторский блок `i18n`. Его обязательные свойства соответствуют первым двум аргументам функции "BEM.I18N" - `keyset` и `key`. Свойства ключа записываются параметрами в сам блок.

Ключевое отличие этого блока от стандартного механизма "BEM.I18N" в том, что вместо строковых полей можно использовать текстовые конструкторские блоки. Это может быть полезно, когда, например, есть надо выводить какой-то текст с ценой - результатом работы блока `price`.

Используя функцию `BEM.I18N`, это можно было бы сделать примерно так:

```js
blocks['adapter-example'] = function(context, snippet) {
    var price = BEMHTML.apply(blocks['construct__text-blocks'](context, {
            block: 'price',
            minValue: snippet.delivery_cost,
            currency: snippet.delivery_currency
        }));

    return {
        block: 'html',
        content: BEM.I18N('adapter-example', 'Доставка: {price}', {
            price: price,
            context: '{price} - строка с ценой вида "12 900€ ... 13 000€" или "от 300 руб."'
        })
    };
};
```

Тот же результат можно получить, используя блок `i18n`:

```js
blocks['adapter-adapter'] = function(context, snippet) {
    return {
        block: 'i18n',
        keyset: 'adapter-adapter',
        key: 'Доставка: {price}',
        price: {
            block: 'price',
            minValue: snippet.delivery_cost,
            currency: snippet.delivery_currency
        },
        context: '{price} - строка с ценой вида "12 900€ ... 13 000€" или "от 300 руб."'
    };
};
```

**Для переводах в адаптеров всегда следует использовать конструкторский блок "i18n"**. Даже, если внутри используются обычные строки.

### Специальные адаптеры и режимы

#### Адаптер Test

Для целей тестирования блоков, а также для использования в "песочнице" у нас есть тестовый адаптер, который прокидывает в блок все данные, пришедшие ему, никак не модифицируя их.
Это удобно, если, например, нужно быстро проверить какой-то блок в песочнице.

Этот адаптер не работает во внешней сети.

#### Адаптер Legacy

Этот адаптер, всегда вызывается для результата поиска, отрисованного конструктором и не являющегося при этом "колдунщиком", и достает из `doc` информацию, которую не всегда могут предоставить источники,
такую как: заголовок снипета, path, extralinks, и.т.д.

Так как он всегда вызывается последним (см. раздел про формирование результата поиска из нескольких адаптеров), любые вернувшиеся из него данные имеют наименьший приоритет и используются только в
том случае, если ни один адаптер не предоставил альтернативы.

При крайней необходимости, есть возможность вызывать части legacy адаптера из обычного адаптера. Это может понадобиться в том случае, если необходимо добавить что-то в текст или заголовок, сформированный legacy адаптером.
Делается это вызовом соответствующих методов legacy адаптера:

```js
blocks['adapter-example'] = function(context, snippet, doc) {
    return {
        title: [
            blocks['adapter-legacy__title'](context.reportData, doc),
            'O_O' // данные добавленные в адаптере.
        ]
    }
};
```
**Ни в коем случае нельзя вызывать таким образом какие-то другие адаптеры или методы-хелперы других адаптеров.**

#### Режим preventLegacy

Также предусмотрена возможность отключать обработку поискового результата legacy адаптером. Это делается с помощью булевого параметра `preventLegacy`. Пример:

```js
blocks['adapter-example'] = function(context, snippet, doc) {
    return {
        title: snippet.title,
        preventLegacy: true
    };
};
```

#### Режим godMode

Для принудительного отключения логики про формирование одного результата поиска из нескольких адаптеров предусмотрена возможность указать в адаптере, который хочется оставить единственным адаптером, участвующим в формировании результата, булевый параметр `godMode`. Пример:

```js
blocks['adapter-example'] = function(context, snippet, doc) {
    return {
        title: snippet.title,
        godMode: true
    };
};
```

**Примечание:** этот режим не выключает legacy адаптер. Дополнительно используйте параметр `preventLegacy`, который описан в разделе "Адаптер Legacy".

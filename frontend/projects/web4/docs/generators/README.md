# Кодогенерация
## Команды кодогенерации 
* `npm run generate:feature`              - генерация фичи
* `npm run generate:component`            - генерация компонента
* `npm run generate:exp-feature`          - генерация эксперимента фичи
* `npm run generate:exp-css`              - генерация эксперимента над css
* `npm run generate:exp-component`        - генерация эксперимента над компонентом
* `npm run generate:icon`                 - генерация иконки
* `npm run generate:global-context-field` - генерация поля GlobalContext
  
## Подробнее о командах
Весь процесс работы генератора логируется в консоль, можно посмотреть пути созданных файлов, измененных или важную информацию о генерации.
___
### Генерация фичи
Для генерации фичи требуется ответить на несколько вопросов:
* Имя фичи
    > Имя адаптера переводится в PascalCase, но все же советуем придерживаться правильного именования фичей
* Дополнительный путь (опционально)
    > Пример: при вводе `Adapter/_hidden` путь до фичи будет выглядеть как `./src/feature/Adapter/_hidden/FeatureName`
* Выбор платформы
* Нужно ли создавать родительский адаптер
* Нужно ли создавать родительский компонент
* Выбор типа компонента 
    > Функциональный или классовый компонент
* Тип адаптера для записи в .registry 
* Подтип адаптера (опционально)
* v-team 
    > Нужно для генерации тестов и записи в .registry

**ВАЖНО:** после генерации фичи требуется перезапустить dev сервер, чтобы изменения в .registry вступили в силу
___
### Генерация компонента
Для генерации компонента требуется ответить на несколько вопросов:
* Имя компонента
* Выбор платформы
* Нужно ли создавать родительский компонент
    > Игнорируется, если была выбрана одна платформа
* Выбор типа компонента
    > Функциональный или классовый компонент
___
### Генерация эксперимента над фичей
Для генерации эксперимента над фичей требуется ответить на несколько вопросов:
* Флаг эксперимента
* Фича над которой будет проводиться эксперимент
    > Список формируется по всем фичам в `src/features`, если вашей фичи там нет, то, скорее всего, это вызвано из-за нестандартной записи адаптера. Если вы все же уверены, что ваша фича легитимно должна находиться в этом списке, то напишите в канал #architecture в Slack
* Выбор платформы
    > Список платформ зависит от выбранной ранее фичи
* Выбор типов фичи 
    > Список типов представляет собой объект с платформой, типом и подтипом. Зависит от выбранной ранее фичи и платформ
* v-team
* Планируете ли вы изменить entry 
* Нужно ли создавать родительский компонент
    > Вопрос игнорируется, если вы не планируете изменить entry
* Выбор типа компонента 
    > Функциональный или классовый компонент. Вопрос игнорируется, если вы не планируете изменить entry
* Нужно ли переносить тесты с помощью Tide
    > **ВАЖНО:** При копировании тестов фичи могут произойти непредвиденные проблемы. Советуем отказаться от автоматического переноса тестов, а ошибку принести в канал #architecture
___
### Генерация эксперимента над компонентом
Для генерации эксперимента над компонентом требуется ответить на несколько вопросов:
* Флаг эксперимента
* Имя эксперимента над компонентом
* Выбор платформы
* Выбор id реестра 
    > Список будет зависеть от платформ, которые вы выбрали
* Выбор типов адаптера
    > Если эксперимент над компонентом, который не принадлежит какой-либо фиче, то по умолчанию будут выбраны все адаптеры (`*`). Либо можно пропустить выбор и по умолчанию будут выбраны все адаптеры
* v-team 
___
### Генерация иконки
Для генерации иконки требуется ответить на несколько вопросов:
* Имя иконки
* Размер иконки
* Выбор иконки
    > Выбор происходит из всех иконок в `@yandex-serp-design/search`
___
### Генерация поля в GlobalContext
Для генерации поля в GlobalContext требуется ответить на несколько вопросов:
* Имя поля
* Нужно ли это поле предоставлять клиенту
    > Если утвердительно ответить, то добавится новое поле в `params` `i-global__params.priv.js`, и добавится новое поле в `contextStub` `GlobalContext.tsx`
* Выбрать stub значение для поля
    > Вопрос игнорируется, если вы решили не предоставлять поле клиенту
___
## Как это работает
Реализация кодогенератора расположена в `./tools/generators/`.
Кодогенерация использует фреймоврк [PLOP](https://plopjs.com/documentation/), который в свою очередь использует под капотом [Inquirer.js](https://github.com/SBoudrias/Inquirer.js), для создания интерфейса командной строки, и [Handlebars](https://handlebarsjs.com/guide/), для создания шаблонов.

Для начала мы создаем генератор (`setGenerator`) и присваиваем ему имя, для последующего вызова (Пример: `create_feature`). В функцию создания генератора мы также передаем объект вида `{ prompts, actions }`.
* `Prompts` - это массив объектов. Из этого массива формируется интерфейс командной строки, затем, когда получены все ответы пользователя, сформированные данные передаются в `actions`.
* `Actions` - это функция, возвращающая массив объектов. Каждый объект - это инструкция для объекта `plop`. Каждая инструкция содержит в себе тип операции, путь для шаблона, путь до файла и т.п. (Об этом можно прочитать в [документации Plop](https://plopjs.com/documentation/)).
  
### Кастомные Action Type
Для исключительных операций (таких как добавление полей в определенный объект или вызов tide) создавались свои ActionType.
В основном для кастомных ActionType использовались:
* `@babel/parser` - для создания AST деревьев и вставки/модификации уже существующих файлов
* `node-plop/lib/generator-runner` - это незадокументированное  API библиотеки `node-plop` (использовалось для вызова генератора feature внутри генератора exp-feature)
* `@yandex-int/tide` и `@yandex-int/tide/build/src/plugins/tide-experimenter` - tide это библиотека для генерации тестов, а tide-experimenter это плагин tide для копирования тестов в эксперимент
    > Подробнее о [tide](https://a.yandex-team.ru/arc/trunk/arcadia/frontend/packages/tide?rev=r8429539) и [tide-experimenter](https://a.yandex-team.ru/arc/trunk/arcadia/frontend/packages/tide/src/plugins/tide-experimenter?rev=r8429539)
# Гайд по написанию шаблонов

- [Тонкости опции escapeContent](#Адаптация-шаблонов-для-использования-с-опцией-escapeContent)
- [Написание unit-тестов](#Написание-unit-тестов-на-шаблоны)
  - [Файловая структура](#Файловая-структура)
  - [Запуск тестов](#Запуск-тестов)
  - [Правила тестирования](#Правила-тестирования)
    - [Общие принципы](#Общие-принципы)
    - [Что тестируем](#Что-тестируем)
    - [Хозяйке на заметку](#Хозяйке-на-заметку)

## Адаптация шаблонов для использования с опцией escapeContent

Чтобы повысить безопасность, в BH-шаблонах есть возможность использовать опцию `escapeContent`, которая активирует режим экранирования всего строчного содержимого в BEMJSON.

Мы используем декларативные шаблонизаторы на базе BEMJSON с генерацией DOM-узлов, поэтому у нас есть возможность экранировать весь контент кроме: `<!DOCTYPE html>`, HTML-комментариев и других строк, содержащих HTML-сущности.
Если нужно вывести готовый HTML, то это следует явно указать шаблонизатору, чтобы он повторно не экранировал HTML-контент ни в одном из режимов работы: как c включенной, так и с выключенной опцией `escapeContent`.

Типовые задачи и решения:

1. Если нужно передать HTML-сущности в поле `content` (`&mdash;`, `&laquo;`) — по возможности, используйте UTF-8 аналоги, иначе — см. п. 2; для `'&nbsp;'` стоит сделать исключение и использовать экранированный UTF-8 символ (`'\u00a0'`), чтобы отличать его от обычного пробела.
2. Если контент нужно вывести как есть (`'<a name=section>Section</a>'`) — для BH оберните контент во вспомогательный объект `content: {tag: false, html: 'оригинальный-контент'}`. В других шаблонизаторах могут быть другие варианты решения. [Общее решение](https://st.yandex-team.ru/BEM-1960#1436518432000) пока не реализовано.
3. Если контент нужно всегда экранировать — самостоятельно экранируйте содержимое с помощью конструкции `bh.xmlEscape(content)` после чего оберните его в конструкцию, описанную в п. 2.
4. Если нужны тесты на XSS в шаблонах — можно для каждого шаблонизатора (`html` для BH, `content` для BEMHTML) передать свое: `{tag: false, html: '<script/>alert(1);</script>', content: '<script>alert(1);</script>'}`.

**NB** Поле `html` имеет приоритет перед полем `content`, поэтому не нужно использовать поле `html` в местах, где пользователь может пытаться переопределить `content` — старайтесь использовать его только в конструкции `{tag: false, html: '<script>'}`.

**NB** Поле `html` не может содержать BEMJSON или массив — только строку.

## Написание unit-тестов на шаблоны

### Файловая структура
Тесты на шаблоны блока кладутся в папку `<block-name>.tmpl-specs`.
Файл с исходным BEMJSON имеет расширение `bemjson.js`, файл с эталонным HTML — `html`.

#### Пример файловой структуры:
Уровень `common.blocks`:
```
attach
├── __control
│   ├── attach__control.bemhtml
│   └── attach__control.bh.js
├── attach.bemhtml
├── attach.bh.js
└── attach.tmpl-specs
    ├── 10-empty.bemjson.js
    ├── 10-empty.html
    ├── 20-simple.bemjson.js
    └── 20-simple.html
```

Уровень `touch.blocks`:
```
attach
├── __control
│   ├── attach__control.bemhtml
│   └── attach__control.bh.js
└── attach.tmpl-specs
    ├── 10-empty.html
    └── 20-simple.html
```
Чтобы протестировать модификатор или элемент блока нужно положить тесты в папку к тестируемой сущности.

Пример файловой структуры:
```
button
└──_disabled
    ├── button_disabled_yes.bemhtml
    ├── button_disabled_yes.bh.js
    └── button_disabled_yes.tmpl-specs
        ├── 10-empty.bemjson.js
        └── 10-empty.html
```

Чтобы написать интеграционный тест, например, для проверки работы сразу нескольких модификаторов, нужно добавить зависимость для технологии `tmpl-spec.js`:
```js
[{
    mustDeps: {...} // здесь общие зависимости блока
},
{
    tech: 'tmpl-spec.js', // зависимости, необходимые только для тестов на шаблоны
    shouldDeps: {
        tech: 'bemhtml',
        mods: {
            counter: 'yes',
            'only-icon': 'yes',
            'has-spin': 'yes'
        }
    }
}];
```
Пример более сложных зависимостей:

```js
{
    // deps for test by html-differ
    tech: 'tmpl-spec.js',
    mustDeps: [
        {
            tech: 'bemhtml',
            blocks: ['input', 'button', 'checkbox']
        },
        {
            tech: 'bemhtml',
            block: 'input',
            elems: ['clear', 'control', 'foot', 'hint', 'box']
        },
        {
            tech: 'bemhtml',
            block: 'button',
            elems: 'text'
        },
        {
            tech: 'bemhtml',
            block: 'checkbox',
            elems: ['box', 'control', 'tick', 'label']
        }
    ]
}
```

### Запуск тестов
Выполнение всех тестов производится командой `enb make tmpl-specs`.
Тесты выполняются для трех платформ: `desktop`, `touch-phone` и `touch-pad`.

Успешный результат выглядит примерно так:
```
  attach (desktop.tmpl-specs)
    ✓ should be equal `20-simple` by bemhtml
    ✓ should be equal `20-simple` by bh

  2 passing (5ms)

  attach (touch-phone.tmpl-specs)
    ✓ should be equal `20-simple` by bemhtml
    ✓ should be equal `20-simple` by bh

  2 passing (5ms)

  attach (touch-pad.tmpl-specs)
    ✓ should be equal `20-simple` by bemhtml
    ✓ should be equal `20-simple` by bh

  2 passing (6ms)
```
Если часть тестов упадет, вы увидите сообщение об ошибке и diff (expected/actual).

### Правила тестирования
Задача в том, чтобы покрыть тестами всю вариативность блока минимально необходимым количеством эталонных файлов.

#### Общие принципы
1. Название теста должно отражать его суть и назначение.
2. BH и BEMHTML сильно отличаются по архитектуре. Тесты должны покрывать эту разницу, если шаблоны написаны с учетом специфики.
3. Если у блока есть две ветви логики, которые влияют на одно и то же место, нужно написать тесты на каждую ветвь отдельно и на их совокупность.
4. При наличии доопределений шаблонов на уровнях `desktop` и `touch*` нужны дополнительные тесты на соответствующих уровнях.
5. Эталоны сохраняются без i18n, вместо текста перевода подставляется соответствующий `key`. Например, не текст "Forgot your password?", а ключ `remember`.
6. В одном тесте допускается тестирование сразу нескольких вариантов блока, только если эти варианты очень сильно связаны друг с другом.
7. Если результат шаблонизации зависит от опции `escapeContent`, то для BH можно использовать поле `html` наряду с `content` для BEMHTML: `{tag: false, html: 'raw string', content: 'another string'}`.

#### Что тестируем
1. Поведение блока по умолчанию, когда у него нет никаких полей в BEMJSON, кроме `block`. Для этого рекомендуется создавать файл `10-empty.bemjson.js`.
2. Рекомендуемое поведение (обычно это самый первый из примеров в документации на блок). Здесь не должно быть кастомных полей и атрибутов, только минимально необходимый для реального использования набор полей. Рекомендуется название — `20-simple`.
3. Расширенный набор полей. Исходный BEMJSON должен содержать пользовательские атрибуты, нестандартную тему, дополнительные миксы..., в общем, всё, что как-либо упоминается в шаблонах и потенциально может быть написано пользователем. Рекомендуемое название — `30-extended`.
4. Модификация контекста. Если блок доопределяет шаблоны других блоков (например, `attach` доопределяет `button`), необходимо добавить эти блоки в зависимости для технологии `tmpl-spec.js`.
5. Модификация от контекста. Если блок работает по-разному в зависимости от внешней среды.
6. Комбинации модификаторов. Если два разных модификатора влияют на одно и то же место (например, расширяют контент или добавляют атрибуты), нужно завести тесты на каждый модификатор в отдельности и на их сочетание, например для блока `link`: `50-pseudo`, `55-pseudo-disabled`, `60-disabled`.

#### Хозяйке на заметку

В момент создания теста эталонный html-код можно получить, используя переменную среды `BEM_TMPL_SPECS_SAVE_HTML`.

Алгоритм такой:

1. Создать bemjson-файл теста. Скажем, `10-empty.bemjson.js`.
1. Создать **не пустой** html-файл теста `10-empty.html`. Можно написать какую-нибудь абракадабру.
1. Запустить тесты: `bem make desktop.tmpl-specs/block/`.
1. В папке `desktop.tmpl-specs/block/` найти файл `10-empty.bemhtml.html`.
1. Перенести содержимое файла в `10-empty.html`, отформатировать.
1. Глазами отсмотреть, что результат корректный и его можно использовать как эталонный.

#### Переопределения

В некоторых случаях может возникнуть необходимость переопределения определенной части
шаблона на уровне тестов. В этом случае, укажите что оригинальный код должен быть
проигнорирован при подсчете покрытия. Сделать это можно при помощи специальных
[управляющих комментариев](https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md).

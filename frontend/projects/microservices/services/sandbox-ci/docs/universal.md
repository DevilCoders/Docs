# Универсальный обработчик событий от GitHub

Запускает задачи в Sandbox.
Позволяет фильтровать входящие события.
Для каждого события можно запустить несколько задач.

## Настройка

В настройках репозитория (`https://github.yandex-team.ru/<owner>/<repo>/settings/hooks`) добавьте новый
вебхук c **Content type**: `application/json`. В качестве адреса укажите:

```
https://sandbox-ci.si.yandex-team.ru/v1/hooks/github
```

Затем там же включите доставку желаемых событий. На данный момент поддерживаются события **Push** и **Pull request**.
После сохранения вебхука он должен ответить `pong` на первоначальное событие `ping`.
Подробнее про события можно почитать [здесь](https://developer.github.com/webhooks/).

### Конфигурационный файл

Для корректной работы сервиса в репозитории должен быть конфигурационный файл.
Путь к нему можно указать query-параметром `&configPath=other/config/path.json`, по умолчанию `.config/sandbox-ci.json`.

> В документации для удобства описания структуры конфигурационного файла используется нотация [JSONPath](http://goessner.net/articles/JsonPath/).

Если содержимое конфигурационного файла не удалось получить после нескольких попыток, сервис ответит кодом 400:

```json
{
  "statusCode": 400,
  "error": "Bad Request",
  "message": "couldn't fetch sandbox-ci config: <детали ошибки>"
}
```

:warning: Для события **Pull request** конфигурация берётся из head-ветки (откуда отправлен пулл-реквест).

Чтобы сервис мог прочитать конфигурационный файл в приватном репозитории, нужно выдать роботу **@robot-serp-bot** разрешение на чтение (**Read**) на странице настроек доступа (`https://github.yandex-team.ru/<owner>/<repo>/settings/collaboration`):

![](./images/robot-collaborator.png)

Конфигурационный файл должен удовлетворять [JSON-схеме](../schema/sandbox-ci.json).
Предварительно можно провалидировать так:

```
curl -X POST \
  https://sandbox-ci.si.yandex-team.ru/validate-config \
  -H 'Content-Type: application/json' \
  -d @.config/sandbox-ci.json
```

#### Шаблонизация

В конфигурационном файле можно использовать плейсхолдеры, которые будут заменены на значения при его последующей обработке внутри сервиса. В качестве источника данных выступает payload, сгенерированный GitHub, в ответ на какое-либо событие в репозитории.

> :heavy_exclamation_mark: В свойство `payload` попадает оригинальный объект события, пришедший от GitHub.

Для того, чтобы обратиться к любому свойству объекта `payload` используется следующий синтаксис:

```json5
{
  // ...
  "key": "{{payload.repository.name}}"
}
```

> :book: Подробнее о работе шаблонизации можно прочитать в описании пакета [json-templater](https://github.com/lightsofapollo/json-templater).

Шаблонизация работает **во всём** конфигурационном файле **во всех ключах и значениях**, но не забывайте следить за тем, какие свойства объекта `payload` вы используете, потому что payload, сгенерированный GitHub, меняется в зависимости от событий. Подробнее о том, какие свойства доступны внутри объекта `payload`, можно посмотреть в [документации GitHub](https://developer.github.com/v3/activity/events/types).

Например, получение имени владельца репозитория для событий `push` и `pull_request` отличаются:

**Событие `push`**

```json5
{
  // ...
  "github_event_handlers": {
    "push": [
      {
        "sandbox_tasks": [
          {
            "custom_fields": [
              { "name": "project_github_owner", "value": "{{payload.repository.owner.name}}" }
            ]
          }
        ]
      }
    ]
  }
}
```

**Событие `pull_request`**

```json5
{
  // ...
  "github_event_handlers": {
    "pull_request": [
      {
        "sandbox_tasks": [
          {
            "custom_fields": [
              { "name": "project_github_owner", "value": "{{payload.repository.owner.login}}" }
            ]
          }
        ]
      }
    ]
  }
}
```

#### Минимальная конфигурация

```json
{
  "github_event_handlers": {
    "push": [
      {
        "sandbox_tasks": [
          { "type": "MY_TASK", "owner": "MY_OWNER" }
        ]
      }
    ]
  }
}
```

Читается так: на каждое событие `push` создать и запустить в Sandbox одну задачу типа `MY_TASK` с владельцем `MY_OWNER`.

При успешном запуске сервис ответит кодом 200:

```json
{
  "startedTasks": [91929394],
  "unsatisfiedFilters": [],
  "errors": []
}
```

Если владельцем задачи является группа, а не робот, то в неё необходимо добавить робота `robot-serp-bot`.

#### Параметры запуска по умолчанию

В поле `$.sandbox_tasks_defaults` можно добавить общие для всех задач параметры.

```json
{
  "sandbox_tasks_defaults": {
    "type": "<тип задачи>",
    "owner": "<владелец задачи>",
    "priority": {
      "class": "SERVICE",
      "subclass": "HIGH"
    },
    "context": {
      "<имя поля контекста>": "<значение поля контекста>"
    },
    "custom_fields": [
      {
        "name": "<имя входного параметра>",
        "value": "<значение входного параметра>"
      }
    ]
  },
  "github_event_handlers": {}
}
```

:warning: Указывайте только те значения по умолчанию, которые понадобятся во всех запускаемых задачах.
Не будет возможности переопределить значения для конкретного события.

> Подробнее о правилах расширения можно почитать в [документации к пакету deepmerge](https://www.npmjs.com/package/deepmerge).

Кроме того, сервис безусловно добавляет в контекст поле `githubEvent` для идентификации источника:

```json
{
  "context": {
    "githubEvent": {
      "type": "<тип события>",
      "deliveryId": "<идентификатор события>",
      "configPath": "<путь к конфигурационному файлу>",
      "payload": {
        "содержимое": "тела вебхука"
      }
    }
  }
}
```

#### Фильтрация событий

Для некоторых событий можно добавить фильтрацию по параметрам в объект:

* `$.github_event_handlers.<event>[*].filter` – фильтр события по параметрам;
* `$.github_event_handlers.<event>[*].reject` – отклонение события по параметрам.

> :warning: Событие должно удовлетворять всем указанным в фильтре полям.

Если событие не удовлетворяет какому-либо фильтру, он будет указан в ответе в поле `$.unsatisfiedFilters`:

```json
{
  "startedTasks": [],
  "unsatisfiedFilters": [
    { "ref": "refs/heads/master" }
  ],
  "errors": []
}
```

##### Фильтрация событий по ref-ам

Для glob-фильтров (`"*_glob"`) используется пакет [`multimatch`][multimatch].
Детали синтаксиса можно посмотреть на домашней странице пакета.
Во всех таких фильтрах можно указать как один шаблон, так и массив.
Проверить совпадения можно в [онлайн glob тестере][glob-tester].

> :label: В большинстве случаев glob-фильтры будут понятнее регулярных выражений, поэтому стоит отдать предпочтение им.

Примеры glob-фильтров:

  * `"ref_glob": "refs/heads/dev"` — фильтр пропустит только push в ветку `dev`.
  * `"base_ref_glob": ["dev", "release/exp?/v*"]` — пропустит только пулл-реквесты, отправленные в `dev` или в релизные ветки экспериментов вроде `release/exp3/v1.2.3`.
  * `"head_ref_glob": "design/**"` — пропустит только пулл-реквесты, отправленные из веток, имена которых начинаются с `design/`.

###### Push

Доступные фильтры для событий **Push**:

* `ref` — проверяем имя запушенной ветки на точное совпадение.
* `ref_glob` — проверяем имя запушенной ветки на соответствие glob-шаблону.
* `ref_regex` — проверяем имя запушенной ветки на соответствие шаблону регулярного выражения.

:warning: Для событий типа `push` нужно использовать полные имена веток, например: `refs/heads/master`.
Это ограничение обусловлено форматом событий GitHub.

:warning: События `push` так же генерируются при создании и удалении веток. То есть, при первом пуше в ветку
пулл-реквеста сначала сгенерируется соответствующее событие `push`, а затем `pull_request`.

Например: для каждого коммита в `dev` запускать задачу `MY_DEV_TASK`;
а для веток, начинающихся с `release/`, — задачу `MY_RELEASE_TASK`.

```json
{
  "github_event_handlers": {
    "push": [
      {
        "filter": { "ref": "refs/heads/dev" },
        "sandbox_tasks": [
          { "type": "MY_DEV_TASK" }
        ]
      },
      {
        "filter": { "ref_regex": "release/.*" },
        "sandbox_tasks": [
          { "type": "MY_RELEASE_TASK" }
        ]
      }
    ]
  }
}
```

###### Pull request

Доступные фильтры для событий **Pull request**:

* `base_ref` — проверяем имя base-ветки (куда отправлен пулл-реквест) на точное совпадение.
* `base_ref_glob` — проверяем имя base-ветки на соответствие glob-шаблону.
* `base_ref_regex` — проверяем имя base-ветки на соответствие шаблону регулярного выражения.
* `head_ref` — проверяем имя head-ветки (откуда отправлен пулл-реквест) на точное совпадение.
* `head_ref_glob` — проверяем имя head-ветки на соответствие glob-шаблону.
* `head_ref_regex` — проверяем имя head-ветки на соответствие шаблону регулярного выражения.

:warning: Для событий типа `pull_reqest` нужно использовать сокращённые имена веток, например `dev`.
Это ограничение обусловлено форматом событий GitHub.

Например: для каждого коммита в `dev` запускать задачу `MY_DEV_TASK`;
а для веток, начинающихся с `release/`, — задачу `MY_RELEASE_TASK`.

```json
{
  "github_event_handlers": {
    "pull_request": [
      {
        "filter": {
          "base_ref": "dev"
        },
        "sandbox_tasks": [
          { "type": "MY_PR_TASK" }
        ]
      },
      {
        "filter": {
          "base_ref_regex": "release/.*",
          "head_ref_regex": "hotfix/.*"
        },
        "sandbox_tasks": [
          { "type": "MY_RELEASE_TASK" }
        ]
      }
    ]
  }
}
```

##### Фильтрация событий по изменённым файлам

Выше мы описали фильтрацию событий по референсам, однако, в некоторых случаях требуется запускать задачи не только в зависимости от референсов, но и с учётом изменившихся файлов. Для того, чтобы внедрить фильтрацию по изменившимся файлам, необходимо добавить поле `changed_files` в блок фильтрации `filter` или `reject`.

> :book: Фильтрация по изменившимся файлам поддерживается во всех типах событий.

###### Push и Pull request

* `changed_files` — проверяем изменённые файлы в пулл-реквесте на соответствие glob-шаблону.

В примере ниже в событии типа `pull_request` к обработке допускается любой пулл-реквест, в котором изменился хотя бы один файл c расширением `js`, но только в том случае, если файл не находится в директории `node_modules`. В событии типа `push` описана та же самая логика, но в рамках одного лишь блока фильтрации `filter`.

```json
{
  "github_event_handlers": {
    "pull_request": [
      {
        "filter": { "changed_files": ["**/*.js"] },
        "reject": { "changed_files": ["**/node_modules/**"] }
      }
    ],
    "push": [
      {
        "filter": { "changed_files": ["**/*.js", "!**/node_modules/**"] }
      }
    ]
  }
}
```

##### Фильтрация событий по метаинформации

Возможна фильтрация по метаинформации, зависящей от типа события. На текущий момент поддерживаются следующие варианты:

###### Push

* `sender_login` – массив логинов на GitHub, события от которых будут допущены к обработке.
* `created` – проверяем состояние рабочей ветки, `true` если ветка была создана.
* `deleted` – проверяем состояние рабочей ветки, `true` если ветка была удалена.

```json
{
  "github_event_handlers": {
    "push": [
      {
        "reject": {
          "sender_login": "robot-serp-bot"
        }
      }
    ]
  }
}
```

###### Pull request

* `action` — проверяем совершённое над пулл-реквестом действие, принимает массив разрешённых действий.
Возможные действия см. [здесь](https://developer.github.com/v3/activity/events/types/#pullrequestevent).
Разумным значением по умолчанию будет `["opened", "reopened", "synchronize"]`.
* `merged` — отфильтровать по свойству merged, см. детали в [документации](https://developer.github.com/v3/activity/events/types/#pullrequestevent).
* `sender_login` — массив логинов на GitHub, события от которых будут допущены к обработке.

```json
{
  "github_event_handlers": {
    "pull_request": [
      {
        "filter": {
          "action": ["opened", "reopened", "synchronize"]
        },
        "reject": {
          "sender_login": "robot-serp-bot"
        }
      }
    ]
  }
}
```

[multimatch]: https://github.com/sindresorhus/multimatch
[glob-tester]: https://codepen.io/mrmlnc/full/OXQjrZ

##### Фильтрация событий по лейблам

> :book: Фильтрация по лейблам поддерживается только в `pull_request` событиях.

```json
{
  "github_event_handlers": {
    "pull_request": [
      {
        "filter": {
          "labels": ["fix"]
        }
      }
    ]
  }
}
```

Поддержка фильтрации по glob-паттерну.

```json
{
  "github_event_handlers": {
    "pull_request": [
      {
        "filter": {
          "labels": ["release-*"]
        }
      }
    ]
  }
}
```

#### Расширение параметров задачи

Для пулл-реквестов есть возможность динамически поменять параметры создаваемой задачи через механизм лейблов.

Используя поле `$.labels` можно переопределить существующие или доопределить новые входные параметры для Sandbox-задачи в том случае, если у пулл-реквеста выставлен лейбл с указанным именем.

```json5
{
  "labels": {
    "<название лейбла>": {
      "custom_fields": [
        {
          "name": "<имя входного параметра>",
          "value": "<значение входного параметра>"
        }
      ]
    },
    "<название лейбла>": {
      // ...
    }
  }
}
```

#### Настройка нотификаций

Для того, чтобы быстро реагировать на проблемы запуска задач, можно настроить нотификации через конфигурационный файл.

В общем виде секция настроек нотификаций имеет следующие поля:

  * `transport` – имя адаптера. Сейчас мы поддерживаем только Slack.
  * `transportOptions` – специфичные для адаптера настройки.
  * `recipients` – получатели нотификаций.

##### Slack

Ниже приведён пример конфигурации нотификаций в Slack для проекта «Диск».

> :warning: Если ваш проект живёт вне [`serp.ya.ru` (СЕРПовый Slack)](https://serpyandex.slack.com) – вам необходимо написать письмо на рассылку [infraduty@] с просьбой добавить токен вашего робота в Slack-е, а также указать название вашего проекта в поле `tokenKey`.

```json5
{
  "github_event_handlers": {
    // ...
  },

  "notifications": [
    {
      "transport": "slack",
      "transportOptions": {
        "tokenKey": "DISK" // имя вашего проекта, если он живёт вне СЕРПового Slack-а
      },
      "recipients": [
        "#ci" // Канал – #ci. Пользователь – @ci
      ]
    }
  ]
}
```

#### Пример конфигурации

Развесистый пример конфигурации.

В нём описаны обработчики событий `push` и `pull_request`:

* На каждый коммит в `master` на сервере `user-sandbox.yandex.net:3000` запускается задача `MY_TASK` с входным параметром (Input parameter) `project_build_context = dev`.
* Открытые, переоткрытые и обновлённые пулл-реквесты в ветку `master` запускают на сервере `http://user-sandbox.yandex.net:3000` задачу `MY_TASK` со всеми параметрами по умолчанию.
* Любые другие события игнорируются.

> :warning: Поле `sandbox_base_url` необходимо для тестирования событий на локальном Sandbox, где авторизация с помощью токена не работает. Не нужно добавлять это поле в конфиг, если в качестве его значения используется URL продакшн Sandbox-а.

```json
{
  "sandbox_base_url": "http://user-sandbox.yandex.net:3000",

  "sandbox_tasks_defaults": { "type": "MY_TASK", "owner": "MY_OWNER" },

  "github_event_handlers": {
    "push": [
      {
        "filter": { "ref": "refs/heads/master" },
        "sandbox_tasks": [
          {
            "custom_fields": [
              { "name": "project_build_context", "value": "dev" }
            ]
          }
        ]
      }
    ],
    "pull_request": [
      {
        "filter": {
          "base_ref": "master",
          "action": ["opened", "reopened", "synchronize"]
        },
        "sandbox_tasks": [{}]
      }
    ]
  }
}
```

<a name="webhook-timeout"></a>
### Таймауты в обработчиках вебхуков

Бывают случаи, когда обработчик событий микросервиса может не успеть построить подробный ответ за _30 секунд_ (со слов поддержки GitHub, это неконфигурируемое время ожидания ответа):

* высокая нагрузка на сервера Sandbox, медленные ответы API;
* необходимость создать много задач по одному событию;
* отсутствуют дырки до указанной в конфиге инсталляции Sandbox (проверить и заказать доступы можно [здесь][fw-parser]).

[fw-parser]: https://golem.yandex-team.ru/fwparser2.sbml

Чтобы избежать появления на странице доставок неясной ошибки **Service Timeout**, при затягивании запроса более _27 секунд_ микросервис ответит кодом [`202 Accepted`][202-accepted], означающим, что событие принято, но обработка ещё не завершена.

[202-accepted]: https://tools.ietf.org/html/rfc7231#section-6.3.3

В таком случае в успешности запуска необходимых задач придётся убедиться либо ручным поиском в интерфейсе Sandbox, либо чтением логов микросервиса (можно обратиться в рассылку [infraduty@]).

Если есть необходимость дождаться ответа (например, при запросе через `curl`), нужно добавить query-параметр `no_timeout=1`:

```
curl -X POST \
  https://sandbox-ci.si.yandex-team.ru/v1/hooks/github?no_timeout=1 \
  -H 'Content-Type: application/json' \
  -H 'X-GitHub-Delivery: test' \
  -H 'X-GitHub-Event: pull_request' \
  -d @payload.json
```

## Материалы

* [FEI-5573](https://st.yandex-team.ru/FEI-5573)
* [FEI-7116](https://st.yandex-team.ru/FEI-7116)

[infraduty@]: mailto:infraduty@yandex-team.ru

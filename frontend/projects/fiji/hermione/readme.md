# Вместо вступления
Hermione тесты — система тестирования верстки в режиме "черного ящика": в окружении, приближенному к реальному, запускается реальный браузер, открывается поднятая бета, выполняются какие-то пользовательские действия (нажать на кнопку, проскроллить страницу) и проверяется какое-то состояние (открылся попап, кнопка поменяла цвет).

Из-за того, что условия теста приближены к реальным, возникает ряд неопределенностей: данные могут не прийти или прийти с большим опозданием, трудно получить какие-то определенные кейсы, тесты могут выполняться очень долго из-за ожиданий AJAX ответов, внешние зависимости (метрика, директ, плеер) могут затормозить загрузку страницы. Из-за этого часть вещей для тестов заменены на заглушки.

# Ограничения Hermione тестов
1. **Стабильность тестов обратно пропорциональна количеству тестируемых блоков.** Чем больше блоков участвуют в тестируемой функциональности, тем сложнее будет тест и тем чаще он будет мигать.
2. **Стабильность тестов обратно пропорциональна времени выполнения тестов.** Долго открытые браузеры в итоге повисают и начинают тормозить.
3. **В тестах нет возможности получить список сетевых запросов.** По идеологическим причинам: Hermione проверяет пользовательские сценарии, а пользователю не важны отправляемые браузером запросы.

# Общие советы по написанию тестов
## Пишите тесты проще
1. **Меньше вложенных** `describe` - если у вас много вложенных `describe`, то скорее всего вы слишком много всего тестируете, или у вас тесты зависят друг от друга.
2. **Задавайте начальное состояние наиболее простым способом** - например, нужно проверить кнопку сброса фильтров, которая показывается если включены другие. Не стоит в тесте включать фильтр, ждать перезапроса и после этого нажимать на кнопку сброса - лучше просто открывать url, по которому фильтры уже включены.
3. **Пишите меньше условий проверки** - тест-кейс может состоять из тучи пунктов, что нужно проверять - надо задуматься нужно ли проверять прямо всё, возможно схожая проверка уже есть в другом тесте, или же проверка не имеет отношения к фиче, возможно, это нужно проверять в отдельном тесте. Например, в тестах на перестроение плеера часто просится проверить, что связанные тоже перестроились, однако очевидно, что это проверить достаточно один раз.
4. **Меньше сложной логики проверок** - если ваш Hermione тест проверяет, что кнопка делает запрос с какими-то параметрами, которые формируются каким-то хитрым способом, который нужно проверить - скорее всего как минимум часть этой логики правильней было бы проверять на уровне Unit тестов. Вдобавок сложная логика в тестах сама по себе может потребовать проверки, что она работает правильно.
## Пишите меньше тестов
1. **Не проверяйте все кейсы и все их комбинации** - разные источники могут натолкнуть на мысль: "надо бы проверить еще и `состояние`" - скорее всего не надо. Не используйте аргумент "а вдруг сломается" - вдруг сломаться может в любом месте, по закону подлости оно скорее всего сломается в непокрытом или труднодоступном месте. Используйте исходный код, как ориентир: есть ли разница если мы, например, выделяем сниппет на морде или на выдаче в нашем кейсе? Если нет, то и нет нужды проверять в двух местах. И если у вас запущенная ситуация с несколькими условиями - например, проверить на морде и на выдаче, на ru и на com.tr - 4 разных варианта, возможно, какие-то варианты будут лишние, опять же - используйте код для справки.
2. **Возможно это стоит унести в unit** - *См. также п.4 предыдущей секции.* Если у вас достаточно простой тест, который крутится вокруг одного и того же блока с малым числом зависимостей и состояний, возможно не стоит писать Hermione тест.
3. **Не проверяйте данные** - часто в тест-кейсах пишутся в качестве проверки наличие каких-то конкретных вещей, например с включенным семейным фильтром нет роликов vk или при включенном фильтре HD не будет роликов без пометки HD - такие проверки делать не нужно, потому что по сути это проверка данных, приходящих на вёрстку. Такие проверки теоретически могут быть опасны для Hermione тестов, например из-за ошибки репорта семейный фильтр сломается и даже с включенным фильтром будут приходить недетский контент. Подобные ситуации конечно частично решаются за счет кэширования данных на бетах, но кэш можно неудачно обновить на неправильный. С другой стороны может быть и обратная проблема: когда условие выполняется всегда, например если в тест-кейсе сказано «не должно быть роликов с vk» - может случиться false positive. Например, в тест-кейсе сказано «включить фильтр, дождаться перезапроса - после него на выдаче не будет роликов vk», тест будет проверять наличие роликов vk, но, может случиться такое, что их и до включения фильтров не было, и при поломке тест может врать и говорить что всё ОК.
4. **Меньше копипасты** - смотри также все предыдущие советы: копипаста в Hermione тестах обычно приводит к тому, что файл раздувается на 800 строк. Никому не хочется ревьювить 800 строк, никому не хочется поддерживать и редактировать 800 строк. Никому.
## Пишите больше (Client) Unit
Каждый раз задумывайтесь при написании теста - действительно ли это нужно? Можно ли это унести в unit? Чем проще и компактнее тесты - тем быстрее они будут выполняться и меньше мигать.
## Соблюдайте индентацию и пишите `.then()` на той же строке
Это самый частый комментарий в PR с тестами ;)

# Технические советы
## Всегда используйте PO (Page Objects)
При выборе какого-то элемента на странице не используйте простые строковые селекторы, чаще всего они будут повторяться как в рамках одного теста так и среди других тестов. Для упрощения поддержки селекторов их прописывают в `runner/page-objects`, так же эти селекторы шарятся с gemini тестами.

[Документация Page Objects](https://github.yandex-team.ru/search-interfaces/bem-page-object)
## Ожидайте выполнения условия, не ожидайте фиксированный интервал
Очень часто в тестах нужно чего-то ждать: появления попапа, догрузки чего бы то не было, завершения анимации (отдельная тема). Старайтесь избегать метода `pause(millis)`: он ожидает (примерно) заданного времени. Выбрать нужное время очень трудно: тест будет мигать если взять слишком маленький интервал. Если брать слишком большой, то тесты будут слишком долго прогоняться. Всегда старайтесь подождать какого-то определенного изменения на странице (появления чего-то, измения текста и тп). Если с задачей не справляются методы `waitFor...` - есть метод `waitUntil()` в котором можно написать какое угодно условие, в том числе и исполнение JS в браузере через `execute` и `selectorExecute`.
## Никаких `if`-ов, меньше `map`-ов
`if` в коде приносит ненужную сложность и неопределенность в исполнение теста. Тест не должен учитывать «если что-то там не будет работать» и из-за этого, например, менять логику проверки или скипать тесты. Если нужно проверить как ведет себя верстка в условиях «что-то не работает», то на это стоит написать отдельный тест.
`map` позволяет в некоторых случаях избежать лишней копипасты, но не стоит злоупотреблять - код теста становится сложным и менее читаемым.
## Никаких проверок в /(before|after)(Each)?/
Распространенный кейс: для нескольких элементов нужно выполнить одну и ту же проверку (алсо см. «пишите тестов меньше» еще раз), и хочется внести эту проверку в `afterEach`. Ввиду технических ограничений так делать не стоит, лучше вынести общую проверку в функцию и использовать её в `.then()`, в качестве `this` у функции будет `browser`. Делается так для поддержки повторных проверок - если тест упал, он будет перезапущен снова (максимум два раза), но данная фича не работает с `before` и подобными. Помимо прочего падения в `before` и подобных очень криво отображается в логах.

**Пример использования:**
```js
it('элемент должен после нажатия на кнопку A', function() {
    return browser
        .click('.some-buttonA').then(checkElement)
})

it('элемент должен после нажатия на кнопку B', function() {
    return browser
        .click('.some-buttonB').then(checkElement)
})

function checkElement() {
    return this
        .isVisible('.some-element').then(assert.ok)
}
```

В теории даже `waitFor*` методы не стоит использовать в `before` или `beforeEach`, для этого тоже делают функцию типа `function testBefore() {}`

## Пишите причину, по которой assert может упасть
Касается всех типов тестов. При написании assert в качестве последнего аргумента пишите почему этот assert упал. Строка, указанная вами, будет выведена в лог как причина падения теста, и может очень сильно помочь в понимании почему тест упал.

**Пример использования:**
```js
assert.isEqual(coounter.sendcount, 0, 'счетчик отправился, хотя не должен был')
```

С третьем аргументом в логе будет нечто подобное:
```
Expected 1 to equal 0 - счетчик отправился, хотя не должен был`
<Stacktrace>
```

без:
```
Expected 1 to equal 0
<Stacktrace>
```

# Типичные кейсы
## Открытие новых вкладок/окон
Использование отдельных вкладок достаточно ограничено. Самый распространенный кейс - проверить, что новая вкладка открылась, для этого стоит использовать хелпер `waitForNewTab()` (предварительно включив внешние ссылки - см. ниже), который просто ждет появления новой вкладки, при этом практически невозможно что-либо сделать на той вкладке или же проверить её урл.

По умолчанию все внешние ссылки отключены. Сделано это из-за того, что открываемые ссылки грузили очень много всего, и тем самым создавали лишнюю нагрузку на машины. Включить ссылки можно так:
```js
.execute(function() {
    window.ENABLE_EXTERNAL_LINKS = 'blank';
})
```
Использование `'blank'` заменяет внешние ссылки на `about:blank`.
Использование `true` включает внешние ссылки в изначальном виде (не рекомендуется).
Подробнее: https://github.yandex-team.ru/mm-interfaces/fiji/blob/dev/.templar/testing/assets/assets-hermione/common/no-external-links.js

Проверить что-то на новой вкладке вряд ли может потребоваться, т.к. обычно на новых вкладках открываются внешние ресурсы (будь то Яндекс диск или twitter - не столь важно), и как правило достаточно убедиться, что вкладка открыта с корректным урлом.

Убедиться, что урл правильный так же слабореализуемо - даже если было бы возможно проверить текущий `location` у вкладки - нет гарантий что ожидаемый урл либо поведет на редирект, либо сам является результатом редиректа. Лучший вариант - покрыть место в коде, которое открывает вкладку unit-тестами: в привах проверить, что формируется правильный `href` у ссылки с `target="blank"`, в пабах проверить место, где формируется урл, который в итоге попадет в `window.open()`

## Проверка счетчиков
https://wiki.yandex-team.ru/search-interfaces/multimedia/counters/#e2e

## Надо дождаться пока произойдет перестроение чего-либо.
### Вариант 1 - ReqId (Выдача, похожие, всё что в себе содержит ReqId)
Можно использовать `waitForReqIdToChange` и `saveReqId` - эти методы принимают на вход объект (который будет хранить состояние на время выполнения it'а) и селектор элемента. Суть методов заключается в следующем: при обновлении выдачи или загрузке новой меняется ReqId - RequestId, уникальный идентификатор для каждого запроса.

**Пример использования:**
```js
var state = {};

return browser
    .saveReqId('.serp-list', state) // Сохраняем текущий ReqId
    .click('.some-button') // Делаем что-то что должно поменять выдачу
    .waitForReqIdToChange('.serp-list', state); // Ожидаем того что выдача поменялась
```
Переменная `state` нужна просто для того чтобы методы могли временно сохранить значение куда-то.
Так же если вам надо проверить что выдача **не** поменялась - можно передать в опциях `waitForReqIdToChange` `{ reverse: true }`:
```js
    .waitForReqIdToChange('.serp-list', state, true) // "Ожидаем" что выдача не поменялась.
```
Однако с таким использованием могут быть проблемы...

Эти методы по сути - компактная семантичная запись. Можно так же вручную использовать `getReqId`.

**Пример использования:**
```js
var reqId;

return browser
    .getReqId('.serp-list').then(function(result) {
        reqId = result;
    })
    .click('.someButton')
    .waitUntil(function() {
        return this.getReqId('.serp-list').then(function(result) {
            return result !== reqId;
        })
    });
```

### Вариант 2 - waitForLoad (Все что при запросе показывает паранжу)
Старый, возможно ограниченный способ: `.waitForLoad`. Его суть - ожидает когда паранжа скроется, используется везде, но теоретически может упасть, например если паранжа не успела появиться на момент проверки.

### Вариант 3 - всё остальное
Если вам надо подождать пока что-то обновит само себя, но не подходят предыдущие варианты - возможные варианты:
1. Ожидать, что появится что-то внутри, если этого не было до перестроения
2. Проверять какой-нибудь BEM или DOM параметр (data-bem, href, src)
3. Проверять, что весь data-bem изменился (не самый худший вариант)
4. Проверять, что HTML элемента изменился (самый худший вариант)

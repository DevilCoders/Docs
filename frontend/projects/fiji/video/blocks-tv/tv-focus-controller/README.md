# tv-focus-controller

> Механизм фокусировки объектов интерфейса с клавиатуры.

## Общие положения
1. Фокусируемые объекты разделяются на два типа:
    * элемент (миксуем класс `tv-focus-controller__item`)
    * область (миксуем класс `tv-focus-controller__area`)
1. Элементы — это конечные фокусируемые точки.
1. Области — это объекты (например: карусель, клавиатура, модальное окно), которые хранят в себе элементы. Они так же могут включать в себя и другие области.
1. Области могут использоваться для особой обработки входящего в них фокуса. Область не является финальным фокусируемым элементом, поэтому она обязательно должна передавать фокус одному из своих дочерних объектов. Например, карусель передаёт фокус своему элементу, на котором закончили прокрутку в прошлый раз или на первый, если прокрутки раньше не было.
1. Области так же могут применяться для особой обработки выходящего из них фокуса. Область обязательно должна передать фокус дальше: либо на ближайший найденный объект за её пределами, либо на какой-то внутренний объект по собственному усмотрению.
1. Контроллер только сообщает области (которая по совместительству должна являться каким-то проектным блоком), что в неё поступает или из неё уходит фокус. На этом работа контроллера выполнена и о последующей судьбе фокуса должна позаботиться сама область.
1. Для нахождения ближайшего объекта в искомом направлении выполняется поиск наименьшего расстояния между двумя центральными точками текущего сфокусированного объекта и искомого.
1. По умолчанию области не рассматриваются в качестве ближайшего объекта для фокусировки. В атрибуте `data-tv-focus-controller` области может храниться поле `focusable`, принимающее значение `true` — это означает, что данную область нужно учитывать при поиске ближайшего объекта.

## Получение фокуса
1. Перемещение фокуса между фокусируемыми объектами осуществляется при нажатии на клавиши стрелок.
1. При отсутствии текущего сфокусированного объекта, в качестве точки отсчёта берётся левая верхняя точка страницы.
1. При получении объектом фокуса:
    * на него добавляется класс `tv-focus-controller__focus`
    * на нём триггерится DOM-событие `tv-focus-controller:focus` с дополнительными данными, на основании которых область может определить цель для дальнейшего перекидывания фокуса
1. При получении объектом фокуса, фокус удаляется с предыдущего сфокусированного объекта:
    * с него удаляется класс `tv-focus-controller__focus`
    * на нём триггерится DOM-событие `tv-focus-controller:blur`
1. После отпускания клавиши стрелки, на новом сфокусированном элементе триггерится событие `tv-focus-controller:arrowkeyup`, у которого в `detail.key` указано направление нажатой стрелки.
1. Для установки фокуса используется публичный метод `BEM.DOM.blocks['tv-focus-controller'].focus(...)`.
1. Дизайн сфокусированного элемента должен быть аналогичен внешнему виду элемента, на который наведён курсор, поэтому предполагается использование таких селекторов для применения стилей к выделенным элементам:
```css
.block:hover,
.block.tv-focus-controller__focus {
    // ...
}
```

## Выбор элемента
1. Выбор элемента осуществляется при нажатии клавиши Enter.
1. Во время нажатия Enter, элементу на 100мс добавляется класс `tv-focus-controller__select`, чтобы успели отразиться стили для обратной связи.
1. Для обработки выбора элемента можно подписаться на DOM-событие `tv-focus-controller:select`.
1. Для интерфейсных элементов, требующих возможность зажатия (например, кнопка перемотки) можно подписаться на DOM-событие `tv-focus-controller:unselect`, которое инициируется при отпускании Enter.
1. Выделенный элемент не получает реальный фокус, во избежание двойных обработок одного и того же действия через события `click` (который инициируется браузером) и `tv-focus-controller:select`.

## Изменение данных о текущих фокусируемых элементах
1. Для быстрого нахождения ближайшего объекта, все данные о фокусируемых объектах хранятся в памяти.
1. Первоначальный сбор этих данных со всей страницы запускается автоматически при загрузке страницы в модификаторе `tv-focus-controller_init_auto`.
1. Данные нужно синхронизировать с изменениями в интерфейсе:
    * при смене экранов (переходе с главной к плееру, от плеера к клавиатуре и тд)
    * при замене содержимого части страницы (смена раскладки клавиатуры)
    * при добавлении содержимого на страницу (дозагрузка элементов карусели)
1. Важно хранить данные только по видимым элементам на странице, иначе фокус будет перемещаться на скрытые объекты и исчезать. Для добавления выделенного набора объектов предоставляется ряд методов, описанных ниже.
1. Метод `updateItemsFromScope(HTMLElement)` полностью обновляет данные, самостоятельно находя все фокусируемые объекты в пределах указанного HTML-элемента.
1. Метод `addItemsFromScope(HTMLElement)` добавляет к имеющимся данным, новые данные, самостоятельно находя все фокусируемые объекты в пределах указанного HTML-элемента.
1. Метод `updateItems(NodeList | Array<NodeList | null>)` полностью обновляет данные на сформированные только на основе переданных элементов. Можно передать массив коллекций, среди которых могут быть `null` — это удобно для передачи результата `querySelectorAll()`.
1. Метод `addItems(NodeList | Array<NodeList | null>)` добавляет к имеющимся данным новые данные, сформированные только на основе переданных объектов. Можно передать массив коллекций, среди которых могут быть `null` — это удобно для передачи результата `querySelectorAll()`.
1. Метод `replaceItemsFromArea(HTMLElement)` заменяет данные по объектам со всех уровней вложенности из переданной области. Метод применим для случаев, когда размеры самой области неизменны при изменении её содержимого, или когда изменение размеров не влияет на общую раскладку.
1. Элементы с нулевым размером (в первую очередь таковыми являются скрытые элементы) не добавляются в данные.
1. Метод `clearItems()` очищает все данные. Используется, например, при переходе к плееру, где отсутствуют фокусируемые объекты.
1. Метод `clearItemsFromArea()` очищает данные по объектам со всех уровней вложенности из переданной области.
1. Если в список очищаемых элементов попадает сфокусированный элемент, с него снимается фокус.

## Ограничения на вход фокуса в область
1. В атрибуте `data-tv-focus-controller` области может храниться поле `preventFocus` с указанием заблокированных направлений фокуса при фокусировке вложенного в область элемента. Это объект, где могут быть ключи `ArrowUp`, `ArrowRight`, `ArrowDown` и `ArrowLeft`, которые принимают следующие значения:
  - `'area'` — перебросить фокус на саму область; область в свою очередь *должна* перенаправить фокус по своему усмотрению.
  - `'never'` - переход в элемент, вложенный в данную область, по нажатию на указанную клавишу запрещен.
1. При отсутствии этого поля фокус останется на ближайшем вложенном элементе, который был найден автоматически.

## Ограничения на выход фокуса из области
1. В атрибуте `data-tv-focus-controller` области может храниться поле `preventBlur` с указанием заблокированных направлений выхода фокуса. Это объект, где могут быть ключи `ArrowUp`, `ArrowRight`, `ArrowDown` и `ArrowLeft`, которые принимают два возможных значения указывающих куда перенаправить фокус при попытке его выхода из области в указанном направлении:
  - `'none'` — никуда не перенаправлять фокус, оставить его там, где он сейчас;
  - `'area'` — перебросить фокус на саму область; область в свою очередь *должна* перенаправить фокус по своему усмотрению.

Например: `preventBlur: { ArrowUp: 'none', ArrowDown: 'none' }` — ограничит выход фокуса сверху и снизу.

1. В момент ограничения выхода фокуса на текущем сфокусированном элементе триггерится событие `tv-focus-controller:preventblur`, в котором `detail.key` указывает заблокированное направление, а в `detail.restriction` указан способ ограничения (из указанных выше).

## Прокручиваемые области
Прокручиваемые области могут быть **только горизонтальными**.

1. Данные о фокусируемых объектах хранятся в памяти в плоском виде с абсолютными координатами центральных точек, рассчитанных относительно левой верхней точки страницы.
<img src="https://jing.yandex-team.ru/files/tenorok/tv-focus-controller-1.png" height="130px">

2. Эти данные не обновляются во время прокрутки из соображений производительности. Поэтому, во время выхода фокуса из текущей прокручиваемой области, для корректного нахождения ближайшего объекта на экране, в качестве точки отсчёта по оси Х берётся текущее положение элемента в прокручиваемой области относительно экрана.
<img src="https://jing.yandex-team.ru/files/tenorok/tv-focus-controller-2.png" height="130px">

3. В атрибуте `data-tv-focus-controller` элемента должно храниться поле `scrollableElemId: string` с указанием ID прокручиваемого HTML-элемента, в котором расположен фокусируемый элемент. Это нужно для того, чтобы контроллер учёл расположение элемента в прокручиваемой области. Это поле добавляется автоматически для узлов, вложенных в блок `tv-carousel_focus-controller` и узлов, динамически добавляемых методом `tv-carousel_spin-enable#appendItems()`. Для корректной работы автодобавления `data`-атрибута, важно миксовать в режиме `def()()` к фокусируемым элементам *именно массив* с классом `tv-focus-controller__(item|area)`.

## Важные нюансы
1. Если возможен ресайз окна, то нужно запускать пересчёт данных о фокусируемых элементах.
1. Элементы карусели должны быть одной высоты, чтобы их центр был на одном уровне. Иначе может сломаться механика перемещения фокуса между ними.
1. Области не должны пересекаться визуально, это может привести к непредсказуемым переходам фокуса.
1. Не должно быть вложенных прокручиваемых областей, это точно будет работать неправильно.

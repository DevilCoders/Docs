> :warning: Этот гайд немного устарел по букве, и нуждается в обновлении, но всё ещё актуален по духу. \
> :warning: Используйте с умом, а ещё лучше - актуализируйте по мере использования.

# Гид соучастника

Нужно следовать [правилу бойскаута](http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule):

> Всегда оставляйте код чище, чем он был до вас.

## Коммитстайл

Мы следуем [Conventional Commits](https://conventionalcommits.org/).

Формат коммита:

```markdown
<тип изменений>(<скоуп>): <краткое описание изменений>

<развёрнутое описание изменений>
```

* Типы изменений: `fix`, `feat`, `build`, `ci`, `docs`, `style`, `refactor`, `perf`, `test`.
* Краткое описание изменений пишем на английском, начинается с глагола с маленькой буквы в форме инфинитива: "add", "fix", "change", "remove", и т.п.
* Развёрнутое описание изменений — подробности в свободной форме, помогающие понять почему именно так и для какой цели сделано изменение. Обычно на русском для понятности.

Пример:

```markdown
feat(shovel-cli): allow to create task with empty configuration

Если не указать `--input` и ничего не направить на вход утилите,
она будет ожидать ввода конфига пользователем руками в интерактивном
режиме, что не имеет смысла практически никогда и не является
поддерживаемым поведением.

BREAKING CHANGE: удалена возможность вводить конфиг интерактивно в терминале.
```

## Кодстайл

### Общее

#### Консистентность

Локальная консистентность важнее глобальной.

Например:

* Если во всём проекте комментарии на английском, но в текущем изменяемом файле на русском, то нужно писать на русском.
* Если глобально пишем без классов, но в одном конкретном модуле всё на классах — нужно писать класс.

Тем не менее, приветствуется устранять локальную консистентность в пользу глобальной.

#### Трекер

Номера задач в баг-трекере в коде указываем без ссылки:

* `https://st.yandex-team.ru/FEI-1` → `FEI-1`

#### Ссылки на код

Для идентификации ветки, коммита или тега используем `@`, пулл-реквеста — `#`:

* `serp/web4@dev`, `serp/web4@79a1e064c2ed0a2a3508866d092ae3b627912c3b`, но `serp/web4#8712`

Это консистентно с отображением на GitHub.

#### Debug

Неймспейс для дебага (`node-debug`): `si:ci:<package>`.

### Bash

* Используем shebang с `env`: `#!/usr/bin/env bash`.
* Именуем переменные в [snake case](http://en.wikipedia.org/wiki/Snake_case): `my_var="1"`.
* Используем переменные с фигурными скобочками: `${my_var}`.
* Используем двойные кавычки вместо одинарных.
* Формат многострочных ssh команд: `$ ssh user@host 'bash -s' << EOF`.

### JavaScript

* Используем Ramda вместо Lo-Dash везде где можно.
  * Если не нравится Ramda, можно писать императивно (см. [ниже](#Политика-функционального-программирования)).
  * Однако, это не даёт права писать утилитные велосипеды вроде `find` или `groupBy`.
* Одна переменная — один `const`. Лучше группировать пустыми строками по смыслу.
* Смешивать `require` разного типа нельзя, нужно разделять на группы.
  * Порядок такой: `core` → `node_modules` → `application`.
  * Группы должны разделяться пустой строкой.
* Используем нативные промисы.
  * Но если вдруг — `Q` пишем с большой буквы.
* Вызовы `debug` и `assert` отделяем пустой строкой от остального кода.
* Сообщения внутри `debug` и тестах (`it`/`describe`) пишем на английском языке с маленькой буквы.
* Комментарии в коде/JSDoc пишем на русском языке.
* Описание опций и аргументов в CLI (`.opt().title('…')`) с маленькой буквы.
* Массивы в опциях или аргументах CLI передаются через пробел: `--opt val1 --opt val2` или `--opt val1 val2` вместо `--opt val1,val2`.
* Идентификаторы, в которых присутствует слово "github", капитализация консистентная: `GitHub` или `github`, но не `Github` или `gitHub`. В комментариях/JSDoc всегда `GitHub`.
* Любые аббревиатуры (если это не константы) капитализируем как обычные слова в нижнем регистре: `recordTTL` → `recordTtl`, `new QLoudAPI()` → `new QloudApi()`, `ABCData` → `abcData`, `isJSON` → `isJson`.

#### JSDoc

* параметризованные типы (generics, шаблоны) пишем в угловых скобках: `LinkedList<string>`.
* массивы пишем через `[]`, не через `Array`: `string[]`.
* промисы описываем как `Promise<ResolveType>`, без возвращаемого типа просто `Promise`.
* `@type {Function}` → `@function`.
* Теги `@function` и `@deprecated` пишем перед параметрами.
* Теги `@see`, `@example` пишем после `@returns`.
* Используем тег [`@fileoverview`](http://usejsdoc.org/tags-file.html) вместо `@fileOverview`.

#### TypeScript

Наследуем все правила из секции [JavaScript](#JavaScript) и [JSDoc](#JSDoc).

* При добавлении нового пакета необходимо добавить его в корневой конфиг [`tsconfig.json`](../packages/tsconfig.json).
* Типы, которые относятся или могут относиться ко всем пакетам, пишем в корневой директории `typings`. Остальные – на уровне пакета в той же директории.
* Стараемся использовать интерфейсы вместо литералов объектов.
* В конце каждого свойства интерфейса ставим `;`.
* По возможности все уникальные «типы» обозначаем через тип-алиас (`type`). При желании используем generic `Nominal`.
* В корневом `package.json` следует хранить все `@types` зависимости, которые нужны только на этапе сборки. Если типы внутри разрабатываемого пакета ссылаются на типы из `@types` и разрабатываемый пакет может использоваться как зависимость в другом пакете, то такие зависимости должны распространяться вместе с разрабатываемым пакетом в поле `dependencies`.
* Если один пакет, написанный на TS, ссылается на другой, который находится в этом репозитории и написан на TS, то эту зависимость нужно отобразить в `tsconfig.json`, используя [`references`](http://www.typescriptlang.org/docs/handbook/project-references.html).

#### Файлы конфигурации

* Свойства в конфигурации пишем в формате `snake_case`.

#### CLI

* Описание команд и аргументов пишем на английском языке.

#### Термины

* pull request → пулл-реквест
* cache → кэш
* slash → слэш
* snapshot → снапшот
* tag → тег

#### Тесты

При написании тестов придерживаемся принципа AAA (Arrange, Act, Assert). Пример:

```js
// arrange …
// Все переменные и подготовка, сюда же определение ожидаемого выхлопа expected
const a = 1;
const b = 2;
const expected = 3;

// act …
// вызов тестируемой функции и получение actual результата
const actual = sum(a, b);

// assert …
// сравнение actual с expected
assert.equal(actual, expected);
```

#### Обработка ошибок

Надо прочитать и следовать [гайду от Joyent][joyent-guide], он подробно описывает суть.
В качестве библиотеки для ошибок используем их же [`verror`][verror] (постановили на [ретро от 19 апреля 2019][retro]).
С ней без лишнего шаблонного кода получается делать цепочки ошибок и сохранять контекст.
Ранее для этих целей использовали [`es6-error`][es6-error], но с ней получается громоздко.
По мере возможности следует переписывать.

Ещё несколько принципов, помимо описанных в гайде:

* оборачивать пойманные низкоуровневые ошибки в соответствующие текущему уровню абстракции;
* в `catch` пойманную ошибку именовать `cause`, так проще прокинуть в `VError`;
* прокидывать максимальное количество информации о контексте ошибки в `info`;
* свойства в конструкторе описывать в том же порядке, как в документации:

  1. `name`;
  1. `cause`;
  1. `info`.

* имя ошибки должно оканчиваться на `Error`;
* сообщения должны начинаться с маленькой буквы, так как они потом собираются в одно большое предложение с уточнениями.

Задача, чтобы результирующее сообщение выглядело примерно так:

```console
ReplaceQueueMembersFailedError: failed to replace members in queue with name "76800-3" to []: failed to clear queue with name "76800-3": failed to find queue by given predicate: no queue matched given predicate
```

Пример употребления:

```js
try {
    // …
} catch (cause) {
    throw new VError({
        name: 'ClearQueueByIdFailedError',
        cause,
        info: { queueId }
    }, 'failed to clear queue with ID "%s"', queueId);
}
```

На самом высоком уровне (выхлоп CLI, HTTP ответ) ошибки можно оборачивать в `WError` (ещё один класс из `verror`), автоматически скрывающий детали.

[joyent-guide]: https://www.joyent.com/node-js/production/design/errors
[verror]: https://github.com/joyent/node-verror
[retro]: https://wiki.yandex-team.ru/search-interfaces/infra/infraspeed/process/retro/
[es6-error]: https://github.com/bjyoungblood/es6-error

#### Материалы

* [15 Ways to Write Self-documenting JavaScript](https://www.sitepoint.com/self-documenting-javascript/)

### Lerna

В `package.json`:

* Описание (`description`) написать на английском языке.
* Автором (`author`) указать `Infraspeed <infraspeed@yandex-team.ru>`.
* Зависимости для разработки (`devDependencies`) не указывать, они наследуются из корня.
* Корректно оформлять `files`/`dirs`, чтобы не публиковать тесты и прочее.
* Версии одноимённых зависимостей в пакете и корневом `package.json` должны совпадать.

## Принципы код-ревью

Хорошее ревью требует внимательного и вдумчивого погружения в задачу. Как этот процесс можно ускорить:

* Написать достаточно подробное описание в пулл-реквесте с обзором изменений. Что изменилось, почему, зачем, для чего и каким образом. Шаблон помогает. Лайфхак: писать изменения в коммитах, а потом просто копипастить в описание.
* Делать атомарные коммиты с аргументацией изменения: зачем это изменилось, чтобы что;
* Пропускать заметки на ревью через себя и не ходить по одним и тем же граблям, а один раз понять и принять.
* Фиксировать договорённости в письменном виде в этом документе.
* Стараться делать маленькие пулл-реквесты, просить быстрое ревью.

### Флеймообразующие замечания

Возникают, когда несколько вариантов сделать одно и то же, есть разные сторонники, но про это нет линтера или доки. Решаются на усмотрение автора. Отличное решение — сделать выбор, постфактум обсудить и зафиксировать в документации.

### Ответственность за ревью

Ответственность за сходимость ревью лежит на авторе пулл-реквеста. Это значит, что если ревью затягивается, то автор должен пинговать, назначать очные встречи и всяческими другими доступными способами форсировать процесс. Пишите в личку, назначайте сроки. Крайнее решение "принять или не принять правку" и ответственность за написанный код — за автором кода.

Если в обозримое время у ревьювера не получается прийти, нужно написать `/busy`.

### Изменение ветки во время ревью

Во время ревью нельзя допушивать в ветку.

Это обосновано тем, что люди в большинстве случаев смотрят по коммитам и этот процесс легко оборвать допушем, так как изменятся номера коммитов.

Нужно дождаться окончания итерации и затем пушить правки, вносить их при этом можно и в реальном времени.

### Критикуешь — предлагай

### Политика функционального программирования

Про Ramda.

В первую очередь использовали для упрощения цепочек промисов до `co` + `yield`. Сейчас, смысла большого нет, но многие привыкли и местами действительно получается проще.

Не хочешь использовать — не используй. Можешь переписать сложный код — перепиши. Видишь сложный код на ревью — предложи вариант переписать.

Однако, это не даёт права писать утилитные велосипеды вроде `find` или `groupBy`.

### Материалы

* [Про парное программирование](https://wiki.yandex-team.ru/search-interfaces/infra/infraspeed/pair-programming/)
* [Регламент кодревью на Серпе](https://wiki.yandex-team.ru/search-interfaces/review/)
  * в первую очередь про правила оформления ПР и коммитов
* [Giving better code reviews](https://medium.com/@mrjoelkemp/giving-better-code-reviews-16109e0fdd36)
* [Code Review Like You Mean It](http://haacked.com/archive/2013/10/28/code-review-like-you-mean-it.aspx/)
* Code review по-человечески ([часть 1](https://habrahabr.ru/post/340550/), [часть 2](https://habrahabr.ru/post/342244/))

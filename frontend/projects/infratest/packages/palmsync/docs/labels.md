# Label – Метки в тестовых сценариях

## Предыстория

Каждый тест кейс в тестовом сценарии должен быть самодостаточен и содержать все необходимые скриншоты.
Это необходимо, так как асессорам попадает рандомный набор тест кейсов.
Чтобы каждый тестовый сценарий был самодостаточен, ему нужен скриншот. Тогда тестировщик всегда понимает как выглядит фича, которую он тестирует.

Для этого в hermione-тестах зачастую использовали такую конструкцию:

```js
describe('фича', function() {
    beforeEach(function() {
        return this.browser
            .yaOpenSerp(...)
            .assertView(...);
    });

    it('проверка 1');

    it('проверка 2');
});
```

Это решало проблему самодостаточности тестовых сценариев, но побочным эффектом являлось дублирование скриншотов на каждый  it.

Поэтому появилось в `yml`-файлах такое понятие, как  label (метка). Теперь для того, чтобы для каждого тестового сценария был доступен скриншот, достаточно сделать его только в одном из тестов и в `yml`-файле использовать его в нужных сценариях.

## Как пользоваться

Достаточно сделать скриншот только в одном `hermione`-тесте, задекларировать его в одном тест кейсе, используя метку, а в остальных тест кейсах ссылаться на этот скриншот с помощью метки.

```yaml
specs:
  фича:
    проверка 1:
      - label: bla
      - do: ...
      - screenshot: внешний вид [plain]
    ...
    проверка 2:
      - do: ...
      - screenshot: внешний вид [bla >> plain]
```

### Обычный режим (deprecated)

Метка доступна не только в пределах одного файла - её можно использовать в любом yml-файле. Поэтому метка должна иметь уникальное имя. Если метка с таким именем уже существует, валидатор непременно вас наругает за это.

### Строгий режим (strictLabels)

Метка доступна не только в пределах одного файла - её можно использовать в любом yml-файле. Но при этом требуется указать этот файл в поле [import-labels](./yaml-files.md#import-labels).
Это ограничение необходимо, если планируется запускать селективную валидацию. Например, вы хотите проверять только изменённые файлы в git/arc хуках.
Если валидатор не будет знать, где искать метки, то будут ложные срабатывания.

Метка должна иметь уникальное имя в рамках одного файла. Если метка с таким именем уже существует, валидатор непременно вас наругает за это.
Если название метки дублируется в текущем файле и в файле из `import-labels`, то приоритет получает метка из текущего файла, потом метка из первого файла в `import-labels` и т.д.

Строгий режим включается с помощью [strictLabels](./configuration.md#strictLabels) в конфигурации.

## Плейсхолдеры

**Важно**

Если вы декларируете метку на `common`-уровне, то важно понимать, что из `yml`-файла получается несколько разных тестовых сценариев для каждой платформы (например, фича (`desktop`), фича (`touch-phone`) и т.д.). Для таких ситуаций рекомендуется использовать плейсхолдеры:

```yaml
specs:
  фича:
    проверка 1:
      - label: bla-{{PLATFORM}}
      - do: ...
      - screenshot: внешний вид [plain]
```

В результате, у вас будет доступно несколько меток с именами  `bla-desktop`, `bla-touch-pad` и т.д. Использовать такие метки вы можете как с плейсхолдерами, так и с конечным названием метки:

```yaml
specs:
  фича:
    проверка 1:
      - label: bla-{{PLATFORM}}
      - do: ...
      - screenshot: внешний вид [plain]
    проверка 2:
      - do: ...
      - screenshot: внешний вид [bla-{{PLATFORM}} >> plain]
    проверка 3:
      - do: ...
      - screenshot: внешний вид [bla-desktop >> plain]
```

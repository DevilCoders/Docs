# tracy

[![oko health](https://oko.yandex-team.ru/badges/pkg.svg?pkgName=@yandex-int/tracy)](https://oko.yandex-team.ru/pkg/@yandex-int/tracy)

Простая обвязка над [OpenTelemetry API](https://opentelemetry.io/docs/instrumentation/js/).

## TL;DR

Используешь этот модуль вместо `debug` и получаешь тот же самый вывод, но кроме того можно

1. получить все зарегистрированные трассировщики;
2. подключить [export'еры OpenTelemetry](https://opentelemetry.io/docs/instrumentation/js/exporters/) и "бесплатно" выгрузить свои логи в OpenTelemtry-совметимый сервис трассировки.

Использовать также просто, смотри:
```typescript
import tracy from "@yandex-int/tracy";
const tracer = tracy("mymodule");
tracer.log("my data:", { data: "to log" });
```

```console
$ DEBUG=* node ./build/look-ma-i-use-tracy.js
tracy event 'tracer_registered' fired with attributes: { name: 'mymodule' } +0ms
mymodule my data: { data: 'to log' } +0ms
```

## Термины

[OpenTelemetry Glossary](https://opentelemetry.io/docs/concepts/glossary/).

### Интервал

Span в терминах OpenTelemetry.

Промежуток в выполнении программы между созданием и завершением интервала.
Интервал может быть создан неявно, например, при вызове методов логирования создается интервал нулевой длины.

У интервала обязательно есть время начала, окончания, имя, идентификатор интервала и идентификатор трассировки,
которой принадлежит интервал.

У интервала могут быть атрибуты, указатель на родительский интервал и тип, регулирующий отношения с другими интервалами.
Интервал может содержать события.

### Событие

Event в терминах OpenTelemetry.

Одиночное событие, не имеющее продолжительности во времени. Существует только внутри интервала. Имеет имя и атрибуты.

### Трассировщик

Объект, возвращаемый методом `tracy(namespace)`, содержащий методы трассировки.

Каждой уникальной строке `namespace` соответствует уникальный экземпляр трассировщика.
Экземпляры кэшируются на уровне модуля, потому не стоит генерировать имена трассировщиков
из пользовательских данных и данных неизвестной размерности.
Для одинаковых строк `namespace` будет возвращен один и тот же экземпляр трассировщика.

Стоимость получения экземпляра трассировщика не дороже создания экземпляра трассировщика OpenTelemetry и объекта debug
одноименного модуля, и не дешевле вызова функции + вызова `Map#get`.

## Инструментирование кода

```typescript
import tracy from "@yandex-int/tracy";
const tracer = tracy("mysuperlib");

function fn(taskId) {
  // Метод log создает интервал нулевой длины с временем начала и окончания на момент вызова и именем "log".
  // Внутри интервала создается событие "log", а форматированное сообщение, исходная строка формата и аргументы
  // выступают атрибутами этого события.
  tracer.log("strange things happens here, dude, idk what to do %o", { taskId });
}

function fn(taskId) {
  // Метод logEvent создает интервал нулевой длины с временем начала и окончания на момент вызова и именем "log".
  // Внутри интервала создается указанное событие с указанными аттрибутами.
  tracer.logEvent("task_launch", { taskId })
}
```

## Отладочный вывод трассировки в консоль

Для каждого трассировщика создается объект debug одноименного модуля с тем же `namespace`, что и трассировщик,
потому для получения трассировки в stderr можно использовать привычные для модуля debug переменные окружения.

Сам модуль tracy использует трассировщик с именем `tracy` для трассирования внутренних событий, например, регистрации
других трассировщиков, потому, чтобы узнать доступные `namespace` достаточно посмотреть на вывод с переменной окружения
`DEBUG=tracy`.

*Не стоит использовать вывод в консоль для получения логов сервиса в продакшене и у пользователей!*
Используйте для этого интерфейс OpenTelemetry для экспорта интервалов в логи или внешние системы,
так как формат отладочного вывода не является публичным контрактом, а также зависит от окружения и может быть хрупким.

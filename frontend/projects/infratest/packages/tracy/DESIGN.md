# Решения в дизайне модуля

1. Модуль opinionated и имеет ограниченную поверхность API. Методы трассировщика tracy имеют прикладную семантику,
чтобы для разработчиков-пользователей было очевидно когда и для чего какой метод использовать. Тут никогда не будет
методов оперирующих абстрактными понятиями OpenTelemetry, такими как Span.

Пример хороших методов для tracy:
- log(format, ...args) — логирует строку
- logEvent(name, attributes) — логирует событие в чуть более структурированном виде, чем просто строка
- measure(fn) — выполнить функцию , измерив время выполнения
- makeMeasured(fn) — обернуть функцию в измерение

Примеры методов, которые не хотелось бы видеть в tracy:
- startSpan
- runWithinContext

2. Тем не менее модуль гарантирует порождение вполне определенных сущностей OpenTelemtry на вызовы своих методов.
Эта гарантия является частью API, то есть если метод log приводит к созданию интервала log с событием log, то
в рамках совместимых версий модуля эта гарантия сохраняется.

3. Для встроенного отладочного вывода не используется экспорт в консоль средствами Opentelemetry, 
а используется модуль debug. Это есть следующие причины:
- tracy — это библиотека, дизайн OpenTelemetry предполагает, что Tracer Provider настраивается и устанавливается 
только в конечном приложении
- Текущая реализация OpenTelemetry имеет некоторые недосмотры в устройстве, не позволяющие подключить несколько
TracerProvider'ов, использую только публичное API и без дополнительного знания на стороне конечного приложения
- Обеспечение совместимости в области пользователького опыта: повторить фичи и особенности debug, включая те,
что являются стечением обстоятельств, а не обдуманных решений несколько не тривиально и не очень то хочется.

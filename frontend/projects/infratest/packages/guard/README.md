# Функции для синхронизации участков кода

## fileGuardedSync(filename, callback)

Гарантирует, что на все время вызова callback() будет получен эксклюзивный lock на файл. Предназначено для синхронизации разных процессов между собой.

Пример использования:
```typescript
const res = fileGuardedSync(filename, () => {
    // do something
    return 15;
});
// res === 15
```
На момент вызова файл может не существовать - в этом случае он будет создан первым процессом, захватывающим lock.

Синхронно ждет получение лока на `filename` при помощи `flock`.

Если попытаться получить лок на файл в коллбэке, получится deadlock:
```typescript
fileGuardedSync(filename, () => {
    fileGuardedSync(filename, () => {});
    // Deadlock, вызов fileGuarded никогда не закончится
});
```

Для этого вызова нельзя задать таймаут - вызов будет ждать, пока не будет получен эксклюзивный доступ к файлу.

Переданный файл не обязательно должен существовать - перед стартом он открывается на запись. **Содержимое этого файла будет утеряно**.

Предполагается, что все процессы, которые хотят синхронизировать свою работу, договорятся об одном имени файла, который будет использован в качестве сигнального - хранить в нем данные нельзя.

## fileGuarded

Асинхронная версия, может работать с асинхронным callback'ом.

Пример использования:
```typescript
const res = await fileGuarded(filename, async () => {
    // do something
    return 15;
}, {retryDelay: 100, timeout: 500});
// res === 15
```

Можно задать retryDelay - количество миллисекунд между попытками получить эксклюзивный доступ к файлу и timeout - время в мс, после которого будет выброшена ошибка. Значения по умолчанию: `{retryDelay: 100, timeout: 500}`.

**fileGuarded не гарантирует порядок работы при двух вызовах подряд**. Например, в таком коде: 
```typescript
const promise1 = fileGuarded(filename, fn1);
const promise2 = fileGuarded(filename, fn2);
```

нет гарантий о порядке вызова `fn1` и `fn2`.

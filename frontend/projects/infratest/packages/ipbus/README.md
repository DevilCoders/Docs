# ipbus

[![oko health](https://oko.yandex-team.ru/badges/pkg.svg?pkgName=@yandex-int/ipbus)](https://oko.yandex-team.ru/pkg/@yandex-int/ipbus)

Шина для "brokerless" межпроцессного взаимодествия. Работает поверх unix-сокетов, поэтому только в рамках одного хоста.
Для взаимодействия достаточно знать `rundir` шины.
Прозрачно поднимает брокер при первом запуске, брокер обслуживает unix-сокет в `rundir`.

## Установка

```bash
npm install @yandex-int/ipbus --registry=http://npm.yandex-team.ru
```

## Использование

```js
const {Bus} = require('@yandex-int/ipbus');
async function example() {
    let bus;
    // использует переменную окружения IPBUS_BROKER_RUNDIR
    bus = await Bus.create();
    // можно передать явно
    bus = await Bus.create({brokerRunDir: '/foo/bar'});
    // data это Buffer
    function handler(data) {
        console.log(data.toString());
    }
    // topic является строкой
    // bus.subscribe и bus.unsubscribe возвращают промисы
    await bus.subscribe('myTopic', handler);
    await bus.unsubscribe('myTopic', handler);
    
    // подписаться на ошибки
    bus.on('error', (e) => {
        // паникуем
    });

    // данные являются буфферами
    bus.send('myOtherTopic', Buffer.from('message'));

    // завершаем работу
    // bus.close возвращает промис
    await bus.close();
}
```

```js
const {BufferedBus} = require('@yandex-int/ipbus');
// вызываем синхронно
const bus = BufferedBus.create();

// send и close будут отложены до момента завершения инициализации шины
// subscribe и unsubscribe не поддерживаются
bus.send('topic', Buffer.from('message'));
bus.close();
```

## Обработка ошибок

Все критичные ошибки брокера можно найти в `stderr`-логе брокера; ошибки клиента (в том числе потери соединения с брокером) всплывают в событии `error` на экземпляре шины.
```javascript
bus.on('error', myErrorHandler);
```

При возникновении таких ошибок `ipbus` не пытается реанимировать проблемного брокера или клиентов. Пользователю нужно самому решить, как поступить: попытаться пересоздать шину или же завершить работу.

**Важно:** если вы не зарегистрировали обработчик события `error`, то получите `Unhandled 'error' event`, который может привести к выходу вашего процесса.

## Отладка

Используется модуль `debug`, все сообщения доступны по префиксу `ipbus:`. Пример:

```bash
DEBUG="ipbus:*" node my_script.js
```

## Пример

Предположим, что нам необходимо передать данные между двумя независимыми плагинами в hermione. Плагины при этом могут работать как в одном процессе, так и в разных.

В плагине-источнике напишем:
```js
const {Bus} = require('@yandex-int/ipbus');

module.exports = (hermione) => {
    let bus;
    hermione.on(hermione.events.RUNNER_START, async() => {
        bus = await Bus.create();
        hermione
            .on(hermione.events.RUNNER_END, () => bus.close())
            .on(hermione.events.ERROR, () => bus.close());
    });

    hermione.on(hermione.events.NEW_BROWSER, browser => {
        browser.addCommand('send', () => {
            bus.send('myTopic', 'message data');
        });
    });
};
```

В плагине-приёмнике напишем:
```js
const {Bus} = require('@yandex-int/ipbus');

const allMessages = [];
function handleMessage(message) {
    console.log(message.toString());
    allMessages.push(message);
}

module.exports = (hermione) => {
    let bus;
    hermione.on(hermione.events.RUNNER_START, async() => {
        bus = await Bus.create();
        await bus.subscribe('myTopic', handleMessage);
        hermione
            .on(hermione.events.RUNNER_END, () => bus.close())
            .on(hermione.events.ERROR, () => bus.close());
    });

    hermione.on(hermione.events.NEW_BROWSER, browser => {
        browser.addCommand('getAll', () => allMessages);
    });
};
```

Теперь, чтобы всё это заработало, надо выставить обоим плагинам одинаковую переменную окружения `IPBUS_BROKER_RUNDIR`.
Это можно сделать в конфиге гермионы. В `.hermione.conf.js` добавим:
```js
// часть с `process.pid` необходима для того, чтобы шины от разных запусков не пересекались
process.env['IPBUS_BROKER_RUNDIR'] = path.join(os.tmpdir(), `hermione-ipbus-${process.pid}`);
```

В плагинах можно создавать процессы и передавать им `IPBUS_BROKER_RUNDIR` в окружении, и они будут иметь доступ до шины.

Стоит отметить, что без переменной окружения `IPBUS_BROKER_RUNDIR` (или `brokerRunDir` в опциях) нельзя даже 
создать инстанс `Bus`, поэтому если плагин может использоваться в окружении без `ipbus` стоит прикрыть 
инициализацию шины и работу с ней чем-то, например опцией плагина.

Также стоит отметить, что в этом примере нет никакой синхронизации, и между вызовами команд `send` и `getAll`
данные могут не успеть доехать от одного плагина до другого. 

## Архитектура

### Общая информация

Публичным интерфейсом для пользователя является экземпляр `Bus` (в дальнейшем – клиент или шина).
Именно клиент скрывает всё взаимодействие с брокером, пользователю не предоставляется API для работы с брокером напрямую.

При инициализации клиента происходит поиск запущенного брокера в `brokerRunDir`.
Если запущенный брокер не обнаружен, шина запускает новый процесс, не зависящий от текущего пользовательского процесса.
Атомарность запуска процесса брокера достигается через `flock(2)`.
Процесс брокера переживает смерть "родительского" процесса и продолжает обслуживать инстансы шины в других процессах.
После отключения последнего клиента брокер сам выходит по таймеру.

Весь межпроцессный обмен в ходе работы шины реализован через unix-socket, так что `ipbus` работает только в рамках одного хоста.
Все сообщения от клиента всегда отправляются брокеру; брокер же, для экономии трафика, отсылает сообщения только тем клиентам, которые подписались на соответствующий топик.
И процесс подписки/отписки, и передача сообщений, проходят через один и тот же сокет.

### Подписка

Метод `subscribe` возвращает промис. Он будет зарезолвлен после того, как подписка произойдёт на брокере.

При **первом** вызове `subscribe` **по каждому** топику клиент отправит брокеру сообщение с темой подписки, в ответ брокер отправит сообщение о том, что подписка произошла.
До этого момента клиент (то есть инстанс `Bus`) не будет получать сообщения по этому топику.

Брокер хранит знание о том, какие клиенты на какие топики подписаны. Клиент же регистрирует пользовательские колбеки-слушатели по каждому топику и вызывает их при получении сообщения от брокера.
(Брокер является отдельным процессом, поэтому напрямую пользовательский слушатель вызвать не может.)

В рамках одного пользовательского процесса можно регистрировать произвольное количество слушателей одного топика, например:
```javascript
await bus.subscribe('topic1', myFirstCallbackFn);
await bus.subscribe('topic1', mySecondCallbackFn);
```

### Отписка

Метод `unsubscribe` возвращает промис. Он будет зарезолвлен после того, как отписка произойдёт на брокере (если это необходимо).

Чтобы отписаться от топика, пользователь должен сообщить клиенту тему, от которой он хочет отписаться, и ссылку на функцию-слушателя.
(Как в стандартном `EventEmitter`.)

```javascript
await bus.unsubscribe('topic1', myFirstCallbackFn);
await bus.unsubscribe('topic1', mySecondCallbackFn);
```

Если после этого слушателей данного топика не осталось, клиент сам сообщит об этом брокеру, и тот исключит соотвествующий клиент из списка получателей сообщений по топику.

**Важно!** При завершении работы пользовательского процесса достаточно вызова `bus.close()`, не обязательно вручную отписывать всех слушателей.

### Размер пересылаемых сообщений

Теоретически, объём сообщений на данный момент ограничен протоколом: размер сообщения в байтах должен укладываться в 32-х битное число.
Но нагрузочного тестирования на таких размерах не проводилось, так что не торопитесь пересылать любимые dvd-rip'ы.

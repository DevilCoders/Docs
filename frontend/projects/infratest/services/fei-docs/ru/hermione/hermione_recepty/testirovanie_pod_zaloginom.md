# Тестирование верстки под залогином

## О проблеме

Практически во всех фронтенд-проектах Яндекса существует потребность в тестировании верстки за логином. И до сего дня каждый проект решал эту проблему самостоятельно:
 
- в некоторых проектах каждый разработчик хранит набор персональных тестовых аккаунтов для своего проекта и вручную проставляет нужные куки при снятии эталонов,
- где-то проблема решается с помощью специальных query-параметров, которые даже протекают в прод (попробуйте пройти по такой [ссылке](https://yandex.ru/search/?text=test&yandex_login=test_user) будучи неавторизованными),
- где-то производится реальная автоматическая авторизация через веб-интерфейс Паспорта, но аккаунты с паролями хранятся прямо в коде проекта и заводить их приходится вручную, 
- кое-где код авторизации приходится раскоменчивать при снятии дампов, 
- где-то ограничивались использованием foreverdata, с невозможностью тестирования комплексных сценариев с переходами и ajax'ом,
- и т.д. и т.п.

Всё это разнообразие подходов отражает отсутствие единого решения ряда проблем тестирования верстки за логином:

- создание, хранение и использование тестовых аккаунтов
- авторизация тестовых аккаунтов
- поддержка различных окружений Паспорта (тестовое и продовое, внутреннее и внешнее)
- необходимость авторизации только при снятии эталонов

Новые команды Hermione призваны стать ответом на эти проблемы и унифицировать подход к тестированию верстки под залогином на разных проектах.

## Решение

Для решения описываемых выше проблем реализован набор базовых команд, воплотившихся в виде двух плагинов Hermione. Один из них отвечает за детали управления тестовыми аккаунтами и их авторизации в Паспорте, другой - за ограничение выполнения команд определенными режимами и фазами выполнения тестов, что делает возможным, например, выполенение команд авторизации только при снятии эталонов.  

Для упрощения внедрения на проект с целью тестирования залогина на дампах реализован еще один hermione-плагин, предоставляющий дефолтную компоновку базовых команд обоих плагинов.

### Команды для авторизации в Паспорте

Для решения проблем создания, хранения и использования тестовых аккаунтов был использован сервис TUS - Test User Service. Данный сервис позволяет автоматически создавать тестовые аккаунты в Паспорте, хранит их в своей базе и позволяет обращаться к ним с учетом разграничения доступов. Подробнее о данном сервисе можно почитать в отдельной [статье](https://clubs.at.yandex-team.ru/passport/3360).

Взаимодействие с TUS, а также детали авторизации в различных окружениях Паспорта спрятаны в командах плагина [hermione-auth-commands](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-auth-commands.html), которые мы рассмотрим далее.

Основная команда пакета `auth` принимает требуемый логин, генерирует тестовый аккаунт (или переиспользует существующий) с данным логином с помощью TUS, и авторизует его в Паспорте. Используемое окружение Паспорта определяется конфигурацией плагина при подключении. После этой команды все последующие уже будут выполняться в контексте авторизованного пользователя:

```js
it("should show some auth example", function () {
    return this.browser
        .auth("some-login")
        .url("/some/url")   // авторизованный запрос
        // ...
});
```

Команда также устанавливает meta-поле `tus` с информацией об авторизованном пользователе:

```js
it("should show some tusMeta example", async function () {
    await this.browser.auth("some-login");
    // login может отличаться от переданного команде auth,
    // когда в конфиге плагина установлен префикс для логинов по умолчанию
    // auth - флаг авторизованности, может быть сброшен командой logout
    const { login, auth } = await this.browser.getMeta("tus");
});
```

Для логаута предназначена одноименная команда `logout`:

```js
it("should show some logout example", function () {
    return this.browser
        .auth("some-login")
        // проверки под авторизованным пользователем
        .logout()
        // проверки после логаута
});
```

Команду `auth` следует применять в таких тестах, где не важно состояние пользователя за логином, а важен сам факт авторизации. В случаях же, когда в тестах модифицируется и проверяется некоторое залогиновое состояние пользователя, могут возникнуть проблемы при параллельных запусках тестов на нескольких браузерах под одним аккаунтом. Для решения этой проблемы можно воспользоваться командой `authAny`. 

Команда `authAny` использует еще одну фичу TUS - атомарная блокировка аккаунтов при их получении, что исключает возможность использования заблокированного аккаунта в других тестах. `authAny` принимает префикс для группы аккаунтов или массив логинов, при необходимости генерирует новый аккаунт группы, и авторизует первый незаблокированный из аккаунтов группы с блокировкой. Размер группы и время блокировки определяется конфигурацией плагина или опциями команды.

```js
it("should show some authAny example", function () {
    return this.browser
        .authAny("some-group-login-prefix")
        // проверки с использованием заблокированного группового аккаунта
});
```

Команда `authAny` также устанавливает meta-поле `tus` с конечным логином выбранного аккаунта группы.

При использовании `authAny` необходимо снимать блокировку с авторизованного аккаунта с помощь `unlockAccount` после теста:

```js
it("should show some unlockAccount example", function () {
    return this.browser
        .authAny("some-group-login-prefix")
        // проверки с использованием заблокированного группового аккаунта
});

afterEach(function () {
    // разблокируем использованный в тесте групповой аккаунт
    return this.browser.unlockAccount();
})
```

`auth*`-команды плагина поддерживают опции. Подробнее о них и о плагине в целом можно почитать в [документации](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-auth-commands.html#komandy).

Далее рассмотрим еще один пакет, который делает возможным ограничение выполнения произвольных команд, в том числе команд авторизации, только режимом снятия дампов, а также упрощает регистрацию шагов для teardown-фазы теста, например помогает избавиться от необходимости явного вызова команды `unlockAccount` в `afterEach`.

### Команды, выполняемые в определенных режимах или фазах тестов

Плагин [hermione-lifecycle-commands](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-lifecycle-commands.html) предоставляет набор команд-оберток, которые выполняют оборачиваемые команды только в определенных режимах или фазах выполнения тестов.

Команда `onRecord` выполняет оборачиваемый коллбек только в режиме снятия эталонов (`save`, `create`) или запуске на живых данных при неустановленном режиме:

```js
it("should show some onRecord example", function () {
    return this.browser
        // авторизация произойдет в режиме снятия эталонов
        .onRecord(() => this.browser.auth("some-login"));
});
```

Для полноты в пакете определена и команда `onPlay`, выполняющая оборачиваемый коллбек только в режиме `play`:

```js
it("should show some onPlay example", function () {
    return this.browser
        // Для унификации с командой авторизации, выполняемой 
        // при снятии эталонов, можем установить meta-поле "tus" 
        // в режиме воспроизведения 
        .onPlay(() => this.setMeta("tus", { 
            login: "some-login", 
            auth: true 
        }));
});
```

Команда `onTeardown` регистрирует коллбек, который будет выполнен в контексте `afterEach`:

```js
it("should show some onTeardown example", function () {
    return this.browser.onTeardown(() => doSomeStuffAfterTheTest());
});
```

### Команды для авторизации при снятии дампов

Комбинируя команды из двух рассмотренных выше базовых плагинов, получаем решение для проблемы тестирования верстки под залогином на дампах:

```js
it("should show some combined example", function () {
    const browser = this.browser;

    return browser
        .onRecord(() => browser
            // команды авторизации и тирдауна будут вызваны только при снятии дампов
            .authAny("some-group-login-prefix")
            .onTeardown(() => browser.unlockAccount())
        )
        // при воспроизведении просто выставляем мета-поле tus
        .onPlay(() => this.setMeta("tus", { 
            // конечный логин, выставляемый в мета учитывает дефолтный префикс, а также суффикс группового логина
            login: "yndx-some-group-login-prefix0", 
            auth: true 
        }));
        // также, можем в тесте установить сервисно-специфичное состояние
        // тестового пользователя
        // ...
        // и восстановить его
        .onRecord(() => browser.onTeardown(restoreSomeServiceState())
});
```

Для упрощения внедрения в проекты для целей тестирования на дампах, команды обоих плагинов были скомпанованы в дефолтной конфигурации в еще одном hermione-плагине - [hermione-auth-on-record-commands](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-auth-on-record-commands.html). В случае наличия на проекте некоторой специфики, которую этот оборачивающий плагин может не учитывать, предполагается, что базовые команды в необходимой конфигурации будут скомпанованы на уровне самого проекта с учетом такой специфики.

Для примера рассмотрим эквивалентные примеру выше команды из пакета:

```js
it("should show some precombined example", function () {
    const browser = this.browser;

    return browser
        // в одной команде спрятаны авторизация, ограничение выполнения
        // режимом снятия дампов и разблокировка аккаунта в конце теста
        // + унификация для режима воспроизведения с установкой 
        // мета-поля "tus" без реальной авторизации
        .authAnyOnRecord("some-group-login-prefix")
        // также, можем в тесте установить сервисно-специфичное состояние
        // тестового пользователя
        // ...
        // и восстановить его с помощью еще одной оберточной команды
        .onRecordTeardown(restoreSomeServiceState();
});
```

### Ограничения
Оба рассмотренных базовых плагина могут использоваться независимо, но на счет `hermione-auth-commands` есть ряд оговорок.

Во-первых, TUS на данный момент не поддерживает (авто)удаления тестовых аккаунтов из Паспорта, и по этой причине максимальный размер группы, а значит и параллельность, для команды `authAny` ограничивается явно.

Во-вторых, плагин разрабатывался в первую очередь для целей тестирования залогина на дампах, где высокая параллельность не требуется, и хотя технически плагин можно подключить и в e2e тесты, и при использовании только команды `auth` с фиксированным набором используемых аккаунтов все должно будет работать, тем не менее, на данный момент жестких гарантий работоспособности плагина в условиях, отличных от снятия дампов, не дается.

Здесь же следует учитывать текущие ограничения TUS на общее количество генерируемых аккаунтов на одного консьюмера - 5000/сутки и на всех консьюмеров - 25000/сутки, т.е. следует подходить взвешено к генерации тестовых аккаунтов, и стараться их переиспользовать между тестами по возможности. 

С внедрением запланированной фичи автоудаления тестовых аккаунтов в TUS рекоммендации могут измениться. 

## Алгоритм внедрения в проект
*Плагины были внедрены в проекты [web4](https://a.yandex-team.ru/review/1351695/details) (+[правка](https://a.yandex-team.ru/review/1362553/details)) и [ydo](https://github.yandex-team.ru/search-interfaces/frontend/pull/12079). Почитать про использование на этих проектах можно [тут](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/docs/hermione/faq.md#%D0%BA%D0%B0%D0%BA-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%B2%D0%B5%D1%80%D1%81%D1%82%D0%BA%D1%83-%D0%B7%D0%B0-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BD%D0%BE%D0%BC) и [тут](https://github.yandex-team.ru/search-interfaces/frontend/blob/master/services/ydo/README.md#%D1%82%D0%B5%D1%81%D1%82%D1%8B-%D1%81-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B5%D0%B9) соответственно.*

**1. Заводим TUS consumer для вашего проекта** 

TUS consumer служит для ограничения доступа к вашим тестовым аккаунтам, исключения конфликтов при межпроектном использовании тестовых аккаунтов и является предусловием использования плагина с командами авторизации. Для создания консьюмера рекомендуется использовать утилиту [tus-cli](https://a.yandex-team.ru/arc_vcs/frontend/projects/infratest/packages/tus-cli):
```bash
tus-cli create-consumer -c "example-consumer"
```

При создании консьюмера вам будет присвоена роль администратора данного консьюмера в IDM. Cледует раздать доступы набору пользователей, которые на данном проекте вероятно будут переснимать тесты. Инструкцию по раздаче доступов можно почитать в [документации TUS](https://wiki.yandex-team.ru/test-user-service/#tusiidm). В случае, если проектов со сходным множеством пользователей несколько, не исключено переиспользование консьюмеров между проектами.

**2. Устанавливаем плагины на проект**

Для тестирования залогина на дампах рекомендуется использовать дефолтную компоновку базовых команд в виде плагина `hermione-auth-on-record-commands`:

```bash
npm i -D @yandex-int/hermione-auth-on-record-commands --registry=https://npm.yandex-team.ru
```

Если же дефолтная реализация не подходит и требуется учитывать проектную специфику, предоплагается использовать базовые плагины на проекте напрямую (с дальнейшим определением оберточных команд на проекте):
```bash
npm i -D @yandex-int/hermione-auth-commands @yandex-int/hermione-lifecycle-commands --registry=https://npm.yandex-team.ru
```

Примером такой проектной специфики могут быть особые правила генерации ключей дампов, которые необходимо учесть в командах авторизации. В существующих интеграциях этого не требовалось, но, например, для web4 подобную специфику оказалось необходимо учесть в соседней команде [yaOpenSerp](https://a.yandex-team.ru/arc_vcs/frontend/projects/web4/hermione/commands/libs/pages/serp/utils.js?rev=7147002#L110) для унификации выполнения тестов в режимах снятия эталонов и воспроизведения, поскольку ключи дампов в web4 зависят от признака авторизованности.

*Обратите внимание, что плагины `hermione-lifecycle-commands` и, соответственно, `hermione-auth-on-record-commands` зависят от наличия на проекте `templar-runner` или `kotik`. Они используются как источники информации о текущем режиме выполнения тестов.*
   

**3. Конфигурируем плагины**

Для плагина `@yandex-int/hermione-auth-on-record-commands`:

```js
// ...
'@yandex-int/hermione-auth-on-record-commands': {
    enabled: true,
    auth: {
        // идентификатор созданного на шаге 1. консьюмера
        tus_consumer: 'example-consumer', 
        // зависит от вашего проекта, на какое окружение Паспорта настроен дев-сервер
        env: 'prod', 
        // "yndx-" - обязательный префикс для генерируемых аккантов, требуемый TUS
        // "exmpl-" - пример необязательного, но желательного неймспейсинга аккаунтов
        //  проекта ввиду глобальности логинов Паспорта
        // При том, что префикс "yndx-" является обязательным, 
        //  данную опцию конфигурации можно не заполнять, 
        //  а прописывать логины целиком при вызовах команд авторизации. 
        // Опция loginPrefix просто позволяет избавиться от необходимости 
        //  прописывать эти префиксы при каждом вызове команд авторизации.
        loginPrefix: 'yndx-exmpl-', 
        // соответствует максимальной параллельности тестов
        groupSize: 8, 
        // 2 минуты, сопоставимо с таймаутамм тестов
        groupLockFor: 120 
    }
},
// ...
```

При использовании базовых плагинов, конфигурация сходна, подробности следует уточнять в документации соответствующих пакетов: [hermione-auth-commands](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-auth-commands) и [hermione-lifecycle-commands](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-lifecycle-commands.html).

**4. Заводим проектные обертки для команд авторизации, при необходимости**

Как при использовании `hermione-auth-on-record-commands` так и при использовании базовых плагинов не исключена дополнительная кастомизация через определение проектных оберток. Например, для ydo команды авторизации переопределены с возможностью не указывать логин, с использованием дефолтного.

**5. Готово! Можем начинать прозрачно переснимать тесты с использованием новых команд**

## Tips & Tricks

- Базовые команды авторизации реализованы достаточно универсально, и их поведение может быть расширено на отдельных проектах. Например, проектная обертка команды авторизации может не принимать явный логин, как базовая команда, а генерировать рандомный на каждое выполнение теста. Другой вариант - генерировать не рандомный, а на основе `fullname` текущего выполняемого теста. Тогда на каждый тест будет заводится (и переиспользоваться) отдельный аккаунт. При реализации подобных кастомизации следует учитывать описанные выше ограничения.

- Описанный в предыдущем пункте подход с генерацией нового тестового аккаунта на каждый тест также может использоваться как альтернатива команде `authAny`. Ввиду обсуждавшихся выше ограничений такой подход также следует применять умеренно.

- Иногда может потребоваться использовать не автоматически генерируемые с помощью TUS аккаунты, а уже существующие тестовые аккаунты, например, имеющие премиум-подписку Плюса. Для поддержки таких аккаунтов со стороны команд авторизации, аккаунт следует сохранить под нужным TUS консьюмером с помощью соответствующей команды [tus-cli](https://doc.yandex-team.ru/si-infra/hermione/hermione_svyazannoe/tus-cli.html#save-l-login-p-password). Каждый аккаунт может быть сохранен только под одним консьюмером TUS. Команда `authAny` поддерживает использование существующих аккаунтов через еще одну сигнатуру - может принимать массив логинов вместо префикса группы.

- Для тестов, в которых меняется залогиновое состояние пользователя, это состояние может быть восстановлено с помощью команд `onTeardown`. Таким образом тесты получаются "самовосстанавливающимися". [Пример такого теста в ydo](https://github.yandex-team.ru/search-interfaces/frontend/pull/12079/files#diff-3965c43d2dbcbf1c6e5d7db1b3e19b50R54).

- Ознакомьтесь с базовыми командами и их опциями в документации плагинов [hermione-auth-commands](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-auth-commands.html#komandy) и [hermione-lifecycle-commands](https://doc.yandex-team.ru/si-infra/hermione/hermione_plaginy/hermione-lifecycle-commands.html#komandy).

- Ознакомьтесь с дефолтной реализацией команд оберточного пакета, заточенных под тестирование на дампах [hermione-auth-on-record-commands](https://a.yandex-team.ru/arc_vcs/frontend/projects/infratest/packages/hermione-auth-on-record-commands/src/commands). Это может быть полезно в случае реализации проектных оберток.

- Ознакомьтесь с [командами tus-cli](https://a.yandex-team.ru/arc_vcs/frontend/projects/infratest/packages/tus-cli#%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B), они могут оказаться полезны при каждодневной разработке.

- Для стороннего программного взаимодействия с TUS может быть использован [tus-client](https://a.yandex-team.ru/arc_vcs/frontend/projects/infratest/packages/tus-client).

Новые команды должны упростить тестирование верстки под залогином и сделать процесс практически неотличимым от других тестов на дампах.

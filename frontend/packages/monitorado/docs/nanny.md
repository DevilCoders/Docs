# Секция nanny

- [Секция services](#секция-services)
- [Секция alertsets](#секция-alertsets)
    - [Алиасы для сигналов](#алиасы-для-сигналов)
- [Алгоритм определения тегов](#алгоритм-определения-тегов)

Пример:
```yaml
nanny:
  services:
    # Имя сервиса
    maps_backend_man: default

  alertsets:
    default:
      settings:
        notifications: [chat, team]  # Кому отправлять уведомления
      alerts:
        cpu_load:
          signal: '%cpu_perc'  # Процент потребления CPU
          warn: 50  # Статус WARN, если больше 50%
          crit: 85  # Статус CRIT, если больше 85%
```

## Секция services

Определяет соответствие `сервис` -> `набор алертов`.

Например, для сервиса https://nanny.yandex-team.ru/ui/#/services/catalog/daas_farm/ нужно указать `daas_farm`.

## Секция alertsets

Базовый формат описан [тут](./common.md#Секция-alertsets).

Для удобства в Monitorado заведены алиасы для наиболее полезных сигналов.
Их названия начинаются с символа `%`.

### Алиасы для сигналов

Алиас | Сигнал | Описание
--------|---------|---------
%cpu_perc | perc(havg(portoinst-cpu_usage_slot_hgram), quant(portoinst-cpu_guarantee_slot_hgram, min)) | Процент потребления CPU относительно гарантированного лимита
%mem_anon_perc | havg(portoinst-anon_limit_usage_perc_hgram) | Процент потребления памяти (anon) относительно гарантированного лимита
%mem_perc | perc(havg(portoinst-memory_usage_slot_hgram), quant(portoinst-memory_guarantee_slot_hgram, min)) | (НЕ рекомендуется использовать, см. %mem_anon_perc) Процент потребления памяти относительно гарантированного лимита **с учетом файловых кэшей**
%cpu_wait | havg(portoinst-cpu_wait_slot_hgram) | Время ожидания процессов в очереди

## Алгоритм определения тегов

К сожалению, для произвольного Nanny-сервиса не cуществует набора голованских тегов, который бы позволял однозначно идентифицировать инстансы этого сервиса.
Поэтому в Monitorado применяется такая эвристика:

1. Пытаемся определить геозону по имени сервиса.
   Проверяем, что оно содержит название геозоны, окруженное подчеркиваниями или началом/концом строки: `man_*`/`*_man_*`/`*_man`.
   Возможные значения: `man`, `sas`, `vla`, `msk`. Если есть `iva`/`myt`, то они матчатся в `msk`.
1. Проходимся по всем инстансам сервиса и собираем с каждого все существующие значения тегов `itype`, `ctype`, `prj` и `geo`, очищая от системных.
1. Если на первом нашли геозону, валидируем, что у всех инстансов сервиса стоит соответствующий `geo`.
1. Собираем теги:
   * `itype` - одно общее для всех инстансов значение.
   * `ctype`/`prj` - список всех уникальных значений.
   * `geo` - геозона, если ее получилось определить.

Такая схема вызвана необходимостью поддержки и YP.Lite, и GenCfg.
Из нее следуют некоторые ограничения:

1. Если в двух сервисах все вышеперечисленные теги на вкладке `Instances` совпадают и при этом в именах сервисов не указаны геозоны - сигнал будет агрегировать все их инстансы,
   поэтому категорически рекомендуется указывать в `prj` что-то уникальное (например, имя сервиса).
2. Поскольку для инстансов в `iva` и `myt` стоит `geo=msk`, их податацентровые сервисы неотличимы и также будут "слипаться". Если для вас это критично, ставьте лайки тут: https://st.yandex-team.ru/TOOLBOX-148.

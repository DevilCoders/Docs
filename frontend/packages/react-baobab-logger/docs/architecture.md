# Архитектура

В данном разделе описано как размечать ваше приложение / библиотеку компонентов с помощью Баобаб.
Вы узнаете как строить дерево компонентов и логировать события.

## Создание дерева

Дерево позволяет разметить страницу в приложении на логические блоки — узлы дерева.
Каждый узел несёт в себе информацию, которая помогает логировать поведение пользователя и что он видит.
Каждое событие, даже техническое, должно возникать на каком-то узле.

### Определение узла

Описание узла дерева задаётся с помощью HOC `withBaobab(nodeDeclaration, [WrappedComponent])`.
Первый параметр обязательный, в нём необходимо описать данные для узла:
 - **name** _[обязательный]_ — Имя узла, под которым он будет логироваться.
 - **attrs** _[опциональный]_ — Произвольные атрибуты об узле, которые нужно сохранить в логах.
 - **events** _[опциональный]_ — События узла, которые будут логироваться. (Подробно будут рассмотрены ниже)

Для примера возьмём компонент кнопки, на котором будем демонстрировать возможности библиотеки.

```typescript jsx
import React from 'react';
import { withBaobab, logClick } from '@yandex-int/react-baobab-logger';

interface IButtonProps {
    onClick?: React.MouseEventHandler;
}

const ButtonComponent: React.FunctionComponent<IButtonProps> =
    props => <button onClick={props.onClick}>{props.children}</button>;
```

Компоненты можно размечать несколькими способами.
Каким именно, решать вам, в зависимости от удобства.
Все способы равнозначны и в итоге приводят к одному результату.

Самый простой способ связать компонент и HOC — передать компонент вторым параметром.

```typescript jsx
export const Button = withBaobab({
    name: 'button',
    attrs: { about: 'baobab' },
    events: {
        onClick: logClick(),
    },
}, ButtonComponent);
```

Второй способ подойдёт вам, если вы хотите использовать `compose`.
Тогда можно сначала определить параметры узла, а позже передать компонент.
Тут стоит обратить внимание, что вам необходимо задать тип параметров компонента.
Это необходимо для того, чтобы Typescript смог проверить типы и корректность подписок на события.

```typescript jsx
const baobabForButton = withBaobab<IButtonProps>({
    name: 'button',
    attrs: { about: 'baobab' },
    events: {
        onClick: logClick(),
    },
});
export const Button = baobabForButton(ButtonComponent)
```

Для коротких компонентов можно сразу определять код компонент внутри `withBaobab`.
Типы будут выведены корректно в этом случае.

```typescript jsx
export const Button = withBaobab<IButtonProps>({
    name: 'button',
    attrs: { example: 'baobab' },
    events: {
        onClick: logClick(),
    },
}, props => <div onClick={props.onClick}>{props.children}</div>);
```

### Создание структуры

Компоненты, обёрнутые в `withBaobab`, можно использовать как обычные компоненты.
Библиотека сама построит дерево на основе их вложенности.
Простенький пример, демонстрирующий использование кнопки, созданной в предыдущем примере:

```typescript jsx
export const MessageBox = withBaobab<IMessageBoxProps>({ name: 'message-box' })(props => (
    <div>
        <div>{props.children}</div>
        <Button>OK</Button>
    </div>
));
```

Итоговое дерево: _message-box.button_.

#### Переопределение параметров

Дерево из предыдущего примера может быть не очень информативно, так как не совсем понятно, что за кнопка, и какие функции она в себе несёт.
Для большей ясности имеется возможность переопределять параметры по умолчанию у узлов с помощью параметра `logNode`.
Параметр `logNode` имеет те же поля `name`, `attrs` и `events`, что и определение ноды, с той лишь разницей, что поле `name` опционально.
Задавая параметры таким образом вы полностью перебиваете значение параметров заданных в `withBaobab`.

```typescript jsx
export const MessageBox = withBaobab<IMessageBoxProps>({ name: 'message-box' })(props => (
    <div>
        <div>{props.children}</div>
        <Button logNode={{ name: 'accept' }}>OK</Button>
    </div>
));
```

После этого дерево будет уже выглядеть так: _message-box.accept_, что уже намного информативнее.

Вам может показаться, что именование не несёт в себе особого смысла, так как разработчик всегда из структуры видит назначение элемента.
Но стоит помнить, что аналитик после логирования увидит только ту информацию, что представлена в Баобабе.

### События

В стандартной реализации Баобаб определено 3 вида событий:
 - **click** — Возникает в результате действия пользователя.
 Стоит отличать от браузерных событий.
 В терминологии логирования Баобаба под кликом понимается более широкий спектр действий со стороны пользователя: клик мышкой, наведение указателя, нажатие клавиши.
 - **scroll** — Возникает в результате прокрутки (scroll) элемента.
 - **tech** — Остальные случаи возникновения события.
 В данном случае обязательно указывать в данных события `type`.

Для логирования событий необходимо описать их в определении узла в поле `events`.
Обязательным условием логирования события является их наличие у компонента в качестве принимаемых `props`, на котором они будут логироваться.
Ключ в поле `events` связывает событие логирования с событием, которое будет происходить внутри компонента.
Например, если мы хотим залогировать события onClick на кнопке, то компонент кнопки внутри обязан вызывать `props.onCLick`.

```typescript jsx
export const Button = withBaobab({
    name: 'button',
    events: {
        onClick: logClick(),
    },
})(props => (<button onClick={props.onClick}>{props.children}</button>));
```

Как было сказано выше, все события пользователя логируются как click.
Если мы хотим залогировать событие пользователя, например, onFocus, то в данных события это можно уточнить так:

```typescript jsx
export const Input = withBaobab({
    name: 'input',
    events: {
        onFocus: logClick({ type: 'focus' }),
    },
}, props => <input type="text" onFocus={props.onFocus} />);
```

По умолчанию `logClick`, `logScrol` и `logTech` всегда инициализируют обработчики в пропсах компонента, даже если они являются опциональными.

Это может привести к ситуации, когда компонент проверяет наличие какого-то опционального обработчика и меняет свою бизнес-логику или отображение.
Хотя в действительности исходный компонент обработчик не получил, но `withBaobab` его проинициализировал, так как он был указан в поле `events`.

Чтобы этого избежать можно использовать `logClickStrict`, `logScrollStrict` и `logTechStrict`.

#### Дополнительные данные события

Тут мы подошли к тому, что у событий есть секция с данными.
Дополнительные данные для события можно передать как объектом (пример выше), так и функцией, которая вернёт нужный объект.

```typescript jsx
<Button logNode={{
    events: {
        onClick: logClick(() => ({ answer: this.state.value }))
    }
}}>Answer</Button>
```

#### Динамические данные события

Иногда данные события зависят от параметров события или `props` компонента.
В этом случае в качестве параметра можно передать функцию.
Функция принимает 2 параметра:
 - **component** — Объект с данными о компоненте, на котором возникло событие:
   - component **.props** — `props` компонента.
 - **eventArgs** — Массив с параметрами события.
 Это данные, которые были переданы в событие при возникновении события.

 Для примера залогируем клик и передадим в данных `value` из `props` компонента и `currentTarget` из данных из `MouseEvent`:

```typescript jsx
export const Rating = withBaobab({
    name: 'rating',
    events: {
        onClick: logClick((component, eventArgs) => ({ value: component.props.value, target: eventArgs[0].currentTarget }))
    }
}, RatingComponent);
```

#### Отмена логирования события

Иногда может возникнуть необходимость отключить логирование события.
Для этого достаточно выставить `false` для нужного события:

```typescript jsx
<Button logNode={{
    events: {
        onClick: false
    }
}}>Answer</Button>
```

#### Технические события

Часто возникает вопрос, как логировать технические события.
Особенно если событие общее для страницы.
Рассмотрим пример, когда нам каждую секунду необходимо логировать, что пользователь onLine.
Это можно сделать так:

```typescript jsx
const PagePresenter: React.FC<IPagePresenterProps> = props => {
    useEffect(() => {
        const timerId = setInterval(
            () => props.onLine && props.onLine(),
            1000,
        );

        return () => clearInterval(timerId);
    }, [props.onLine]);

    return <div>{props.children}</div>
}

export const Page = withBaobab({
    name: '$page',
    events: {
        onLine: logTech('online'),
    },
}, PagePresenter);
```

В результате техническое событие с подтипом online, которое будет вызываться раз в секунду.

#### Lego + withBaobab = withBaobabPure
Если вы используете компоненты из Lego, то следует помнить, что withBaobab добавляет в props свойство baobabNode.
Поэтому, если компонент Lego пробрасывает все неизвестные для себя props в DOM атрибуты, то это приведёт к появлению в верстке `baobabNode="[object Object]"`.
А так же в dev режиме React будет ругаться: "React not recognize the baobabNode on a DOM element".
Чтобы этого не было необходимо обернуть лего компонент в withBaobabPure.

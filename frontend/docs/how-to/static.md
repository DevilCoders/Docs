# Сборка статики для библиотеки или сервиса

## Best practices
 * Для каждого сервиса лучше всего иметь отдельный бакет привязанный к соответствующему ABC-сервису. Это позволит управлять ресурсами сервиса ответственным.
 * Всегда разделяйте production- и development- бакеты. Это повысит отказоустойчивость и снизит человеческий фактор.
 * Заводите бакет от имени робота robot-frontend. Роботы не увольняются внезапно. И работают в CI скриптах безотказно 24/7. Это же робот сможет работать с бакетом в CI.
 * Храните доступы от бакета в vault/секретнице.
 * Для development-бакетов рассмотрите возможность настройки (TTL на объекты](https://wiki.yandex-team.ru/mds/s3-api/FAQ/#lifecycleexpiration). Расчитать TTL можно прикинув сколько должна жить бета от пулреквеста.
 * Перед заказом бакета вам нужно расчитать объём бакета. Обычно это произведение: `кол-во сборок проекта` ⨉ `объём сборки (будет ли фризинг влияет)` ⨉ `планируемый период (не менее года)`.

## Сборка

### Режим сборки
Определяется значением переменной окружения `YENV`, которая может иметь одно из трех значений: `development` (по умолчанию), `testing` или `production`.

### Скрипт сборки
Сборка любого пакета или сервиса в монорепозитории запускается командой `npm run build`.
Кроме того, результат сборки должен удовлетворять [соглашениям о путях и именовании](#Соглашения), описанных ниже.  В этом случае деплой-скрипты монорепозитория автоматически разложат статику в кластер.
Сама сборка реализуется силами проекта.
❗️TODO: написать рекомендации

### Фризинг статики
Фризинг (заморозка) статики это автоматический процесс именования статических файлов на основе содержимого файла. Фризинг полезен:
1) Фиксированными урлами. Браузер пользователя кеширует ресурсы.
2) Сокращением занимаемого места под статику. При постоянном деплое добаляются только новые (измененные файлы).
3) Append only работа с бакетом. Отсутствует опасность перезаписать существующий файл другим содержимым. Только добавление файлов с новыми именами, что всегда безопасно.

Формат хеша описан в [соглашениях о путях и именовании](#Соглашения)..

### Соглашения

#### О путях и именовании
| Тип статики                | Папка для сборки         | Типы файлов           | Путь до файла                |
| -------------------------- | ------------------------ | --------------------- | ---------------------------- |
| 1. Специфичная для проекта | `build/static`           | `js, css`             | `{filepath}`                 |
| 2. Для заморозки           | `build/_`                | картинки, шрифты и тп | `[sha1:hash:base58:8].[ext]` |
| 3*. Библиотеки вендоров    | `build/vendors`          | `js, css`             | `[sha1:hash:base58:8].[ext]` |
| 4**. Файлы Service Worker  | `build/service-workers`  | `js`                  | `{filepath}`                 |

\* Библиотеками вендоров считаем набор зависимостей, которые a) редко меняются, б) специфичны для сервиса. При сборке вендорная статика не попадает в общую фризовую папку, а лежит в папке сервиса. Примеры вендорных библиотек: `moment`, `lodash`, полифилы для реакта.
_Примечание_: `react-with-dom` хоть и является вендорной библиотекой, не требует сборки, т.к. используется на многих сервисах и тянется с CDN.
Библиотеки вендоров могут отсутствовать.

\** Service Worker файлы выкладываются отдельно от основной статики, на специальные
бакеты `service-workers`, `service-workers-test`. Воркеры требуют отдельной выкладки по нескольким причинам:
1) **Same Origin** воркер нельзя установить на домен `yandex.ru` c домена `yastatic.net`.
2) **HTTP заголовок Service-Worker-Allowed** необходим для того, чтобы файл по указанному пути можно было установить
в качестве сервис-воркера по пути выше (такое поведение запрещено по умолчанию, увеличивать путь можно, уменьшать — нет).
3) **Scope** - рассмотрим следующую ситуацию:
Воркер занимает определенный scope (Например: `/notifications/`, т.е. `https://yandex.ru/notifications/`).
Есть два сервиса (Например: Морда и СЕРП), которые этот воркер используют, т.к. сервисы живут на одном домене scope у них общий.
Каждый сервис раздает воркер по своему пути (Например: Морда `https://yandex.ru/service-workers/file-v1.0.0.js`,
СЕРП `https://yandex.ru/service-workers/file-v2.0.1.js`).
Тогда при переходах с одно сервиса на другой, файлы сервис-воркеров будут перетирать друг друга (т.к. scope у них общий), что может
приводить к различным проблемам, когда сервис ожидал файл воркера `file-v2.0.1.js`, а фактически утановлен `file-v1.0.0.js`.

В бакете `service-workers` вышеуказанные проблемы решены, т.к. на него смотрят специальные
[L7 балансеры](https://nanny.yandex-team.ru/ui/#/awacs/namespaces/list/service-workers.yandex.ru/show/).
Эти балансеры отдают HTTP заголовок `Service-Worker-Allowed: /`, а также на них настроена специальная прокси ручка
с главного домена `https://yandex.<tld>/service-workers/`.

На файловой системе структура папки `build` выглядит так:

```bash
build
├── static
│   └── {filepath}
│   └── main.desktop.js // для примера
├── _
│   └── [sha1:hash:base58:8].[ext]
├── vendors
│   └── [sha1:hash:base58:8].[ext]
└── service-workers
    └── {filepath}
    └── path/to/file.js // для примера
```

Формат хеша используем такой (пример дан в формате конфига webpack): `'[sha1:hash:base58:8].[ext]'`.

## Деплой

### Режим деплоя
Определяется значением переменной окружения `YENV`, которая может иметь одно из двух значений: `testing` или `production`. Деплой для режима `development` не нужен.

### Скрипт деплоя
Деплой статики любого сервиса в монорепозитории запускается командой `npm run ci:deploy:static`. _**В будущем вместо скрипта будет package**_: https://st.yandex-team.ru/FRONTEND-25.
Для того, чтобы статический пакет сервиса автоматически деплоился скриптами монорепозитория, в `package.json` сервиса необходимо реализовать команду:

```json
  ...
  "ci:deploy:static": "node ../../tools/static/deploy"
  ...
```

Для деплоя сервис-воркеров нужно использовать скрипт `deploy-service-workers`

```json
"scripts": {
    "ci:deploy:static": "node ../../tools/deploy-service-workers"
}
```

Скрипт деплоя ожидает, что статика собрана в папку `build` в корне проекта. При этом соблюдаются [соглашения о путях и именовании](#Соглашения).

Если по каким-то причинам не подходит стандартный для монорепозитория способ деплоя статики, можно указать свой скрипт для `ci:deploy:static`. Если сборка статики не нужна совсем, можно не указывать этот скрипт в `package.json`.

## Статический кластер

### Деплой в режиме testing
Режим `testing` применяется для сборки автобет для Pull Request'ов. Описанное ниже справедливо до тех пор, пока монорепозиторий живет на [гитхабе](https://github.yandex-team.ru/search-interfaces/frontend).
В S3 используется бакет `frontend-test` для основной статики и `service-workers-test` для сервис-воркеров.
Правило резолвинга путей файлов:
`//<name-bucket>.s3.mds.yandex.net/<service>/<pullRequestNumber>/<commitHash>/filepath`.

### Деплой в режиме production
В S3 используется бакет `frontend` для основной статики и `service-workers` для сервис-воркеров.

`<name-bucket>.s3.yandex.net` и `<name-bucket>.s3.mds.yandex.net` – один и тот же бакет, первое имя доступно из внешнего мира, второе только для внутренней сети Яндекса.

`*.s3.yandex.net` не имеет CDN и политик кеширования контента, поэтому для основной статики используется проксирование через `yastatic.net`,
для сервис-воркеров используются прямые пути к файлам.

Правило резолвинга путей файлов:

| Папка для сборки        | Резолв в продакшене                                                      |
| ----------------------- | ------------------------------------------------------------------------ |
| `build/static`          | `//yastatic.net/s3/frontend/<service>/v{major.minor.patch}/filename`     |
| `build/_`               | `//yastatic.net/s3/frontend/_/[sha1:hash:base58:8].[ext]`                |
| `build/vendors`         | `//yastatic.net/s3/frontend/<service>/vendor/[sha1:hash:base58:8].[ext]` |
| `build/service-workers` | `https://yandex.<tld>/service-workers/<service>/path/to/file.js`         |

Все замороженные файлы кладутся в общую папку `_` в корне бакета. Это позволяет реиспользовать кеш между всеми сервисами монорепозитория. Сервисы не из монорепозитория также могут использовать общий бакет `frontend` и реиспользовать общий кеш.

### Проксирование статики
|                            | Адрес на `https://yastatic.net`     | Перенаправление                           |
| -------------------------- | ----------------------------------- | ----------------------------------------- |
| Статика сервиса            | `/s3/frontend/<service>`        ⟹ | `frontend.s3.yandex.net/<service>`        |
| Вендорная статика сервиса  | `/s3/frontend/<service>/vendor` ⟹ | `frontend.s3.yandex.net/<service>/vendor` |
| Общая замороженная статика | `/s3/frontend/_`                ⟹ | `frontend.s3.yandex.net/_`                |

### Сжатие
Проксирование через `yastatic.net` настроено так, что при получении в HTTP заголовке `Content-Encoding` типа алгоритма шифрования (поддерживаются `br` или `gz`) автоматически будет пытаться отдать сжатый файл с указанным алгоритмом вместо исходного файла `static-file`. Если файл найден не будет, в ответ будет передан HTTP код 404.
⚡️В сервисе сжатием заниматься самостоятельно не нужно, скрипт деплоя статики сделает это сам.  Перед выкладкой статики в s3 все файлы будут автоматически сжаты с помощью алгоритмов `gzip` и `brotli` и отправлены в s3.

### Отслеживание состояния бакетов
Есть дашборд от команды S3 MDS: https://yasm.yandex-team.ru/template/panel/s3_client/bucket=hermione-tests;owner=2173/?range=15552000000

Подставляем ABC id в %%owner%% и bucket name в %%bucket%% и смотрим на любой бакет. Там есть:
 * Кол-во объектов в бакете
 * Общий объём объектов в бакете
 * Запросы на чтение и на запись объектов

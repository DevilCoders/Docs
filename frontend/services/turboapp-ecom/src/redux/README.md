# Стор
Для хранения данных приложения используется redux, в частности утилиты:
* [react-redux](https://react-redux.js.org/)
* [redux-toolkit](https://redux-toolkit.js.org/)
* [redux-persist](https://github.com/rt2zz/redux-persist/)

Приложение состоит из экранов:
* Главная страница магазина
* Каталог (верхний уровень)
* Список категорий (n+1 уровень каталога)
* Все бренды
* Категория с товарами (n+1 уровень каталога)
* Фильтр товаров
* Товар
* Магазины на карте
* Экран поиска
* Корзина
* Оформление заказа
* Личный кабинет
* Список заказов
* Заказ пользователя
* Выбор текущего города

## Организация

Стор поделен на следующие основные части:

- Хранилища данных `./src/redux/data`
    - Хранилища данных-справочники, к которым относятся
        - Товары
        - Категории
        - Список брендов
        - Списки товаров главной страницы
        - Списки рекомендованных товаров
        - Заказы пользователя
        - Города
        - Списки подсказок при поиске
        - Списки результатов поиска
            
        `> В хранилище данных, организованном как справочник, данные о каждой сущности хранятся в виде структуры "ключ->значение".`
        
    - Простые хранилища данных
        - Состояние корзины
        - Авторизация пользователя
        - Данные ФИО, почта, телефон пользователя
        - Текущий выбранный город
        - Просмотренные уведомления
        - Выбранные магазины в текущем городе
    
        `> В простом хранилище данных, данные хранятся в виде объекта.`
    
- Состояние экранов `./src/redux/screens`
    - Данные о текущем состоянии UI на экранах с параметрами
        - Товара
            - выбранные аттрибуты товарв
        - Категории каталога с товарами
            - текущая сортировка
            - текущие настройки фильтрации
        - Фильтров товаров
    
        `> Экраны с параметрами - это экраны, которые могут, в рамках одного сеанса использования ТАПа, отображать несколько сущностей
        из справочника - товаров, брендов, категорий каталога уровня ниже первого. Например, пользователь может осуществлять навигацию между разными товарами, совершать какие-то действия, а возвращаясь назад - видеть предыдущие просмотренные товары с сохраненным 
        состоянием экрана этого товара.`
        
    - Данные о текущем состоянии UI на уникальных экранах
        - Оформления заказа
            - выбранный магазин для бронирования
        - Выбора города
            - текущая фильтрация по названию
        
        `> Уникальные экраны - это экраны, которые в рамках одного сеанса использования ТАПа, не могут иметь набор различных состояний. Например, переходя к корзине из разных товаров, пользователь всегда видит одно и то же состояние этого экрана, которое осталась с момента предыдущей навигации с этого экрана.`
    
## Хранилища данных

В хранилище данных, организованном как справочник, данные о каждой сущности хранятся в виде структуры "ключ->значение".
В качестве ключа может выступать либо ID сущности, либо комбинация параметров.

Например, информация о товарах в конкретной категории может меняться в зависимости от текущего выбора глобальных фильтров, текущего города, фильтров категории, выбранной категории, выбранного бренда магазина, выбранных магазинов в текущем городе. Все эти параметры приводятся к строковому ключу
и по нему сохраняются в сторе. В следующий раз, при нахождении такого ключа в кэше и при условии, что он достаточно свежий, не будет
производится загрузка данных из сети, а будет сразу отрисован экран категории.

- Товары - разложенные по их ID
- Списки брендов - разложенны по глобальному фильтру
- Категории - разложенны по глобальному фильтру, ID бренда и ID категории
- Связи между товарами и категориями - разложенны по глобальному фильтру,
ID бренда и ID категории, настройке фильтрации и сортировки

## Изменение данных

Реализация логики изменения состояния инкапсулирована внутри одного файла, который содержит как
экшены (actions), так и редьюсеры (reducers).

Асинхронные запросы за данными описываем внутри функций, которые лежат рядом с экшенами и редьюсерами.
Пример организации стейта:
https://redux-toolkit.js.org/tutorials/advanced-tutorial#logic-for-fetching-issues-for-a-repo

## Получение данных

### Селекторы

Селекторы, преобразующие данные из стора, описываются с помощью `createSelector`.
При повторном вызове такой селектор сначала вызывает все переданные ему селекторы,
и если их результаты не поменялись, не вызывает преобразующую функцию второй раз,
а отдает закэшированное с прошлого вызова значение.

Пример описания селектора:
```typescript
export const cartTotalSelector = createSelector(
    (state: RootState) => state.cart.data.items,
    (state: RootState) => state.products.data,
    (items, products) => items.reduce((acc, item) => {
        return acc + item.count * products[item.id].price;
    }, 0),
);
```

Пример использования селектора:
```typescript jsx
import React from 'react'
import { useSelector } from 'react-redux';

import { cartTotalSelector } from '../../../slices/cart'

const Order: React.FC = () => {
  const cartItemsSummary = useSelector(cartTotalSelector);

  return <div>Итого: {cartItemsSummary}</div>;
}
```

### Селекторы с параметрами

В случае, если в селектор нужно передать параметр, оформляется селектор в виде функции-конструктора,
на входе которой параметр, а на выходе – результат `createSelector`.
Для корректного кэширования необходимо мемоизировать селектор, полученный из функции-конструктора.

Пример описания селектора:
```typescript
export const makeCategorySelectorBySlug = (slug: string) => createSelector(
    (state: RootState) => state.category.data,
    data => {
        const categoryId = Object.keys(data).find(id => {
            const category = data[id];

            return Boolean(category && category.slug === slug);
        });

        return categoryId && data[categoryId];
    },
);
```

Пример использования селектора:
```typescript jsx
import React, { useMemo } from 'react'
import { useSelector } from 'react-redux';

import { makeCategorySelectorBySlug } from '../../../slices/category'

type Props = {
  slug: string;
};

const Category: React.FC<Props> = ({ slug }) => {
  const categorySelector = useMemo(() => makeCategorySelectorBySlug(slug), [slug]);
  const category = useSelector(categorySelector);

  return <div>Категория: {category && category.name}</div>;
}
```

[Подробнее](https://react-redux.js.org/next/api/hooks#using-memoizing-selectors) про мемоизацию `createSelector`

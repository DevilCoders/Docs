### Рекомендации по разработке

В ходе обсуждений подходов к разработке на техновстречах были выработаны следующие рекомендации,
следование которым должно привести к упрощению добавления новых фич в проект, упрощению поддержки,
уменьшению количества багов (и превращению кода в эталон красоты :) ):

#### Выносить изменяемые поля в отдельные свойства верхнего объекта Стора Redux'а

Во избежание громоздкой и лишней логики в редюсерах в тех случаях, если редюсер изменяет данные,
лежащие глубоко в объекте-Сторе Redux (~ уровень 3 и глубже), перепроектировать Стор таким образом,
чтобы эти данные лежали желательно в свойстве самого верхнего объекта Стора Redux.

Также в
[документации](https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns#correct-approach-copying-all-levels-of-nested-data)
Redux'а советуют делать Стор Redux'а максимально плоским:
```
Obviously, each layer of nesting makes this (Copying All Levels of Nested Data) harder to read,
and gives more chances to make mistakes. This is one of several reasons why you are encouraged
to keep your state flattened, and compose reducers as much as possible.
``` 

_Почему?_

Кроме того, что редюсеры становятся тяжело читаемыми, они для поддержания immutability при изменении данных в Сторе
вынуждены копировать большое количество данных, которые на самом деле не изменяются.

[Пример](https://github.yandex-team.ru/mm-interfaces/samadhi/pull/776/commits/29a35f32ebd4f5ff06f74e2686ede4d12cbdd769#diff-9a1922e8172e41f325456c7cf3ca813bR25),
как бы выглядел редюсер для изменения реакций пользователя на комментарии,
если бы реакции не были перенесены на верхний уровень Стора Redux.

#### Разделять компоненты на компоненты-представления и компоненты-контейнеры

Компоненты, управляющие представлениями должны быть максимально "глупыми": не знать про существование Redux'а,
не выполнять сетевые запросы, не знать ничего про окружение и т.п. Все необходимые данные и ручки они должны получать
через props'ы, переданные через атрибуты компонента, которые ему подготваливает компонент-контейнер, который уже
знает то, в каком контексте работет.

_Почему?_

Так компонент-предсталвение становится максимально отчуждаемым,
и его можно переиспользовать в других частях проекта, поменяв только компонент-контейнер для него.
Также предположительно это должно уменьшить боль при добавлении новых фич,
так как не придется во многих местах проекта вносить изменения,
а только добавить логику представления в один компонент-представление и в окружающих его компонентах-контейнерах,
выступающих в роли оберток, получать необходимые данные различными способами.

#### Советоваться перед внедрением более-менее сложных модулей в проект

Возможно, в проект уже подключен модуль, позволяющей выполнить текущую задачу. 
Или кто-то из коллег может посоветовать какой-то из готовых модулей:
имел опыт работы с ними при решении подобных задач и т.п.  

_Почему?_

 Хочется видеть проект Samadhi как можно более "чистым" - не имеющим лишних подключенных модулей -
 без которых можно было обойтись. А также модулей, дублирующих функциональность. 

#### При добавлении размеров в стилях задавать их в пикселях (px)

На данный момент в проекте часть размеров задана в px, часть - в rem.
В новых компонентах рекомендуется использовать px.
При правке стилей старых по возможности также было бы хорошо переводить заданные в rem размеры в px.

_Почему?_

При использовании единых резмерностей в проекте,
все компоненты будут вести себя единообразно при открытии сервиса на разных устройствах или,
например, при разных масштабах. Может, и не совсем корректно, но единообразно - веб-страница не будет "разваливаться".
Так как пока наш веб-сервис предназначается только для десктопов,
нет смысла поддерживать его работу на других устройствах: это достаточно дорого.

Пиксели (px) были выбраны, так как (на основе наших существующих знаний)
rem помогут настроить "резиновость" и адаптивность разметки, но разработка с использованием px будет быстрее,
поскольку в используемых дизайнерских макетах используются именно они,
и поэтому не нужно будет производить конвертирование размеров.

#### Уникальные ключи в key

В атрибутах `key` jsx-разметки формировать и указывать уникальную строку на основе данных (еще лучше - идентификаторы),
не использовать индексы массивов.

_Почему?_

В документации React в конце [раздела](https://reactjs.org/docs/lists-and-keys.html#keys),
посвященному ключам, есть специальное указание о том,
что не рекомендуется использование индексов массивов в качестве ключей:
```
We don’t recommend using indexes for keys if the order of items may change.
This can negatively impact performance and may cause issues with component state.
```
Действительно, есть приписка "if the order of items may change", однако возможности ошибиться будет гораздо меньше,
если идентификаторы будут использоваться всегда.

#### Typescript в серверной части

Решили потихоньку внедрять `typescript`, начинаем с серверной части ([/app](https://github.yandex-team.ru/mm-interfaces/samadhi/tree/master/app)). Для импорта модулей использовать es6 `import` вместо `require`.

_Почему?_

Так подтягиваются все тайпинги на библиотеку.

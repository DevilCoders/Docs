# Терминология

В рамках этой страницы

- `Lang` — мидлварь для express, которая определяет язык. [Исходник](../../src/express/middlewares/lang.js).
- `Прокси` — прокси-мидлварь к бэкэнду. В [конфиге express-приложения](../../src/express/index.js) — обработчики для
  `/back-proxy/` и `/dispenser`.
- `Fetcher` — утилита для формирования аякс-запросов, которая используется в коде на реакте.
  [Исходник](../../src/abc/react/redux/utils/fetcher.js).


# Описание

## TL;DR

Язык определяется настройкой на стаффе. Но его можно явно переключить параметром `lang=en|ru` в урле.

## Важное

Есть три сущности:
1. фронт (браузер)
2. бэк фронта (express-приложение для формирования статичных ответов)
3. бэкенд (собственно бэк, который работает с данными)

Есть три типа запросов:
1. Фронт → express, синхронный. Это когда пользователь загружает страницу в браузере.
2. Фронт → express, асинхронный. Это когда мы делаем аякс-запрос на странице.
3. Express → бэкенд. Это продолжение предыдущего пункта. Нужно, потому что CORS не разрешит пойти в бэкенд напрямую
  из браузера, например. Бэкенд отвечает express’у, который в свою очередь отвечает браузеру.

Что, собственно, важно помнить: параметр `lang` из урла передаётся только в первом случае.

Во втором случае его нужно не забыть добавить в запрос, само это не произойдёт. Это не забыто, делается автоматически,
ниже описано, как именно это делается. Но это важно понимать.

В третьем случае параметр не передаётся. Передаётся заголовок `Accept-Language`. Он мало где используется бэкендом,
в большинстве случаев бэк отвечает объектом со всеми доступными переводами, а нужный выбирает фронт. Но это тоже важно
понимать.

## Алгоритм

В Lang определяется текущий язык, который нужен пользователю. По такому пути:

1. Происходит запрос к express’у от браузера, когда пользователь открывает какой-то урл
2. Берём специальной мидлварью язык из настройки на стаффе (тут неважно, как именно)
3. Если в запросе есть параметр `lang`, и он валидный, то берём его, иначе оставляем настройку со стаффа
4. Записываем вычисленный язык в локальное поле приложения, оно используется в дальнейшем при формировании ответа
5. При конструировании ответа берём файлы статики на нужном языке: шаблоны, скрипты, вот это всё
6. В статике нет никакой логики определения языка, просто сборка производится на всех языках, и в файле на языке N везде
   захардкожен язык N
7. При отправке аякс-запросов к express’у этот захардкоженный язык добавляется в запрос в Fetcher’е. Добавляется
   в GET-параметр `lang`. При этом надо учесть, что есть ещё формирование запросов в старом i-bem, и там язык
   не передаётся, но там это и не нужно, ничего не сломается.
8. Язык опять же определяется в Lang по пути 2..4, но в этом случае у нас уже не ответ на синхронный запрос,
   а проксирование запроса к бэкенду и асинхронный ответ.
9. Для путей `/back-proxy/`, `/dispenser/` и `/d/` используется прокси, который собирает опции запроса от фронта
   (включая заголовки), мержит их с опциями, которые указаны явно для этого прокси (включая заголовки) и собственно
   отправляет запрос к бэку. В явно указанных опциях мы берём вычисленный в п.7 язык и кладём в заголовок
   `Accept-Language`.
   
NB: Для `/back-proxy/` и `/dispenser/` значением `Accept-Language` остаётся просто язык, без дополнительных под-тегов.
Для `/d/` язык мапится на значения с тегами региона: `en-US` и `ru-RU`. Бекенд сервиса D по-умолчанию ожидает такие
стандартные значения во всех ручках.


## Пройденные грабли

Текущий язык от фронта к express-приложению нужно передавать именно параметром. Неважно каким, в данном случае это `lang`.

До этого была попытка использовать заголовок `Accept-Language` в запросах фронт→express. Это не работает.
Если его использовать, возможно два случая:

1. В Lang мы смотрим на заголовок `Accept-Language`. Это был бы пункт 1.5: после проверки настройки на стаффе и перед
   проверкой параметра lang мы смотрим на заголовок `Accept-Language`, и если там валидное значение, то берём его. Здесь
   возникает проблема: некоторые браузеры отправляют в этом заголовке настройку предпочитаемого языка в виде, который мы
   считаем валидным. В случаях, когда мы явно не определили заголовок, там будет лежать занчение из браузера. Явно
   заголовок мы определяем при аякс-запросах, а при обычной загрузке страницы в браузере — не определяем. В этом случае
   будет возникать ситуация, когда настройка стаффа перетирается настройкой браузера. При этом настройка стаффа у нас
   на сервисах всегда должна быть дефолтно приоритетная. А про настройку браузера многие пользователи вообще не знают.
   В общем, этот вариант не работает. На `Accept-Language` в Lang смотреть нельзя.
2. В Lang мы НЕ смотрим на заголовок `Accept-Language`. В этом случае нет проблемы с тем, что браузерная настройка
   внезапно перезапишет текущий язык сервиса. При этом задача «отправлять на бэк текущий язык в заголовке» решается,
   т. к. заголовки по-умолчанию прорастают из запроса фронт→express в запрос express→бэк. И если явно не класть в этот
   заголовок в прокси какое-либо значение, то в нём будет лежать значение, которое было в запросе от фронта. Но в этом
   случае возможна ситуация, когда в мидлвари Lang определяется один язык (мы же не смотрим на заголовок), а в запросе
   к бэку в заголовке `Accept-Language` отправляется другой язык. Это может вызвать непредвиденные баги и будет
   запутывать всех, кто попытается разобраться, как работает определение языка. Нужно, чтобы всё было синхронизировано.
   Не смотреть на заголовок `Accept-Language` в Lang тоже нельзя.

Значит, заголовок `Accept-Language` между фронтом и express’ом трогать вообще нельзя. Нужно дописывать в аякс-запросы
такой же параметр `lang`. В этом случае язык всегда определяется по нему. Какой язык был использован для формирования
статики, такой 100% будет в аякс-запросах. Значит, этот язык будет в окружении приложения в express. И его нужно явно
переложить оттуда в заголовок в прокси.

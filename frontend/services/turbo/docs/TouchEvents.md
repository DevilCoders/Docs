## Touch Events

Основными используемыми событиями являются
* Для обработки **клика/тапа** используем просто `.on('click', handler)`

    Ожидается, что это будет основой для организации простого взаимодействия с пользователем (то есть почти всегда
    этого должно быть достаточно).
    Например, [раскрытие/скрытие аккордиона по тапу на заголовок](../blocks/accordion/__item/accordion__item.js),
    [срабатывание метрики](../blocks/metrika/__goal/metrika__goal.js#L6),
    [клик по кнопке](../blocks/button/button.js#L37)

* Для обработки **других событий** как обычно подписываемся на тач события + аналогичные события мыши, например:
    * `.on('touchstart mousedown', handler)`
    * `.on('touchend mouseup', handler)`

    Ожидается что эти события будут использоваться для решения специфических задач (например, связанных с особенностями
    именно тач-интерфейса), например:
    * если необходимо отследить состояние "нажания" (pressed), когда пользователь удерживает контрол нажатым. Например,
        состояние ["pressed" у кнопки](../blocks/button/button.js#L65)
    * для "оживления" блоков и элементов на действие пользователя, например,
        [checkbox](../blocks/checkbox/checkbox.js#L50), [input](../blocks/input/input.js#L58). В качестве
        обработчиков в таких случаях обычно используется пустая функция, позволяющая просто проинитить блок, а
        бизнес-логика завязана на [другие события](../blocks/input/input.js#L47).

### Важно! Про клики не на контролах и ссылках
На Safari iOS события на элементах не являющихся "**ссылками и форм-контролами**" (т.е. `<div>`, `<span>` и т.д.)
обработчики событий мыши (в том числе и клик) в `i-bem` могут не срабатывать. Это происхоит из-за отсутствия всплытия
делегированных событий мыши в Safari. Решением этой проблемы является:
* добавление css правила `cursor: pointer` к элементу (рекомендуемый вариант, с учетом отсутствия курсора на
    мобильных девайсах). Например, реализация [аккордиона с кликом по заголовку](blocks/accordion/accordion.sass#L19).
* прикрепление обработчика события либо в атрибуте элемента `onclick=''`, либо в js коде
    `this.domNodes[0].addEventListener('click', function(){})` (сам обработчик может быть пустой, главное чтобы был
    прикреплен, тогда событие будет всплывать)

**Замечание**: обработчики или правило для курсора могут быть прикреплены к самому элементу или к любому родительскому
элементу (исключая body).

**Не забывайте добавлять!**

**Подробности** https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile и
https://patrickhlauke.github.io/getting-touchy-presentation/#210

### Проблема 300мс
При обработке события `click` на тачах может возникнуть [известная](https://www.youtube.com/watch?v=uNxYbDtDPGM)
[300мс задержка](https://www.youtube.com/watch?v=IJ1fhtRRXG8) между тапом пользователя и вызовом обработчика.
Для борьбы с ней используются эвристики
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```
```css
body {
    /* Кое-где пишут, что это свойство нужно указывать непосредственно на элементе, на котором ловим событие */
    /* Видимо, из-за i-bem, достаточно указать на body (тестировалось на iOS 10 и 11) */
    touch-action: manipulation;
}
```

Это отключает задержку во всех поддерживаемых браузерах, за исключением Safari 8 и 7 (что составляет 1,3%), у
которых будет задержка клика (в режиме зума).

Таким образом, при разработке эта особенность не требует никаких дополнительных действий.

**Подробности** [тут](http://www.telerik.com/blogs/what-exactly-is.....-the-300ms-click-delay),
[тут](https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away) и
[вот тут много всяких данных](https://patrickhlauke.github.io/getting-touchy-presentation/#98).

---

#### Ручная обработка touchend
Иногда для того, чтобы всё таки сделать быструю обработку событий клика, применяют конструкцию вида:
```js
.on('touchend', function(e) {
    e.preventDefault(); // это нужно сделать чтобы отменить обработчик клика
    _onClickHandler();
})
.on('click', _onClickHandler) // обычный обработчик клика
```
Недостатками таких методов является то, что
* `preventDefault` ломает последующий *pinch*, *zoom* и т.д.
* `touchEnd` может произойти не на том элементе, на котором был `touchStart`
* ... и ещё куча подводных камней

---

#### PointerEvents
Не используем из-за недостаточной поддержки в мобильных браузерах, а реализация `PointerEvents` из bem-core работает
только для устройств на iOS (соответственно появляется набор клиентов, в которых они точно не работают).

---

#### fastclick
... и подобные библиотеки не внедряем по совокупности причин: увеличение размера сборки, негативный опыт внедерения
таких библиотек, например, в лего, допустимый уровень пользователей, у которых проявляются некритичные негативные
эффекты

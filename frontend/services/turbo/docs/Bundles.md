# Бандлы

## Какую проблему решаем?
Рассмотрим ситуацию, что у нас есть блок со своим шаблоном `.bemhml.js`, скриптами и стилями.
Но нужен он только тогда, когда шаблонизируется и присутствует на странице. Прописывать этот блок
в `deps` зависимостях нельзя, ведь его статика будет в общей сборке вне зависимости есть ли блок
на странице или нет.

## Решение

В данном случае нам поможет зарекомендовавший себя подход с бандлами.

Для этого сборка разделяется на 2 составляющие:

  - основной бандл `pages/all/all.bemdecl.js`:
    - в нём должны быть задекларированы **все** блоки, имеющие `.bemhml.js` шаблоны
    - цель сборки основного бандла:
      - шаблон `pages/all/_all.bemhtml.js`
  - бандл статики `pages/main/main.bemdecl.js`
    - в нём должны быть описаны минимально необходимые зависимости для статической
      сборки скриптов и стилей
    - цели сборки бандла статики:
      - статика скриптов `pages/main/_main.js`
      - статика стилей `pages/main/_main.css`

В итоге основной бандл будет знать про все блоки, что позволяет шаблонизировать конечную вёрстку, а
бандл статики будет содержать только общий и конечный набор скриптов и стилей. Вся остальная
статика должна быть доставлена на страницу с помощью бандлов блоков вместе с телом страницы.

## Создание бандла блока
Если блок попадает под указанное описание, то следует создать для него бандл.
То есть, если у блока есть скрипты и/или стили, то нужно задекларировать его в `bundles/` вот так:

  1. декларируем блок

        Создаём `{platform}.bundles/<block name>/<block name>.bemdecl.js` с подобным содержимым:

        ```javascript
        exports.deps = [{ block: '<block name>' }];
        ```

  2. добавляем его в общие зависимости _(только если у блока есть `.bemhml.js`)_

        Для того, чтобы при сборке `.bemhml.js` шаблон блока попал в основной бандл, следует внести его в `pages/all/all.bemdecl.js`

        ```javascript
        exports.deps = [
            // ...
            { block: '<block name>' }
        ];
        ```

## Как статика бандлов попадает на страницу
Существует временное хранилище запроса, управляемое CommonJS модулем `core/assets`.
В его задачи входит принимать "заявки" на добавление статики и предоставление по требованию
результата с котентом стилей и скриптов. Так же он сам следит за отсутствием дубликатов и
очисткой между запросами, а также кэшированием содержимого файлов статики.

Блок `root`, являющийся точкой входа, обращается во временное хранилище за собранной
при шаблонизации статикой и раскладывает её по нужным местам: стили в `head`, скприты в
конец документа.

#### Автоматическое добавление бандла блока при его шаблонизации

Вместо того, чтобы в каждом блоке городить такое:

```javascript

block('<block name>')(
    def(node => {
        node.pushBundle('<block name>');

        return applyNext();
    })
);
```

и для того, чтоб разрабатываться было удобно используются возможности BEMHTML, а именно
[добавление шаблонов](../core/assets.js#L114) в runtime режиме.

```javascript
BEMHTML.compile(`block('<block name>').def()(node => node.pushBundle(node.block) && applyNext());`);
```

Рутиной проверки есть ли бандл и добавлением его во временное хранилище запроса
занимается модуль `core/assets`. Вкратце: при сборке проекта создаётся json
файл `configs/current/bundles.json` со списком бандлов, который потом и используется
для проверки наличия бандла блока.

#### Ручное добавление бандла блока
Может возникнуть ситуация, когда нужна статика блока, но блок не шаблонизируется (например,
если он примиксовывается к другом блоку). В таких случаях можно использовать механизм добавления
бандла напрямую:

```javascript
block('page')(
    addMix()(() => [
        apply('metrika')
    ]),

    mode('metrika')(node => {
        node.pushBundle('metrika');

        return {
            block: 'metrika',
            js: { counters: node.counters }
        };
    })
);
```

## Бандлы и зависимость блоков
Может случиться так, что у какого-то блок будет js, который зависит от js другого блока. Например:
```javascript
modules.define(
    'page',
    ['i-bem-dom', 'tracking', 'metrika'],
    function(provide, bemDom, Tracking, Metrika) {
        var Page = bemDom.declBlock('page', {
            // ...
        });

        provide(Page);
    }
);
```

Но что делать, если блоки `tracking`, `metrika` вынесены каждый в свой бандл и хотя бы 1 из них
не был определён через `modules.define`? Ведь при декларации блока `page` будет брошено исключение.

И для этого случая есть решение:

```javascript
modules.decl(
    'page',
    ['i-bem-dom', 'tracking', 'metrika'],
    function(provide, bemDom, Tracking, Metrika) {
        var Page = bemDom.declBlock('page', {
            // ...
        });

        provide(Page);
    }
);
```

Теперь, если статика необязательного блока не попала на страницу, то соответствующие
переменные `Tracking` или `Metrika` будут попросту иметь значение `undefined`.
В коде блока достаточно будет проверить переменную и принять решение в зависимости от
сложившейся ситуации.

О том каким образом реализуется декларация блока с разрешением необязательных зависимостей
можно посмотреть [тут](../common.vanilla/modules/modules.js).

## CLI

Обновление json'а со списком бандлов. После обновления необходимо перезапустить templar.

```bash
make bundles.json
```

Создание бандла с добавлением его в общие зависимости при необходимости.
```bash
make bundle
```

# Правила TokenLogic

Библиотека TokenLogic позволяет писать набор правил, которые проверяют наличие указанных слов в тексте и их количество, но при этом игнорируют порядок расположения этих слов. Слова при этом могут задаваться не только через их текст, но и через классы слов, задаваемые как наборами, так и специальными логическими условиями.


## Задание правил {#zadaniepravil}

Файл с правилами состоит из последовательности предложений. Каждое предложение заканчивается точкой с запятой. Все, что идет после символа `#` и до конца строки, считается комментарием.


### Токены {#tokeny}

Основной единицей правил является токен, определяемый через [литерал](literals.md) и расширяющий его возможностью добавления [именованных меток](#imenovannajametka).

В правилах TokenLogic действует специальная интерпретация литерала `.` - он соответствует любому слову, которое не подпадает ни под один другой литерал, используемый в текущем правиле.


#### Именованная метка {#imenovannajametka}

Сразу после литерала (включая его суффиксы согласования) через двоеточие может быть указана одна или несколько _именованных меток_. В этом случае слово, сопоставленное данному токену, попадает в результат работы правила и может быть извлечено по имени метки.

Пример использования именованной метки:

```
[карта схема маршрут путь проезд]#gzt(1):track
[один два три]:label1:label2
```


### Предложения {#predlozhenija}

#### Включение файла {#vkljucheniefajjla}

```
include "<имя файла>"; 
```
Данное предложение включает в текущий файл текст из указанного файла. Включаемый файл ищется относительно директории текущего обрабатываемого файла.

#### Внешние статьи {#vneshniestati}

Если правила ориентированы на использование некоторых газетирных статей, которые не упоминаются явно в правилах, то их можно декларировать следующим образом:

```
use-gzt <статья1>, <статья2>, ...<статьяN>;
```

Если имя статьи содержит пробелы или знаки препинания, то оно может быть заключено в кавычки.

Таким образом могут декларироваться доминантные статьи, которые создают каскады. В этом случае каскад будет создан даже если статья не упоминается в правилах.

#### Определение {#opredelenie}

Определение задает указанному токену символьный идентификатор, который может использоваться в правилах, определениях и общих условиях через конструкцию `$<идентификтор>`.

```
token <идентификатор> = <литерал или ссылка на другой токен>; 
```

Определение токена может включать именованные метки, а также ссылаться на другой токен.

Примеры:

```
token tok1 = [?gzt=test1]:res1;
token tok2 = [один два три четыре];
token tok3 = [?gram=S,nom & (prop=cs-title | prop=cs-upper)];
token other = .:res4;
token tok1withLabel = $tok1:res2;
```

#### Правила {#pravila}

```
rule <имя> = <логическое выражение>;
```

Правило задает условие на обработку токенов. Имя слева от знака "=" задает имя правила (может быть получено как результат работы правила). Логическое выражение справа от знака "=" задает условие на присутствие токенов в тексте.

Логическое выражение состоит из условий, объединенных операциями `||` (ИЛИ), `&&` (И), `^^` (ИСКЛЮЧАЮЩЕЕ ИЛИ), `!` (ОТРИЦАНИЕ) и круглыми скобками.

Условие может быть одним из следующих (во всех ниже перечисленных условиях сам токен может задаваться как непосредственно, так и через идентификатор ранее заданного определения токена, и может содержать именованную метку):

#|

||`<токен> <сравнение> <число>`| Условие на количество слов, соответствующих данному токену, в тексте. 

<сравнение> может быть одна из следующих операций: `==`, `=<`, `>=`, `<``!=`.

<число> может быть любым неотрицательным целым числом. ||

|| `<токен>` | Условие на наличие указанного токена в тексте. Сокращенная запись условия `<токен> >= 1` ||

|| `<токен>?` | Условие на возможное наличие указанного токена в тексте. Сокращенная запись условия `<токен> >= 0` ||

|| `!<токен>` | Условие на отсутствие указанного токена в тексте. Сокращенная запись условия `<токен> == 0` ||

|#

Приоритет правил учитывается при снятии омонимии фактов и по-умолчанию имеет значение 1.0.

Для правил можно задавать приоритет - любое вещественное число:

```
rule <имя> (<приоритет>) = <логическое выражение>; 
```

Примеры правил:

```
rule r1 = $token1:name && $token2;
rule r2 = $token1 || $token2;
rule r3 = !$token1 && $token2;
rule r4 = [один два три четыре] && [?gram=S,род] && !.;
rule r5 = $token1 && ($token2 >= 0 || $token4 >= 0);
rule r6(1.3) = $token1 > 0 && ($token2 == 2 || $token2 >= 0);
```

#### Общие условия {#common}

```
default <логическое выражение>; 
```

Общее условие задает [логическое выражение](literals.md#logicheskoeuslovie), которое автоматически включается через оператор `И` во все правила, идущие после данного предложения.

Можно задать несколько общих условий. Каждое новое общее условие дополняет все предыдущие.

Общие условия действуют только в пределах текущего файла. Если файл с включен через `include` в другой файл, то во включающем файле общие условия из включенного файла действовать не будут.

Примеры:

```
token track = [*карта схема маршрут путь проезд];
default [?gzt=geo]:geo >= 1;
default $track:track;
```


## Конвертация из Perl {#konvertacijaizperla}

#|

|| **Конструкция**  | **Синтаксис Perl** | **Синтаксис TokenLogic** ||

|| Неявные слова | `+Geo;` 
`-:-`
`...` | `default $Geo;` ||

|| Правило с исключением других слов | `...`
`-:-`
```* Weather && (Geo || 1) = ($Geo);``` | `rule w = $Weather && $Geo:geo? && !.;` 

или исключение других слов из всех правил: 

`default !.;` ||

|| Множество слов (совпадение по точной форме слова) | `games = (!игры, !играть, !play, !поиграть);`
`-:-` 
`...` | `token games = [игры играть play поиграть];` ||

|| Множество слов (совпадение по любой форме слова) | `games = (игры, играть, play, поиграть);` 
`-:-`
`...` | `token games = [*игры играть play поиграть];`

или с использованием газетира: 

`token games = [?gzt=play];` ||

|| Получение сматченных слов в результате | `...` 
`-:-`
`* (Geo == 1 && cinema_place) = ('Кинотеатры', 'cinema', $Geo, 'Все фильмы')` | `rule cinema_place_all_films = $Geo:geo == 1 && $cinema_place;` 

Константные имена кодируются в имени правила, которое доступно в результате работы правила. ||

|#





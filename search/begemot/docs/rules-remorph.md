# Правила Remorph


## Внешние статьи {#vneshniestati}

Если правила remorph ориентированы на использование некоторых газетирных статей, которые не упоминаются явно в правилах, то их можно декларировать следующим образом:

```
use-gzt <статья1>, <статья2>, ...<статьяN>;
```

Если имя статьи содержит пробелы или знаки препинания, то оно может быть заключено в кавычки. Таким образом могут декларироваться доминантные статьи, которые создают каскады. В этом случае каскад будет создан даже если статья не упоминается в правилах.


## Строки {#stroki}

Строка позволяют присвоить идентификатор произвольной последовательности символов и повторно использовать его в качестве имени правила.
```
string <идентификатор> = "<строка, в которой кавычки пишутся как \">";
```
Пример:
 
 
```
string abramov = "(#enc_name=\"abramov\" | #enc_name=\"shortsin\" | #enc_name=\"slovinrusyaz\")";
rule $abramov = синоним $slovo? (<>.);
```


## Определения {#opredelenija}

Определение позволяет присвоить идентификатор какому-либо регулярному выражению и использовать это определение в других правилах/регулярных выражениях. С его помощью можно выделить часто используемые части правил в некоторое подобие библиотеки.
```
def <идентификатор> = <регулярное выражение>;
```
Пример (кавычки не нужны!):

```
def slovo = к слову | слова;
```


## Логические определения {#logicheskieopredelenija}

Логические определение позволяет присвоить идентификатор какому-либо [логическому условию](literals.md#logicheskoeuslovie) и использовать это определение в других логических условиях.

```
logic <идентификатор> = <логическое условие>;
```

Пример:
 
```
logic Noun = gram = S & gram != abbr;
def NounGen = [?$Noun & gram=gen]
```


## Правила {#pravila}

Это основное предложение, которое идентификатору или произвольной строке сопоставляет "правило". Правило является обычным регулярным выражением, только вместо отдельных символов выступают слова. Есть возможность в качестве подвыражений использовать ссылки на другие выражения, определенные ранее предложением `def`.

Правило задается конструкцией следующего вида:

```
rule <идентификатор> = <регулярное выражение>;
```

В качестве идентификатора правила можно использовать ссылку на предварительно определенную строку - `$<идентификатор строки>`.

Пример:

```
rule $abramov = синоним $slovo? (<>.);
```

Правилу можно задать приоритет, указав его в круглых скобках сразу после имени:

```
rule <идентификатор>(<приоритет>) = <регулярное выражение>;
```

В качестве приоритета можно указать любое вещественное число. По умолчанию, все правила имеют приоритет 1.0. Приоритет правила автоматически учитывается при снятии омонимии фактов. Его значение может быть получено также программным путем из поля `TMatchResult.RulePriority`.


## Регулярные выражения {#reguljarnyevyrazhenija}

Регулярное выражение поддерживает следующий набор операторов:

#|

|| ? | Предшествующий символ может входить 0 или 1 раз  ||

|| + | Предшествующий символ может входить не менее одного раза ||

|| * | Предшествующий символ может входить 0 или более раз ||

|| ^ | Анкер, соответствующий началу входной последовательности ||

|| $ | Анкер, соответствующий концу входной последовательности ||

|| / | Анкер-разделитель, который может встречаться в любой части регулярного выражения. В отличие от других анкеров, после анкера-разделителя можно указать суффикс [согласования](literals.md#soglasovanie). Данное согласование будет выполняться для соседних слов, захваченных по левую и правую сторону анкера. ||

|| <подвыражение> <подвыражение> | Последовательное вхождение - вхождение одного выражения за другим ||

|| <подвыражение> \| <подвыражение> | Альтернативное вхождение - может входить либо одна, либо другая последовательность ||

|| (<подвыражение>) | Простая группировка выражения (используется для изменения приоритета) ||

|| (<> <подвыражение>) | Неименованное захватывающее подвыражение. 

Последовательность слов, захваченная данным подвыражением, может быть получена в результате срабатывания правила по номеру этого подвыражения. Номер подвыражения - это последовательный номер среди всех захватывающих подвыражений, используемых текущим правилом. ||

|| (<идентификатор> <подвыражение>) | Именованное захватывающее подвыражение. 

Последовательность слов, захваченная данным подвыражением, может быть получена в результате срабатывания правила по идентификатору этого подвыражения. ||


|| $<идентификатор> | Использование [определения](rules-remorph.md#opredelenija) с заданным идентификатором в качестве подвыражения ||
|#

В качестве символов регулярного выражения в Remorph-правилах используются [литералы](literals.md).


## Согласование {#soglasovanie}

В Remorph-правилах [согласование](literals.html#soglasovanie) можно задать не только для литералов, но и для [определений](rules-remorph.md#opredelenija). Например, правило

```
rule np_cmplx = $ap#cn(grm) $np#cn(grm);
```

задает согласование между двумя ранее заданными определениями. При этом определение, участвующее в согласовании, должно удовлетворять хотя бы одному из следующих условий:

- Регулярное выражение определения всегда захватывает ровно одно слово.
    
- Если регулярное выражение определения не однозначно, то можно отметить в нем главное слово, которое и будет участвовать в согласовании. При этом главное слово:
    
    - не может участвовать в операторах ?, *, или +.
    
    - не может задаваться более одного раза за исключением альтернатив.
    
    - если участвует в операторе альтернативы, то должно задаваться в каждой ветке альтернативы.
    

Главное слово отмечается суффиксом `#head`, который может быть указан только внутри определения после литерала или после другого вложенного определения.

Пример:
 
```
def np = [? gram=A]* ([? gram=S]#head | [? gram=сокр]#head);
rule np_plus_np = (<first> $np#c(1)) (<second> $np#c(1));
 
```


## О сложности {#oslozhnosti}

Экспоненциальную сложность можно получить на запросе, каждое слово которого входит во все классы, а само выражение представляет собой ИЛИ всех классов, повторяющееся 0 или более раз. Например,

```
rule r = ([a b c] | [a d e] | [a f g])*;
```

на запросе "a a a".


## Дополнительные возможности в колдунщике {#dopolnitelnyevozmozhnostivkoldunshhike}

При использовании Remorph в правилах колдунщика есть возможность ссылаться на результаты работы предыдущих правил колдунщика. Например, в правиле Remorph можно написать условие, которое будет срабатывать на последовательности, выделенной правилом `Fio` или `GeoAddr`. Необходимым условием для этого является, что бы соответствующее правило публиковало свой результат как газетирную статью.

Пример: правило `Date` публикует свои результаты как статью с типом `TOntoResult`.

Для ссылки на такой результат нужно написать в Remorph условие `[?gzt.TOntoResult.Rule = DateTime]`.


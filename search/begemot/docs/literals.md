# Литералы

Основной единицей любых правил Remorph является литерал. Каждый литерал соответствует одному слову или целому классу слов. Данный документ описывает способы описания литералов и особенности их обработки библиотеками Remorph.


## Способы описания литералов {#sposobyopisanijaliteralov}

Следующая таблица описывает способы описания литералов в правилах:

#|

|| **Конструкция** | **Значение** | **Примеры** ||

|| `"<слово>"` | Простой литерал.

Последовательность любых символов, заключенная в кавычки.

Внутри двойных кавычек для задания символа двойных кавычек используется последовательность `\"`.

Соответствует слову, нормализованный текст которого (текст слова с восстановленными диакритиками и приведенный к нижнему регистру) совпадает с указанным. 

| `"weather"``"погода"``"124"``"санкт-петербург"``"."``","` ||

|| `.` | Соответствует любому слову. | ||

|| `[<слово1> <слово2> "<слово3>" ...]` | Задает класс слов.

Соответствует слову, нормализованный текст которого совпадает с любым из перечисленных слов класса.

Каждое слово в классе должно представлять собой последовательность любых алфавитно-цифровых символов, включая национальные, + ASCII-символ дефиса `-`, либо последовательность любых символов, заключенную в кавычки. | `[карта карты схема схемы маршрут маршруты "путь" "пути" "проезд"]` ||

|| `[*<слово1> <слово2> "<слово3>" ...]` | Задает класс лемм.

Соответствует слову, текст леммы которого совпадает с любым из перечисленных слов класса.

Каждое слово в классе должно представлять собой последовательность любых алфавитно-цифровых символов, включая национальные, + ASCII-символ дефиса `-`, либо последовательность любых символов, заключенную в кавычки. | `[*карта схема маршрут "путь" "проезд"]` ||

|| `[%"<имя файла>"]` | Задает класс слов, где список слов класса загружается из указанного файла (UTF-8 без BOM, по одному слову на строку).

Файл ищется относительно директории текущего обрабатываемого файла. | `[%"file1.txt"]` ||

|| `[*%"<имя файла>"]` | Задает класс лемм, где список лемм загружается из указанного файла (UTF-8 без BOM, по одному слову на строку).

Файл ищется относительно директории текущего обрабатываемого файла. | `[*%"file2.txt"]` ||

|| `[?<логическое условие>]` | Задает класс слов с использованием [логического условия](#logicheskoeuslovie). | ||

|#


## Логическое условие {#logicheskoeuslovie}

Каждый литерал может обладать определенным набором атрибутов. Имена атрибутов и их типы являются предопределенными и не могут изменяться.

При описание литерала можно задать одно или несколько условий на атрибуты литералов и таким образом описать необходимый класс слов.

Условие на атрибуты литерала состоит из базовых утверждений вида атрибут = значение и атрибут != значение.

Базовые выражения объединяются оператором & (логическое И), оператором | (логическое ИЛИ) и оператором ! (логическое отрицание).

Круглые скобки позволяют произвольно группировать подвыражения.

Значения атрибутов с пробелами или спецсимволами нужно писать в двойных кавычках:

```
attr="значение"
```

Задать символ двойной кавычки внутри такой записи можно с помощью последовательности `\"`.

Для отдельных типов атрибутов поддерживается использование регулярных выражений:

```
attr=/регулярное выражение/модификаторы
```

Такие регулярные выражения являются Perl-совместимыми и работают над байтами, а не над символами.

Модификаторы - опциональная последовательность символов, обозначающих режим работы с регулярным выражением.

На данный момент единственным поддерживаемым модификатором является модификатор независимости от регистра `i`. То есть `/кошка/i` будет матчить слово "кошка", написанное в любом регистре.

Важно заметить, что для задания полного соответствия регулярного выражения слову необходимо использовать маркеры начала и конца `^` и `$`.

Как и в случае с кавычками, символ косой черты внутри регулярного выражения задается с помощью последовательности `\/`.

Более подробную информацию об использовании регулярных выражений с конкретными типами атрибутов см. в таблице ниже.

Поддерживаются следующие атрибуты:

#|

|| `lang` | Проверка на принадлежность хотя бы одной хорошей словоформы к указанному списку языков.

В качестве значения можно указать буквенные коды языков через запятую, где код языка должен распознаваться функцией `LanguageByName`. ||

|| `qlang` | Проверка языка исходного документа/поискового запроса.

В качестве значения можно указать буквенные коды языков через запятую, где код языка должен распознаваться функцией `LanguageByName`. ||

|| `gzt` | роверка на принадлежность слова к указанной газетирной статье.

Газетирная статья может задаваться как заголовком статьи, так и именем ее типа.

Можно указать список газетирных статей через запятую. В этом случае проверка выполняется на принадлежность слова хотя бы к одной из указанных статей. ||

|| `gzt.<тип>.<атрибут>` | Проверка на наличие статьи с типом <тип> и атрибутом <атрибут>, имеющим указанное значение, заданное в правой части.

Атрибут может быть комплексным, т.е. ссылаться на подполе из вложенного сообщения. В этом случае атрибут задается в виде `<аттрибут>.<под-атрибут>.<под-под-атрибут>` и т.д. ||

|| `gram` | Проверка на наличие указанных грамем у слова. Грамемы задаются списком через запятую. ||

|| `ftext` | Проверка исходного текста слова с присоединенными знаками препинания (full text).

{% note info %}

Для задания значений данного атрибута могут быть использованы регулярные выражения.

{% endnote %} ||

|| `reg``ireg` | Алиасы для `ftext`, автоматически включающие режим регулярных выражений.

Данные атрибуты оставлены для сохранения обратной совместимости со старыми версиями remorph и не рекомендуются к использованию.

- Условие `reg="регуряное выражение"` аналогично условию `ftext=/регулярное выражение/`.
    
- Условие `ireg="регуряное выражение"` аналогично условию `ftext=/регулярное выражение/i`. ||

|| `prop` | Проверка на наличие у слова предопределенных свойств.

Поддерживаемые свойства:

{% note info %}

Можно указать список свойств через запятую. Условие срабатывает, если слово имеет хотя бы одно из указанных свойств.

{% endnote %}


- `mw` - составное слово, состоящее из нескольких слов (как результат работы газетира или дочернего каскадного правила)
    
- `cmp` - составное слово (более общее понятие, нежели `mw`, не обязательно является результатом работы газетира или дочернего каскадного правила)
    
- `cs-lower` - весь текст слова в нижнем регистре
    
- `cs-upper` - весь текст слова в верхнем регистре
    
- `cs-title` - текст слова начинается с заглавной буквы, остальное все в нижнем регистре
    
- `cs-camel` - составное слово, в котором как минимум два слова (включая первое) начинаются с заглавной буквы
    
- `cs-mixed` - слово со смешанной капитализацией текста
    
- `cs-1upper` - слово, начинающееся с заглавной буквы, регистр остальных букв не важен
    
- `alpha` - литерал, который состоит только из букв (обычное слово)
    
- `num` - литерал, который состоит только из цифр (положительное целое число)
    
- `calpha` - литерал (в том числе составной), состоящее из букв (compound alpha)
    
- `cnum` - литерал (в том числе составной), состоящий из цифр (compound num)
    
- `ascii` - литерал состоит только из ASCII-октетов
    
- `nascii` - литерал состоит только из не-ASCII-октетов
    
- `nmtoken` - литерал содержит только буквы и цифры и начинается с буквы
    
- `nutoken` - литерал содержит только буквы и цифры и начинается с цифры
    
- `first` - литерал является первым в предложении (в последовательности символов)
    
- `last` - литерал является последним в предложении (в последовательности символов)
    
- `user` - пользовательское свойство. Может быть вручную установлено на входных символах. ||

|| `lemq` | Проверка на качество леммы.

Возможные значения:

- `good` - лемма из словаря
    
- `bast` - лемма-бастард (не в словаре), леммы с префиксами к бастардам не относятся (см. pref)
    
- `fling` - лемма является непонятным набором букв
    
- `sob` - лемма из быстрого словаря
    
- `fix` - лемма из фикс-листа
    
- `pref` - лемма из словаря + стандартный префикс ||

|#

Пример литерала с логическим условием:

```
[?gram=S,род & gram!=сокр & gzt!=all_street_descr,geo_city,geo_hauptstadt,metro_descr,quater_descr]
[?((gzt="_уличность_0_2") | (gzt=_уличность_0_8) | prop=mw)
  & (gzt=geo_street,geo_pereulok,geo_highway,geo_prospekt,geo_square,geo_proezd,geo_city_toponym,geo_metro,geo_quarter) ];
[?reg="\,"];
[?gram=A,род]? [?gram=A,род]? [?(gram=S,род) & (gram!=сокр) 
  & (gzt!=all_street_descr,geo_city,geo_hauptstadt,metro_descr,quater_descr) ];
[?gzt.TOntoResult.Rule = Fio];
```

Логическое условие может ссылаться на ранее определенное [логические определение](rules-remorph.md#logicheskieopredelenija), используя конструкцию `$<идентификатор определения>`. Такая возможность есть например в [правилах Remorph](rules-remorph.md).

Пример литерала, использующего ранее заданное определение:

```
[?$Noun & gzt!=all_street_descr,geo_city,geo_hauptstadt,metro_descr,quater_descr]
```


## Контекст сопоставления литерала {#kontekstsopostavlenijaliterala}

Некоторые атрибуты литералов (а именно `gram`, `lemq` и `gzt`) содержат множественные значения.

При сопоставлении литерала конкретному слову, условие литерала может сработать только на части значений этих атрибутов. Множество значений, на которых сработало условие, запоминается в специальном контексте сопоставления.

Данный контекст используется, когда для входного слова проверяются дополнительные условия (например согласование). В этому случае проверка выполняется не на всем множестве значений атрибута, а только на подмножестве из контекста. Каждое такое успешное сопоставление обновляет (и соответственно сужает) контекст сопоставления.

С учетом контекста сопоставления следующие два условия работают не эквивалентно:
1. ```
    gzt=geo_street,geo_pereulok,geo_highway
    ```
    
1. ```
    gzt=geo_street | gzt=geo_pereulok | gzt=geo_highway
    ```
    
В первом случае будет проверено наличие всех трех статей у слова и в контекст сопоставления попадут все статьи из указанных, которые присутствуют у слова. Во втором случае проверка остановится после первого истинного условия, и в контекст попадет только первая найденная статья.


## Согласование {#soglasovanie}

Согласование позволяет указать, что два и более литерала, используемые в правиле, должны иметь одинаковое значение указанного атрибута. При этом само значение атрибута не конкретизируется.

Согласование задается специальным суффиксом после литерала в виде `#<тип согласования>(<имя согласования>)`.

На один литерал может быть назначено несколько согласований в виде нескольких подряд идущих суффиксов. Согласование нельзя указать для литерала . (любое слово).

Пример:

```
[?(gram=A | gram=S)]#gnc(gram) [?gram=S]#gnc(gram)#gzt(art) [?gram=S]#gzt(art);
```
Первое сопоставленное слово, участвующее в согласовании, используется как мастер-слово. Все последующие слова, участвующие в согласовании того же типа и имеющие то же имя согласования, сравниваются с мастер-словом.

Согласование по грамматическим атрибутам и газетирным статьям происходит с учетом контекста сопоставления литералов - для сравнения выбираются только подмножества значений из контекста. Для выбранных подмножеств значений мастер-слова и проверяемого слова ищется пересечение, и если оно не пустое, то согласование успешно.

Найденное пересечение сохраняется в контекстах сопоставления обоих слов. Таким образом, исключается ситуация, когда первое и второе слово согласуется по одному значению, первое и третье - по другому значению, а второе и третье не согласуются между собой.

Поддерживаются следующие типы согласования:

#|
|| `c` | Согласование по падежу ||

|| `n` | Согласование по грамматическому числу ||

|| `t` | Согласование по грамматическому времени ||

|| `cn` | Согласование по падежу и числу ||

|| `cfp` | Согласование по падежу + первое слово во множественном числе ||

|| `gn` | Согласование по роду и числу ||

|| `gc` | Согласование по роду и падежу ||

|| `pn` | Согласование по лицу и числу ||

|| `gnc` | Согласование по роду, числу и падежу ||

|| `gzt` | Все согласуемые слова должны иметь хотя бы одну газетирную статью совпадающую по заголовку или типу ||

|| `gztid` | Все согласуемые слова должны иметь хотя бы одну одинаковую газетирную статью ||

|| `geogzt` | Все согласуемые слова должны иметь газетирные статьи, принадлежащие одной ветке гео-онтологии ||

|| `distN` | Согласование по расстояниям. 

Все согласующиеся слова должны находиться друг от друга на расстоянии не более чем N слов (т.е. между ними может быть не более, чем N-1 слов).

В качестве N можно указать любое неотрицательно целое число. Если N опущено, то используется расстояние 1 (согласуемые слова должны быть непосредственными соседями).

Пример:

`[?gzt=geo]#dist(geoctx)` (расстояние не более одного слова),

`[?gzt=geo]#dist3(geoctx)` (расстояние не более 3-х слов) ||

|| `txt` | Согласование по нормализованному тексту слов ||
|#

Перед каждым типом согласования можно указать префикс `no-`, что равносильно отрицанию согласования.

Например, можно указать тип согласования `#no-gnc` для слов, которые не должны согласовываться между собой по роду, числу или падежу.

Пример:

```
[?gram=A]#no-gzt(1) [?gram=S]#no-gzt(1);
```

Имя согласования представляет собой любой идентификатор. Оно позволяет различать группы согласующихся слов, которые согласуются по одним и тем же атрибутам, но группы целиком не должны согласовываться между собой.

Примеры правил Remorph:

```
rule complex1 = (<geo1> [?gram=S]#gzt(geo1) [?gram=S]#gzt(geo1)) (<geo2> [?gram=S]#gzt(geo2) [?gram=S]#gzt(geo2));
```

Правило выделяет две группы, каждая из которых должна ссылаться на одинаковую газетирную статью, но обе группы могут ссылаться на разные статьи.

```
rule complex2 = (<geo1> [?gram=S]#gzt(geo1)#no-gzt(neg) [?gram=S]#gzt(geo1)) (<geo2> [?gram=S]#gzt(geo2)#no-gzt(neg) [?gram=S]#gzt(geo2));
```

Модификация предыдущего правила, которое срабатывает, если группы ссылаются на разные газетирные статьи.


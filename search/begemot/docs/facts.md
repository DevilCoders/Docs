# Факты


## Общее описание {#obshheeopisanie}

Факты описываются в файле формата `protobuf` и должны соответствовать синтаксису protobuf. Описание синтаксиса protobuf можно прочитать [здесь](https://code.google.com/p/protobuf/).

Файл описания фактов должен импортировать файл `factmeta.proto`, который описывает специальные опции, специфичные для remorph. Этот файл встроен в библиотеку и его содержимое всегда доступно для импорта, поэтому в директиве `import` нужно указывать этот файл без абсолютных/относительных путей.

Каждый тип факта описывается как тип protobuf-сообщения. Все факты должны быть описаны внутри пакета . Типы, описанные в других пакетах, игнорируются.

Имя типа сообщения соответствует имени факта. Поля типа сообщения соответствуют полям факта.

Флаг `repeated` можно указывать для всех полей, кроме `bool`.

Поддерживаются строковые и булевские типы полей и поля-сообщения. Остальные поля недопустимы.

Пример описания факта:

```
import "factmeta.proto";
package NFact;
message Addr
{
  option (matcher) = "rules.remorph";
  option (matcher_type) = REMORPH;
  option (search_type) = SEARCH_ALL;
  option (gazetteer) = "main.gzt.bin";
  required string  addr = 1 [(prime) = true];
  optional string  numbers = 2;
  optional string  city = 3 [(norm) = NOMINATIVE, (text_case) = CAMEL];
  optional string  q_descr = 4;
  optional string  descr = 5;
  optional string  m_descr = 6;
  optional string  street = 7;
  optional string  metro = 8;
}
```


## Трансляция результатов в факты {#transljacijarezultatovvfakty}


### Правила Remorph и Char {#pravilaremorphichar}

Результаты Remorph- и Char-правил транслируются в факты следующим образом.

Для каждого именованного захватывающего выражения заполняется поле факта с таким же именем, если оно есть. Остальные захватывающие выражения игнорируются.

Для строкового поля значение записывается как есть.

Для булевского поля выставляется значение true, если результат содержит непустую строку. Если заполнены все обязательные поля факта, то факт пишется в результат.


### Правила TokenLogic {#pravilatokenlogic}

Результаты TokenLogic-правил транслируются аналогично правилам Remorph, только вместо именованных захватывающих выражений используются именованные токены.

Для каждого именованного токена заполняется поле факта с таким же именем, если оно есть. Остальные захватывающие токены игнорируются.

Для строкового поля значение записывается как есть.

Для булевского поля выставляется значение true, если результат содержит непустую строку. Если заполнены все обязательные поля факта, то факт пишется в результат.


## Примеры использования {#primeryispolzovanija}

В качестве примера будем рассматривать Remorph-правило, выделяющее адреса в тексте. С помощью данного правила мы хотим выделить все встречающиеся названия улиц в тексте. Для этих целей создаем следующее описание факта:

```
import "factmeta.proto";
package NFact;
message Street
{
  option (matcher) = "addr.rules.remorph.bin";
  option (matcher_type) = REMORPH;
  option (search_type) = SEARCH_ALL;
  option (gazetteer) = "main.gzt.bin";
  reqired string  street = 1;
}
```

Данное описание указывает Remorph-правило и словарь газетира, которые должны использоваться. Опция `option (search_type) = SEARCH_ALL` задает, что поиск будет выполняться с любой позиции предложения (в отличии от `option (search_type) = MATCH_ALL`, когда правило сопоставляется только с начала предложения).

Данный факт будет содержать только одно поле, которое извлекается из одноименного захватывающего выражения `street`.

Поскольку поле `street` указано как `required`, то все адреса без указания улиц будут игнорироваться.

Если мы хотим, что бы в факт попадали еще и номера домов, то просто добавляем новое поле:

```
...
message Street
{
  ...
  reqired string  street = 1;
  optional string number = 2;
}
```

Поле `number` указано как необязательное, поэтому оно может отсутствовать в некоторых фактах.

Если захватывающе выражение номера дома имеет другое имя (например, `str_numbers`), а мы хотим что бы в факте номер дома присутствовал под меткой `number`, то через опции полей задаем альтернативное имя поля:

```
...
message Street
{
  ...
  reqired string  street = 1;
  optional string number = 2 [(origin) = "str_numbers"];
}
```

Название улицы в тексте может встречаться в произвольном падеже и регистре. При извлечении соответствующего поля факта мы можем задать его нормализацию, как по грамматической форме, так и по регистру:

```
...
message Street
{
  ...
  reqired string  street = 1 [(norm) = NOMINATIVE, (text_case) = TITLE];
  ...
}
```

Если нас интересует только наличие какого-либо захватывающего выражения, но не важно его значение, то можно объявить в факте поле булевского типа. Данное поле будет принимать значение `true`, если захватывающее выражение есть в найденном факте. Например, для адреса нам может быть интересно, употреблялся ли данный адрес с предлогом:

```
...
message Street
{
  ...
  reqired string  street = 1 [(norm) = NOMINATIVE, (text_case) = TITLE];
  reqired bool with_prep = 2 [default = false, (origin) = "prep"];
  ...
}
```

По умолчанию, границы факта в предложении определяются границами сработавшего правила Remorph.

Если из адреса нас интересуют только название улицы и номера домов, и мы хотим выделять границы только по этим двум полям, то с помощью опции `prime` мы можем переопределить границы факта. Наличие хотя бы одного поля с флагом `prime` задает границы факта только в пределах границ всех найденных `prime`-полей.

В приведенном ниже примере границей факта будет только найденная улица и номер дома при его наличии:

```
...
message Street
{
  ...
  reqired string  street = 1 [(prime) = true, (norm) = NOMINATIVE, (text_case) = TITLE];
  optional string number = 2 [(prime) = true];
  reqired bool with_prep = 3 [default = false, (origin) = "prep"];
}
```

Если Remorph-правило использует другие каскадные правила, то нам могут быть интересны захватывающие выражения дочерних правил. Для их извлечения необходимо описать поля факта как вложенные сообщения.

Например, у нас есть каскадное правило, которое ищет конструкции типа `"проезд от <адрес1> до <адрес2>"`.

`<адрес1>` и `<адрес2>` помечены захватывающими выражениями `from` и `to` соответственно. Поиск `<адрес1>` и `<адрес2>` осуществляется с помощью вложенного дочернего правила. Нам необходимо извлечь улицу и дом обоих найденных адресов.

Описание факта будет выглядеть следующим образом:

```
import "factmeta.proto";
package NFact;
message Track
{
    option (matcher) = "track.remorph";
    option (matcher_type) = REMORPH;
    option (search_type) = SEARCH_ALL;
    option (gazetteer) = "main.gzt.bin";
    message Addr
    {
        reqired string  street = 1 [(norm) = NOMINATIVE, (text_case) = TITLE];
        optional string number = 2;
    }
    required Addr from = 1 [(prime) = true];
    required Addr to = 2 [(prime) = true];
}
```

Оба поля `from` и `to` здесь описаны как сообщения с типом `Addr`. Для полей `Addr` мы можем задавать дополнительные опции точно также, как и для основных полей.

Поля-сообщения могут быть указаны как `repeated` (что запрещено для обычных полей). Если захватывающее выражение поля покрывает несколько результатов дочерних правил, то все они будут записаны в коллекцию сообщений данного поля.

Для `required` и `optional` полей используется только последний результат захватывающего выражения.

В приведенном выше примере оба адреса можно записать в одно поле следующим описанием:

```
...
message Track
{
    ...
    message Addr
    {
        ...
    }
    required Addr from = 1 [(prime) = true, (origin) = "to"];
}
```

Альтернативно можно поменять в правиле захватывающее выражение, что бы оно покрывало оба адреса.

Для описания поля сообщения можно использовать также ранее описанный факт:

```
import "factmeta.proto";
package NFact;
message Addr
{
    option (matcher) = "rules.remorph";
    option (matcher_type) = REMORPH;
    option (search_type) = SEARCH_ALL;
    option (gazetteer) = "main.gzt.bin";
    reqired string  street = 1 [(prime) = true, (norm) = NOMINATIVE, (text_case) = TITLE];
    optional string number = 2 [(prime) = true];
}
message Track
{
    option (matcher) = "track.remorph";
    option (matcher_type) = REMORPH;
    option (search_type) = SEARCH_ALL;
    option (gazetteer) = "main.gzt.bin";
    required Addr from = 1 [(prime) = true];
    required Addr to = 2 [(prime) = true];
}
```


## Описание опций расширения {#opisanieopcijjrasshirenija}

Все опции фактов указываются либо как расширенные опции типов, либо как расширенные опции полей. В соответствии с синтаксисом protobuf, имена расширенных опций должны указываться в круглых скобках.


### Опции фактов (protobuf-типов) {#opciifaktovprotobuf-tipov}

#|
|| **Опция** | **Тип** | **Значение по умолчанию** | **Описание** ||

|| matcher | строка | | Путь к файлу с правилами матчера, которые используются для поиска данного факта.

Относительный путь разрешается относительно файла описания фактов.

Данная опция обязательна. ||

|| matcher_type | энумератор со значениями:
- `REMORPH`
    
- `TOKENLOGIC`
    
- `CHAR` | `REMORPH` | Тип используемого матчера. ||

|| gazetteer | строка | | Путь к файлу газетирного словаря.

Относительный путь разрешается относительно файла описания фактов.

Данная опция обязательна, если правила ссылаются на газетирные статьи. ||

|| ambig_gazetteer | булевский | true | Будет сниматься омонимия газетирных статей или поиск будет выполняться по всем вариантам.

По умолчанию поиск идет по всем вариантам. ||

|| gazetteer_rank_method | строка | `"greater-coverage,less-count,greater-weight"` | [Метод ранжирования](coverage-ranking.md) покрытий при снятии омонимии газетирный статей. ||

|| ambig_cascade | булевский | true | Будет сниматься омонимия результатов каскадных правил или поиск будет выполняться по всем вариантам. По умолчанию поиск идет по всем вариантам.

Данный флаг управляет омонимичностью результатов подкаскадов корневого правила.

Омонимичность результатов подкаскадов второго уровня и глубже управляется соответствующими флагами [газетирных статей](cascades.md). ||

|| cascade_rank_method | строка | `"greater-coverage,less-count,greater-weight"`| [Метод ранжирования](coverage-ranking.md) покрытий при снятии омонимии результатов каскадных правил. ||

|| search_type | энумератор со значениями:
- `SEARCH_ALL`
    
- `MATCH_ALL`
    
- `SEARCH_FIRST`
    
- `MATCH_FIRST` | `SEARCH_ALL` | Задает метод сопоставления правил. ||

|| filter | строка | | Задает [логическое условие на литералы](literals.md), исполнение которого хотя бы для одного слова в предложении обязательно для применения правил.

Остальные предложения игнорируются. ||

|| dominants | строка | | Список газетирных статей (имен типов или заголовков), которые всегда участвуют в поиске, если они присутствуют в предложении.

Другие статьи, которые содержаться внутри данных или пересекаются с ними, игнорируются и не образуют альтернативных вариантов поиска.

Список может задаваться через запятую, точку с запятой или пробел. Заданые здесь доминанты действуют как для газетира, так и для всех каскадных правил ||
|#


### Опции полей фактов {#opciipolejjfaktov}

#|
|| **Опция** | **Тип** | **Значение по умолчанию** | **Описание** ||

|| origin | строка | | Позволяет использовать для поля факта имя, отличное от имени захватывающего выражения. В опции `origin` в этом случае указывается имя захватывающего выражения. ||

|| text_case | энумератор со значениями:
- `AS_IS`
    
- `TITLE`
    
- `CAMEL`
    
- `UPPER`
    
- `LOWER` | `AS_IS` | Задает способ капитализации текста поля.

По умолчанию значение поля записывается как есть.

Можно указать следующие способы изменения капитализации:
- `TITLE` - капитализация первого символа первого слова;
    
- `CAMEL` - капитализация первого символа каждого слов;
    
- `UPPER` - капитализация всего текста;
    
- `LOWER` - приведение всего текста к нижнему регистру. ||

|| norm | энумератор со значениями:
- `NONE`
    
- `NOMINATIVE`
    
- `GAZETTEER`
    
- `LEMMER` | NONE | Задает способ нормализации текста поля.

По умолчанию текст поля не нормализуется. Можно указать следующие способы нормализации: 
- `NOMINATIVE` - приведение текста к именительному падежу единственного числа;
    
- `GAZETTEER` - использование текста леммы, указанного в соответствующей газетирной статье. Если есть несколько вариантов лемм и поле задано как `repeated`, то будут сохранены все варианты.
    
- `LEMMER` - использование нормализованного текста из леммера. ||

|| prime | булевский | false | Маркер основного поля факта.

Если факт имеет хотя бы одно основное поле, то позиция факта (и его приоритет) вычисляется по позиции основных полей, а не по позиции всего сопоставления правила. ||

|| head | int32 | | Маркер главного слова.

Данный маркер используется для полей, которые участвуют в вычислении главного слова факта.

Если в факте данным маркером помечено несколько полей, то будет использоваться поле, присутствующее в факте, и определенное ранее в списке полей факта.

Если поле повторяющееся и содержит несколько значений, то выбирается значение поля в зависимости от значения маркера - для нулевого или положительного значения маркера выбирается первое встретившееся в предложении значение поля, а для отрицательного - последнее.

Если в факте нет полей, помеченных маркером head, то по умолчанию главным считается первое слово факта.

Значение маркера используется для выбора главного слова, если поле покрывает несколько слов. 0 задает использование первого слова поля, 1 - второго и т.д.

Отрицательное значение определяет выбор слова с конца: -1 задает использование последнего слова поля, -2 - предпоследнего и т.д.

Если вычисленное главное слово факта является составным символом (собрано каскадом), то вместо него используется главное слово составного символа.

Сложные поля факта могут иметь свои главные слова. Механизм выбора главного слова сложного поля точно такой же, как и для факта, за исключением того, что по умолчанию используется главное слово составного символа, который используется для заполнения под-полей. ||
|#

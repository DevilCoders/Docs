# alien

Библиотека для типобезопасной работы с прямым доступом к памяти через примитивы [JEP-370](https://openjdk.java.net/jeps/370).

Документация в разработке, но можно посмотреть [пример](examples/src/main/scala/example/ZioExample.scala).

## Основные понятия
### Layout
**Layout** - описание схемы данных, хранящихся в памяти. В основе лежит `jdk.incubator.foreign.MemoryLayout`. 
Например, некоторые данные представляют собой массив целых чисел размера `N` и два числа с плавающей точкой.

Схема собирается из кирпичиков:
- [Value](memory/src/main/scala/alien/memory/Value.scala) - элементарный слой для целых чисел, символов и т.д., актуальный список в `alien.memory.Values`
  ```scala
  val a = Values.Long //  слой под Long значения
  ```
- [Sequence](memory/src/main/scala/alien/memory/Sequence.scala): BoundedSequence и UnboundedSequence - контейнер для последовательности данных одного типа.
  Упрощенно можно собирать последовательности с помощью оператора `*`, это повышает читабельность для матриц. 
  ```scala
  val a = Values.Long * 2 * 5 // матрица с 5 строчками и 2 столбцами 
  ```
- [Aligned](memory/src/main/scala/alien/memory/Aligned.scala) - контейнер группы данных, который задает выравнивание в байтах для нижележащих данных.
- [Padding](memory/src/main/scala/alien/memory/Padding.scala) - "пробел" в памяти. В нем не хранятся данные, добавляет смещение в байтах перед нижележащим элементом.
- [Dynamic](memory/src/main/scala/alien/memory/DynamicLayout.scala) - контейнер группы данных. В JEP выделяют два типа: структуры и объединения. 
  Например, описываем массив целых чисел размера `N` и массив чисел с плавающей точкой размера`M`.
  
  **[Структуры](https://ru.wikipedia.org/wiki/Структура_(язык_Си))** записывают в память данные первого массива(заполняют `N * jl.Integer.SIZE` байтов) и сразу же 
  после записывают в память данные второго массива(заполняют `M * jl.Float.SIZE` байтов). 
  
  **[Объединения](https://ru.wikipedia.org/wiki/Объединение_(структура_данных))** же определяют max_size = MAX(`N * jl.Integer.SIZE` и `M * jl.Float.SIZE`) и выделяют max_size памяти под группу.
  Записать в объединение можно либо данные с Int, либо с Float. Объединение можно сравнить с различными VIEW над одной таблицей. 
  
  В alien для конструирования групп используются операторы (точнее, специальным образом названные case class'ы, мимикрирующие под операторы):
  - для объединений:
    
    `<>` - инициализация объединения: переданный в такой конструктор Layout теперь считается объединением, его можно присоединять к другим объединениям
    
    `<>:` - дополнение текущего объединения другим объединением
  - для структур: 
  
    `>>`  - инициализация структуры: переданный в такой конструктор Layout теперь считается структурой, ее можно присоединять к другим структурам
  
    `>>:` - дополнение текущей структуры другой структурой

   Части структур и объединений можно **именовать** с помощью оператора `:=`.
  **Пример**: 
  ```scala
  val a = "matrix"  := Values.Long * 7 * 2 // матрица с именем matrix
  val b = "array" := Values.Long * 5 // массив с именем array
  val memoryL: ("matrix" := BoundedSequence[BoundedSequence[Value[Long]]]) >>:
  (>>["array" := BoundedSequence[Value[Long]]]) = a >>: b // структура из матрицы и массива
  ```

### [Path](memory/src/main/scala/alien/memory/Path.scala)
Используется для навигации по сложной структуре данных, описанных через Layout. 
Начинается с корневого Layout. Углубляемся внутрь через оператор `/`. 
Далее допустимые термы:

| терм         | применим на Layout | куда углубляемся             |
|:------------:|:------------------:|:----------------------------:|
|"_<имя слоя>_"| Dynamic            |в слой с этим именем          |
|      i       | Sequence           |в i-й элемент последовательности  |
|(n, m)        | Sequence           |в подмножество элементов, а именно начиная с элемента n, далее каждый m-ный элемент |
|`%`           | Sequence           |в каждый из элементов последовательности |
|`$`           | Value              |никуда, конечный терм         |

**Примеры**:
```scala
val matrixVH = otherL / % / % / $ // слой - матрица, не усложненная структурами
val matrix  = memoryL / "bitmap" / % / % / $
val array = memoryL / "nonnull" / % / $ 
val oneElement = memoryL / "bitmap" / 1 / 0 / $
```

### [Memory](memory/src/main/scala/alien/memory/Memory.scala)
**Memory** - обертка над `jdk.incubator.foreign.MemorySegment`
Позволяет выделять off-heap память для массивов примитивов, байт-буфферов и схем данных, описанных через Layout.

Всегда ассоциирована с определенным Layout.

Внутренний класс `Memory.Ops` предоставляет общие методы для манипулирования записанными данными. 

Методы для записи/чтения конкретной группы данных находятся в сгенеренных трейтах `OpsN` с реализациями под каждый 
примитивный тип `*OpsN`. Так, для чтения из массива i-го элемента используем 
```Ops1.get(memoryWithArray) (i)```, а  для матрицы, у которой на одно измерение больше, -  ```Ops2.get(memoryWithArray) (i, j)```.


## Использование:
Подключить библиотеку в build.sbt
```sbt
libraryDependencies += "com.yandex" %% "alien-core" % "0.1.0-M8"
```

## Публикация новой версии:
1. Обновить версию `ThisBuild / version` в файле `build.sbt`
2. Закоммитить новую версию в репозиторий 
3. ```sbt clean compile package publish```
4. Проверить что новая версия попала в `artifactory`.  
Пример для версии релизной версии [0.1.0-M8](http://artifactory.yandex.net/artifactory/yandex_vertis_releases/com/yandex/alien-core_2.13/0.1.0-M8/).   
Пример для снапшотной версии [0.0.10-SNAPSHOT](http://artifactory.yandex.net/artifactory/yandex_vertis_snapshots/com/yandex/alien-core_2.13/0.0.10-SNAPSHOT/)

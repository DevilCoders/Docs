# Индекс первичного ключа (Primary Index)

[Первичный ключ](glossary.md#pk) (***primary key***, ***pk***) уникален для каждого 
из [документов](glossary.md#document) в рамках одной [базы данных](glossary.md#database).

Тип первичного ключа должен быть совместим с `scandex.db.index.values.ValueIndex`
Допустимые для первичного ключа типы перечислены в [соответствующей таблице](glossary.md#types), однако, рекомендованным
типом для первичного ключа является `Long`.

С помощью первичного ключа определяется, какой [шард](glossary.md#shard) будет использоваться. Номер шарда вычисляется
как остаток от деления pk.hashcode() на количество шардов в системе. В рамках каждого из шардов используется свой 
индекс, хранящий первичные ключи, используемые лишь в данном шарде. 

Индекс первичного ключа должен выполнять три операции:
- получение порядкового номера значения первичного ключа
- получение первичного ключа по порядковому номеру значения
- добавление нового ключа в индекс с получением его порядкового номера
```scala
trait PrimaryIndex[PK] {
  def getDocumentId(pk: PK): DocumentId
  def getPrimaryKey(id: DocumentId): PK
} 
```

## Внутреннее устройство различных реализаций 

### IntegralPrimaryIndex

Реализация, в которой первичный ключ имеет целочисленный тип данных.

Содержит в себе три сегмента: 
- [Набор значений (кодификатор)](glossary.md#segment-values) - массив хранящий в себе все ключи (`PK`) в порядке их возрастания.
Индекс в массиве - `ValueIdx`.
- [Инвертированный индекс](glossary.md#segment-posting-list) - массив хранящий в себе `DocumentId`. Индекс в массиве - `ValueIdx`.
- [Прямой индекс](glossary.md#segment-forward) - массив хранящий в себе `ValueIdx`. Индекс в массиве - `DocumentId`.

Операция `getDocumentId` реализуется с помощью бинарного поиска в наборе значений, после чего берется его значение
по смещению в инвертированном индексе.

Операция `getPrimaryKey` реализуется с помощью взятия значения по смещению из прямого индекса, после чего
берется значение первичного ключа из набора значений.

- Набор значений реализован с помощью `Memory` со структурой `Sequence[Value[PKType]]` размером `N * sizeOf(PrimaryKeyType)`
- Прямой и обратный индексы реализованы с помощью `Memory` размером [`N * cardinality(N)`](glossary.md#log-size-of)

где N - количество первичных ключей, зарегистрированных в индексе

Сериализация будет осуществляться традиционным для индекса способом:
- Заголовок
- Сегмент набора значений
- Сегмент прямого индекса
- Сегмент инвертированного индекса

Заголовок будет содержать тип ключа и N (количество сохраненных ключей):

```proto
message IntegralPrimaryIndexHeader {
  enum PrimaryKeyType {
    BYTE = 0;
    SHORT = 1;
    INT = 2;
    LONG = 3;
  }

  enum ByteOrdering {
    BIG_ENDIAN = 0;
    LITTLE_ENDIAN = 1;
  }
  
  ByteOrdering byte_order = 1;
  PrimaryKeyType pk_type = 2;
  Long N = 3;

}
```
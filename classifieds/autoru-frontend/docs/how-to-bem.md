# Как работать с BEM'ом

Весь новый код в Авто.ру пишется на React'е, но есть еще какое-то количество старого кода,
который написан на bem-технологиях. Этот код регулярно выпиливается и заменяется на новый-кленовый,
но какое-то время мы еще будем наслаждаться всем этим великолепием.

Так что нужна краткая инструкция, как не сойти с ума.

В BEM'е все состоит из блоков. Блоки у нас находятся в нескольких блокохранилищах:

    auto-core/blocks/
    www-desktop/blocks/
    www-mobile/blocks/
    ...

В `auto-core/blocks` лежат блоки, которые могут быть использованы в нескольких проектах плюс
в каждом проекте есть специфичные блоки.

## Структура блока

Здесь `foo` — название блока.

    blocks/
        foo/
            foo.deps.js
            foo.priv.js
            foo.bh.js
            foo.js
            foo.styl

`foo.deps.js` — это список других блоков, которые использует блок `foo`.
`foo.priv.js` и `foo.bh.js` — отвечают за шаблонизацию (т.е. генерацию html'я) на сервере (на клиенте html не генерится никак).
`foo.js` — клиентский код, выполняющийся в браузере (всякие там обработчики событий и т.д.).
`foo.styl` — стили блока на Stylus'е.

Еще в папке `foo` могут быть папки с элементами (например, `__title`) и с модификаторами (например, `_color`).
Но про это в другой раз.

## `foo.deps.js`

Если блок `foo` использует как-то внутри себя блок `bar`, то нужно в `foo.deps.js` написать что-то такое:

```js
({
    shouldDeps: [
        { block: 'bar' },
    ],
});
```

И наоборот. Если мы добавляем новый блок `foo`, то нужно убедиться, что кто-нибудь про него знает,
чтобы он попал в собранный бандл. Как правило, нужно добавить его в один из страничных deps'ов. Например:

    www-desktop/blocks/page/_type/page_type_sale.deps.js

Здесь `_type` — это модификатор страницы под названием `type`, а `page_type_sale` — блок `page` с модификатором `type`,
у которого значение `sale` (это карточка объявления, например).


## `foo.priv.js` и `foo.bh.js`

Эти файлы отвечают за формирование html'я блока.
`bh` мы используем очень редко, как правило достаточно одного лишь priv'а.

### `foo.priv.js`

Внутри priv-файлов можно использовать несколько глобальных переменных:

`blocks` — сюда мы добавляем код для блока.

`data` – здесь хранится все данные, полученные для этой страницы.
На bem-страницах можно добавить в урл параметр `&__raw` и посмотреть прямо в браузере всю data
(на самом деле не всю, так как там еще есть много разных методов и прочего несериализуемого мусора).

Мы должны создать функцию, которая вернет bem-дерево (BEMJSON) -- это просто js-объекты
определенной структуры:

```js
(function() {

    blocks['foo'] = function() {
        return {
            block: 'foo',
            js: {
                id: data.id,
            },
            mods: {
                color: 'red',
            },
            content: [
                {
                    //  В данном случае следующая строчка не нужна.
                    //  Так как выше у нас задан block.
                    //  Но в ситации, когда внутри блока foo есть блок bar, а внутри него
                    //  мы хотим вывести элемент foo, вот тогда таки нужно задавать имя блока явно.
                    //
                    //  block: 'foo'
                    elem: 'title',
                    content: data.title,
                },
                {
                    // если нам нужно сформировать конкретный html,
                    // мы можем описать его следующим образом
                    block: 'link',
                    tag: 'a',
                    attrs: {
                        href: data.url,
                        target: '_blank',
                    },
                    content: data.text,
                },
                ...
            ],
        };
    };

})();
```

Дальше это дерево сериализуется в html по довольно простым правилам:

  * Блок с именем `foo` сериализуется в `div` (по-дефолту,
    можно изменить это при помощи bh, но, как правило, не нужно, так как описать несложный html можно и прямо в priv):

        <div class="foo">
            <!-- content -->
        </div>

  * Если у блока были модификаторы, они добавляются в `class`:

        <div class="foo foo_color_red">
            <!-- content -->
        </div>

  * Элементы блока сериализуются аналогично, только имя класса меняется:

        <div class="foo__title">Заголовок</div>

  * Содержимое поля `content` рекурсивно сериализуется и вставляется внутрь блока:

        <div class="foo foo_color_red">
            <div class="foo__title">Заголовок</div>
            ...
        </div>
  * Дефолтные теги заменяются на указанные, проставляются атрибуты:

        <div class="foo foo_color_red">
            <div class="foo__title">Заголовок</div>
            <a href="https://yandex.ru" target="_blank">Yandex</a>
            ...
        </div>

Параметр `js` у блока отвечает за то, будет ли выполнен клиентский код блока (расположенный в `foo.js`).
Если передать туда объект, то он будет доступен как `this.params` в клиентском коде блока.
Кроме того, можно написать просто `js: true`, если никаких параметров у блока нет.
Не забывайте, что этот объект с параметрами сериализуется в html, так что не нужно туда передавать гигантских структур,
а так же несериализуемых данных.

Если к урлу bem-страницы добавить `&__bemjson`, то можно увидеть, что получилось на выходе после priv'ов (и до сериализации).

[Документация по BEMJSON](https://en.bem.info/platform/bemjson/).


### `foo.bh.js`

Как правило priv'ов вполне достаточно, чтобы сгенерировать нужный html блока.
Но если нужно что-то более сложное, то есть дополнительный слой шаблонизации — BH.

```js
module.exports = function(bh) {

    //  Это правило не нужно, так как тег по-дефолту как раз div.
    bh.match('foo', function(ctx) {
        ctx.tag('div');
    });

    bh.match('foo__title', function(ctx) {
        //  Меняем тег элемента title на span.
        ctx.tag('span');
    });
};
```

Менять теги обычно смысла нет, все можно разрулить css'ом.

Документация про [BH](https://github.com/bem/bh).


## `foo.js`

Самая эзотерическая часть bem'а: i-bem

```js
modules.define(
    'foo',

    [ 'i-bem__dom' ],
    function(provide, BemDom) {

    /*
    //  Можно добавить каких-то еще дополнительных модулей.
    //  Например, здесь помимо обязательного i-bem__dom добавляется:
    //
    //      gate-api -- для ajax-запросов
    //      metrika  -- для работы с метрикой
    //      cookie   -- для работы с куками
    //
    [ 'i-bem__dom', 'gate-api', 'metrika', 'cookie' ],
    function(provide, BemDom, gateApi, Metrika, cookie) {
    */

        provide(BemDom.decl(this.name, {
            onSetMod: {
                js: {
                    inited: function() {
                        //  Это по сути конструктор.
                        //  Здесь можно всякую инициализацию делать.
                        ...
                    },
                },
            },

            onTitleClick: function(e) {
                ...
            },

        }, {
            live: function() {
                //  Навешиваем событие click на элемент title.
                this.liveBindTo('title', 'click', this.prototype.onTitleClick);

                return true;
            },
        }));
    }
);
```

На самом деле никто не умеет программировать на i-bem, так что единственный способ — копи-паст из соседних блоков.

[Документация по i-bem](https://en.bem.info/platform/i-bem/). Кажется, что английская версия более актуальная.


## Как собирать

Для bem-части нет отдельного сборщика, поэтому, как правило, нужно собирать все вообще:

    make

Инкрементальной сборки тоже нет, так что пересборка занимает прилично времени.
Если меняется только bem-код, то можно попробовать сделать так:

    cd www-desktop
    /opt/nodejs/14/bin/node ../node_modules/.bin/enb make

По неизвестным мне причинам, эта команда иногда валится и спасает потом только полная пересборка (`make`).
Но если она таки отрабатывает, то делает это сильно быстрее, чем `make`.

Если вы правите только клиентский код `foo.js` и `foo.styl`, то сборка не нужна вообще, эти файлы пересобираются на лету,
при запросе из браузера.


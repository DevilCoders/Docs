# Как правильно выбирать timeout для запросов в бекенды

## Зачем это надо и почему очень важно?

Node.js - это event loop и один воркер одновременно обрабатывает много запросов.
Все запросы ждут обработки в очереди.
Если запросов в очереди станет очень много, то это приведет к большому потреблению памяти и процессора.
Нода будет много времени и ресурсов тратить на обработку очереди.
В итоге, event loop не будет в нужное время добираться до обработки http-запросов в бекенды, они все начнут таймаутится и нода фактически превратится в тыкву.

Как этого избежать? Правильно подбирать таймауты для бекендов в общем и конкретных ручек в частности!
Т.о. медленный бекенд будет отстреливаться по таймауту,
что будет приводить к завершению обработчки входящего запроса и рассасыванию очереди.

Важно понимать, что лучше нода будет работать, писать в логи про медленные бекенды и отвечать 500, чем превратится в тыкву и не будет отвечать совсем.

## Как правильно подобрать таймаут?

У нас есть два вида таймаутов:
1) На весь ресурс, задается в конфигах. Он должен быть небольшим, лучше для конкретных медленных ручек поставить высокие таймауты.
2) На конкретную ручку. Задается в декларации ручек.

**Советы по выбору:**
1) Лучше отстреливать ручки по таймауту и деградировать сервис, чем иметь лежащий фронт
1) Если ручка или бекенд новый, то надо спросить разработчиков про тайминги.
Если точных чисел нет, то лучше поставить 500мс, а после выкатки проставить реальные таймауты.
0) Если кто-то просит поставить таймаут ручки больше 1с, надо 100 раз подумать про вышеуказзаные проблемы.
Для высоконагруженных ручек такой таймаут недопустим в принципе, потому что тормозящий бекенд завалит за собой весь фронт.
1) Высоконагруженным ручкам желательно иметь таймаут не больше 500мс, лучше еще меньше (100-200мс).
Особенно это касается ручек, которые вызываются на каждой странице (авторизация, инфа про дилера, количество новых сообщений)
2) Лучше подбирать индвидуальные таймауты для ручек, чем надеяться на общий таймаут ресурса
1) Если ручка отвечает быстро, но бекенд может иногда тупить (например, GC в случае Java-приложений), то лучше сделать маленький таймаут + ретрай.
1) Полезно смотреть на трейсы в [jaeger](https://jaeger.vertis.yandex.net/search/), чтобы находить медленные ручки и зарезать им таймауты. Можно искать по request_id ([пример](https://jaeger.vertis.yandex.net/trace/a0d8d6ae3625abcf2ce68f85d66bfad9))

## Нужен ли перезапрос?

В общем виде перезапрос нужен только для запросов на чтение (обычно это GET).
Но не надо делать его везде, это должно быть осознанное и взвешанное решение.
Очень важно понимать, что **перезапрос спасает от неответов и деградации сервиса за счет увеличения времени ответа**(см. почему важны таймауты).

Неважные ручки, без которых можно успешно сдеградировать (например, провязки на карточке или в листинге), лучше не ретраить совсем.
Важные нагруженные ручки (например, авторизация, поиск) лучше ретраить по схеме "маленький таймаут + перезапрос",
чтобы не сильно увеличивать время ответа.

Если время ответа или поведение ручки все равно не устраивает, надо разговаривать с бекендом. Всегда можно что-то сделать.

Если ручка меняет данные, то при перезапросе легко нарваться на неконсистентность.
Например, ручка добавления объявления отправила в БД SQL-запрос. БД запрос приняла, но затормозила.
Скорее всего БД успешно выполнит SQL-запрос, но фронт оборвет запрос в бекенд по таймауту и сделает перезапрос, что приведет к дублированию объявлению.
Поэтому, если надо ретраится в такие ручки, нужно убедиться, что бекенд имеет контроль дубликатов. На фронте это сделать не получится.

**Как понять нужен ли перезапос**
1. Поговорить с бекендом, узнать про тайминги, специфику всего бека и конкретной ручки.
2. Посмотреть на текущие тайминги ответов в ноде. Проще всего это посмотреть на одной машинке в Grafana (данные собирает Prometheues), [пример таймингов ответов ручки](https://grafana.vertis.yandex-team.ru/d/gijPm-Iik/autoru-nodejs-frontends-backend-total-timings?orgId=1&refresh=1m&var-source=Prometheus&var-job=autoru-frontend-desktop&var-dc=All&var-backend=publicApiSearch&var-name=GET%20%2F1.0%2Fsearch%2F%7Bcategory%7D%2Fcount).
3. Узнать у менеджера и коллег важность этой ручки

**Что не стоит делать:**
1) Безконтрольно добавлять ретраи.
2) Безконтрольно добавлять ретраи на долгие ручки.
Скажем, ручка отвечает 800мс и добавляется ретраи. В худшем случае, такой запрос завершится через 800+100(таймаут между перезапросами)+800 = 1700мс. Что много.
3) Если ты точно не знаешь нужен ли ретраи, лучше не добавлять.

## Правильное описание "ресурса"

У нас есть абстракция под названием "ресурс".
Это компонент, который знает как правильно общаться с конкретным бекендом: какие добавлять заголовки, как сериализовывать параметры и т.п.

Неправильно: один бекенд - один ресурс. Правильно: один бекенд - много ресурсов.

Ресурс не только инкапсулирует логику работы с бекендом, но и объединяет под собой:
1. Ручки с одинаковым профилем нагрузки и таймингами ответов
2. Выделяет под себя отдельного [http-агента](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_class_http_agent)
3. Имеет уникальное имя. Соответственно, на него можно навесить отдельные healthcheck, таймауты и построить графики.

Разберем на примере. Возьмем PublicAPI, который соединяет в себе кучу разных бекендов с разными спецификой, зависимостями и временами ответов.
Ручка авторизация ходит в одну базу и зависит от одного набора компонент,
серчер использует другие технологии, а API добавления объявлений третьи.

Что будет, если мы все эти разные ручки объединим в один ресурс под названием PublicAPI?
1. Для каждой ручки придется проставлять собственный таймаут. Они все разные (авторизация быстрая, добавление объявлений медленное) и общий таймаут всего ресурса теряет смысл.
2. На каждый ресурс выделяется http-agent, который ограничивает доступный пул сокетов, чтобы не мешать остальным ресурсам.
Допустим, затупит база авторизации, тогда она будет мешать другим ручкам, которые с ней вообще никах не связаны, потому что пул доступных сокетов будет забит.
3. График времени ответа и ошибок будет показывать среднее по больнице и будет бесполезен.

Если же разделить ресурс на `PublicApiAuth`, `PublicApiSearch` и `PublicApiPoffer`, то исправим все эти проблемы.
1. Понятные общие таймауты + тюнинг конкретных ручек.
2. Ресурсы независимы, не мешают друг другу и всему сервису.
3. Понятные, полезные графики и мониторинги.

Пример из жизни. Серчер из-за GC-lock имееть хитрый профиль запросов (небольшой таймаут + 2 перезапроса + 300ms между перезапросами).
На такой шаг пришлось пойти, потому что серчер отвечает за очень важную часть сайта: поиск + карточка объявления.
На конкретные медленные ручки (например, расширение георадиуса) перезапрос вообще убрали, потому что сервис не потеряет свою ключевую ценность без этой провязки.
Пока ребята пытаются решить эту проблему в беке, мы живем и процветаем.
При этом один ресурс пришлось распилить на `seacherCars`, `seacherMoto`, `seacherCatalog` и т.п., потому что банально просто неудобно прописывать во все ручки этот хитрый профиль.

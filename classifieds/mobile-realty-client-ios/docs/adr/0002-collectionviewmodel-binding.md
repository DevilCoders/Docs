# Использование UICollectionView, активной ViewModel и Binding в Форме Подачи объявления

* Статус: Принято
* Ответственные: [coreshock](https://staff.yandex-team.ru/coreshock)
* Дата: 2020-07-02

Тех.история: [Форма Подачи объявления](https://st.yandex-team.ru/VSAPPS-6894)]

## Контекст

Форма подачи объявления.<br/>
Классический формопостроитель.<br/>

## Причины

* Потребность в интенсивном взаимодействии с пользователем посредством UI
* Нужно модульное решение: переиспользование компонентов, простая кастомизация
* Как можно меньшее количество приведения типов
* Как можно меньше ограничений возможностей UIKit
* Минимальное изобретение "комбайнов на магнитной подушке"

## Рассматриваемые варианты

* UITableView, ItelListController, ListDataSource
* UIScrollView, Passive ViewModel, Binding
* UICollectionView, Active ViewModel, Binding
* Texture, Passive ViewModel, Delegates

## Принятое решение

Выбран вариант: "UICollectionView", потому что:
* Есть кастомизирующийся лейаут (по сравнению с UITableView)
* Активная ViewModel абстрагирует работу с View
* Активная ViewModel легко проецируется во View
* Есть механизм переиспользования ячеек: меньше потребление памяти
* Есть поддержка частичной инвалидации размеров
* Есть поддержка плавной/частичной замены ячеек посредством Diff-механизма

### Позитивные последствия

* Решение хорошо масштабируется:
  * Можно применить для списочной выдачи
  * Можно реализовать ленивую загрузку ViewModel (например, с диска)

### Негативные последствия

* Могут возникнуть непредвиденные требования, критически несовместимые с принятой архитектурой

## Плюсы и минусы вариантов

### UITableView, ItelListController, ListDataSource

Плохой, потому что:
* Objective-C
* Предназначен для списков и постраничной загрузки
* Протекающие абстракции
* Много приведений типов
* Нет тесной связи между (view-)model и view (обратная связь)
* Необходимость реализации протоколов
* Нет эффективного/анимированного обновления (batch update)
* Избыточный функционал: лейблы ошибок, индикатор загрузки, загрузить еще

### UIScrollView, Passive ViewModel, Binding

Собрать форму вручную на UIScrollView.

Хороший, потому что:
* Нет промежуточных абстракций в виде ячеек
* Нет проблем с reuse queue

Плохой, потому что:
* Появляется необходимость ручного лейаута:
  * Ресайз ячеек
  * Контроль contentSize
* Все равно получится реализация похожая на таблицы (с вытиранием типов)
* Заменять содержимое View из ViewModel целиком – дорогое удовольствие для render

### UICollectionView, Active ViewModel, Binding

Ключевые пункты решения:
* UICollectionView
* UICollectionViewLayout – самописный, имитирующий UITableView
* Активные ViewModel, содержащие всю ту же информацию, что и View
* Binding между ячейками и их ViewModel
* Binding между секциями и их ViewModel
* Binding между UICollectionView и ее ViewModel
* Diff для ячеек и секций

Хороший, потому что:
* Есть поддержка частичной инвалидации размеров
* Есть поддержка плавной/частичной замены ячеек посредством Diff-механизма
* ViewModel под ячейки активные
  * Это позволяет работать с ними как с ячейками, не опасаясь что они будут захвачены по сильной ссылке или будут уничтожены раньше времени
  * Это также позволяет мгновенно переносить данные и лейаут в переиспользуемую ячейку
* Связывание ячейки с ее ViewModel осуществляется через Binding, ограниченные временем отображения ячейки на экране
* Нет необходимости реализовывать интерфейсы, ограничивающие возможности UIKit. Изменить или добавить поведение можно без специальных знаний
* Диспатч типов ячеек локализован буквально двумя методами

Плохой, потому что:
* Требуется время на изучение кода
* Некоторые решения неочевидны по причине нетривиального механизма работы UIKit (сложные длинные циклы callback'ов)

### Texture, Passive ViewModel, Delegates

Хороший, потому что:
* Flexbox
* Лейаут считается в фоне

Плохой, потому что:
* Требуется время на изучение библиотеки
* Невозможность бесшовной интеграции UIView-ASDisplayNode. Все преимущества асинхронного лейаута при использовании UIView становятся не такими эффективными
* Сложно реализуемые анимации переходов
* Редко выходят обновления Texture
* С пассивной ViewModel и цепочкой делегатов получается очень длинный цикл вызовов, очень много кода для поддержки

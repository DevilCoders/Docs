# Соглашения по коду

Здесь "высекаются в камне" все соглашения по коду,
к которым мы приходим после обсуждений.

* Соглашения нужны для единообразия.
* Единообразие часто важнее конкретных решений.
* Если это возможно, то соглашение должно быть автоматизированно, например через правило линтера.

## vow

Не используем в новом коде, в старом выпиливаем.
Для нового кода используем нативные промисы.

## reselect

Используем только если это действительно необходимо для производительности,
в остальным местах выпиливаем.

## most

Не используем в новом коде, в старом выпиливаем.

## lodash/get

И подобные методы (`safeGet`) не используем, вместо них [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)


## Мемоизация

Главное - не все можно и нужно мемоизировать. Также, стоит использовать ее для функций с параметрами примитивных типов (либо указывать свой resolver), иначе выигрыш от мемоизации может нивелироваться медленным вычислением cache key.

- `React.memo` ok
- `memoize-one` ok
- `memoizee` с обязательным указанием максимального размера кеша `{ max: n }`, если только вы точно не уверены, что в этом месте может быть всего несколько возможных ключей

- lodash.memo **не используем**, так как он запросто может дать утечку памяти, плюс строит ключ только по первому параметру

## prop-types
В новых компонентах не пишем, используем вместо них TypeScript.

## TypeScript
Новые компоненты (и любые другие файлы) пишем на TypeScript.

[Соглашения по TypeScript](./typescript.md)

## nodules

Запрещается использовать `Gate` напрямую в `react-компонентах`. Между компонентами и гейтами всегда есть слой абстракции
в виде actions, подразумевается redux-actions, вне зависимости от того кладется результат запроса в стор или нет.

## Дата и время

Считаем  `moment` и `date-fns` _deprecated_.
В новом коде используем `dayjs`, в старом выпиливаем `moment` и `date-fns`.

## Именование css классов

В проекте встречается несколько способов работы с классами:
1. `vertis-react/lib/classname`
2. `vertis-react/enhancers/withClassName`
3. `realty-lk-www/view/lib/classname`
4. `realty-core/view/react/libs/bem`
5. `classnames`

В новом коде используем подход `css-modules` с пакетом `classnames`. Остальные способы считаем _deprecated_
и выпиливаем с проекта.  
**Исключение**: библиотека базовых компонентов vertis-react, там используем `classnames` без `css-modules`.

**Примеры использования `css-modules`:**  
1. Тривильное использование
```javascript
import styles from './styles.module.css';

const Hello = () => (
    <h1 className={styles.title}>
        Привет!
    </h1>
)
```
2. Когда есть необходимость в классах, завязанных на флаги
```javascript
import classnames from 'classnames/bind';

import styles from './styles.module.css';

const cx = classnames.bind(styles);

const Hello = ({ visible }) => (
    <h1 className={cx({ visible }, styles.title)}>
        Привет!
    </h1>
)
```

## Использование общих по проекту CSS переменных

Во всех проектах поддержан [список](https://github.com/YandexClassifieds/realty-frontend/blob/master/vertis-react/view/vars/vars.css)
css-переменных. Для работы с цветом, текстом и загруглением обязательно использовать переменные из списка.
Если по дизайну задачи требуются отличные от приведенных в списке переменные, то необходимо уточнить у дизайнера являются ли
требования по дизайну гайдовыми. Если являются - то нужно добавить в общий список новые переменные, и проконтролировать,
что дизайнер внес соответствующие правки в гайды. При выборе названия для
новых css переменных скидываем варианты в общий чат realty-frontend на обсуждение.

## Файловая структура react-компонентов
Независимо от длины названий компонентов используем наименование компонентов ниже.
Ограничение по вложенности компонентов - два уровня, то есть предел `User -> UserPopup -> UserPopupAvatar`.
Название компонента в `index.js` файле соответствует названию папки.

**Неправильно**:
```
User
    __popup
        index.js
    __accounts
        index.js
    index.js
```

**Правильно**:
```
User
    UserPopup
        index.js
    UserAccounts
        index.js
    index.js

```

## export default

Запрещен, в новом коде не используем, в старом переходим на именованый export. [Мотивация](https://medium.com/devschacht/%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D1%82%D0%B0%D0%BB-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E-%D0%B2-%D0%BC%D0%BE%D0%B8%D1%85-javascript-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F%D1%85-d03e63bed126)  
**Исключение**: экспорт стилей из `css-modules` и экспорт локализации i18

## Создание отдельных entries для новых страниц

На усмотрение разработчика, нужно отталкиваться от идеи насколько новая страница логически изолирована от существующих.
При возникновении вопросов - решаем в общем чате.

## Вопросы, которые не имеют строгих ограничений (нельзя запросить request changes в ПР)

1. Язык при названии тестов
2. Использование классовых или функциональных `react-компонентов`
3. Использование `data-test-*` атрибутов при скриншотном тестировании

# Соглашения по тестам

В виду того, что основным потребителем отчета по скриншотным тестам является отдел тестирования - есть ряд рекомендаций по написанию тестов:

## Язык в названии тестов

Название тестов пишем на русском языке. Исключение - верхнеуровневый блок describe, где пишем название компонента, который тестируется.

## Название теста

Название теста должно отражать какие именно условия этот тест проверяет. Если условий много - можно вынести детали в описание теста, например:

```js
import { allure } from '@realty-front/jest-utils/puppeteer/tests-helpers/allure';
// ...
allure.descriptionHtml(`<pre>${JSON.stringify(params, null, 2)}</pre>`);
```

## Вложенные describe

По возможности группируем семантически связанные тесты, с помощью вложенных describe, например:

```js
describe('Звонки в столицах', () => {
    describe('Обиленные', () => {
        // ...
    });

    describe('Не обиленные', () => {
        // ...
    });
});
```

## Проверка на разных разрешения

Проверку компонента на одних и тех же входных параметрах, но разных разрешениях экрана лучше делать в рамках отдельного узла allure-отчета:

```js
describe('Компонент', () => {
    it('Тест-кейс', async () => {
        await render(<Component />, { viewport: { width: MIN_WIDTH, height } });

        expect(await takeScreenshot()).toMatchImageSnapshot();
        
        await render(<Component />, { viewport: { width: MAX_WIDTH, height } });

        expect(await takeScreenshot()).toMatchImageSnapshot();
    })
});
```
```js
describe('Компонент', () => {
    describe(`Тест-кейс`, () => {
        renderOptions.forEach((renderOption) => {
            it(`${renderOption.viewport.width}px`, async () => {
                await render(<Component />, renderOption);

                expect(await takeScreenshot()).toMatchImageSnapshot();
            });
        });
    });
});
```

## AppProvider

По возможности стараемся писать тест с использованием компонента AppProvider, который позволяет проверить не только view-компонент, но и его контейнеры, что делает тест более честным.

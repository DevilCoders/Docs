# ProvidersMixin

Миксин добавляет статический метод `dataProviderDecl` для определения источников данных и их связей, необходимых для построения ответа.

> **todo:** допилить для корректного определения источников данных и связей для нескольких действий контроллера.

## API

### Статические свойства

#### ProviderError

Класс ошибок `ProviderError`, наследник [`AbstractControllerError`](AbstractControllerError.md).

Коды ошибок:

* `DATA_PROVIDER_FUNCTION_NOT_DEFINED`
    – если при декларации провайдера не передана функция и нет метода `getData_<providerName>`;
* `UNRESOLVED_PROVIDERS_DEPENDENCY` – не удалось найти провайдер по зависимости от другого провайдера;
* `DATA_PROVIDER_NOT_EXISTS` – провайдер не объявлен в контроллере.

#### blocks

Свойство не наследуется и должно быть определено индивидуально для каждого контроллера,
в котором используются методы миксина `ProvidersMixin`.

Формальная структура:

```javascript
@typedef Block
@property {String} block — имя  блока
@property {String|String[]} [data] — провайдеры данных для блока
@property {Block|Block[]} [content] — дочерние блоки
```

> ##### Блок
> 
> Блок в контексте ProvidersMixin — это абстрактная сущность, зная имя которой,
> можно однозначно определить и выполнить дерево провайдеров.
> Может быть, как элементом интерфейса (блоком, виджетом, да как хотите его назовите),
> так и, например, именем метода публичного сервиса API или [действия контроллера](Controller.md#callAction).

Пример декларации:

```javascript
var MyController = Controller.create();

MyController.mixin(ProvidersMixin);

MyController.blocks = {
    block: 'b-page',
    data: [ 'direct', 'navigation' ],
    content: [
        {
            block: 'b-content-left',
            content: {
                block: 'b-user',
                data: 'userinfo'
            }
        },
        {
            block: 'b-content-right',
            content: {
                block: 'b-content',
                data: 'content'
            }
        }
    ]
};
```

Пример для некоего CRUD API или гейта (что суть одно и тоже):

```javascript
APIItemsController.blocks = [
    { block: 'list', data: 'listItems' },
    { block: 'get', data: 'getItem' },
    { block: 'create', data: 'create' },
    { block: 'update', data: 'update' },
    { block: 'delete', data: 'delete' }
];
```

> **todo:** допилить `getData` и `getProvidersForBlocks`, чтобы на верхнем уровне [`Controller.blocks`](#blocks) мог быть массив блоков.

#### providers

Хэш дескрипторов объявленных в контроллере провайдеров.
Не рекомендуются прямые манипуляции с этим свойством, если вы не разобрались с реализацией провайдеров.

Свойство не наследуется.

> ##### Дескриптор провайдера
> Дескриптором провайдера назван объект с двумя полями:
> 
> * `{Function} fn` — функция провайдера;
> * `{Array} deps` — имена провайдеров от которых провайдер зависит.

#### dataProviderDecl()

`dataProviderDecl(name, deps, provider) → this`

* `{String} name` – имя провайдера;
* `{String|String[]} [deps]` – зависимости от других провайдеров;
* `{Function} [provider]` – функция провайдера.

Объявляет провайдер в контроллере:

* если передана функция `provider`, то создает в прототипе контроллера метод `getData_<name>`;
* если второй аргумент отсутсвует, то у провайдера нет зависимостей;
* создается дескриптор `{ deps: deps, fn: this.prototype.getData_<name> }`
* дескриптор провайдера помещается в статический хэш `providers` конструктора контроллера.

Возвращает `this`.

##### Функция провайдера

`function(data, blocks) → {Promise|*}`

* `{Object} data` — хэш, который провайдеры наполняют данными;
* `{String[]} blocks` — массив имен блоков, для которых был вызван метод [`getData`](#getdata).

Функция провайдера наполняет хэш `data` своими данными.
Хэш `data` может уже создержать данные провайдеров, которые выполнены ранее.

Если функция выполняет асинхронную операцию, то должна вернуть промис и разрешить его, когда операция будет выполнена.

В случае ошибки нужно вернуть отмененный промис, чтобы выполнение дерева провайдеров было прервано.

#### getProvider()

`getProvider(name) → {Function}`

* `{String} name` – имя провайдера

По имени провайдера возвращает функцию провайдера.

#### getProvidersForBlocks()

`getProvidersForBlocks([blocks], [action]) → {String[]}`

* `{String|String[]} [blocks]` — массив имен блоков, для которых нужно получить провайдеров
* `{String} [action]` — имя экшена, для которого нужно получить провайдеров

Возвращает массив имен провайдеров, которых нужно вызвать для получения данных для отрисовки блоков.

Если массив блоков не передан, или хотя бы один из блоков не был найден в структуре
[`blocks`](#blocks) контроллера, то будут возвращены имена всех провайдеров.
Если аргумент action НЕ передан, то возвращает массив имен провайдеров всех блоков из аргумента blocks

### Свойства прототипа

#### getData()

`getData([blocks], [action]) → {Promise}`

* `{String|String[]} [blocks]` – имена блоков, для которых нужно получить данные.
* `{String} [action]` – имя экшена, для которого нужно получить данные.

Метод строит дерево вызовов провайдеров необходимых для отрисовки блоков.
Для получения имен провайдеров используется метод [`getProvidersForBlocks`](#getprovidersforblocks),
поэтому, если блоки не указаны или хотя бы один из них не найден в структуре [`blocks`](#blocks) контроллера,
то вызваны будут все провайдеры.
Если аргумент action НЕ передан, то вызывает все провайдеры всех блоков из аргумента blocks

Возвращает промис, который будет разрешен, когда выполнится все дерево провайдеров,
то есть когда все данные будут получены (или выполнение прервано ошибкой или отменено в одном из провайдеров).

В случае успеха промис разрешается объектом `data`, который наполняется провайдерами.

#### getAllowedBlocks()

`getAllowedBlocks(blocks) → {String[]}`

* `{String|String[]} [blocks]` — имена блоков для проверки.

Если метод вызван без аргумента `blocks`, то вернет имена всех блоков,
которые описаны в структуре [`blocks`](#blocks) провайдера.

Если в аргументе `blocks` передан список имен блоков, то вернется новый массив содержащий только те имена,
которые есть в структуре [`blocks`](#blocks) контроллера.

# ansible-pull

Данная страница рассказывает про наш механизм автоматической конфигурации серверов под названием `ansible-pull`.

## Архитектура и общие сведения

Так как все плейбуки хранятся в Аркадии, а монтировать Аркадию на каждый сервер небезопасно и избыточно, то мы используем схему с промежуточными хостами.

Примерная схема выглядит следующим образом:
![image](images/ansible-pull-scheme.jpg)

Есть несколько особенностей:

* На `infra`-серверах мы маунтим Аркадию. Для этого на их кондукторный макрос сделана сетевая дырка до Аркадии. От остальных серверов такой дырки нет и маунтить Аркадию на них нельзя.
* Сервера скачивают данные по **rsync** по логину и паролю. Без них не получится получить доступ.
* Мы не используем `grpc API` Аркадии потому, что через него можно получить только конкретный файл, а нам нужна вся директория.

[Директория в Аркдии](https://a.yandex-team.ru/arcadia/classifieds/infra/vertis-ansible)
[Графики выкладки новых версий на сервера](https://grafana.vertis.yandex-team.ru/d/L2nr6ejGk/ansible-pull?orgId=1&refresh=30s)

## Управление

На каждом сервере стоит скрипт `/usr/sbin/vertis-ansible-pull.sh`, доступный из-под рута.

Он умеет временно отключать автоматический прогон:

```
/usr/sbin/vertis-ansible-pull.sh -d (<type>)
```

при этом **текущий прогон не будет остановлен**. Это может быть полезно для тестирования (когда мы хотим выкатить пакет на один хост).

Последний параметр опционален и может принимать два значения - `default` (тогда будет отключен только привоз конфигурации) или `datasources` (тогда будет отключен только привоз датасурсов). Если не указан, отключается и привоз конфигурации и привоз датасурсов.

Включить обратно:

```
/usr/sbin/vertis-ansible-pull.sh -e (<type>)
```

Логи доступны в файле `/var/log/ansible-pull/vertis-ansible-pull.log` на каждом сервере.

## Lookup plugin 'yav'

Исходники: [https://a.yandex-team.ru/arcadia/classifieds/infra/vertis-ansible/lookup_plugins/yav.py](https://a.yandex-team.ru/arcadia/classifieds/infra/vertis-ansible/lookup_plugins/yav.py)

Чтобы не хранить секретные данные в репозитории, мы позаимствовали и адаптировали `lookup-plugin` для ansible. Он позволяет хранить в репозитории ссылки на секреты в Секретнице, которые будут сконвертированы в сами секреты при прогоне плейбуки.

Формат шаблона:

```
{{ lookup('yav', '<secret>', '<key>') }}
```

в качестве секрета может быть указана конкретная версия секрета или айди секрета (в этом случае при прогоне возьмется самая последняя версия секрета). В качестве ключа должно быть указано названия конкретного поля из секрета.

### Аутентификация

Для аутентификации при запросах в Секретницу используется [механизм подписи по SSH-ключу](https://wiki.yandex-team.ru/oauth/token/#granttypesshkey). Поэтому важно, чтобы в системе стояло правильное время.

При прогоне плейбуки руками используется локальный SSH-agent на хосте. При прогоне автоматикой используются SSH-ключи роботов `robot-vertis-yav-tst` и `robot-vertis-yav-prd` (соответственно для **теста** и **прода**) - этим роботам необходимо выдать доступ к секрету (в зависимости от окружения).

### Файлы

Секретница дает возможность хранить данные в виде файлов. Мы настоятельно рекомендуем сохранять данные как строку, поскольку секрет приедет ровно в том виде, каким вы его видите в секретнице.
Привоз секретов из файлов менее предсказуемый, хотя он так же доступен. Если секрет привозится из файла, но нужно добавить опцию `encode=True` в запрос. При указании этой опции плагин закодирует содержимое секрета в **base64**. В самом шаблоне нужно раскодировать в оригинальное содержимое при помощи фильтра `b64decode` у Jinja2.

Пример:

```
{{lookup('yav', 'secret_version_or_ID', 'secret_key', encode=True) | b64decode }}
```

### Кэширование

Так как шаблонов секретов может быть много, а прогоняем плейбуки мы сразу на всех серверах, то может возникнуть ситуация, когда мы будем генерировать слишком большой объем запросов в Секретницу.

Чтобы этого избежать, мы используем кэширование.

Так как версии секретов в Секретнице **иммутабельны**, то мы можем их кэшировать навечно. Для этого используется (если доступно) кэширование на файловую систему в **tmpfs** (в частности раздел `/dev/shm`). Это позволяет сохранить кэш между разными запусками прогона и, при этом, безопасно, так как данные при выключении сервера будут стерты и не окажутся на жестком диске.

Если такой директории не существует (это возникает при запуске с локального ноутбука или мы намеренно не создали эту директорию) или мы запрашиваем не конкретную версию секрета, а последнюю по айдишнику, то используется кэширование в памяти самого ансибла. Это позволяет избежать большого кол-ва походов в Секретницу, если один и тот же секрет указан несколько раз.

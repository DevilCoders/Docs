# Шифрование данных в Пальме

Данные шифруются с помощью алгоритма симметричного шифрования AES256-GCM с рандомным IV. На каждую сущность справочника
генерируется рандомный IV.

Значение индексных полей таких справочников хешируются криптостойким алгоритмом sha256.

## Связанные тикеты

* [Шифрование в сервисе ПД](https://st.yandex-team.ru/VSSEC-349)
* [Схема](https://wiki.yandex-team.ru/users/ruslansd/Shifrovanie-v-palme/)
* [Реализация схемы](https://st.yandex-team.ru/VSDATA-771)

## Ключи шифрования

Используем схему envelope encryption c ротацией ключей

[пример от гугла](https://cloud.google.com/kms/docs/envelope-encryption).

Ключи для шифрования данных (DEK - data encrypted key) шифруются мастер ключем (KEK - key encryption keys). Актуальный
мастер ключ хранится в секретнице (в base64 представлении). Его актуальная версия и необходимые для ротации старые
версии, доставляются через конфиг. Пример:

```hocon
encryption {
    master-key {
        current = ${ACTUAL_ENCRYPTION_MASTER_KEY}
        old = [
            ${OLD_ENCRYPTION_MASTER_KEY_1},
            ${OLD_ENCRYPTION_MASTER_KEY_2}
        ]
    }
}
```

Ключи шифрования данных (DEK) хранятся в ydb пальмы в зашифрованном виде вместе с версией мастер ключа (sha256 от KEK).

Схема:

```sql
CREATE TABLE secrets
(
    dictionary_id      Utf8,
    data_key_id        Utf8,
    master_key_hash    String, --(sha256 от KEK)
    encrypted_data_key String, --(encrypted DEK)
    is_active          Bool,   --(флаг актуального DEK)
    PRIMARY KEY (dictionary_id, data_key_id)
);
```

## Шифрование

Для шифрования данных всегда берется актуальный DEK. Для зашифрованных данных храним id ключа из таблицы secrets. Если
для данного справочника актуального DEK нет - генерируется новый и шифруется с помощью текущего KEK.

## Расшифровка

Ключи данных храним в ydb и кешируем на чтение по `secret_key_id`. По `secret_key_id`
получаем `master_key_hash` и `encrypted_data_key`. Ищем KEK, соответствующий данному хешу.

{% note warning %}

Если такого ключа нет - расшифровать данные будет невозможно. С помощью KEK расшифровываем DEK, далее расшифровываем данные.

{% endnote %}

## Ротация KEK

Создается новая версия с новым KEK в секретнице. Новая версия прокидывается в encryption.master-key.current, предыдущую
версию обязательно положить в encryption.master-key.old[]. При попытке зашифровать данные - будут сгенерированны новые
DEK и данные зашифруются актуальными ключами. Сейчас это "ленивый" процесс.

## Ротация DEK

В [планах](https://st.yandex-team.ru/VSDATA-918) сделать апи, по которому можно инвалидировать ключи по dictId (
реализация DAO уже позволяет это сделать, осталось прокинуть в апи). При этом, для чтения будут использоваться старые
ключи. Для шифрования будут сгенерированны новые DEK. Сейчас это "ленивый" процесс.

## Перешифрование данных при ротации ключей

[Планируем](https://st.yandex-team.ru/VSDATA-919) сделать таску (можно запускать регулярно или через апи) по
перешифрованию. Можно либо обходить вообще всё, либо получить из ydb только те, которые зашифрованы неактуальными
ключами. После перешифрования всех данных можно удалять старые KEK из конфигурации. Удаление неактуальных DEK сейчас не
предусмотрено (можно сделать, если в этом будет потребность)

# Как мигрировать репозиторий в монорепу

Переезд состоит из трех основных шагов:
1. импорт исходников
2. настройка bazel сборки
3. релизы сервисов из монорепы
4. завершение переезда

Их необязательно совершать в один момент времени, т.е. пока происходит переезд можно продолжать разрабатывать привычными инструментами.

## Импорт исходников

Так как все уже лежит в одном репозитории, дополнительный импорт не требуется, достаточно сделать `mv`.
Однако для более плавного переезда можно завести временный симлинк в [tools/bazel](https://a.yandex-team.ru/arc_vcs/classifieds/verticals-backend/tools/bazel)
Дальше нужно выключить scalafmt для нашей папки – он будет мешать нам, пока мы переезжаем.
В корне репозитория лежит файл `.scalafmt.conf`.
Нужно добавить в него такую строку (либо добавить папку в существующую)
```
project.excludePaths = ["services/my-superrepo"]
```

## Настройки bazel сборки

Первым шагом добавим внешние зависимости, которых не хватает в монорепе.
Тут предполагается, что если зависимость есть, то будет использоваться версия из монорепы.
Т.е. нельзя иметь две версии одного артефакта.
Если такое необходимо — напишите в чат; это сложнее, но возможно.

Добавление новой версии выглядит так:
1. добавляем зависимость в вызов `maven_install` в файле `WORKSPACE`
2. вызываем `make update/maven` – это команда отрезолвит зависимости и запинит их в файле `maven_install.json
3. комитим файлы `WORKSPACE` и `maven_install.json`

Вторым шагом добавляем BUILD файлы.
Оставим старое разбиение на модули и просто переведем их на сборку базелем один за другим.
Обычно один модуль превращается в один BUILD файл 
и несколько таргетов внутри него (scala_library, scala_test и возможно scala_binary).

При миграции на базель могут потребоваться минорные фиксы.
Если случился warning – его можно либо пофиксить, либо подавить аннотацией `@nowarn`
При миграции со старых версий скалы на 2.13 потребуются такие замены:
`import scala.collection.JavaConverters._` на `import scala.jdk.CollectionConverters`
`map.mapValues(...)` на `map.view.mapValues(...).toMap`

Примеры миграций:
[promocoder-core](https://github.com/YandexClassifieds/verticals-backend/pull/7483/commits/0dd69afc3e6930f5cdb169cb6cf4a817e57c3a82)
[promocoder-core (tests)](https://github.com/YandexClassifieds/verticals-backend/pull/7483/commits/394ea7fb7cc9ffe2c9ab8f7738be87d0699a4857)
[promocoder-api](https://github.com/YandexClassifieds/verticals-backend/pull/7483/commits/34358fd5cd079c2f5a91f8c770ebf0a94de8bfea)

На этом шаге тратится основное время, потому что нужно добиться успешной сборки и прохождения тестов.

## Релизы сервисов из монорепы

Для сборки докер-образа приложения нужно добавить таргеты `scala_image` и `shiva_service`.
Их нужно добавить в тот же BUILD файл, в котором объявлен scala_binary.
Предположим что у нас есть сервис `myrepo-api` в папке `services/my-superrepo/api`, и мы настраиваем для него сборку докер образа. 
Пример:
```
scala_image(
    name = "image",
    binary = ":api", # ссылка на таргет scala_binary
    jvm_flags = [ # флаги для запуска джавы в контейнере, не обязательны
        "-Xms3g",
        "-Xmx3g",
    ],
    main_class = "myrepo.Main", # main класс, если не указал – возьмется из таргета scala_binary
    service = "myrepo-api", # имя сервиса в шиве
    
    # хорошей практикой является ограничение области видимости таргета, чтобы от него не зависили другие сервисы
    visibility = ["//services/my-superrepo/api:__subpackages__"],
)

shiva_service(
    name = "service",
    binary = ":api", # ссылка на таргет scala_binary, такой же как в scala_image
    service_name = "myrepo-api", # имя сервиса в шиве
    start_vertion = 42, # номер следующей версии сервиса, это нужно для продолжения истории при переезде на аркадийные релизы
    nomad = True, # сервис деплоится через Jenkins (по умолчанию, False)
    changelog = True, # генерировать changelog для релизов сервиса
    link_tickets = True, # привязывать к деплою тикеты, вошедшие в релиз
)
```

Далее нужно запустить `make gen/yaml`, чтобы сгенерировать конфиг для CI-релизов.

После попадания в trunk новую сборку можно найти [тут](https://a.yandex-team.ru/projects/verticals/ci/actions/launches?dir=classifieds%2Fschema-registry&id=build).

Для сервисов из монорепы имя докер образа в registry совпадает с именем сервиса, поэтому нужно [удалить](https://github.com/YandexClassifieds/services/commit/db93352d083317e1337f6f3362362ecfd566b770) из манифеста деплоя имя образа, если он не совпадает.

Если ваш сервис под SOX или вам нужно собирать тикеты, вошедшие в релиз по другой причине – у нас есть механизм сбора [changelog](../../ci/changelog.md).

## Завершение переезда

После того, как все было успешно мигрировано и разработка полностью перешла на новую схему, необходимо почистить симлинки и убрать проект из исключения форматирования.
После этого можно разово вызвать команду `make format`, чтобы привести код в соответствии с текущими настройками и закоммитить изменения.

# susanin-react
Роутер для React поверх [susanin](https://github.com/YandexClassifieds/susanin) (двусторонний роутер).

Роутер реализует простую и ненавязчивую (unobtrusive) схему работы: перехватывает клики по ссылкам и, вместо перехода на страницу с перезагрузкой, запрашивает данные страницы через `fetch` и вставляет их в redux, заставляя страницу перерисоваться.

## Мотивация

Мы долго использовали `react-router`. Но у него были проблемы с подключением сусанина.

Почему нам так важен `susanin`? На сайте, где все ссылки имеют понятный (`/article/:name`, `/user/:id`) неизменяемый вид, сусанин скорее всего не пригодится. Нам же для SEO надо генерировать сложные и нетривиальные ссылки на поиск, карточку и другие разделы сервиса. В такой момент логично инкапсулировать всю логику по разбору ссылки на параметры и наоборот в одно место. Это называется двусторонний роутинг.

В чем смысл двусторонноего роутинга? Он представляет из себя две обратные друг другу функции:

* `parse(url: string): [routeName, routeParams]`
* `link(route: [routeName, routeParams]): string`

А разве `react-router` так не умеет? Нет, не умеет. Прикрутить к нему сусанина нативными способами не получилось (нет API, куда можно подключить сусанина для разбора ссылок). Плюс ко всему, у `react-router` нет API для генерации ссылок. Сколько я видел, разработчики сбоку пишут генераторы ссылок, которые не всегда находятся в синхронном состоянии с роутером, потому что это две разные библиотеки.

В итоге было принято решение перестать есть кактус и написать свой простой роутер поверх susanin.

Ответственный за такое решение: [@aandrosov](https://staff.yandex-team.ru/aandrosov )

## Детали реализации

### Как подключить

В общем виде надо сделать вот так:

```js
import { Router } from '@vertis/susanin-react';

const App = () => {
    return (
        <Provider store={ store }>
            <Router
                // Словарь компонентов: Record<string, React.ElementType>
                components={ susaninComponents }
                // экземпляр susanin
                susanin={ susanin }
            />
        </Provider>
    );
};
```

Также есть различные пропы `onFail`, `onLoading`, `onUpdate` и т.д. Смотрите типы.

Плюс к этому в `susanin`-роутах в `data` должен быть массив `components`, который расскажет `susanin-react`, какую цепочку компонентов надо создать для роута. Если цепочки нет, то произойдет обычный переход по ссылке.

```js
{
    name: 'card',
    pattern: '/my-card-route/',
    data: {
        components: [ ...BaseComponentsCard, susaninComponents.PageCard ],
    },
},
```

### redux-store susanin-react

Стор `susanin-react` представляет из себя простую [типизированную структуру](src/redux/StateRouter.ts) `previous` / `current` / `next` + текущее состояние перехода `state` (`LOADED` / `LOADING`).

Правила работы:

* action `PAGE_LOADING` - начало перехода. Текущий роут не меняется, в `next` появляется информация о будущем роуте. `state` переходит в состояние `LOADING`. 
* action `PAGE_LOADING_FAILED` - ошибка перехода. Текущий роут не меняется, `next` удаляется. `state` переходит в состояние `LOADED`. 
* action `PAGE_LOADING_SUCCESS` - конец успешного перехода. В `previous` роут перемещается из `current`, `current` заменяется на конечное состояние после редиректов, `next` удаляется. `state` переходит в состояние `LOADED`. 

К примеру, на изменение `state` можно показывать лоадер на странице.

Такие названиея для `action` выбраны, потому что в Авто.ру все редьюсеры уже были завязаны на `PAGE_LOADING_SUCCESS` и не хотелось переписывать весь мир. Надо было максимально прозрачно заменить устаревший `react-router-susanin` на схожую реализацию.

### react context

В context прокидываются две функции, аналогичные [History API](https://developer.mozilla.org/ru/docs/Web/API/History_API), чтобы можно было программно управлять переходами по страницам:

* `pushState(url: string, options?: Options)`
* `replaceState(url: string, options?: Options)`

Под капотом эти функции вызывают нативные `history.pushState` и `history.replaceState`. В `options` можно передать, к примеру, флаг `loadData`, который загрузит данные для нового урла. Эти функции проходят теже стадии обработки, что и обычные клики.

`Options` - смотрите [декларации в коде](src/components/Router.tsx#L33).

### Хитрости

* **ВАЖНО**: настоящий запрос от запроса susanin-react [отличается заголовком](src/components/Router.tsx#L295) `x-susanin-react: true`
* `<a href="" data-spa="false"/>` - принудительное выключение обработки ссылки `susanin-react`
* Если у ссылки есть `target`, она нажата с ctrl/cmd или клику кто-то сделал `preventDefault` - обработка такого клика `susanin-react` отключается

# shiva

Инфраструктурный сервис для управления деплое.
Представляет собой абстракцию над шедулерами и опирается на
[описание в декларативном стиле](https://github.com/YandexClassifieds/services).

Представлен отдельными компонентами:

- [Updater](./cmd/github-updater) - сервис синхронизации карты сервисов и манифеста деплоя
- [Deploy](./cmd/shiva) - основной сервис реализующий АПИ деплоя
- [Telegram bot](./cmd/telegram) - точка входа в деплой на основе чат бота
- [Github app](./cmd/github-app) - github бот для хуков для валидации карты
- [Generator](./cmd/generator) - генератор окружения по карте

Для локально запуска сервисов в тестовое окружения (в случае проблем с данными сервисами в рабочих слоях) обратиться к <https://github.com/YandexClassifieds/shiva/tree/master/cmd/selfdeploy>
Тестовый телеграм бот: @vertis_shiva_test_bot

## Разработка

Для запуска приложений и тестов требуется postgres, zookeeper, kafka (собрана из <https://hub.docker.com/r/wurstmeister/kafka/>) и grafana:

```sh
~ make up
```

Для общих библиотек используется [go-common](https://a.yandex-team.ru/arcadia/classifieds/infra/go-common), для его использованяи нужно добавить `replace`


### Конфигурация

Для локального запуска и прогона тестов нужны секреты [shiva-dev](https://yav.yandex-team.ru/secret/sec-01ejtqd8hxr3v701qzj4ztv810) для проекта в файле local.env в корне проекта.
Также, для тестов Яндекс.Деплоя нужен oauth токен: <https://wiki.yandex-team.ru/deploy/docs/tools/dctl/#token>, который следует добавить в local.env в переменную:

Для тестов используется `common_test.env`, `local.env` и соответствующий проекту `test.env`

Для локального запуска используется `common_dev.env`, `local.env` и соответствующий проекту `dev.env`

### protobuf

Для работы генерации protobuf и grpc сервисов требуются определенные версии генераторов:

```sh
brew install protobuf
```

Должна установиться последняя версия (3.19.4), она будет проверена в makefile.
Если версия выше, то нужно обновить на более высокую в README.md и makefile.
Если версия ниже, то нужно обновить библиотеку.

Для генерации используются локальные бинарники (macos) (`shiva/go/bin`): `protoc-gen-go@v1.24.0` и `protoc-gen-go-grpc@@v0.0.0-20200603165752-42eed59dfa46`

Бинарники можно пересобрать если пратформа отличается от macos:

```sh
~ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.24.0
~ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v0.0.0-20200603165752-42eed59dfa46
```

Все `.proto` должны находиться в schema-registry и генериться посредством команды `make protos`

#### schema-registry

Для генерации связанных api proto-файлов используем [schema-registry](https://github.com/YandexClassifieds/schema-registry)

- внести изменения в [schema registry](https://github.com/YandexClassifieds/schema-registry) через PR
- `make protos`

### mocks

Для генерации моков используется локальный бинарник (macos) `mockery`.

Генерация:

```shell
make mocks
```

### tvmtool

Понадобится для интеграционных `nomad` тестов и проверки авторизации по tvm

- информация и как скачать: <https://nda.ya.ru/3UWe5D>
- tvm-секрет посмотреть здесь: <https://nda.ya.ru/3VnUHr>

```sh
# between shiva and secret-service
$ tvmtool add --secret <tvm_secret> --src 2015331:2015331 --dst 2015329:2015329
# run it
$ tvmtool -p 1234 -a 00000000000000000000000000000000
```

### Локальный запуск

Запуск осуществляется через `main.go` одного из проектов.

Для полноценной работы необходимо поднять `github-updater` и оставить его вкл, чтобы актуализировать и наполнить бд.
А также `shiva`, как основной, с которым так или иначе взаимодействуют остальные.

Далее можно поднимать любой проект.

Крайне рекомендуется проверять работоспособность любой доработки через автотесты.

### Тесты

Тесты разделены на два блока:

1. Однопоточные. Это упрощает их написание и позволяет не заботится о состоянии бд. Однако тест должен чистит перед собой и не оставляет артефактов.

- Все тесты: ```go test -p 1 ./... -tags unit```
- Тесты на проект:  ```go test -p 1 ./cmd/shiva/... -tags unit```
- Тесты на pkg:  ```go test -p 1 ./pkg/... -tags unit```

2. Многопоточные **Nomad** тесты. Если тест выполняется долго то к тесту стоит добавить ```_Parallel```. Такие тесты должны уметь не влиять на другие паралельные тесты

`go test ./... -run '_Parallel' -timeout 20m -parallel 32`

### Компоненты

Инициализация и использование глобальных переменных считается недопустимым.
Компоненты должны быть инициализированы при старте приложения.
Внешние зависимости компонентов должны быть переданы через dependency injection – в нашем случае это конструкторы в main.

Каждый компонент представляет собой набор:

- **Client**
  - Низкоуровневая прослойка для работы с внешним АПИ.
  - При простой интеграции, для приближения тестов к реальной работе, рекомендуется использовать реального клиента.
  - Для сложной интеграции (или проблем с ней) для упрощения тестов может быть покрыт интеграционным тестом и заменен на Mock.
- **Service**
  - публичный API для данного пакета/модуля
  - получает из main все dependency
  - изолирует внутренние особенности, такие как форматы, БД, предобработки и прочее
  - является основным компонентом для dependency injection в другие сервисы
  - инициализируется тремя способами
    - `NewService(dependencies...)` - создания чистого сервиса без побочных эффектов
    - `RunService(dependencies...)` - создания экземпляра сервиса с запуском фоновых процессов (работа в отдельных рутинах, запуск обработчиков кафка и т.д.)
    - `func (*Service) Init() *Service` - для сложных сервисов (где 6+ зависимостей), DI-зависимости передаются как публичные поля, Init выступает в роли конструктора с инициализацией приватных полей и не должен принимать новые зависимости.
- **Storage**
  - реализует и икапсулирует особенность работы с БД
  - использует ORM: <http://gorm.io>
  - отвечает за миграцию своего компонента
  - использует storage.BaseStorage
  - может загрузить связанные сущности в объекте без обращения к соответствующим storage
  - должен создаваться в конструкторе сервиса и быть приватным компонентом
- **Model**
  - элемент работы с БД
  - является публичным объектом предоставления информации компонента, если не используются сложные предобработки,
    такие, как в `manifest` или `service_map`
- **Conf**
  - отвечает за конфигурацию именно этого пакета/модуля/компонента
  - только conf работает с переменными окружения в конструкторе
  - передается через DI в компонент, чтобы
    - можно было подменить в тестах
    - panic при отсутствии параметров в env на момент старта
    - по-разному конфигурировать один и тот же компонент (например, scheduler/nomad/Service)
  - если есть валидация, то она должна происходить при старте приложения, те также в конструктор

Все компоненты передаются как ссылки.
Если компонент представлен интерфейсом (например, при замене на Mocks в тестах), то используется префикс `I`. Например: `IService`, `IClient`, ...

## Автоматические Миграции

Каждая миграция представлена 3 файлами, находящимися в директории `migrations` в корне проекта:

- `<version>.up` - будет выполнена при деплое на новую версию. Если существует больше одной миграции, они будут выполнены в порядке возрастания версий.
- `<version>.down` - миграция, которая приведет базу в валидное состояние при откате приложения на более раннюю версию. Если существует больше одной миграции, они будут выполнены в порядке убывания версий.
- `<version>.drop` - миграция, которая удалит неиспользующиеся таблицы и колонки, будет выполнена с таймаутом в 1 месяц.

Пример:

1. Была добавлена миграция с версией 1.
2. Происходит деплой на версию tc100, применяется 1.up.
3. Добавляем миграцию с версией 2
4. Происходит деплой на версию tc101, применяется 2.up.
5. При откате на версию tc99 будут применены 2.down и 1.down. После отката можно изменять файлы откаченных миграций,
   если это необходимо.
6. Собрали новую версию, например tc.102, при деплое применяются 1.up и 2.up.
7. Через месяц после последнего применения миграции выполняется drop.

### Требования к миграциям

- `up` миграция не должна изменять или удалять существующие колонки и таблицы, т.к это убивает возможность отката.
- `down` миграция не должна удалять существующие колонки и таблицы.
- `up` и `down` миграции будут выполнены несколько раз (минимум 2), их повторное исполнение должно приводить к корректному результату.
- возможна ситуация, в которой `drop` будет выполнен 2 раза, используйте `if exists` синтаксис.
- версии миграций должны быть целочисленной возрастающей последовательностью и начинаться с 1.

### Использование

Миграция будет выполнена поверх [миграции gorm](https://gorm.io/docs/migration.html), которая создаст таблицы, колонки, индексы, констрейты и т.д. Изменяйте схему в коде через `Model`.
Миграция будет проходить в 3 этапа:

1. Создадутся "чистые" колонки без индексов и констрейтов.
2. Выполняется `up` миграция.
3. Накладываются индексы и констрейты.

Используйте `default` вместе с `not null`, т.к gorm не считает это констрейтом и применит на 1 этапе.

### Тестирование

Рекомендуется протестировать миграции: создать снапшот базы и выполнить по 2 раза up, down и drop миграцию.

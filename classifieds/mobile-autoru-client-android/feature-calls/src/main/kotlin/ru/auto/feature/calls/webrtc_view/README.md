Привет мой друг! Здесь я расскажу тебе зачем нужен этот замечательный пакет, и как тут всё устроенно.

А нужен он для отрисовки на экране полученного видео-потока от webRTC в общем и от вокса в частности посредством
TextureView. И у тебя мог уже возникнуть в голове вопрос, а зачем же нам нужен TextureView?
Вообще, есть у webRTC целых 3 способа отобразить поток на экране:
1) SurfaceViewRenderer(свой, webRTC-шный)
2) GLSurfaceView(андроидный)
3) своё кастомное вью

Как можно догадаться из названия, первые 2 основаны на SurfaceView, найденное отличие между ними лишь в том, что
второй может шэрится между несколькими рендерерами, иными словами, можно не создавая новых рендереров
(чего мы кстати и не можем делать) показывать один поток на нескольких вьюшках. Для SurfaceViewRenderer же действует правило:
Одна вью - один рендерер.

- Так почему-же они(SurfaceView) нам не подходят?

Ответ кроется в устройстве SurfaceView, которая по сути является не вьюшкой, а отдельным Window, отображаемым поверх
реального окна(да, тут можно задать z-order и засунуть её сзади окна активити, но нам это не интересно).
И это окно примотано изолентой к действительной иерархии вью.
И тут проблем несколько:
1) Оно не может быть прозрачным. Вообще! Никак! И даже нельзя сделать тут прозрачные области(скажем скругления по краям)
2) Не применяются анимации вью, только виндоу-анимации(вспомни как анимировать появление/сокрытие активити)
3) Перемещается и трансформируется через жопу

Но у неё есть плюс - она рендерится на другом потоке и, в зависимости от реализации, может использовать аппаратное
ускорение.

- Лан, разобрались с SurfaceView, и получается надо рассмотреть кастомный вариант)
- Чо тогда эт за балалайка, ваш TextureViewRenderer?

А это, мой дорогой читатель, самая настоящая вьюшка, которая может в OpenGL(а значит и в аппаратное ускорение), и она не
имеет недостатков предыдущих вариантов, то есть:
1) может быть полупрозрачной, круглой, с дырой посередине, что хочешь - то и получишь
2) анимруй и перемещай как обычную вью
Почему его не использует webRTC и вокс, для меня пока загадка:)

А так это, по-сути, тоже самое что и SurfaceView, контейнер для поверхности(в данном случае это SurfaceTexture),
который может устанавливать положение и размер этой самой поверхности.

- Ага, но зачем тогда суета в виде переписывания уже и так написанных классов либы webRTC?

Краткий ответ - чтобы подружить EGL(именно его и использует webRTC) с TextureView,
которая по-умолчанию использует OpenGL, а также для того чтобы применить
необходимые трансформации, будто зеркальное отражение видоса, поворот, масштабирование и позиционирование.
*EGL отличается от OpenGL тем, что это не конкретный графический фреймворк, а абстракция над ними, под капотом которого может
быть как вышеназванный OpenGL, так и вулкан и т.д. и т.п., более полный список тут:
https://en.wikipedia.org/wiki/Khronos_Group

Давай расскажу что тут есть интересненького)
Итак сердце всего - TextureViewRenderer, его мы и используем в для отрисовки видоса, он единственный тут с публичной областью
видимости, остальные же классы - package private.

Рассмотрим их назначения и особенности:
*TextureViewRenderer* :
    а) Управляет ЖЦ всех потрохов(init(), release())
    б) Дает возможность преобразовывать SurfaceTexture(для целей указанных выше)
    в) Выступает адаптером между SurfaceTexture и EglSurface

*TextureEglRenderer* переопределён чтобы:
    а) прокинуть необходимые события в слушатель RendererEvents, будто отрисовка первого кадра, смена размеров и ротации.
    б) фиксировать ориентацию кадра(или задавать свою кастомную)
    в) правильно инициализирует и дестроит(потокобезопасно и с ретраем, если такой дестрой оборвался InterruptedException)

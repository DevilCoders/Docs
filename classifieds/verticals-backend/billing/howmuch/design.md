# Howmuch design doc

howmuch (a.k.a. price service) - сервис, аудируемо хранящий цены на продукты наших классифайдов.

Название выбрано из принципа: главный вопрос, на который отвечает сервис - "сколько стоит продукт на нашем сервисе?"

## Мотивация

Исторически, в авто.ру и недвижке были свои бэкенды ценобразования: мойша и абрам.

Они хранят цены в одном из следующих мест:
1. Прямо в коде, в одном большом паттерн-матче.
2. В одном огромном файле на десятки мегабайт.
3. В рекламной кампании в биллинге.

Какие проблемы есть в этом подходе:
1. Для цен в коде нужно участие бекэндеров для почти любого изменения цен.
2. Для каждого продукта каждого сервиса написан свой код, нет общего подхода.
3. Обновление цен не валидируется.
4. Сложно или невозможно понять, какая цена была выставлена для продукта при заданных параметрах в определённый момент времени.

К тому же, появился продуктовый запрос: реализовать аукцион стоимости звонков в авто. Его сложно/невозможно сделать на существовавших подходах.

Поэтому принято решение хранить ставки в аукционе в новом сервисе цен. А со временем перевести на этот сервис всё ценообразование в Вертикалях.

## Общая идея

Ранее мы пробовали сделать сервис цен один раз и навсегда, без привязки к конкретной задаче, сразу продумав абсолютно все детали. В итоге упёрлись в большой скоуп и ад бесконечных обсуждений, и в итоге дальше [дизайн-дока](https://wiki.yandex-team.ru/users/ilya-kuz/verticals-price-service-technical-design-doc) дело не пошло.

Теперь попробуем реализовать только часть сервиса, необходимую для цен на звонки в авто.ру. После проекта про аукционы его нужно будет улучшать.

Цели:
1. Получить аудируемое хранилище цен, в котором лежит вся история изменений. Нужно для ответов на вопросы от аудита и смежников "а почему цена была такой".
2. Наложить на возможности ценообразования максимально возможные ограничения.
   Упрощаем работу с ценами так, что для ответа на вопрос, сколько стоит услуга, достаточно сматчить запрос с ценовым правилом через ==.
   Нужно, чтобы не просто уметь отвечать аудиту и смежникам, а делать это легко.
3. Сделать основу, на которой можно в будущем сделать пункты из "не-цели прямо сейчас". Необходимо, чтобы howmuch не был доменно-специфичным сервисом.

Не-цели прямо сейчас:
1. Сделать изменение цен более удобным, исключив из этого процесса разработку (через админку).
2. Сделать умную валидацию цен.

## Терминология (кратко)

**Проект** - авто.ру/недвижка/дженерал. Любая сущность привязана к проекту. Для простоты далее проект обычно опущен.

**Продукт** - то, что пользователь покупает за некоторую денежную сумму.

**Критерий** - параметр, от которого зависит цена продукта. Имеет строковые ключ и значение.
Пример: mark = audi.

**Контекст** - набор критериев.
Пример: region_id = 10174, mark = audi, model = q7.

**Ценовое правило** - цена в матрице, соответствующая заданному контексту, и действующая в рамках временного интервала.
Пример:
id матрицы = call
контекст = (region_id = 10174, mark = audi, model = q7)
интервал действия правила = [2021-03-07; 2021-04-18)
цена = 5000 рублей

**Матрица** - список таких ценовых правил, что интервалы действия для одного контекста не пересекаются.

Пример:
```
id матрицы = call

(region_id = 10174, mark = audi, model = q7), [2021-03-07, 2021-04-18) -> 5000
(region_id = 10174, mark = audi, model = q7), [2021-04-18, infinity)   -> 6000
(region_id = 10174, mark = audi, model = tt), [2021-03-08, 2021-04-13) -> 4000
(region_id = 10174, mark = audi, model = tt), [2021-04-15, infinity)   -> 3000
```

Даты представлены просто для наглядности -- формально, это таймстемпы в UTC.

В любой момент времени ключи контекста в рамках матрицы совпадают. В примере выше - это всегда (region_id, mark, model).

id матрицы уникален в рамках проекта.

## Реалтаймовый API

Все ручки батчовые, для простоты описана работа с одним мессаджем.

**Запрос цены** - содержит id матрицы, контекст, timestamp.
Пример:
Запрос: (region_id = 10174, mark = audi, model = q7), timestamp = 2021-03-10
Ответ: 5000 рублей

Должен работать с поддержкой историчности.

Оценка порядка нагрузки: тысячи rps.

**Сохранение цен**. Юзкейсы:
1. Миграция исторических цен из мойши/абрама
2. Текущие цены (например, сохраняем ставки дилера)
3. Будущие цены (например, сохраняем базовые цены, действующие, когда ставок нет)

Ручка для миграции исторических цен является одноразовой на матрицу. Т.е. при наличии ценовых правил в матрице до выполнения запроса, эта ручка отдаёт ошибку. Так сделано, чтобы избежать изменения логики вычисления ценовых правил в прошлом.

Запросы на сохранение текущих и будущих цен идут в отдельную ручку от миграции, и отличаются только передаваемым from (началом действия правила):
1. Для текущих -- from считается равным now из howmuch, для избегания кейса "время на клиенте отстало от времени в howmuch, поэтому зареджектили запрос в прошлом".
2. Для будущих -- from в будущем.

Дополнительно, будет передаваться контекст и цена, либо флаг остановки действия правила. Также, для более явного изменения цен и для защиты от гонок, нужно указать, какую цену мы изменяем.

В будущем, может быть добавлена возможность "прикрыть" текущее ценовое правило другим временно (например, может быть полезно для распродаж). На старте отдельной ручки для этого кейса не будет, но можно реализовать такое руками через ручку загрузки будущих цен.

Оценка порядка нагрузки: <<1 rps, но периодически большими батчами, десятки-сотни тысяч строк.

## Нереалтаймовый API

Текущие ценовые правила будем периодически выгружать в S3 целиком.

Это необходимо для индексации авторушных объявлений.

## Схема матриц

Схема матрицы -- список ключей контекста в некоторый момент времени.

Он может эволюционировать. Пример:

```
(region_id = 10174, mark = audi, model = q7           ), [2021-03-18, 2021-04-18)   -> 6000
(region_id = 10174, mark = audi, model = tt           ), [2021-04-15, 2021-04-18)   -> 3000
(region_id = 10174, mark = audi, model = q7, gen = 123), [2021-04-18, infinity  )   -> 5000
(region_id = 10174, mark = audi, model = tt, gen = 124), [2021-04-18, infinity  )   -> 4000
```

Здесь с 18 апреля в схему матрицы добавился критерий gen. Т.е. с этого момента во всех правилах матрицы должен быть этот критерий.

Аналогично может происходить удаление критериев. После удаления во всех новых правилах матрицы критерий должен отсутствовать.

На старте версии схемы будут захардкожены, миграция будет производиться вручную.

## Фоллбеки

Часто нужна логика такого вида:
1. Попытаться получить цену по полному контексту.
2. Если не получилось, попытаться сделать это по уменьшенному контексту, и т.д.

Пример, как это реализовано: есть матрица:

```
id = call
(region_id = 10174, mark = audi, model = q7) -> 5000
(region_id = 10174, mark = audi, model = tt) -> 4000
// хочется использовать это правило для всех остальных, не указанных в call, моделей
(region_id = 10174, mark = audi) -> 6000
// для остальных марок
(region_id = 10174) -> 3000
```

Т.е. в общем случае, чтобы узнать цену звонка, нужно по очереди сходить в матрицу с параметрами (region_id, mark, model); затем (region_id, mark); затем (region_id).

Мы делаем это прозрачно для клиента. Он передаёт нам id матрицы и контекст, а мы уже знаем, что в матрице call нужно фоллбечиться.

Если фоллбек нужен, он всегда происходит отбрасыванием последнего критерия из списка, согласно схеме матрицы.

В схеме матрицы может быть прописано, что фоллбеки не нужны -- тогда запрещено создавать правила с частью критериев.

## Применение ценовых правил

Хочется иметь связь оплаты продукта с ценовым правилом. Т.е. в событии оплаты должен быть прописан уникальный id использованного ценового правила, полученный из howmuch-api вместе с ценой.

Также хочется быть уверенным, что в этом ценовом правиле в базе ничего не изменилось после оплаты (особенно цена).

Для этого id будем формировать как хеш от всех остальных полей ценового правила.

## Изменение цен в прошлом

В целом, оно запрещено. Иногда бывают ситуации, когда это всё же необходимо, например: [29 дней списывали неверную сумму за звонки со страницы дилера](https://st.yandex-team.ru/VERTISINCIDENTS-259).

В таких случаях это делает разработка вручную. API для этого не предполагается, по крайней мере, на старте.

Предполагается делать это по примерно такому алгоритму:
1. Берём все невалидные правила.
2. Бекапим их в соседнюю табличку (типа `canceled_rule`), обязательно оставляя ссылку на тикет или другой артефакт, говорящий о том, зачем мы это сделали.
3. Изменяем цены в правилах (в т.ч. хеши правил), опять же, положив в `source` ссылку на тот же артефакт.
4. Переобилливаем то, что обиллили не по той цене.

Но предпочтительно по возможности этого избегать, и проставлять новую цену в будущем, а не обновлять старую в прошлом.

## Схема данных

На старте достаточно иметь таблицу:

**rule_log** (хранит всю историю изменения цен):
- project
- matrix_id
- context
- from -- с какого момента действует это правило
- to -- до какого момента оно действует, или NULL для ещё не протухших правил
- price -- цена
- source -- для аудита. например, id тикета или апрувера
- hash(project, matrix_id, context, from, price, source)

(project, matrix_id, context, from) - уникальный ключ. По нему же нужно уметь быстро искать.

По хешу может быть необходимо искать, но скорее не в реалтайме, а при всяких ручных разборках. Поэтому можно обойтись и без индекса по нему.

Контекст хранится как kv-строка с разделителями, для человекочитаемости данных, в т.ч. в запросах для аудита.

## База данных

Выбор между классической реляционкой (MySQL/PostgreSQL) и YDB -- т.к. в любом случае, нам нужна транзакционность.

Плюсы реляционки для нас:
1. Нет шансов словить тормоза на распределённых транзакциях, кроме репликации (вероятно, некритично)
2. Если в будущем понадобятся фичи реляционки - можно будет их просто заюзать, вместо эмуляции вручную

Плюсы YDB для нас:
1. Проще избежать багов из-за аномалий, т.к. строгая консистентность (критично для базы цен)
2. Можно эффективнее заливать цены (полезно для жирных батчей от аналитиков)
3. TTL для индекса из коробки (некритично, т.к. легко эмулируется)

По плюсам YDB 1 и 2 выбираем YDB.

Нюансы:
1. В качестве shard_id (первого поля ключа) используем hash(project, matrix_id, context), для равномерного распределения нагрузки по шардам.
2. Чтобы избежать проблем с выгрузкой актуальных правил в S3 при росте объёма исторических данных, рядом с таблицей rule_log делаем таблицу actual_rule, в которой хранятся ценовые правила в том же виде, но с TTL = (to + 60 дней). 60 дней на случай, если мы захотим оптимизировать получение недавних цен в реалтайме (сканить историю не за всё время, а только за пару месяцев).

## Хотелки, которые передумали делать

1. Хотели представлять матрицу цен в виде дерева с фоллбеками. Например:

```
(region_id = 10174, mark = audi, model = q7) -> 5000
(region_id = 10174, mark = audi, model = tt) -> 4000
(region_id = 10174, mark = audi, model = * ) -> 6000
(region_id = 10174, mark = *   , model = * ) -> 3000
```

Где `*` -- любое значение, кроме указанных выше.

Почему решили так не делать:
- сравнение через `=` гораздо проще, чем обход дерева
- `*` дают слишком легко представить некоторые невалидные ситуации, например:
```
(region_id = 10174, mark = audi, model = q7) -> 5000
(region_id = 10174, mark = audi, model = tt) -> 4000
(region_id = 10174, mark = audi, model = * ) -> 6000
(region_id = 10174, mark = *   , model = a3) -> 3500 // это правило не должно существовать!
(region_id = 10174, mark = *   , model = * ) -> 3000
```

2. Хотели фоллбечные матрицы делать отдельными. Например:

```
id = call
(region_id = 10174, mark = audi, model = q7) -> 5000
(region_id = 10174, mark = audi, model = tt) -> 4000
```

```
id = call_just_mark
// хочется использовать это правило для всех остальных, не указанных в call, моделей
(region_id = 10174, mark = audi) -> 6000
```

```
id = call_just_region
// для остальных марок
(region_id = 10174) -> 3000
```

Почему решили так не делать:
- Надо как-то запрещать запрос в call_just_region
- Это сложнее, чем хранить данные в одной матрице

3. Хотели не делать в howmuch никакую логику про фоллбеки, вместо этого оставить её на стороне клиентов.

Почему решили так не делать: логика определения цены таким образом сильнее размазывается.

4. Хотели вообще никогда не делать фоллбеки, а вместо этого всегда заполнять матрицу целиком. Например:

```
(region_id = 10174, mark = audi, model = q7) -> 5000
(region_id = 10174, mark = audi, model = tt) -> 4000
// здесь не фоллбек, а явно указываем все возможные комбинации
(region_id = 10174, mark = audi, model = a3) -> 6000
(region_id = 10174, mark = audi, model = a4) -> 6000
```

Почему решили так не делать:
- в тарифах указаны всё же не все возможные комбинации => эмулируем домен не совсем точно
- редактировать "фоллбеки" в такой схеме можно исключительно групповыми операциями -- выглядит, что здесь легко ошибиться
- нужны дополнительные процессы, синхронизирующие геобазу, каталог, ... с хранилищем howmuch

5. Хотели каждый раз атомарно обновлять всю матрицу целиком.

Почему решили так не делать: появилась матрица ставок дилеров в аукционах. В ней нужно обновлять ценовые правила отдельно от всей матрицы. Решили, что это же имеет смысл и в других матрицах.

При этом, атомарное обновление всей матрицы реализуемо, если можно атомарно обновлять конкретное правило.

6. Хотели отдавать цены из api из in-memory, а не из персистентной базы.

Почему решили так не делать: появилась матрица ставок дилеров в аукционах. В ней нужен read-your-writes. Кроме того, возможно, перекладывание в in-memory - преждевременная оптимизация.

7. Хотели давать возможность делать поисковые запросы цен по части критериев матрицы.

Почему решили так не делать: в абсолютном большинстве матриц эта фича не нужна. В целом, она плохо ложится на дизайн howmuch.

8. Хотели хранить даты действия ценового правила в локальной таймзоне, а не в UTC.

Почему решили так не делать: со временем таймзона может меняться. Поэтому хранение локального времени усложняет:
- Валидацию, точно ли ценовые правила не пересекаются по времени -- вместо банального >/< чиселок надо сначала конвертить их в UTC, ведь таймзона может быть разной в разных строчках. Что сильно усложняет понимание происходящего, т.к. процесс конвертации в UTC сложен.
- Поиск подходящего правила -- опять же, вместо условного `from < $timestamp order by from desc limit 1` нужно загрузить всю историю правила, и найти подходящее, с учётом таймзон.

9. Хотели делать read your writes в матрицах: после сохранения цены, действующей с now, можно получить эту цену, передав now.

Большая часть матриц изменяется заранее, по запросу от нашего бизнеса. Типичный пример -- повысить цены с 1 числа следующего месяца.

Но есть матрицы, которые изменяются пользователями в интерфейсе. Они изменяются с текущего момента времени. Для них важен read your writes: юзер сохранил правило, а затем получил его же get-запросом.

Наивное решение проблемы: сохраняем правило со сроком действия `[now; +inf)`, а затем селектим правило, действующее в момент `now`.
Это решение не будет верно работать, если `now` при сохранении правила окажется больше, чем `now` при селекте. Это возможно, т.к. в общем случае, часы не монотонны.

Корректное решение проблемы:
1. Делаем свойство матрицы: реалтаймовость. Для реалтаймовых матриц можно создавать, обновлять и останавливать ценовые правила только в текущий момент времени, но не в будущий.
2. Делаем способ вытаскивания текущих данных такой матрицы. В ручке патча цен актуализируем эти данные.
3. Даём в апи получать цены на текущий момент. Если пришёл такой запрос для реалтаймовой матрицы, запрашиваем цену способом из п.2. Если такой запрос пришёл для нереалтаймовой матрицы, запрашиваем цену, как обычно, глядя на интервал `[from; to)`.

Таким образом, если юзер сохранил правило со сроком действия `[now; +inf)`, а после этого запросил правило на момент `now`, мы отдадим ему сохранённое правило.
Аналогично, будет верно работать, если юзер остановил правило, после чего запросил текущее правило.

Почему решили так не делать: выглядит, что это нужно только в одном кейсе -- для матриц аукционов. Выглядит как переусложнение howmuch ради одного кейса. В итоге решили проблему костылём на стороне аукционов: они запрашивают цену с from = now + 5 минут, чтобы минимизировать вероятность отсутствия гарантии.


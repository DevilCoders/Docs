# Решаемая проблема
Сейчас промокодер используется для выдачи/списания кэшбека.
Кэшбек не в доменной области промокодера, и его использование в этом месте выглядит костыльно.
Само апи используется не тем способом, который изначально задумывался. При работе с кэшбеком таким образом возникают
сложности и у команд, которые его используют.

Хочется иметь возможность работать с конкретными транзакциями-списаниями кэшбека. Например чтобы их можно было отменять.
Хочется скрыть сложность работы с промокодером в этом сервисе. Позже избавиться от промокодера в области работы с кэшбеком.

Почему делаем сейчас - делаем проект цель которого научиться списывать кэшбек за звонки.
Это было бы ещё одно место, в котором было бы нужно использовать неудобный для кэшбека промокодер.

В первом приближении api должно быть удобно для решения задачи списания кэшбека за звонки.
Далее оно должно быть просто удобным.
# Решение
Делаем новый сервис с удобным апи для работы с кэшбеком.<br/>
Перевозим тех кто использует промокодер на новое апи.<br/>
Перевозим данные и заменяем имплементацию так, чтобы промокодер не использовался.

# Модель
## Api

**Сделать платёж(withdraw).**</br>
workspace, clientId, paymentId, amountKopecks

workspace

clientId

paymentId
Для первой реализации кэшбека за звонки оказалось удобно передавать id платежа снаружи (это будет id звонка),
для того чтобы в первой реализации в сервисе который будет списывать кэшбек за звонки не хранить список успешных транзакций.

amountKopecks - сколько списать с кэшбека

**Вернуть платёж(refund)**<br/>
workspace, clientId, paymentId<br/>
Возврат - терминальный статус, если мы вернули платёж с ним больше ничего сделать нельзя.

**Отменить платёж(cancel)**<br/>
workspace, clientId, paymentId<br/>
При отмене платежа для пользователя сервиса, сервис должен выглядеть так, как будто платёж никогда и не делали.
Идея отмены возникла из-за того что для первой реализации списания кэшбека за звонки для какой-то части звонков, списывать правильное кол-во
кэшбека только на второй итерации обиливания. И первую итерацию нужно отменить. При этом пользователь кэшбек-сервиса
будет знать id звонка и не сможет сгенерить новый идентификатор для списания.
Альтернатива этого решения - разрешить несколько списаний и возвратов для одного платежа.
Но несколько списаний и возвратов звучит как неожиданная логика в апи(это можно обсудить).

## Внутренняя модель сервиса
**Платёж**<br/>
Мутабельная сущность с которой работают на уровне api.
В api статус платежа, например платёж может быть возвращён.

**Транзакция (Отвечает на вопрос - что происходило с платежом)**<br/>
Иммутабельная сущность с которой работаем на уровне базы.
Это запись об успешном событии - таком как Списание, Возврат, Отмена.
По списку таких событий легко получить текущее состояние платежа.
Работать с иммутабельными записями выглядит хорошей идеей, когда работаем с любого рода списаниями.

**Кошелёк с кэшбеком**<br/> (Т.к эта сущность не в первом этапе плана, возможно её не будет или будет называться иначе)
Отвечает на вопрос - сколько есть кэшбека?<br/>
Дополнительное требование - кэшбек может сгорать, т.е есть какой-то дедлайн после которого им нельзя воспользоваться.<br/>
Возможно будет требование - одновременно активен ровно один кэшбек(тут ещё нужно разговаривать с продуктом/думать).<br/>
Если это требование будет, реализация будет проще.

# Схема хранения данных
## Транзакции
таблица transactions<br/>
shard_id, workspace, client_id, payment_id, transaction_id, sequence_number, transaction_type, amount_kopecks, epoch<br/>
PR shard_id, workspace, client_id, payment_id, transaction_id<br/>

**shard_id** считаем как хэш от workspace, client_id, payment_id.<br/>
От shard_id зависит в какой шард попадёт строка. Для большинства запросов в базу мы хотим чтобы запрос попадал в один шард
(такие запросы работают гораздо быстрее), и при этом чтобы нагрузка на разные шарды была равномерно распределена.
Почему выбран так: Таким образом все транзакции(история что происходило с платежом) из одного workspace, для одного клиента,
по одному payment_id будут в одном шарде. Это основной запрос который нам нужен. История у каждого платежа будет не большой,
т.е ожидаем что данные будут равномерно распределены по разным шардам. И запросы тоже будут равномерно распределены по разным шардам.

**workspace** - cтрока вида autoru_loyalty. У сервиса autoru их может быть несколько(сейчас так и есть).
Сервис сам будет запоминать какие у него есть workspace-ы.
**client_id** - строка. Любой идентификатор клиента в сервисе.<br/>
**payment_id** - идентификатор платежа<br/>

**transaction_id** - строка<br/>
Идентификатор платежа, уникальный для в (workspace + client_id)<br/>
Сейчас transaction_id = payment_id#sequence_number<br/>
Когда понадобится работать с конкретным id транзакции, мы сможем из id транзакции получить payment_id(id платежа) и сделать запрос полностью по PR.

**sequence_number** - число<br/>
Порядковый номер для ордеринга событий по платежу. epoch использовать нельзя, т.к пишем его со стороны приложения и нельзя гарантировать
что с разных инстансов приложения время строго возрастает.
В конечном итоге последний sequence_number и запись нового будет происходить внутри serializable транзакции.

**epoch** - время записи в базу, просто для удобства.

## Платёж
Каждый раз вычисляем его состояние по списку транзакций


## Кошелёк с кэшбеком
Cхема подробно не придумана, на первом этапе не нужен.

# Нагрузка
В начале, звонков в autoru примерно 20к в день.
Т.к нам нужно 2 раза пройти через цикл - получается примерно 40к запросов в день.
Распределены они более менее равномерно в течении дня.

В конечном итоге по звонкам будет примерно 20к в день(будет не нужен повторный цикл).
Плюс все остальные списания будут проходить через кэшбек-сервис. Их кол-во мы не оценивали.

# Интеграции
promocoder (временно)
broker

# Масштабирование
В целевом варианте у сервиса две части.
Инстансы сервиса в которых нет стейта, для масштабирования нужно выкатить больше инстансов.
И ydb-база, которая масштабируется сама.

# Отказоустойчивость
Аналогично, полагаемся на гарантии, которые нам предоставляет ydb.
Т.к сервис про списания, на какой-то кэш полагаться в процессе не можем.

# Доступность для аналитики
Успешные транзакции будем писать в брокер(а он будет писать в YT).

# Альтернативные решения
Использовать промокодер, не делать новый сервис.
Могло быть валидным решением, но таким образом мы бы увеличили кол-во техдолга.

Использовать postgre для базы, а не ydb.
Postgre показался сложнее, потому что для реализации подобной логики на postgre нужно использовать локи.
Реализации на ydb выглядит проще, т.к в конечном итоге все действия можем делать внутри транзакции с уровнем изоляции serializable.
Т.е работать с логикой так, как будто события происходят одно за другим.
Ещё одним признаком по которому выглядело что ydb хорошо подходит - выглядит что нам нужны запросы по ключу и нет каких-то больших списков в ответе.
Т.е мы всегда ищем по ключу несколько записей.

# План
Первый этап - это реализация на промокодере, с тем апи которое мы хотим иметь в итоге.
Примерный план, как делать списание (success path)
1. Получаем список транзакций по платежу из ydb
2. Проверяем валидный ли запрос для состояния платежа (например если списание уже сделано, нельзя делать ещё одно с этим же id)
3. Делаем идемпотентное списание с фичи в промокодере. Используем следующий transaction_id как id идемпотентности для промокодера.
4. Записываем успешный результат в ydb
Для корректной обработки стейта в промокодере в случае ошибок, возможно появится ещё таблица для работы с промокодером.

Возврат/отмена списания для промокодера будут выглядеть также, если нужно, будет сделано списание с отрицательной суммой,
чтобы вернуть деньги на фичу.

Второй этап - использовать его в других сервисах вместо промокодера. Кэшбек нигде не списывается и не пополняется не через этот сервис.
Третий этап - перестать использовать промокодер в имплементации, перевезти данные. Сущность кошелька с кэшбеком появляется где-то на этом этапе.

# Будущее развитие
- Если понадобится, в будущем появится api, в котором можно работать с конкретными транзакциями(с конкретными событиями платежа списание/возврат).
- Если понадобится, можно добавить возможность генерить id платежей в сервисе и возвращать их из сервиса.
- Если понадобится для аналитики, добавим аналогичный лог с записью не успешных списаний. На первый взгляд выглядит не нужным.
Финансовая статистика
- Возможно сервис можно обобщить до абстрактного кошелька, не только для работы с кэшбеком. Или можно вынести общую для кошелька часть в отдельный сервис, а здесь оставить api удобное для работы с кэшбеком.
- Протянуть историю списаний в финстату. В этой области есть разные идеи, но нет решения как делать. Сложность в том, что для показа списка транзакций нам понадобится иметь поля "сколько списали денег и сколько списали кэшбека
в одной записи.
# Риски
В первой реализации обработка ошибок сложная.
Возможно понадобится ещё таблица для записи запросов в промокодер, возможно понадобятся какие-то действия, если
мы каким-то образом получили неконсистентный стейт запроса в сервис-состояния в промокодере-состояния у нас.
Этих проблем не будет, когда в имплементации откажемся от промокодера.

# Для написания дизайн-дока использовал шаблон
https://docs.yandex-team.ru/classifieds-infra/verticals-backend/development/new-service/best-practices/design-doc

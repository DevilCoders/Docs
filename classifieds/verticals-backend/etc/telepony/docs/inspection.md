# Проверка работоспособности подменников

### Важно:
Это design doc в состоянии "до" написания кода as is.
Реализация находится в `NumberInspectionServiceImpl`!

## Описание

Хотим (полу-)автоматически проверять номера на дозвон через скрипт вокса.

- [Тикет](https://st.yandex-team.ru/TELEPONY-2180)
- [Чуть чуть диаграмм про статусы](https://whimsical.com/telepony-check-redirect-proxy-phone-2XB6ocz8UBBoiGmBCLJXC)

## Контекст
В пуле много подменников, часть из них не проверялась на работоспособность, часть может ломаться в неожиданные моменты. Нужно сделать механизм проверки работоспособности прохождения звонков по ним.
Также отметим, что сейчас проверки дозвона осуществяются людьми, что не очень эффективно.

## Контекст про код

Возможные переходы номеров доменного пула между статусами очень сложны (т.к. затрагивают консистентные изменения в редиректах) и размазаны по многим сервисам и таскам в коде.


## Примерный план

1. Каким-то образом атомарно переводим номер/батч номеров в статус `OnCheck`. Переход возможен только из статусов `New`, `Ready`, `Downtimed` и возможно `Garbage`. Как именно переводим номера - подумаем позже. Тут есть ручные, автоматические варианты, из текущего редиректа с его удалением/заменой и т.п.
2. Пул номеров с доп информацией в этом статусе нужно использовать как в некотором роде очередь. Для каждого номера нужно хранить некоторое состояние. Начинаем с `new`. Также нужно понимать, в какие статусы мы хотим перевести номера
3. Выгребаем номер/батч номеров для проверки. Помечаем номера `in progress`. Запускаем скрипт вокса для проверки с ними.
4. В скрипте делаем pstn вызов на номер. Результаты и коды отправляем в реактив апи.
5. В реактив апи реализуем online сбор таких звонков из вокса. Отправляем в специальном формате в отдельный топик.
6. В контроллере делаем оффлайн получение истории из вокса. Отправляем в специальном формате в отдельный топик.
7. В сборе звонков оффлайн и онлайн операторов нужно проверять, если это звонок по номеру, который в статусе проверки - то не собирать обычный звонок, а собирать специальную информацию и отправлять во второй отдельный топик.
   Таким образом такие обзвоны не будут вообще видны нашему антифроду.
- **Проблема 1:** а если к моменту сбора у номера уже другой статус? Решение: нужно хранить отдельно историю проверок номеров!
  Еще нужно помнить, что все тестовые звонки будут со специальных известных номеров (так что может история и не нужна).
- **Проблема 2:** а как операторы отреагируют на массовый прозвон их номеров с единого callerId? Решение: нужно договориться с операторами о помещении этого номера в белый список и о допустимом рейте таких звонков.
8. Делаем новый компонент, который читает новые топики, смотрит на новую табличку. Основная задача - понять, проходит звонок или нет.
   Также нужно контролировать количество ретраев проверок и время между ними.
   При этом, нужно актуализировать результат и состояние в новой таблице (`failed`, `success`, `retry`).
9. Делаем новую таску шедулера, которая обрабатывают по новой таблице терминальные состояния (`failed`, `success`).
   Также нужно определить, какие дальнейшие действия. В метаинформации нужно хранить, из какого состояния пришел звонок (статус и ttl) и в какое состояние его перевезти. Например, нужно понять, продлевать ли ttl и т.д.
- Меняем статус номера в основной таблице доменных номеров.
- Создаем жалобу, если надо.
- Возможно, нужно отправлять фейлы в отдельную поставку брокера.
10. Также нужна таска, которая будет обрабатывать `retry`.


## Схема данных:

1. Добавляем статус `on_check` для доменного пула.
2. Делаем таблицу проверок номеров (ydb, но это можно решить позже)
   Это "горячая таблица", после синка статуса номера из нее удаляются (очередь)
- number
- domain
- operator
- account
- createTs
- updateTs
- shouldCheckAfterTs
- state Enum(`new`, `in_progress`, `processing`, `failed`, `success`, `retry`)
- operatorInfo - тут техническая информация от операторов (коды и т.п.)
- PK state, shouldCheckAfterTs
- IDX number

3. Делаем таблицу **истории** проверок номеров (ydb, но это можно решить позже). Возможно, эта таблица не требуется.
- number
- domain
- operator
- account
- startTime - время, когда создали для проверки
- endTime - время, когда убрали из проверки (опционально)
- result - результ проверки (`failed`, `success`) (опционально)
- PK number - подумать, нужен ли домен, оператор или аккаунт. пока кажется, не нужны.

## Про скрипт

- Скрипт должен запускаться через апи
- В скрипт передается номер и callerId
- В скрипте производится вызов callPSTN
- Я бы еще добавил tts автоинформатора (чтобы было какое-то медиа в звонке)
- Все события (нужно конкретизировать) отправлять в ручку реактив апи и сохранять в custom data для оффлайн сбора

## Про сбор звонка
На основе вокса нужно делать вывод со стороны вокса.
Также нужно на основе кодов от операторов строить результат по операторам.
Затем нужно уметь мержить любое кол-во из 4-х (оффлайн/онлайн вокс/оператор) в конечный результат.
При сборе нужно будет подумать, в каком формате хранить эту техническую информацию.
Должны быть четкие критерии, когда нам уже достаточно информации.
В `processing` нельзя висеть долго, нужно переводить в терминальный статус по ttl .(?)

## Состояния проверки

- `new` - новый
- `in_progress` - взяли в работу в таске проверки
- `processing` - отправили в вокс в скрипт и ждем результаты
- `failed` - проверка неудачная
- `success` - проверка удачная
- `retry` - что-то пошло не так, нужен ретрай проверки

## Открытые вопросы

- Какую нагрузку выдержит Vox по callPSTN и по запускам скрипта?
- Какую нагрузку выдержат операторы, и как обезопасить наши callerId от их антиспама?
- Какую нагрузку ожидаем в среднем в день, если проверять все New/Downtimed номера (в разбивке по доменам)
- **ВАЖНО:** Точно ли проверка номеров без редиректов будет иметь смысл для операторов, которые не работают с реактив апи. Возможно, нужно будет подсовывать фейковый редирект (кстати, это может быть тоже скрипт вокса с автоинформатором TTS - но тогда сбор сильно усложнится).


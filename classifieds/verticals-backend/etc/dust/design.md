# Dust - сервис кластеризации диалогов
Диалогом в данном случае является текст общения двух пользователей.

## Решаемые задачи
Группировка диалогов в кластеры, позволяющие определить сценарии общения.
В дальнейшем это можно будет использовать для модерации и аналитики.
Примеры сценариев:
- Обзвон из авито / спамеры
- Выкуп / не выкуп авто

## Термины
`Диалог/Dialog` - текст общения двух пользователей.
Это может быть как переписка в чате, так и транскрипция звонка.
Диалог в рамках сервиса кластеризации - неизменяемая сущность.

`Модель кластеризации` - некоторый способ объединения диалогов в кластера.

`Домен` - некоторая предметная область диалогов.
Например, могут быть диалога-транскрипции разговоров из недвижимости или переписки в чатах авто.

`Тип кластера/Cluster type` - конкретная модель кластеризации
некоторым образом объединяет диалоги в кластера.
Для диалогов разных доменов, а так же для разных задач диалогов одного домена
могут быть использованы разные модели кластеризации.

## Про кластера и типы кластеров
- Разбивание одних и тех же диалогов на кластера может быть
  разным в зависимости от сценария кластеризации.
- При кластеризации мы можем хотеть кластеризовать лишь часть
  существующих в сервисе диалогов, пришедших из одного внешнего источника
  (например, не смешивать диалоги из недвиги и транскрипции звонков из авто)

Поэтому могут понадобиться разные модели кластеризации,
в соответствие которым ставится тип кластера (`cluster_type`).
Таким образом один и тот же диалог может принадлежать не более чем к одному кластеру в некотором типе кластера,
но может быть кластеризован в разных типах кластеров.

## Про версии
Используемые модели кластеризации могут меняться (например, дообучаться).
При переходе на измененную модель что-то может пойти не так (вдруг модель получилась "плохая").
Тогда может понадобиться фоллбек на предыдущую версию.
Для этого мы храним актуальные версии моделей каждого типа кластера,
а так же версионируем результаты кластеризации
и храним как минимум текущий результат + результат предыдущей версии, если такой имеется.
Версии результатов кластеризации приходят вместе с самими результатами из нирваны.
Так же, можно будет завести процесс, который удаляет все результаты выше данной версии -
при фоллбеке на меньшую версию просто запускать его.

## Про взаимодействие с нирваной
Для кластеризации используем модельки, запускающиеся в нирване на данных, лежаших в yt-е.
Есть два работы с этими данными и нирваной:
1. Используем брокер для поставки данных в yt и генерации артефактов реактора,
   которые инициируют вызов таски в нирване
   + Не нужно генерировать из кода артефакты реактора, брокер сделает это за нас
   + Не нужно самим собирать батчи диалогов, брокер сделает это за нас
   - Так как моделей кластеризации может быть много, для каждой нужны будут свои входные
     данные - одной поставкой в брокер дело не ограничится, он не умеет класть данные в разные места.
     Нужно либо заводить поставку для каждой новой модельки,
     либо триггерить реактором таску в нирване, которая сгруппирует данные из входного батча по `cluster_type`-ам
     и отдаст их нужным таскам нирваны с конкретными моделями, сгенерировав для них артефакты реактора.
2. Сами отправляем входные данные в yt и генерируем артефакты реактора, инициируя запуск тасок в нирване
   + Можем сразу класть отдельно данные для каждой модели кластеризации, не нужны дополнительные
     промежуточные таски в нирване, либо множественные поставки брокера
   + Так как сами инициируем запуск тасок, можем мониторить, какие таски бегут долго, алертить, если очень долго
   - Нужно самим собирать батчи (через очередь-таблицу на кластеризацию)
   - Нужно из кода генерировать артефакты реактора
   - Сложнее схема данных (таблица-очередь, таблица запущенных тасок нирваны)

Вариант с множеством поставок в брокер - самый простой и понятный, но звучит костыльно.
Однако, на старте у нас некоторое время будет только одна модель.
Поэтому стартуем с поставкой на модель, а когда нужно будет несколько моделей -
подъедет тикет https://st.yandex-team.ru/VSDATA-1241 - субпоставки в брокере по фильтрам.


## Компоненты

### API
Grpc API для управления очередью кластеризации и получения результатов кластеризации.

#### Получение результатов кластеризации по id диалога и cluster_type
1. Идем в таблицу `dialogs`, получаем диалог по `dialog_id`
2. Если записи нет - возвращаем Not Found
3. Идем в таблицу `statuses`, пытаемся получить запись по `dialog_id` и `cluster_type`.
4. Если записи нет - возвращаем Not Found
5. Если есть запись в статусе `PROCESSED` - идем за результатами в таблицу `dialogs_clusters`,
   получаем результаты с максимальной версией и отдаем.
   Если записи нет - отдаем просто статус.

#### Листинг диалогов в данном кластере по cluster_id, cluster_type, pagination
Отдаем все диалоги, состоящие в данном кластере
1. Идем в таблицу `dialogs_clusters`, получаем по `cluster_id` и `cluster_type` идентификаторы диалогов
3. Отдаем наружу с информацией о пагинации
Пагинация нужна, потому что всегда могут быть жирные кластера, а ydb больше 1000 сущностей в запросе не отдаст.

#### Изменение актуальной версии некоторого типа кластера по new_version, cluster_type
Меняем актуальную версию модели для данного типа кластера. Используется при обновлении модели кластеризации данного типа кластера.
1. Идем в таблицу `versions`, upsert-им версию по cluster_type (нужна ли валидация с предыдущей версией?)

#### Получение актуальной версии некоторого типа кластера по cluster_type
1. Идем в таблицу `versions`, пытаемся получить версию по `cluster_type` и вернуть.
  Если не нашли - возвращаем Not Found.

#### Добавление диалога в очередь на кластеризацию по dialog_id, dialog_info (опционально), коллекции cluster_type
Инициируем кластеризацию для переданного диалога
Предполагаем, что в dialog_info лежат текст диалога и домен
1. Пытаемся получить существующий диалог по dialog_id в таблице `dialogs`
  - Если получили - валидируем домен, возможные изменения диалога игнорируем
  - Если не получили - создаем новую запись в таблице по dialog_info
    Если же dialog_info при этом не пришло - возвращаем Bad Request
2. Для каждого `cluster_type` получаем из таблицы `statuses` статус кластеризации диалога.
3. Кладем запись в брокер для кластеризации через нирвану для каждого `cluster_type`,
   в котором не идет кластеризация в данный момент.
4. Для каждого `cluster_type` ставим статус `IN_PROGRESS` в таблице `statuses`
5. Возвращаем набор cluster_type-ов, для которых запустилась кластеризация.

### Scheduler
Запускает асинхронные таски для кластеризации офферов

#### Таска чтения топика с диалогами на кластеризацию
Читаем из кафка-топика диалоги, которые необходимо кластеризовать.
Логика схожа с ручкой апи добавления диалога в очередь на кластеризацию.
Для каждого диалога
1. Пытаемся получить существующий диалог по dialog_id в таблице `dialogs`
- Если получили - валидируем домен, возможные изменения диалога игнорируем
- Если не получили - создаем новую запись в таблице по dialog_info
  Если же dialog_info при этом не пришло - возвращаем Bad Request
2. Для каждого `cluster_type` получаем из таблицы `statuses` статус кластеризации диалога.
3. Кладем запись в брокер для кластеризации через нирвану для каждого `cluster_type`,
   в котором не идет кластеризация в данный момент.
4. Для каждого `cluster_type` ставим статус `IN_PROGRESS` в таблице `statuses`
5. Логируем, в каких cluster_type-ах добавили в очередь, а в каких кластеризация в процессе.

p.s. возможно, это не лучший способ сообщения сервису, какие записи нужны кластеризовать из-за отсутствия ответа о том,
какие диалоги мы действительно поставили кластеризоваться.

#### Таска обхода работающих инстансов нирваны
Поллит локации в yt, куда нирвана кладет результаты кластеризации, чтобы получить их.
1. Забираем из yt результаты очередной кластеризации, если таковые появились (путь пока не известен).
2. Для каждого результата обновляем запись в таблице `dialogs_clusters`,
   устанавливаем статус `PROCESSED` в таблице `statuses`

#### Таска подсчета записей, находящихся в кластеризации
Ходит в таблицу `statuses`, собирает общее количество записей в статусе
`IN_PROGRESS`, и отдельно количество записей в статусе `IN_PROGRESS`,
которые в нем больше часа (используя колонку `updated_at`)

## Хранилище
Используем ydb
- данных может стать много, а ydb хорошо масштабируется.
- нам не нужны какие-либо сложные индексы
- в Вертикалях уже довольно хорошая экспертиза и средства для взаимодействия с ydb

### Таблица с диалогами
Храним необходимую для кластеризации информацию о диалоге (текст общения), чтобы можно было перекластеризовывать.
Идентификатор `dialog_id` - внешний, это может быть callId из телепони или id чата из авто.

Основные сценарии:
- Получение диалога по идентификатору `dialog_id`

`dialogs`:
  - `shard: Int32` - шард/партиция, считается на основе id диалога
  - `dialog_id: Utf8` - id диалога, задается снаружи
  - `proto: String` - протобаф с диалогом, нужен для кластеризации
  - `domain: Utf8` - домен диалога

  `PK = (shard, dialog_id)` - первичный ключ

### Таблица со статусами кластеризации
Храним информацию о статусе кластеризации данного диалога в данном типе кластера.
Нужно, чтобы отличать диалог, который никогда не кластеризовался в данном типе от кластеризующегося в данный момент.

Основные сценарии:
- Получение статуса диалога по внутреннему идентификатору и типу кластера

`statuses`:
  - `shard: Int32` - шард/партиция, считается на основе id диалога
  - `dialog_id: Utf8` - id диалога
  - `cluster_type: Utf8` - тип кластера
  - `updated_at: UInt64` - таймстемп последнего изменения
  - `status: UInt32` - id статуса кластеризации
    `0 = IN_PROGRESS` - диалог в данный момент кластеризуется в данном типе кластеров
    `1 = PROCESSED` - диалог кластеризован в данном типе кластеров

  `PK = (shard, dialog_id, cluster_type)` - первичный ключ
  `updates_idx = (status, updated_at)` - для посчета долго обрабатываемых диалогов

### Таблица с результатами кластеризации
Храним результаты кластеризации диалогов в данном типе кластера с данной версией.
Версия нужна, чтобы при переходе на обновленную модель уметь фоллбечить на предыдущую версию.

Основные сценарии:
- Получение кластера диалога в данном типе кластера по внутреннему идентификатору диалога
- Получение списка диалогов по идентификатору кластера в данном типе кластера

`dialogs_clusters` - таблица с результатами кластеризации диалогов
  - `shard: Int32` - шард/партиция, считается на основе id диалога
  - `dialog_id: Utf8` - id диалога
  - `cluster_type: Utf8` - тип кластера
  - `version: Int32` - версия модели кластеризации
  - `cluster_id: Utf8` - идентификатор кластера

  `PK = (shard, dialog_id, cluster_type, version)` - первичный ключ
  `cluster_dialogs = (cluster_id, cluster_type, version)` - глобальный индекс для быстрых походов за диалогами одного кластера


### Таблица с версиями
Храним актуальные версии моделей кластеризации разных типов кластеров.
Используется при кластеризации для выставления версии в результате кластеризации

Основные сценарии:
- Получение версии по типу кластера

`versions`
  - `cluster_type: Utf8` - тип кластера
  - `version: Int32` - актуальная версия

  `PK = (cluster_type)` - первичный ключ
  
## Про взаимодействие с сервисом и обработку результатов кластеризации

Предполагается, что результаты кластеризации будут в дальнейшем размечаться модерацией.
Для получения результатов планируется API, возможно сделаем запись результатов в топик в кафке.

# FeatureToggles v2 design doc

Сервис для работы с фича-флагами.

Разделяем 3 кейса:

- Фича-флаги, переключающие функциональность сразу везде, живущие в пределах одного сервиса.
- AB-эксперименты с выкаткой на долю. Обычно сквозные.
- Динамический конфиг – набор связанных между собой полей с возможностью частичного обновления и валидацией согласованности данных.

Здесь планируется покрыть кейс 1.  
Кейс 2 вполне покрывается [abt](https://ab.yandex-team.ru/observation) (там специфический интерфейс, но работать с ним можно, и он довольно фичастый).  
Кейс 3 правильнее решать на уровне сервиса – только он понимает гранулярность изменений и правила. Но при поддержке protobuf в качестве типа фичи, сервис в теории может быть использован и для этого кейса тоже.

## Задачи

1) По заветам trunk-based development, фичи должны быстро попадать в мастер, даже не в готовом состоянии. Это позволит интегрировать работу чаще и не плодить долгоживущие ветки.

2) Фичи позволяют разделить по времени выкладку кода от включение фичи, например, для функциональности, которая еще не поддержана смежниками

3) C помощью фич можно быстро откатывать неудачные фичи.

4) Фича-флаги можно использовать как kill switches – деградировать сервис под слишком высокой нагрузкой, отключая некритичную функциональность полностью или частично.


## Текущее решение

Текущий подход заключается в интеграции в приложение библиотеки, напрямую работающую с Zookeeper. Ее недостатки:

1) Тяжелая зависимость на zookeeper (нельзя поменять сторадж). Решается через pluggable-storage.
2) Отсутствие центральной истории изменений (хотя есть и те, кто поддержал это в zk)
3) Нет api для управления, сервис должен реализовать его сам
4) ACL без staff-авторизации и только через тикет в VASUP
5) UI через ZooNavigator, либо через тикет в VSIF (админка)

## Решение

Все перечисленные пункты решаются, если между непосредственным хранилищем конфигурации и потребителями вставить промежуточный бэкенд. Это позволяет сделать различные интеграции (например, staff-авторизацию и провязку с картой сервисов).

Помимо сервера также требуется клиентская библиотека, которая упрощает работу с фича-флагами.

## API (server)

[gRPC-API](https://a.yandex-team.ru/arcadia/classifieds/schema-registry/proto/feature-toggles/api.proto)

Планируется поддержка только простых типов фича-флагов: bool, string, int64.  
В теории string-фичи можно использовать для хранения json или protobuf, но сервис никак не будет интерпретировать protobuf и вы получите невнятную историю изменений, а так же не самый приятный вид в ui.
В будущем, возможно, будут поддержаны protobuf-фичи, но без проверки эволюции и возможности изменить FQDN существующей фичи.

Все мутирующие методы будут иметь обязательную аутентификацию через TVM user-ticket'ы.
Авторизация через [API](https://docs.yandex-team.ru/classifieds-infra/deploy/integration/api) над картой сервисов.

Есть два подхода к получению значения флага:
1) **push** – клиент держит соединение с сервером и получает апдейты, текущий стейт поддерживает сам. 
2) **pull** – периодический опрос на предмет изменения, стейта нет.

Предпочтительным вариантом является **push** (метод `Watch`). Для **pull** есть методы `Get`/`List`, кеширование должно быть на стороне сервисов. 

## API (client)
Начнем со scala-клиента на zio в базель-монорепе, в случае успеха и наличия желающих вынесем в отдельный репозиторий и, возможно, перепишем на scala с минимумом зависимостей от библиотек.

## Процесс работы с фичами
- Регистрация фичи происходит из сервиса, зарегистрировать фичу получится фичу только в своем неймспейсе = имени сервиса. Это будет проверяться через TVM service-ticket и поход в карту сервисов. Регистрация происходит только при отсутствии фичи в сторадже, если фича с таким именем уже есть, то переписана она не будет, а будет выдано предупреждение.
- Изменение значение фичи доступно только пользователю – владельцу сервиса через админку с user-ticket соответственно. Удаление – аналогично. Подобные действия будут отражены в истории.
- Перерегистрация существующих фич не допускается. При необходимости изменить тип фичи, придется ее сначала явно удалить через админку.
- Сервис может подписаться на неймспейсы других сервисов и получать изменения чужих фич.

## Еще мысли
- Раз все знание в одном месте, проще в теории делать разные плюшки типа аннотаций в графане на изменение флага.
- Большинство типов фич, кроме kill switch, должны жить ограниченное время. Можно добавить механизм ttl, а так же некоторую телеметрию использования фич в сервисах, чтобы затем помечать в UI более не используемые фичи.
- Для удобства переезда возможна миграция существующих фич в zk в новый сервис.
- Для использования во фронтенде, возможно, не подойдет описанная pull-модель с периодическими опросами, скорее понадобится поход за фичами на каждый пользовательский запрос. Мы вряд ли захотим выдерживать нагрузку в десятки тысяч рпс, так что тут понадобятся кэши и еще подумать.
- Поинт про отказ от zookeeper не работает до тех пор, пока нет альтернативы текущему token distributor, которым пользуются большинство пользователей текущих фича-флагов.

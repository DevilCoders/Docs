#Сервис для работы с изображениями

## Решаемая задача
Выполнение различных вычислений над изображением или их преобразование
Асинхронное вычисление и кеширование результатов позволяют
 - не хранить в оффере производные данные, то есть, те, которые могут быть вычислены на основе уже имеющихся
 - не хранить в оффере все возможные производные данные по картинкам, дообогащать ими только там где их нужно отдать
 - легко пересчитывать эту информацию без необходимости перезаписывать офферы
 - ускорить работу стейджей госта, достаточно будет вызывать нужный метод, не дожидаясь фактического вычисления, и _в какой-то момент_
   `gateway` сможет подтянуть их результат при отдаче

## Определения

### функция 
   - произвольная операция над изображением, принимает на вход ссылку на картинку и специфичные для функции
     дополнительные аргументы
   - каждой функции должен быть поставлен в соответствие метод API возвращающий результат её работы
   - функция не обязательно чистая
        
### задача
запись в очереди, содержит имя функции и аргументы к которым она должна быть применена

### url
координаты изображения в аватарнице
 
## Функции
### Поворот 
 - (url, angle) -> url
 - Создаёт новое изображение, повернутое на заданный угол
 - сохраняет результат (в s3 или аватарницу?)
### Превью 
 - url -> Array[Byte]
 - Создаёт изображение очень низкого разрешения
### Ratio 
 - url -> (W, H, R)
 - получает из аватарницы размеры оригинального изображения, вычисляет соотношение сторон
### Главный цвет
 - url -> RGB 
 - вычисляет главный цвет изображения

## Компоненты

### Public API
  - grpc
  - по методу на каждую функцию 
  - функция принимает аргументы и опции
    - аргументы
      - ссылка на изображение
      - опции функции
    - опции 
      - `ttl` - время хранения результата - если не задано - пусть используется дефолтное
      - `cache-only` - не пытаться вычислить если нет в кеше
      - `compute` - игнорировать кеш (или удалить)?, форсировать создание задачи
  - сначала ищем результаты в кеше (если не `compute`)
  - если найдено - отдаём результат
  - если не найдено в кеше и не `cache-only` - создаётся задача и помещается в очередь, возвращается статус
      
### Обработчик очереди задач
  - параметризуется списком функций которые будет вычислять
    - это позволит отдельно масштабировать количество обработчиков для каждой функции
  - для каждой функции параметризуется списком партиций (в случае с кафкой этого не нужно)
    - параллелизм на уровне одной функции
    - партиций сразу делаем много, при малой нагрузке один обработчик может слушать сразу все партиции
    - партиция считается на основе аргументов 
  - вытягивает из очереди задачи для заданных функций и партиций
  - передаёт аргументы в функции
  - сохраняет результаты
  - ошибки обработки можно разделить на восстанавливаемые и невосстанавливаемые
    - невосстанавливаемые ошибки - например по ссылке не изображение
    - восстанавливаемые - например не смогли скачать, отправить в начало очереди, увеличить счётчик ретраев
      по достижении максимального количества ретраев - удалить
  
## Внешние зависимости

### Очередь
#### kafka
 - по топику на функцию
 - не нужно назначать партиции, они сами распределяться среди потребителей
 - можно подписать обработчик на несколько топиков разом
 - нужно делать дедупликацию повторных запросов вручную - например проверять есть ли уже вычисленный результат в кеше и скипать обработку
#### БД
 - таблица вида (функция, партиция, время создания, аргументы)
 - обработчик получает самые старые записи для назначенных функций и партиций
 - после обработки запись удаляется
 - нужно опрашивать вручную
 - дедупликация повторных запросов возможна либо при pk=(функция, партиция, аргументы) либо так же как на кафке, 
   при этом для получения задач в обработку необходим индекс (функция, партиция, время)
#### redis pub-sub
 - вероятно не подойдёт, редис не хранит публикуемые события, только буферизирует
   при падении обработчиков все запросы потеряются
### Хранение результатов
результаты можно хранить как key-value, ключ считается как хеш от функции и аргументов, по нему же можно шардировать
#### БД
  - таблица вида (ключ, результат: proto)
  - postgres бд потребует шедулер следящий за ttl
  - ydb поддерживает ttl
#### Redis
  - простая работа с ttl
  - быстрый
  - ограничен оперативной памятью
  - можно сделать шардирование на клиенте
#### Двухслойное хранение
  - редис как кеш, бд как хранилище
  - позволит хранить больше чем только редис, может отдавать результаты быстрее чем только бд
  - полезно если обращение к ключам будет неравномерное, то есть, есть более "горячие" ключи
  - ttl в редис можно копировать из базы при кешировании
  
## Сценарии использования
 - `gost` в своих стейджах может обращаться к функциям, ставить задачи в очередь, таким образом к моменту показа оффера
   в выдаче нужные данные будут уже вычислены, при этом стейдж не ждёт завершения этих вычислений
 - gateway при отдаче листинга офферов/карточки запрашивает по урлам изображений необходимые производные данные
   этих изображений
  
## Порядок реализации
  - [модель апи](https://st.yandex-team.ru/CLASSBACK-506)
  - [модель задачи](https://st.yandex-team.ru/CLASSBACK-507)
  - [модель хранимого результата](https://st.yandex-team.ru/CLASSBACK-508)
  - [реализация апи (для начала можно сделать синхронное вычисление результата без кеширования)](https://st.yandex-team.ru/CLASSBACK-509)
  - [реализация функций](https://st.yandex-team.ru/CLASSBACK-510)
  - [хранилище результатов (пока нет обработчика просто писать в него вычисленное)](https://st.yandex-team.ru/CLASSBACK-511)
  - [очередь (пока нет обработчика можно дублировать запросы в очередь и вычитывать заглушкой)](https://st.yandex-team.ru/CLASSBACK-512)
  - [обработчик результатов](https://st.yandex-team.ru/CLASSBACK-513)
  
## Открытые вопросы
  - если для какого-то изображения было форсировано вычисление, нужно ли удалять из кеша
    или же пусть остальные запросы читают старую версию
  - в случае ошибки обработки можно записывать в результаты статус и ошибку, это может быть полезно если по ссылке
    не изображение, нет смысла пытаться его каждый раз обработать
  - можно сразу при помещении задачи в очередь писать статус в кеш - повторные запросы в таком случае будут сразу
    отдавать этот статус, в случае успешного вычисления - пишем на его место резульатат, в случае ошибки - статус ошибки
  - нужен ли способ уведомления потребителя о готовности результата
    - топик результатов
    - какой-нибудь коллбек, например ссылка, которую нужно будет дернуть

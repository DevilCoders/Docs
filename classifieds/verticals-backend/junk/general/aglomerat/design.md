# Сервис кластеризации объявлений

Платформа для запуска различных алгоритмов кластеризации объявлений и получения их результатов

## Описание

*Алгоритм кластеризации* состоит из функции попарного сравнения, которая для двух объявлений
возвращает некоторый уровень уверенности в том, насколько эти объявления похожи
Также алгоритм может содержать эвристики, позволяющие уменьшить количество сравнений, например условие, что
есть смысл попарно сравнивать только объявления с одинаковой категорией

В результате работы *алгоритма кластеризации* образуются *кластеры* объявлений - непересекающиеся множества,
В рамках одного кластера для любой пары объявлений функция попарного сравнения должна выдавать заданный уровень уверенности

Каждый алгоритм кластеризации задаёт *тип кластера*, в соответствие которому ставится идентификатор
таким образом — объявление может принадлежать только к одному кластеру каждого типа

Зачем нужны разные типы кластеров?
Разные функции (алгоритмы) кластеризации могут быть полезны для решения разных задач, 
кроме того, можно присваивать разные типы кластера несовместимым версиям
одного алгоритма, это позволит осуществлять постепенный переход и легкий
откат если что-то пойдёт не так

## Решаемая задача
Группировка опубликованных объявлений в кластеры, которые впоследствии можно
использовать для решения различных задач, например:
 - улучшение разнообразия выдачи за счёт отображения одного наиболее релевантного объявления из каждого кластера
 - улучшение рекомендаций — можно рекомендовать сразу кластеры, а не отдельные объявления
 - ???

## Компоненты

### API
  - Принимает id объявления и id типа кластера — возвращает id кластера
  - Принимает id объявления — возвращает мапу из id типа кластера в id кластера (?)
  - Принимает id типа кластера и id кластера — возвращает список id объявлений
  - Есть смысл сразу делать батчевые ручки для всех запросов выше  
  - Принимает пару (id_1, id_2) идентификаторов объявлений и id алгоритма — создаёт склейку кластеров с логикой
    "объявление с id_1 теперь принадлежит к тому же кластеру, что и id_2"
  - Принимает пару идентификатор объявления и тип кластера, удаляет привязку к кластеру если такая есть, ничего не возвращает  
  - ручка принудительного запуска кластеризации (?)

### Планировщик 
  - Запускает таски выполняющие батчевую кластеризацию офферов
  - Запускает переливку результата кластеризации из YT в YDB  
  - Подчищает старые версии кластеризаций из YDB

### Консюмер
  - на начальном этапе не нужен
  - может использоваться для потоковой кластеризации объявлений
  - может использоваться для "гибридной" кластеризации если это возможно — объявления кластеризуются батчами, между запусками
    джобы изменяющиеся объявления "подвязываются" в кластеры потоково, если этот процесс будет работать достаточно хорошо — 
    можно будет реже запускать батчевую джобу

## Внешние зависимости
  - YT
  - YDB

## Хранилище

### Индексы по результатам кластеризации
Индекс будем хранить в YDB

`offer_clusters`
  - `shard: Int32` - нужен для балансировки, считается на основе id объявления
  - `offer_id: Utf8` - id объявления
  - `cluster_type: Utf8` - id типа кластера 
  - `version: Uint32` - версия кластеризации
  - `cluster_id: Utf8` - id кластера соответствующего типа 
  - `meta: Object` - какая-нибудь мета, почему это объявление попало в этот кластер, например, может быть полезно для отладки
   
  `PK = (shard, offer_id, cluster_type, version)`  - первичный ключ, ищем к какому кластеру принадлежит объявление
  `cluster_offers = (cluster_id, cluster_type, version)` - глобальный индекс - ищем какие объявления принадлежат к кластеру

`active_versions`
  - `cluster_type: Utf8` - id типа кластера
  - `version: Uint32` - текущая полностью залитая версия

  `PK = (cluster_type, version)`

`version` - заводим для консистентности, использоваться будет так:
для батчевых алгоритмов кластеризации каждое успешное завершение порождает новую версию, соответствующая
версии таблица будет лежать в YT

Запускаем наливку из YT в YDB, при успешном завершении наливки устанавливаем новую версию
соответствующему типу кластера в таблице `active_versions`

Из апи всегда обращаемся к последней версии из `active_versions`, её можно кешировать в in-memory для скорости

### Результаты кластеризации в YT

Результаты кластеризации будем хранить в YT
Периодически запускается кластеризация, по завершению результаты наливаются в индекс YDB

Таблицы должны иметь следующую структуру:

`../${cluster_type}/${version}`
  - `offer_id: Utf8`
  - `cluster_id: Utf8`
  - `meta: Object?`

### Ручные склейки

Скорее всего, ручные склейки кластеров будут привязаны к конкретному типу кластера, в случае
`search_duplicates` вероятно даже не понадобятся

`cluster_bindings`
  - `shard: Int32` - нужен для балансировки, считаетяс на основе id объявления
  - `offer_id: Utf8` - id объявления
  - `cluster_type: Utf8` - id типа кластера
  - `bind_to: Utf8` - id объявления, к чьему кластеру будет привязано это объявление

  `PK = (shard, offer_id, cluster_type)`

С такой схемой может возникнуть ситуация, когда объявления циклически ссылаются друг на друга, 
можно либо разрешить это, обнаруживать такие цепочки и считать их одним кластером, либо запретить
одному id объявления появляться одновременно в колонках `offer_id` и `inherit_from` 
(это можно сделать в запросе на вставку)

## Реализуемые типы кластеров

### `search_duplicates`  
  в кластер объединяются все офферы удовлетворяющие условию — 
    принадлежат одному продавцу И 
    находятся в одном регионе И 
    значения всех полей кроме **адреса** и **телефона** полностью совпадают

  Реализация — этот тип кластера можно сделать относительно просто с помощью YQL запроса — берём снепшот госта,
  для каждого объявления считаем хеш, зависящий от продавца, региона, всех ugc полей кроме адреса и телефона
  этот хеш и будет id кластера

## Ожидаемые сложности

- В случае с батчевой кластеризацией будут достаточно большие задержки в появлении `cluster_id` у объявления, 
  это может приводить, например, к тому что после публикации фида объявления в выдаче будут какое-то время
  "расклеены"
- в зависимости от алгоритма, могут возникать ситуации когда в разных версиях одно и то же объявление может попадать в 
  разные кластеры
- В случае с потоковой — здесь мы решаем проблему из предыдущего пункта, задержка становится меньше, но могут возникнуть
  ситуации, когда из-за ошибок система попадает в нежелательное состояние, и это влияет на весь дальнейший поток, 
  то есть одна ошибка может сделать невалидной все результаты вычисленные после того как она произошла. Вариант решения — 
  возможность сбросить состояние в случае ошибки и рассчитать кластеры заново, например батчевой задачей
- Хочется чтобы кластеры были не слишком большие и не слишком маленькие, здесь кажется можно только подбирать коэффициенты, 
  всё очень специфично в зависимости от алгоритма
- в случае с потоковой кластеризацией нужно уметь склеивать и, возможно, расклеивать кластеры
- если у объявления поменялся кластер - неплохо бы его переиндексировать в поиске, если конечно этот тип кластера
  влияет на поисковую выдачу

## Возможные улучшения

- Топик с событиями — изменение кластера для объявления, для батчевых это выглядит немного страшно, 
  будет прилетать несколько миллионов ивентов огромной пачкой
- Кеши для наиболее горячих запросов в YDB, ближайший горизонт — это постоянные запросы в API при индексации

## Эвристики алгоритмов кластеризации
  - если мы начнём использовать векторные представления объявлений 
    проверять для каждого кандидата все объявления кластера будет неоптимально, есть вариант хранить для каждого кластера
    центроид всех входящих векторов и сравнивать только с ним, в теории этот центроид может ещё для чего-нибудь пригодиться
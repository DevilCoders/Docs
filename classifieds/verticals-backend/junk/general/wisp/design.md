# WISP - Сервис чатов Яндекс.Объявлений
Функционирует на основе Яндекс мессенджера.

Решает следующие задачи:
- Создает и управляет чатами пользователей на платформе мессенджера
- Маскирует пользователя Я.Паспорта под его имя с сервиса объявлений(из general-users)
- Пишет логи сообщений в [брокер](https://github.com/YandexClassifieds/etc-mono/blob/master/services/broker/docs/design.md)
- Обеспечивает безопасность чатов:
    - Ходит в ["чистый веб"](https://wiki.yandex-team.ru/jandekspoisk/antispam/cleanweb/). Таким образом обеспечивается фильтрация фродовых ссылокб порно и спама
- Предоставляет инструментарий для реализации пользовательских сценариев (оплата, доставка) _ToDo - описать инструментарий_
- Отправка уведомлений о непрочитанных сообщениях пользователям
- Предоставляет доступ к истории переписки для модерации

Не решает следующие задачи:
- Хранение списка комнат, истории сообщений
- Отправка сообщений пользователем
- Работа со службой поддержки

## Сущности
`Чатом` в этом документе будем называть переписку между двумя пользователями Яндекс.Объявлений,
построенную вокруг конкретного объявления. <br>
В чате должно отображаться имя [пользователя на нашем сервисе](https://github.com/YandexClassifieds/verticals-backend/blob/master/general/users/design-doc.md#хранение) (может отличаться от паспорта).<br>
В названии чата в списке чатов и внутри чата показываем объявление, про которое ведется диалог.<br>
Новый чат можно создать через карточку объявления.

`Комнатой` будем называть чат Яндекс Мессенджера.

`Владельцем ботов` будем называть особого пользователя, заведенного нами, с подтвержденным телефоном.
Телефон важно не забывать переподтверждать раз в год.<br>
На имя этого пользователя будем создавать всех ботов в [АПИ ботплатформы](https://bp.mssngr.yandex.net/docs/api/meta/)

### Идентификаторы

`uid` - паспортный идентификатор пользователя. Используется во многих сервисах Яндекса, в том числе в Объявлениях и Мессенджере.
Uid есть у всех юзеров мессенджера и у его ботов.

`guid` - идентификатор юзера в мессенджере. Так же есть и у юзера и у бота. Внутри мессенджера есть отображение 1-1 guid-ов на uid-ы.

## Архитектура
Мессенджер имеет ряд ограничений, которые не подходят нам продуктово:
- показывает личные данные из Яндекс.Паспорта - мы хотим показывать имя на нашем сервисе
- не позволяет создать несколько личных чатов с одним пользователем - мы хотим один чат на одно объявление
- я.мессенджер не предупреждает пользователя о возможном мошенничестве, когда ему предлагают перейти в другой мессенджер

В качестве обхода этих ограничений используется следущая архитектура чатов
![](chat_scheme.jpg)
- На каждого пользователя Яндекс.Объявлений заводится бот в [ботплатформе мессенджера](https://bp.mssngr.yandex.net/docs/).<br>
Бот принадлежит владельцу ботов.<br>
Имя и аватар бота берем из настроек пользователя на Яндекс.Объявлениях.
- На каждый чат создаем по 2 комнаты, как показано на рисунке.
- Каждый пользователь общается не напрямую со своим собеседником, а с ботом, представляющим его на сервисе Яндекс.Объявлений.
- Организуем пересылку сообщений от пользователя к боту, и от бота к пользователю

Для отправки системных сообщений (причины скрытия сообщения, баны) в чаты используется бот Я.Объявлений, который имеет возможность писать во все чаты (но не читать!), не находясь в них.

## Хранилище

`chats` – таблица с чатами
- `buyer_id: Utf8` – паспортный id покупателя
- `offer_id: Utf8` – id оффера, вокруг которого строится чат
- `seller_id: Utf8` – паспортный id продавца
- `buyer_room_id: Utf8` - id комнаты "Покупатель + бот продавца"
- `seller_room_id: Utf8` - id комнаты "Продавец + бот покупателя" <br>
`PK = (buyer_id, offer_id)`<br>
    Индексы:
    - buyer_room_id
    - seller_room_id
    - seller_id

`bots` – таблица с ботами
- `user_id: Utf8` – паспортный id пользователя
- `bot_uid: Utf8` – uid бота, соответствующего пользователю
- `bot_guid: Utf8` – guid бота, соответствующего пользователю <br>
`PK = (bot_uid)`<br>
    Индексы:
    - user_id

`locks` - таблица с локами на создание чатов
- `buyer_id: Utf8` - паспортный id покупателя
- `offer_id: Utf8` - id оффера, вокруг которого строится чат
- `expired_at: Int64` - таймстемп протухания лока в милисекундах
`PK = (buyer_id, offer_id)` <br> 

`unreads` - таблица с информацией о непрочитанных пользователями сообщениях
- `room_id: Utf8` - id комнаты мессенджера
- `last_read_message: Int64?` - timestamp/id последнего прочитанного пользователем сообщения
- `last_notified_message: Int64?` - timestmp/id последнего сообщения, по которому отправлялась нотификация
- `last_message: Int64` - timestamp/id последнего сообщения в комнате
- `notify_after: Int64?` - timestamp, после которого можно будет уведомить пользователя из комнаты о непрочитанных сообщениях
`PK = (room_id)` <br>
    Индексы:
    - notify_after
    
## Компоненты

### API
Grpc api для управления чатами.

#### Получение чата по (buyer_id, offer_id)
Пытаемся получить существующий чат, иначе создаем новый:
1. Создаем по боту на каждого пользователя(или берем существующих)
    - nickname однозначно вычисляем из user_id
    - Устанавливаем аватарку и имя
2. Создаем блокировку в таблице Locks по buyerId и offerId для создания чата
3. Проверяем, не забанен ли один из будущих собеседников в чатах, в случае наличия бана чат не создается
4. Создаем комнату buyerRoom
5. Создаем запись о чате
6. Удаляем блокировку в таблице Locks

### Internal API
Внутреннее grpc api для модерации

#### Получение чатов пользователя по (user_id, page, page_size)
Возвращаем список чатов пользователя, учитывая только чаты с хотя бы одним пользовательским сообщением
Для каждого чата отдаем offer_id, buyer_id, seller_id, seller_room_id, buyer_room_id, и кем является пользователь в данном чате
1. Достаем из базы чаты, в который пользователь состосит как buyer или seller, содержащие непустую sellerRoomId (есть сообщения), применяя пагинацию на основе page и page_size
2. Отдаем во вне результат

#### Получение истории сообщений по (room_id, max_timestamp, limit)
Возвращаем историю сообщений чата мессенджера с идентификатором room_id.
Возвращается не более limit сообщений с timestamp < max_timestamp, включая удаленные и сообщения с негативными вердиктами чистого веба.
Если max_timestamp не указан или 0, возвращаем limit самых свежих сообщений.
1. Идем в базу за нужным чатом по room_id
2. Если чат не существует, возвращаем NOT_FOUND
3. Получив чат, идем в ручку fanout_api [/history](https://wiki.yandex-team.ru/messenger/fanoutapi/#/history) для получения истории сообщений из комнаты продавца
4. Отдаем список полученных сообщений, указывая для каждого сообщения текст, отправителя, таймстемп, а так же набор fileId, если у сообщения есть прикрепленные медиа

#### Получение медиа из чата по (file_id)
Отдаем файл/фото из чата по file_id и room_id мессенджера
1. Получаем токен системного бота объявлений
2. Идем в ручку bot_api [/file/<file_id>](https://bp.mssngr.yandex.net/docs/api/bot/methods/#poluchenie-soderzhimogo-faila-po-file-id) с токеном бота
3. Проксируем результат во вне

### Webhooks
Http Api для обработки поступающих [сообщений от ботов](https://bp.mssngr.yandex.net/docs/api/bot/methods/#poluchenie-obnovlenii).

Имеет только 1 endpoint для обработки входящего сообщения для бота:
1. По id комнаты запрашиваем инфу о чате из хранилища
2. Если пришедшее сообщение - маркер прочитанности:
    1. Если в таблице `Unreads` есть запись для комнаты, обновляем в ней `last_read_message`. Если теперь `last_read_message` == `last_message`, сбрасываем у записи `notify_after`.
    Если записи нет - создаем запись с last_read_message
    2. Используя id сообщения(которое так же является timestamp-ом) как maxTimestamp с limit 1 получаем последнее сообщение с таким таймстемпом из ручки fanout_api [/history](https://wiki.yandex-team.ru/messenger/fanoutapi/#/history).
        При этом указывая комнату, сопряженную той, из которой получили апдейт.
    3. Из полученного сообщения получаем его айдишник, посылаем маркер прочитанности через bot api по данному айдишнику в сопряженную комнату.
        Идея в том, что если пользователь прочитал сообщение, значит в сопряженной комнате оно было на 1-2 секунды раньше, поэтому используя айди сообщения как таймстемп, мы получим искомое сообщение из сопряженной комнаты и сможем обозначить его прочитанным.
3. Если пришедшее сообщение - сообщение от пользователя:
    1. Если один из собеседников забанен в чатах - сообщение не пересылается.
    2. Создаем блокировку в таблице Locks по buyerId и offerId для проверки существования sellerRoom
    3. Если sellerRoom еще не создано - создаем её и обновляем запись о чате
    4. Удаляем блокировку в таблице Locks
    5. Логируем сообщение в [брокер](https://github.com/YandexClassifieds/etc-mono/blob/master/services/broker/docs/design.md)
    6. Идем в ["чистый веб"](https://wiki.yandex-team.ru/jandekspoisk/antispam/cleanweb/) (ЧВ)
    7. В случае бан-вердикта антифрода (АФ) от чистого веба баним отправителя в чатах, сообщение не пересылаем.
       - Для бана идем в ручку сервиса [users](https://github.com/YandexClassifieds/verticals-backend/blob/72c4c9040a4d89493f275605ca996b737f3febcc/schema-registry/proto/general/users/api.proto#L42)
    8. В случае негативных реакции от чистого веба
       1. Скрываем сообщение в мессенджере через [посылку вердиктов модерации](https://wiki.yandex-team.ru/messenger/fanoutapi/#/push)
       2. Пишем сообщение о причине скрытия от имени бота объявлений
    9. В случае отправки файлов, [шейрим](https://github.com/YandexClassifieds/verticals-backend/blob/679851564589f119d7350c65a447954a03dd7e5a/general/wisp/clients/messenger-meta-api/MessengerMetaApiClient.scala#L18) их в чат получателя (в доке мессенджера нет этого метода:( )
       Еще есть [такой тикет с инфой](https://st.yandex-team.ru/CLASSBACK-1068)
    10. Пересылаем контент сообщения, если нет негативных вердиктов от ЧВ и АФ
        1. По id ботов достаем их OAuth токены из [api](https://bp.mssngr.yandex.net/docs/api/meta/methods/#poluchenie-novogo-tokena)
        2. Отправляем от имени второго бота сообщение второму пользователю
        3. Если в таблице `Unreads` для комнаты, в которую было отправлено сообщение, нет записи. создаем её, иначе обновляем у нее `last_message`
    
Так же в webhooks есть фоновый процесс для обработки таблицы `Unreads`  и оповещения пользователей, у которых есть непрочитанные сообщения.
Процесс работает на основе vertis-scheduler, рассылая нотификации раз в n минут.
1. Читаем записи из таблицы `Unreads`, у которых `notify_after` < now
2. Для каждой записи
    1. По `roomId` получаем чат и id пользователя, находящихся в комнате
    2. Используя guid бота объявлений и считая minTimestamp = max(`last_read_message`, `last_notified_message`) из таблицы получаем непрочитанные сообщения из ручки [истории сообщений](https://wiki.yandex-team.ru/messenger/fanoutapi/#/history)
    3. Получаем email и телефон пользователя, находящегося в комнате
    4. Формируем из текстов сообщение, которое отправляем по email-у пользователя, а так же смс-кой на телефон.
    5. Сбрасываем `notify_after` у записи, и устанавливаем ей новый last_notified_message по последнему отправленному в письме сообщению

#### Получение OAuth токенов ботов

Для получение Oauth токена из апи ботплатформы нужен userTicket владельца ботов <br>
Для получения userTicket-a будем ходить в blackbox (в реалтайме или переодически) c OAuth токеном авторизации владельца ботов. <br>
OAuth токен авторизации храним в секретнице.
    
### Consumers
Сервис подписан на топик в кафке `general-users`(топик событий изменения пользователей Объявлений), чтобы обновлять у ботов имена и аватарки, когда у соответствующих юзеров они поменялись.
Сервис подписан на топик в кафке `gost-offer-updates`(топик событий изменения самих объявлений), чтобы обновлять название и аватарку чата, когда соответствующее объявление изменилось.

### Лог событий
Wisp репортит [события](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/general/wisp/events_model.proto) в [брокер](https://github.com/YandexClassifieds/etc-mono/blob/master/services/broker/docs/design.md), при этом для медиа используются координаты из Я.Мессенджера.
Для получения самого контента медиа сообщений по координатам можно воспользоваться [Files Api](https://wiki.yandex-team.ru/messenger/api/#m-filesapi) мессенджера.

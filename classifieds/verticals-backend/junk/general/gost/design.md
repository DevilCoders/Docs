# GOST Design Doc

## Требования
- **50 млн.** активных объявлений.
- **500 тыс.** новых объявлений в день.
- **180 млн.** архивных объявлений в год.
- Размер объвления - до **100 кб**.
- Нагрузка на чтение – 20к рпс
- Нагрузка на запись – 5к рпс

NB! Как получены числа:

Взяли нагрузку автошного воса (в пике шедулер обрабатывает около 1к объявлений в секунду),
и умножили на (случайную) константу 5

## Компоненты
GOST состоит из двух частей – `API` и `scheduler`.

## Черновики
Перед публикацией объявление является черновиком. 
Черновики позволяют хранить недозаполненные объявления или объявления от незалогинившегося продавца.
У продавца может быть не более одного черновика. При этом продавцом может считаться как анонимный пользователь, так и залогиненный.

Логика сброса черновиков:<br>
Если клиент передал id желаемой категории черновика и ни один из черновиков(черновик анонима или черновик залогина) не принадлежит этой категории, то сбрасываем один из его черновиков(оставляем залогина в приоритете) с сохранением id<br>
Если под категорию подходит только один из черновиков, то он переносится на залогина(если возможно), а остальные затираются.<br>
Если под категорию подходят оба черновика, или же категорию не передали вообще, то выбирается самый новый черновик(с максимальным lastUpdateTimestamp). 

## Формирование offer_id
Каждое объявление имеет глобальный уникальный идентификатор.
Некоторые требования:
 - невозможность перебора (нельзя использовать авто-инкремент)
 - уникальность в рамках фида
 - человекочитаемость для обращения в службу поддержки. Короткое цифровое представление. TODO: спорный момент, стоит уточнить

Сейчас используются UUID. При конфликтах нужен ретрай. 

## Валидация объявлений
TODO

## Экспорт в топик
Экспорт происходит в режиме `at-least-once delivery`.

При модификации данных помимо таблицы `offer` все изменения пишутся в нужный шард таблицы `queue`. 
Сам экспорт осуществляется одним или несколькими инстансами `gost-scheduler`. 
Распределение работы происходит через `zookeeper` (с помощью `TokenDistributor`).
Каждый инстанс обрабатывает свою часть шардов, вычитывает батч изменений (начиная с самых старых) и пишет его в топик в параллель.
После этого весь батч удаляется из базы.

Важно, что батч не должен содержать изменения по одному объявлению.
В противном случае это может повлечь за собой реордеринг событий.

## Личный кабинет частника и магазина
Фундаментальной проблемой организации хранения данных для ЛК является наличие очень крупных продавцов.
Потенциально имеющих порядка 1 млн объявлений. Сортировки, фильтрация и счетчики для такого объема данных в стандартных
реляционных базах быстро работать не будут. YDB также ограничена и не эффективна в джойнах по нескольким индексным таблицам.
Поэтому в ЛК в MVP можно управлять только пресетом (таблица `user_offer_presets`) – дополнительные фильтры и различные
сортировки не предусмотрены. YDB хранит данные отсортированные по ключу, что позволяет нам, добавив время создания
объявления в ключ, получить дефолтную сортировку по этому значению в рамках пресета. 
Для каждого пресета пользователя в отдельной таблице (`user_offer_presets_count`) хранится количество объявлений
попадающих под него. Набор пресетов и таблица счетчиков обновляются при изменении объявления. Пресеты под которые
попадает оффер вычисляются при сохранении объявления из данных находящихся в самом оффере.
Риски: сохранения офффера и обновления таблиц пресетов происходит в одной транзакции. Что гарантирует консистентность
данных. Но в случае расхождения счетчиков с реальным количеством записей в таблице, их нужно как-то починить.
Решения на данным момент нет. Возможный вариант:
сделать запрос `select seller_id, preset_id, count(*) from user_offer_presets group by (seller_id, preset_id)`
и его результат вставить в таблицу `user_offer_presets_count`. Но 1) это очень долгий запрос 2) данные в `user_offer_presets`
обновляются с потенциальной нагрузкой несколько тысяч rps. Полученный результат будет либо не актуальный, либо нужно 
останавливать запись. 

## Модерация (TBD)
`Scheduler` вычитывает топик с опинионами модерации и сохраняет их в сервисе.

## Автозагрузка (TBD)
Массовая загрузка объявлений.

Загрузка идет через стрим событий с явным событием окончания загрузки. 
Каждое сообщение идентифицируется `seller_id` и `task_id` (монотонно растет в пределах фида).

Процесс выглядит примерно так:
- сервис автозагрузки высчитывает внешний id объявления `external_id` (vin, id от партнера или хеш от контента)
- ищем `external_id` среди существующих (не удаленных, но включая забаненных) объявлений в рамках `seller_id`.  
- если объявление уже было обновлено более поздним `task_id`, оно игнорируется (мы должны были его уже обработать).
- сматченные объявления обновляются (учитывая баны объявлений)
- несматченные объявления создаются
- все старые объявления, которых нет в фиде удаляются

Матчинг происходит по неудаленным объявлениям (в дальнейшем это может распространиться и на недавно удаленные объявления).
Это нужно, чтобы не генерировать новые идентификаторы
Удаление можно построить по схеме автору с небольшими отличиями:
На основе таблицы с офферами строится вспомогательные таблица `feed`.
При получении сообщения о конце загрузки пытаемся в несколько заходов почистить таблицу (и данные) 
`SELECT * FROM feed WHERE seller_id = ? AND task_id < ? LIMIT 1000;`.
Коммит оффсета происходит в момент, все старые объявления удалены (select ничего не нашел).

### Обработка фотографий
Фотографии, переданные пользователем, необходимо залить в [Аватарницу](https://wiki.yandex-team.ru/mds/avatars/) для эффективной раздачи и нарезки на нужные размеры.
Для этого будет использоваться сервис [Pica-pica](https://wiki.yandex-team.ru/vertis/pica-pica/)

При публикации объявления `Gost` делает запрос на прокачку фотографий (если они есть) в `Pica-pica` и сохраняет исходные урлы в базу.
В пейлоад кладется `offerId` для последующего матчинга.
Далее шедулер читает топик ответов `Pica-pica` и добавляет их в объявление.

Вопросы:
 - как избежать амплификации трафика? Сравнивать до/после?
 - нужен ли промежуточный статус перед публикацией (не публиковать без фотографий)?
 - как информацию (ошибки/статистику) по изображениям донести до статистики фида и нужно ли?


## Стейджи (TBD)
В отличие от VOS стейджи работают вне сервиса. 
Если стейджу необходимо сохранить стейт, он может использовать GOST как key-value (пейлоад при этом не прозрачен для GOST).

## Счетчики
В процессе обновления офферов GOST накапливает глобальную статистику продавца в счетчиках.

Счетчики, отражающие текущее состояние личного кабинета (могут и увеличиваться, и уменьшаться):
 - Active - количество активных объявлений продавца на текущий момент;
 - Expired - количество протухших (завершенных) объявлений продавца на текущий момент;
 - Banned - количество заблокированных объявлений продавца на данный момент;

Счетчики, отражающие общую статистику взаимодействия с сервисом (всегда растут):
 - Sold - общее количество объявлений, по которым были совершены успешные сделки (количество объявлений, когда-либо пребывавших в статусе SoldOnYandex)
 - MoneyEarned - общая выручка продавца на сервисе. Сумма цен проданных объявлений, при условии, что была указана цена на момент продажи.

## Хранение
Данные хранятся в YDB.

`draft` – таблица с черновиками
 - `owner_id: Utf8` – id владельца черновика
 - `id: Utf8` – id черновика
 - `proto: String` – данные черновика в [protobuf](storage/proto/draft_model.proto)-формате 

`PK = (seller_id, id)`

`current_draft` – таблица с текущими черновиками
 - `owner_id: Utf8` – id владельца черновика
 - `draft_id: Utf8` – id черновика

`PK = (seller_id)`

`offer` – таблица с данными по объявлениям
 - `id: Utf8` – id объявления
 - `kind: Utf8` – тип данных (само объявление, данные модерации, биллинга)
 - `proto: String` – данные в protobuf-формате 

`PK = (seller_id, id)`

Такая структура выбрана для уменьшения контеншена на запись от разных сервисов и упрощения добавления новых типов данных.
Также за счет нахождения в одной таблице данные по одному ключу лежат на одном шарде (различные таблицы этого гарантировать не могут из-за отсутствия table collocation).

`user_offer_presets` – таблица с готовыми пресетами для ЛК
 - `seller_id: Utf8` – id продавца
 - `preset_id: Int32` – id пресета
 - `create_time: Utf8` – время создания объявления
 - `offer_id: Utf8` – id объявления

`PK = (seller_id, preset_id, create_time, offer_id)`
 
`user_offer_presets_count` - – таблица со счетчиками пресетов для ЛК
- `seller_id: Utf8` – id продавца
- `preset_id: Int32` – id пресета
- `counter: Int32` – количество объявлений

`PK = (seller_id, preset_id)`

`queue` – таблица для экспорта изменений в топик
 - `shard_id: UInt32` – PK, id шарда (`user_id % ShardNumber`)
 - `timestamp: Int64` – PK, unixtime изменения
 - `offer_id: Utf8` – PK, id объявления
 - `proto: String` – данные пользователя в [protobuf](storage/proto/offer_model.proto)-формате

`PK = (shard_id, timestamp, offer_id)`

`feed` – таблица с данными автозагрузки
 - `seller_id: Utf8` – id продавца
 - `external_id: Utf8` – внешнее id объявления
 - `offer_id: Utf8` – id объявления
 – `task_id: Int64` – id загрузки

`PK = (seller_id, external_id)`

`Indexes = (seller_id, task_id)`

`user_total_counters` - таблица с глобальными счетчиками пользователя по офферам
- `shard_id: Uint32` - Id шарда
- `seller_id: Utf8` - Id продавца
- `counter_id: Utf8` - Id счетчика
- `seq_no: Int32` - случайное число от 0 до 9 для уменьшения нагрузки на конкретные строки таблицы
- `counter_value: Int64` - значение счетчика

`PK = (shard_id, seller_id, counter_id, seq_no)`

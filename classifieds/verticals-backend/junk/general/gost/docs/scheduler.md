# Шедулер в gost

Проблема:
с объявлением периодически необходимо делать различные действия.

Стейдж – какой-то код, который может поменять объявление после какого-то события.

События бывают такие: 
 - объявление создано или изменилось
 - наступило заранее "запланированное время" aka таймер.

## Примеры решаемых задач
1. Снятие объявления после 180 дней экспозиции.
2. Эволюция объявления на новую версию каталога.
3. Обогащение объявления "предсказанной ценой"
4. Сортировка фоток по ракурсу
5. Проверка доступности видео на youtube.com
6. Скачивание фоток через сервис pica-pica
 
## Очередь
Каждый стейдж имеет свою очередь, чтобы не влиять на задержку обработки других стейджей.
Каждое объявление может находиться в очереди одного стейджа не более одного раза.

## Таймеры
Для совершения какого-то действия в будущем стейдж может "зашедулить" себя на какой-то момент в будущем.
И когда этот момент произойдет, объявление автоматически попадет в очередь этого стейджа.

## Стейт
Для стейджей гост предоставляет возможность хранить рядом с объявлением свой стейт,
который доступен только ему.
Внутри стейта можно хранить произвольный протобаф (`google.protobuf.Any`).
Гарантируется, что изменения в стейт и в оффер применяются атомарно.

## Разрешение конфликтов
Проблема: разные стейджи могут работать параллельно.
Так же параллельно их работе изменения могут прийти из внешнего источника.

Возможные решения:
1. стейджи возвращают не новый контент оффера, а патч к содержимому.<br/>
потребует проработки модели патча и дальнейшей поддержки.
2. стейджи берут оптимистичную блокировку на оффер, и в случае неуспеха запускаются заново.
в случае высокого контеншена производится много ненужной работы.

Эти варианты не исключают друг-друга, и могут работать совместно.

## Сайд эффекты в стейджах
Проблема: стейдж может взаимодействовать со внешней системой.
Например, посылать нотификации (пуши и письма).
Но при этом запись в базу может сфейлиться из-за различных причин. 
Например, пользователь успел изменить объявление раньше или ydb инвалидировала транзакцию.

Поэтому используется такой механизм:
Стейджи всегда "чистые" - они не должны делать никаких сайд эффектов в основных методах.
Шедулер стейджей может без опаски ретраить эти вызовы.

После успешного вызова стейджа и сохранения результатов в базу, 
будет, сохраненное состояние оффера и стейта будет записано в кафку.

Стейдж имеет возможность делать сайд-эффекты на основе стейта, который пришел ему в "пуше после сохранения".
Внешний сервис так же имеет возможность подписаться на топик, и делать сайд эффекты на его основе.

Стоит понимать что из-за особенности (офферы безусловно отправляются на обработку, если запрос `shouldProcess` зафейлился) отправки офферов на обработку стейджами,
стоит самостоятельно явно проверять необходимость делать `process`, `shouldProcess` внутри самих методов.

## API стейджа
```scala
/**  
 Метод для быстрой проверки, надо ли положить оффер в очередь стейджа после изменения.
 Должен работать супер быстро 
*/
def shouldProcess(offer: Offer, state: State): NewTimer | Boolean

/**
 Основной метод стейджа. Может вернуть вернуть изменения в оффере, новый стейт и новые настройки таймера
*/
def process(offer: Offer, state: State): (OfferUpdate, NewState, NewTimer)

```

`Offer` – модель объявления.\
`State` – стейт стейджа. алиас для `google.protobuf.Any`\
`OfferUpdate` – модель обновления оффера. новый оффер или патч, в зависимости от реализации.\
`NewState` – новый стейт стейджа. алиас для `google.protobuf.Any`\
`NewTimer` – новые настройки таймера.


## GRPC-api

Стейджи являются точкой расширения госта для других сервисов.
Вместо приноса своего кода в кодовую базу госта, 
сервис может реализовать определенный grpc сервис и выступать в качестве стейджа.

Так же доступно grpc-апи для чтения и изменения стейта снаружи (только через cas update) .

Примерное апи:
```scala
def read(offerId: String): (State, Version)
def update(offerId: String, newState: State, version: Long): Boolean 
```

## Алгоритм работы

### Шардирование
Обработка разных объявлений полностью независима друг от друга.
Поэтому для шардирования работы используется offer_id.
Каждый инстанс шедулера отвечает только за часть офферов (шард).
Шард считается как `hash(offer_id) % shardCount`, где `shardCount` – общее число шардов в системе. 

### Работа стейджа
1. Наступает очередь обработки оффера `X` стейджем `Y`
2. Инстанс шедулера, который отвечает за шард в котором лежит оффер, грузит его из базы.
3. Запоминается версия загруженного объявления.
4. Грузится стейт для стейджа Y
5. Вызывается метод `process` у стейджа.
6. Если версия объявления в базе не изменилась – сохраняем новый стейт, объявление, и взводим новые таймеры.
7. Если версия объявления в базе изменилась – начинаем все с пункта 2. 
8. Опрашиваем все остальные стейджи в системе на необходимость переобхода.
9. Кладем запись в очередь всех стейджей, которые потребовали переобход.
10. Если объявление не изменилось – ничего не делаем.

Этот алгоритм предполагает, что в один момент для оффера работает только один стейдж.
Этот инвариант обеспечивает шедулер стейджей.
И именно эту версию планируется реализовывать в первой версии шедулера.

### При изменении оффера
Шедулер следит за очередью измененных объявлений.
1. для каждого изменившегося оффера берем все стейджи, в очереди которых оффер еще не лежит
2. проверяем что вернулось в `shouldProcess`
3. кладем в очередь в зависимости от п. 2

## Проблемы

### Комбинаторный взрыв изменений
После каждого стейджа объявление может измениться, 
и необходимо проверить как остальные стейджи отреагируют на данное изменение.
Эти стейджи в свою очередь тоже могут изменить оффер, и проверка потребуется снова.

Эту проблему призван решать метод `shouldProcess`, 
и надежде что все релизации достаточно быстры и не триггерятся на ненужные изменения. 


## Возможные улучшения
### Унести часть логики в шедулер стейджей
На уровне шедулера понимать изменения в каких полях интересуют стейдж.
Если изменилось что-то ненужное, то этот стейдж даже не опросят (через метод `shouldProcess`).
Минус: часть информации про логику стейджа прорастает в шедулер.

### Фоновый переобход всей базы
Периодический процесс обходит всю базу объявлений, опрашивает стейджи (метод `shouldProcess`),
 и добавляет в очередь тем кто попросил.

Минус: Стейдж может стриггериться на все объявления, и тогда его очередь "переполнится"; 
это начнет мешать стейджу обрабатывать обычный поток изменений. 

Для обхода этой проблемы можно сделать вторую очередь у стейджа, 
которая разгребается с меньшим приоритетом, чем основная.

### Ограничение нагрузки на стейдж.
Если стейдж делает что-то тяжелое, или ходит во внешнюю систему,
то со стороны шедулера можно ограничить нагрузку, которая посылается в этот стейдж.
Возможны 2 варианта ограничений:
  - rate-limiter на вызов метода `process`
  - max parallelism – максимальное число параллельных запросов в стейдж.

## Реализация

### Устройство очереди
API:
```scala
trait Queue {
  def offer(shardId: Int, stageId: StageID, offerId: OfferID, timestamp: java.time.Instant): Boolean
  def peek(shardId: Int, stageId: StageID, limit: Int): Seq[OfferID]
  def delete(shardId: Int, stageId: StageID, offerId: OfferID): Unit
  def check(shardId: Int, offerId: OfferID): Seq[(StageID, java.time.Instant)]
}
```

Схема таблиц:
```
queue:
  - shard_id: unit32
  - stage_id: utf8
  - timestamp: unit64
  - offer_id: utf8
PK = (shard_id, stage_id, timestamp, offer_id)

queue_inverted:
  - shard_id: unit32
  - offer_id: utf8
  - stage_id: utf8
  - timestamp: uint64
PK = (shard_id, offer_id, stage_id)
```

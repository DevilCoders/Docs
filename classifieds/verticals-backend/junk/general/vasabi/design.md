## Vasabi - сервис доп услуг Я.Объявлений

Какие задачи решает сервис:
- Предоставление апи формирование цен
- Предоставление апи оплаты ВАСов частным лицам
- Хранение ВАСов
- Отправка ВАСов на индексацию
- Применение ВАС-ов к фидовым офферам
- Снятие ВАСов с офферов
- Раздача информации об активных ВАСах

Disclaimer: еще не изестен конечный вариант того как будет выглядеть payment api, так что некоторые вещи, описанные в этом
документе описаны "на глазок". Нам известно что оно будет иметь возможность инициализировать оплату, привязывать услуги к 
ObjectId(offerId для нас), хранить список услуг, сигнализировать нам об успешной оплате, поддерживать id идемпотентности для
заказа.

## Компоненты

#### VasabiApi
Синхронное апи для формирования цены, инициализации процесса оплаты и, возможно, приема callback-ов от paymentApi.

#### VasabiScheduler
Снимает васы с офферов при окончании их действия

#### VasabiConsumers
Возможно понадобится для приема асинхронных сигналов от paymentApi.

## Хранилище

`vases` – таблица с активными ВАСами
- `shard_id: Uint32` – murmur hash от objectId
- `entity_type: Utf8` - тип сущности, к которой применен ВАС (пока только offer)
- `entity_id: Utf8` – id сущности, к которой применен ВАС
- `proto: String` – данные о ВАСе
`PK = (shardId, entity_type, entity_id)`<br>

`processing_queue` – очередь для периодической обработки ВАСов
- `shard_id: Uint32` – partition очереди
- `operation_type: Utf8` - тип операции, которую нужно выполнить
- `entity_type: Utf8` - тип сущности, к которой применен ВАС (пока только offer)
- `entity_id: Utf8` – id сущности, к которой применен ВАС
- `process_time: Timestamp` – время обработки ВАС-а
`PK = (shardId, operation_type, entity_type, entity_id)`<br>
    Индексы:
    - (shard_id, entity_type, process_time)

`export_queue` – очередь на экспорт ВАСов в топик изменений
- `shard_id: Uint32` – partition очереди
- `entity_id: Utf8` – id сущности, к которой применен ВАС
- `timestamp: Timestamp` – время изменения
- `proto: String` – данные об изменении ВАС-а
`PK = (shardId, timestamp, entity_id)`<br>

ToDo: Таблица с интентами от фидов??

## Формирование цены
Обсудили с Русланом 3 итерации:
1. Мы храним матрицу цен у себя наиболее простым способом(скорее всего прям в коде)
2. Ходим за ценами в price service вертикалей - переходим к этому, когда сервис будет готов к использованию
3. Передаем в paymentApi параметры оффера, а paymentApi сам ходит в матрицу цен (Возможно это даст нам выйти из под sox).

Формирование цены происходит синхронным запросом в VasabiAPI:
1. Идем в базу и считываем текущие активные ВАСы оффера. Отдаем соответствующую ошибку, если ВАС активен.
2. Отдаем цену по схеме текущей итерации

## Апи для оплаты

Большинство работы по процессу оплаты будет происходить в paymentApi.
Задачей VasabiApi будет только инициализация платежа.
(Если paymentApi не будет обеспечивать однократное применение услуги к офферу, то схема тут сильно усложнится)

## Применение ВАСа

Применение ВАСа к офферу происходит при получении "сигнала" от paymentAPI, об успешной оплате.
При этом Vasabi записывает в базу информацию о ВАСе.

Идемпотентость при этом обеспечивается с помощью id идемпотентности от paymentApi. 

## Применение ВАС-ов к фидовым офферам

ToDo (предварительно фидпроцессор может синхронно класть интенты в vasabi, а vasabi применять эти васы при чтении топика изменений gost,
сопоставляя офферы по userId+externalId)

## Снятие ВАСа и экспорт

При модификации ВАСа, помимо таблицы `vases`, vasabi транзакционно обновляет таблицы с очередями на протухание и экспорт.

Экспорт и протухание осуществляются несколькими инстансами `vasabi-scheduler` с распределением нагрузки через shard_id и 
TokenDistribution. Обработка очередей всегда идет с самых старых значений.

Нужно не забыть дедуплицировать записи об одном entityId внутри батча на экспорт.


## Индексация

Vasabi пишет топик изменений ВАСов в Кафку. Индексацией этих изменений может заниматься любой сервис, в том числе searcher.

## Открытые вопросы

- Кто обеспечивает однократное применение ВАСа к офферу, мы или payment api?

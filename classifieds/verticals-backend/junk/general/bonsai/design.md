# Bonsai Design Doc

##  Сущности
На данном этапе в каталоге всего две сущности — это категории и атрибуты.
Со временем могут появиться новые.

### Категории

`Категория` описывает класс сущностей.
Например, смартфоны (объем батареи, размеры) или вакансия (требования, вилка зарплаты).
Категория может иметь несколько дочерних категорий. В этом случае можно говорить о `дереве категорий`.
Например, "смартфоны" является дочерней для категории "электроника".
Категории имеют порядок внутри родительской категории, которым можно управлять из админки.
Объявления можно создавать только в `конечных` категориях (листьях).
Также, конечные категории содержат `атрибуты`.
Любое редактирование категории создает новую версию.
Объявления ссылаются на конкретную версию категории.
Цель – никогда не получить ситуацию, что оффер ссылается на несуществующую категорию. И понимать об какую версию категории валидировался оффер.

Существуют категории-ссылки.
Они не несут смысла сами по себе, а ссылаются на другую категорию в другом поддереве.
(альтернативная реализация — сделать несколько родителей у категории)
Для таких категориях нельзя добавлять атрибуты и делать детей.

Примерная оценка объема:
- Несколько тысяч активных категорий.
- Десятки тысяч вместе с архивными версиями.
- Сотни тысяч записей в истории.

Protobuf-модель: https://github.com/YandexClassifieds/schema-registry/blob/master/proto/general/bonsai/category_model.proto#L14

#### Свойства категорий
- Полное название
- Краткое название
- `uri_part` (для урла, глобально уникален)
- Лингвистика
- Родительская категория (пусто для корневых категорий)
- Активно/опубликовано
- Разрешено создавать новые объявления
- Ссылка на категорию, в которую надо перенести офферы

### Атрибуты

Описывает какое-то свойство сущности.
Например, размер диагонали у смартфона/ноутбука/телевизора.
Имеют определенный порядок внутри категории, которым можно управлять из админки.
Можно скрыть от показа (soft delete).
Может быть обязательным и опциональным, repeatable.
Типы - `enum(словарь)`, `boolean`, `численный`, `строковый`.
Словари содержат список возможных значений, который версионируется вместе с атрибутом.
Атрибуты и значения могут содержать разную дополнительную мета-информацию, которая редактируется через админку.
Например, можно включать и выключать поиск по этому атрибуту или еще как-то влиять на поиск. Подробности не важны в контексте каталога, поэтому опущены.
Т.к. атрибут в базе лежит одним прото-сообщением, то новые свойства в него добавляются "бесплатно".
Атрибут может влиять на доступные ограничения в другом атрибуте.
Подробности ниже (см. `Взаимные ограничения атрибутов`).

Protobuf-модель: https://github.com/YandexClassifieds/schema-registry/blob/master/proto/general/bonsai/attribute_model.proto#L9

### Связи между сущностями
- Оффер → Категория – объявление всегда принадлежит категории
- Оффер → Атрибут — объявление одержит атрибуты соответствующей категории
- Категория → Категория – категория является родителем другой категории; категория является ссылкой на другую категорию
- Категория → Атрибут – категория описывает атрибуты для заполнения в объявлениях; Категория может описывать ограничения на атрибуты
- Атрибут → Атрибут — атрибут может накладывать ограничения на значение другого атрибута в объявлении

Все сущности ссылаются на конкретную версию другой сущности.
Объявления асинхронно пытаются перейти на новую версию.
Ссылки на атрибуты синхронно обновляются при изменении атрибута.

### Взаимные ограничения атрибутов
Выбор значения в одном атрибуте может влиять на доступные значения в другом атрибуте.
Например, если шины летние, то у них не может быть шипов.

Такие ограничения описываются через "правила ограничений" ([restriction rules](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/general/bonsai/restriction_model.proto)).
Правила физически лежат внутри категории и версионируются вместе ней.
Правила не должны образовывать циклические зависимости атрибутов, поэтому при сохранении категории это должно проверяться.
Предполагается, если правила ограничили область значения какого-то атрибута до единственного значения, то "фронтенд" автоматически заполнит это значение на форме добавления
(это не относится напрямую к каталогу, но требует упоминания).

## Версионирование
Каждое каталога изменение имеет версию.
Версионирование сквозное на весь сервис: если отредактировать сначала категорию А, а потом Б, то версия у Б будет больше чем у А
После того как изменение произошло, всегда можно получить сущность по api зная id и версию.
Теоретически возможно восстановить каталог на конкретный момент времени, но готовых методов для такой операции не делаем.

## История изменений
При каждом изменении версии обязательно меняются какие-либо сущности каталога.
Чтобы понимать, что изменилось между версиями - фиксируем, какие именно сущности в какой версии изменились.
По api можно получить последние изменения или изменения между указанными версиями в порядке от поздних к ранним.

## Поиск
Для полнотекстового поиска (и возможно каких-то сложных фильтров) используется [ClickHouse over YDB](https://ydb.yandex-team.ru/docs/getting_started/start_chydb).
Для этого в основных таблицах колонка с протобафом дублируется колонкой с json версией контента.

## Релизы каталога
Раз в какое-то время делается дамп в каталога в s3.
Оператор может нажать на кнопку в админке и тогда последний экпорт промоутится до стабильного.
Сервисы в продакшене используют только стабильный экспорт.
Чтобы это было проще – над этим экспортом поднят отдельный сервис, который сможет отвечать на запросы про каталог.

## Идентификаторы
Мы рекомендуем все ссылки на каталог в логах сервисов строить по одному принципу:
`entity_type:entity_id@version`
Примеры:
`category:mobile_phones@32`
`attribute:cameras_count@2`

## Хранение
Данные хранятся в YDB.

`entity` – таблица с последними версиями атрибутов/категорий
  - `type: Utf8` – тип сущности `attribute`/`category`
  - `id: Utf8` – идентификатор сущности
  - `proto: String` – данные сущности в протобаф формате
  - `json_view: Json` – json-версия данных

 `PK = (type, id)`

`entity_history` – таблица со всеми версиями атрибутов/категорий
  - `type: Utf8`
  - `id: Utf8`
  - `version: Uint64` – версия сущности
  - `proto: String`

 `PK = (type, id, version)`

`category_hierarchy` – таблица с актуальной версией иерархии, для истории `parent_id` все еще доступен внутри сообщения категории
  - `parent_id: Utf8`
  - `child_id: Utf8`

 `PK = (parent_id, child_id)`

`history` – таблица с метаданными о том, кто создал конкретную версию.
  - `version: Uint64` – версия изменения
  - `timestamp: Uint64` – время изменения
  - `uid: Uint64` – идентификатор автора изменений
  - `comment: Utf8` – комментарий к изменению

 `PK = (version)`

`uniq_constraint` – вспомогательная таблица для проверки уникальности
  - `entity_type: Utf8` – тип сущности `attribute`/`category`
  - `field: Utf8` – поле, на которое установлено ограничение
  - `value: Utf8` – значение поля
  - `entity_id: Utf8`

 `PK = (entity_type, field, value)`

`reference_constraint` – вспомогательная таблица для проверки внешних ссылок
  - `target_type: Utf8`
  - `target_id: Utf8`
  - `source_type: Utf8`
  - `source_id: Utf8`

 `PK = (target_type, target_id, source_type, source_id)`
 
 `global_history` - таблица с записями об изменениях сущностей
   - `version: Uint64` - версия изменения
   - `order: Utf8` - при изменении нескольких сущностей за версию обеспечивает сохранение порядка внутри версии при пагинации
   - `previous_version` - предыдущая версия изменившейся сущности
   - `entity_type: Utf8` - тип сущности `attribute`/`category`
   - `entity_id: Utf8` - идентификатор изменившейся сущности
   
   `PK = (version, order, entity_type, entity_id)`


# Coding Guideline

## Технологии

Мы пишем на scala с использованием библиотеки zio. 
Тесты пишутся на zio-test.
Приложения упаковываются в docker контейнеры и выкладываются с помощью [shiva](https://wiki.yandex-team.ru/vertis-admin/deploy/).

## GRPC

Для связи между сервисами используется grpc.<br/>
Для связи с legacy и внешними сервисами может использоваться http. 

## Базы данных
В качестве баз данных мы используем [ydb](https://ydb.yandex-team.ru/) и [postgresql в mdb](https://yc.yandex-team.ru) (на момент написания еще не использовался).

Для батч-задач мы используем [yt](https://yt.yandex-team.ru/hahn). Там же лежат различные данные большого объема (например, дампы).
Так же это основное место вокруг которого строится аналитика на сервисе.

## Секреты
Секреты не должны попадать в репозиторий; но если он туда попал, то он должен быть оперативно изменен.
Хоть часть секретов и повторяется между сервисами, 
но мы рекомендуем создавать новый секрет в [секретнице](https://yav.yandex-team.ru/) на каждый сервис.
Таким образом сервисы не должны получать доступ к паролям в которых нет нужды.

## Логирование
Сервисы пишут логи в stdout. Дальше они попадают в [вертикальную систему для логов](https://wiki.yandex-team.ru/vertis-admin/logs/).

## Sentry
Все сервисы должны отправлять критичные ошибки в [sentry](https://sentry.vertis.yandex.net/verticals/).
Для сервисов в Shiva, проект в Sentry создается автоматически и DSN от него прорастает в переменную окружения [_DEPLOY_G_SENTRY_DSN](https://wiki.yandex-team.ru/vertis-admin/deploy/env/#deploygsentrydsn).
Для удобства лучше добавить проект в team #classifieds. 
Для настройки нотификаций идем на вкладку Alerts и выбираем пресет Telegram notifications. Параметры:
- token: нужно взять из настроек других проектов #classifieds.
- receivers: `-1001177566110`. 
- шаблон:

        *[Sentry]* {project_name} {tag[level]} in {tag[environment]}: {url}  
        {title}   
        ```   
        {message}   
        ```

Чтобы повторное появление ошибки присылалось в чат, надо отредактировать дефолтный rule.
Дла этого также на экране Alerts нужно открыть вкладку Rule. Добавить туда "An issue changes state from resolved to unresolved" и заменить all на any
[](../docs/sentry/sentry_alerts_rule.jpg)
[](../docs/sentry/sentry_alerts_edit_rule.jpg)

## Структура сервиса
Типичный сервис состоит из двух приложений – api и scheduler.

В api находится реалтаймовая часть сервиса, которая отвечает на запросы пользователя. Обычно его недоступность является критичной.

В scheduler обычно находится всевозможная offline обработка данных: 
периодические задачи, обработка триггеров и пр.

Такое разделение необходимо для изоляции различных кусков приложения: 
падение одного приложения не должно влиять на доступность другого приложения.
Например, шедулеры любят работать батчами, и небольшая неаккуратность может привести его к OOM-у. 
Поэтому падение шедулера должно происходить практически незаметно для пользователя.

Иногда в сервисе может отсутствовать какая-то часть (например не быть шедулера), или могут быть дополнительные приложения.
Это связано со спецификой сервиса и требованиям по изоляции из предыдущего пункта.

### Внутренняя структура приложения

Обычное приложение api состоит из трех слоев:
 - XxxService – имплементация grpc сервиса;
  содержит валидацию входных параметров и трансформацию между внешними DTO (proto моделями) во внутреннюю предметную модель.
  общаются с manager слоем
 - xxxManager – содержит всю бизнес-логику приложения; может вызывать других менеджеров и dao-слой 
 - xxxDao – инкапсулирует работу с базой данных. обычно работает соотношение `1 таблица = 1 dao`, но иногда бывают исключения.
 
### Пагинация
Волевым решением (методом "и так сойдет") приняли, что пагинация для фронта (в gateway) начинается с единицы, 
а в grpc сервисах (между бекендами) начинается с нуля.
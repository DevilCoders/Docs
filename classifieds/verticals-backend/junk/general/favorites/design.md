# Избранное и сохраненные поиски

## Описание требований:

1) Пользователь может сохранить для быстрого доступа: объявление, фильтры для поиска (в том числе текстовый), продавца.

2) Пользователь получает уведомления если у объекта в избранном случились изменения
а) изменилась цена у оффера в избранном
б) появились новые объявления попадающие под критерии сохраненного поиска
в) появились новые объявления у сохраненного продавца

2.1) Получает только одно уведомление если новое объявление попало и под критерий поиск и под подписку на продавца. 
Тип нотификации зависит от того какое событие будет обработано раньше.

3) Для объявления можно получить число пользователей, которые добавили его в избранное.

4) Пользователь может оставить заметки к объявлению.

5) Пользователь может объединять объявления в избранном в коллекции, у коллекции есть свое название.

6) При залогине все избранное перемещается от анонима к пользователю

## Варианты решения:

### 1) personal-api + subscriptions 

Плюсы:
- наименее трудозатратное, если согласиться со всеми ограничениями

Ограничения:
- список избранного в personal-api лежит в произвольном payload и требует вычитывания целиком в память,
 следовательно, ограничен по размеру
- на данный момент subscriptions умеет матчить поиски по атрибутам, но не подходит для полнотекстового поиска

Что можно сделать:
- смириться с ограничением на размер payload
- доработать subscriptions и каким-то неизвестным сейчас способом научиться в полнтекстовый поиск или
отказаться от полнотекста

### 2) personal-api + периодический процесс уведомления, который итерирует по всему избранному и вычисляет дифф

Плюсы:
- готовое хранилище избранного, теоретически можем слать уведомления для полнотекстового сохраненного поиска

Ограничения:
- personal-api использует на данный момент couchbase по нему нельзя итерировать, но можно итерировать по дампу;
регулярное снятие и работа с дампами при этом неудобна (дамп снимается в формате SQLLite, теоретически можно его допинать до yt и возможно даже до ydb)
- при росте объема избранного полный его обход станет крайне трудоемкой операцией
- время на изготовление дампа снижает оперативность отправки уведомлений и их актуальность (будем слать по неактуальному
 избранному)
- для вычисления дифа нужно хранить старую версию документа (либо хэш от полей) и обновлять его при каждой итерации,
 это создаст повышенную нагрузку на personal-api и раздует payload

Что можно сделать:
- переписать personal-api на ydb, тогда мы можем делать переливку (через снятие и восстановление дампа) и итерировать
 из приложения по копии (sdk ydb поддерживает stream либо пагинацией по PK)
- нужно оценить объем когда мы перестанем справляться, возможно это наступит не скоро и подойдет для запуска
- смириться, что шлем с задержкой и не актуальное 

### 3) собственное избранное + периодический процесс уведомления, который итерирует по всему избранному и вычисляет дифф

Плюсы:
- храним избранное в ydb, для каждого объекта отдельной строкой и можем по нему итерироать 
- меньше межкомандных взаимодействий

Ограничения:
- при росте объема подписок полный их обход станет крайне трудоемкой операцией
- надо больше разрабатывать

### 4) собственное избранное + subscriptions 

Плюсы:
- храним избранное в ydb, для каждого объекта отдельной строкой, нет ограничения на размер и можно делать пагинацию
- используем существующий механизм подписок

Ограничения:
- на данный момент subscriptions умеет матчить поиски по атрибутам, но не подходит для полнотекстового поиска

Что можно сделать:
- доработать subscriptions, или отказаться от полнотекста, или обрабатывать в subscriptions только
 атрибутивные сохраненные поиски, а полнотекстовые с помощью итерации по избранному

### Резюме

1) personal-api имеет ряд ограничений: лимит на количество избранного (в авто сейчас 100), невозможность пагинации,
невозможность итерации по избранному. Поэтому предпочтительным решением является реализации собственного сервиса избранного.

2) subscriptions требуют доработок в плане интеграции полнотекстового поиска, но теоретически могут использоваться
 для атрибутивного

3) если доработки subscriptions трудоемки или невозможны в ближайшее время, то для для MVP нужно реализовать 
собственный периодический процесс уведомлений. 

4) рано или поздно процесс обхода всего избранного станет занимать неприемлемо много времени, до этого момента можно:
- доработать подписки 
- перенести процесс вычисления в yt, пересекать дамп избранного с дампом объявлений (детали пока не ясны)
- что-то еще

5) как быстро мы иссякнем? Если считать приемлемым временем отправки уведомления 24 часа и то, что поиск может
 держать 100 рпс, то мы достигнем этих показателей при избранном 8-9 млн сохраненных поисков. Как быстро накопится
  такое количество поисков точно сказать нельзя. 

## Собственное избранное

### API

- добавить сохраненный поиск
- удалить сохраненный поиск (батч)
- добавить продавца в избранное (батч)
- удалить продавца из избранного (батч)
- добавить объявление в избранное (батч)
- удалить объявление из избранного (батч)
- переместить все избранное от анонима к залогину
- создать коллекцию
- добавить объявление в коллекцию (батч)
- удалить объявление из коллекции (батч)
- получение листинга по пользователю с пагинацией
- получение избранного пользователя по id объявления/поиска/продавца

### Хранилище
В качестве хранилища используется ydb. 

1) Избранное 
 `favorites` – таблица с избранным
      - `owner_id: Utf8` – id пользователя
      - `kind: Utf8` – тип избранного (объявление, сохраненный поиск, пользователь, заметка)
      - `favorite_id: Utf8` - id избранного(id объявления, hash от строки поиска, id продавца,  id коллекции)
      - `create_timestamp: Int64` - время добавления в избранное, для дефолтной сортировки и фильтрации    
      - `proto: String` – данные нужные для запроса сохраненного объявление, пользователя, поиска, заметки или коллекции (protobuf) 

      `PK = (owner_id, kind, favorite_id)` 
      `INDEX = (owner_id, kind, create_timestamp)` 
      
  `meta`:
  1) объявление - ничего
  2) пользователь - настройки уведомления
  3) поиск - запрос и настройки уведомления
  4) заметка - текст заметки
  5) коллекция - имя коллекции и количество элементов в коллекции
      
2) Обратные индексы
  
а) `saved_search_inverted` – инвертированная таблица с сохраненными поисками, для отправки нотификаций
   - `shard_id: UInt32` – id шарда (`hash(search_id) % ShardCount`)
   - `search_id: Utf8` - id сохраненного поиска (hash от поискового запроса)
   - `owner_id: Utf8` – id пользователя сохранившего поиск
   - `meta: String` – запрос и настройки уведомления, время создания, время последнего отправления (protobuf) 
    
   `PK = (shard_id, search_id, owner_id)`
    
б) `saved_users_inverted` – инвертированная таблица с сохраненными продавцами для отправки нотификаций
   - `seller_id: Utf8` -id сохраненного продавца
   - `owner_id: Utf8` – id пользователя, который сохранил пользователя 
   - `meta: String` – настройки уведомления, время создания, время последнего отправления (protobuf) 
   
   `PK = (seller_id, owner_id)`      
    
в) `saved_offers_inverted` – инвертированная таблица с сохраненными пользователями для отправки нотификаций
   - `offer_id: Utf8` -id сохраненного объявления
   - `owner_id: Utf8` – id пользователя, который сохранил объявление 
   - `hash: String` – объект (версия + хэш) с хэшом от полей объявления, изменение которых влечет за собой
                       отправку нотификации (protobuf)   
   `PK = (offer_id, owner_id)`

4) Коллекции объявлений

а) `saved_offers_collection_content` – объявления объеденные в коллекции
    - `collection_id: Utf8` – id коллекции     
    - `offer_id: Utf8` – id объявления добавленного в коллекцию
    - `create_timestamp: Int64` - время добавления в коллекцию, для дефолтной сортировки и фильтрации 
       
    `PK = (collection_id, offer_id)`
     
5) Счетчики 

а) `favorites_counts` – таблица со счетчиками избранного, оптимизация для крупных избранных
    - `owner_id: Utf8` – id пользователя
    - `kind: Utf8` – тип избранного (объявление, сохраненный поиск, пользователь, коллекции)
    - `count: Int32` - количество элементов в избранном
    
    `PK = (owner_id, kind)`
     
б) `offer_save_counts` – таблица со счетчиками сколько раз добавили конкретное объявление в избранное,
                                  чтобы не сломаться на очень популярных объявлениях
    - `offer_id: Utf8` – id пользователя
    - `count: Int32` - сколько раз добавили в избранное
        
    `PK = (offer_id)`
      
6) Отправка нотификаций

а)   `users_offer_sent` – таблица с отправленными нотификациями по сохраненными продавцам и поискам
     - `owner_id: Utf8` – id пользователя   
     - `offer_id: Utf8` – id объявления, по которому была отправлена нотификация
       
     `PK = (owner_id, offer_id)`
     
б)   `notification_queue` – таблица отправки нотификаций, позволяет отправлять нотификации шедулером
                            отдельно от итерации по избранному
     - `shard_id: UInt32` – PK, id шарда (`user_id % ShardNumber`)
     - `timestamp: Int64` – PK, unixtime созданий нотификации
     - `proto: String` – данные необходимые для отправки нотификации (protobuf) 
    
    `PK = (shard_id, timestamp)`
    
#№ Уникальность id сохраненного поиска

Для того чтобы группировать сохраненные поиски в обратном индексе по id, нужно чтобы одинаковые по смыслу поиски имели одинаковые id.
Одинаковые по смыслу означает идентичные вне зависимости от последовательности заполнения полей. 
Для этого преобразуем параметры поискового запроса:
1) у каждого поля модели есть свой строковый ключ;
2) у каждого операции фильтра есть свой строковый постфикс, он добавляется к каждому параметру фильтра
3) конвертируем запрос в мультимапу <строкой ключ, Set<значение>>
4) сортируем мультипаму по ключам, для каждого ключа достаем значение и сортируем значения, для каждой пары формируем строковое
 представление (`text=шкаф`, `sort=desc`, `weight-less-than=100`)
5) конкатенируем строки и считаем от них sha1, это и есть наш search_id.
     
## Периодический процесс уведомлений

Scheduler обходящий все избранное и проверяющий изменения, которые произошли с элементом. 
В случае наличия значимых изменений отправляет уведомление пользователю и сохраняет факт отправки в `users_offer_sent`
для сохраненных поисков и подписок на пользователей. Либо обновляет `hash` в  `saved_offers_inverted` для подписок на объявления.

### Варианты реализации
1) YDB stream. Читаем стримом или пагинацией по PK данные из базы `saved_search_inverted`. Идем в searcher с запросом.
Получаем первую страницу объявлений, фильтруем те, по которым нотификация уже отправлялась
на основе таблицы `users_offer_sent`,  а так же те, которые созданы до создания подписки. Складываем нотификации для
новых объявлений в таблицу нотификаций `notification_queue`. Обновляем список отправленных в `saved_search_sent`.
Отдельной таской шедулера достаем батч нотификации из `notification_queue` отправляет s SUP и sender.
Для организации параллельной работы нескольких интсансов шедулера, с помощью TokensDistribution распределяем между ними
токены, где token = номер шарда. Каждый инстанс шеделура итерирует по своему набору ключей согласно полученным токенам.
В zookeeper храним пару значений (номер шарда, offset), при запуске инстанс проверяет с какого с какого offset начинать обход.
Когда доходит до конца, сбрасывает offset. 
Удаляем из очереди отправленные.
Примерные расчеты:
Допустим хотим слать уведомления 1 раз в час и серчер способен выдержать 100 rps. Тогда предельным для нас является
360 000 сохранённых поисков. 
За 10 часов - 3,5 млн.
За сутки - около 8 млн.
То есть время за которое мы сможем гарантированно отправить уведомление пользователю будет естественным 
образом деградировать вместе с ростом избранного. Как вариант оптимизации – уведомления отправлять только поискам
не старше Х дней. 

2) Вариант 1 используется только для сохраненных поисков. Для одиночных объявлений слушаем топик изменений объявлений.
Достаем из  `saved_offers_inverted`  пользователей  выбираем те у которых сохраненный хэш не совпадает с хэшом в таблице,
и отправляем для них нотификацию в сервис нотификаций. Если находим новое объявление от пользователя, то достаем из
таблицы `saved_users_inverted` пользователей, проверяем что не отправляли уже уведомление на основе таблицы
`saved_users_sent`  и отправляем для них нотификацию в сервис нотификаций.

### Альтернативный варианты реализации
Процесс поверх YT. Делаем экспорт избранного в yt. Делаем экспорт базы объявлений в YT. 
Пересекаем получаем кандидаты на уведомления. Возможно, перейти на этот вариант реализации нужно будет, когда итерация не станет справляться.
Реализация не выглядит простой, а также нет понимания как прикрутить к этому полнотекст (возможно, рядом можно хранить инвертированный индекс).
 
## Метрики 
 
 1) Время выполнения задачи итерации по всему избранному
 2) Скорость итерации по избранному (записи / секунда)
 3) Тайминги и количество запросов к серчеру
 4) Размер очереди нотификаций
 5) Количество отправленных нотификаций
 6) Время добавление/получения избранного
 7) Размер избранного

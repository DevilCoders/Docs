# Hammer - Сервис, оповещающий пользователей об их банах

Читает топики изменений офферов и юзеров сервиса Я.Объявления и рассылает уведомления, если статус забаненности изменился.
А также снимает редирект/подмену телефона, если у пользователя больше не осталось активных объявлений.

В топиках [gost](https://github.com/YandexClassifieds/verticals-backend/tree/master/general/gost) и [general-users](https://github.com/YandexClassifieds/verticals-backend/tree/master/general/users) не содержат информации о предыдущем состоянии забаненности, поэтому их придется хранить у себя.
При этом не будем хранить инфу о сущностях, на которые не наложены ограничения.

## Модели 
##### `general.hammer.queue_model.Email`
- `address` - имейл, куда нужно отправить нотификацию
- `templateName` -- названия темплейта в рассыляторе (берётся из пальмы templateGost по banReason)
- `payloadJson` -- поля, для заполнения плейсохолдеров в темплейте рассылятора (например, ban_reason_description -- чтобы пользователь мог увидеть в письме, по какой причине забанили его оффер)

##### `general.hammer.queue_model.Push`
- `userId` -- passport user id, которому нужно отправить нотификацию
- `title` -- название нотификации
- `text` -- текст нотификации
- `deeplink` -- ссылка на экран в приложении, на который нужно отправить при клике на нотификацию

<br/>

#### Батчёвые нотификации

##### `EmailBatchElem`
- `email` -- имейл, куда нужно отправить нотификацию 
- `eventName` -- название аггрегированного ивента  
- `banReasonTitle` --  название причины бана (берётся из пальмы по banReason)

##### `PushBatchElem`
- `userId` -- passport user id, которому нужно отправить нотификацию
- `eventName` -- название аггрегированного ивента 

Возможные значения eventName в аггрегированных сообщениях: 
* `OFFER_EXPIRED_BATCHED_SENDING`
* `OFFER_BAN_BATCHED_SENDING`
* `OFFER_UNBAN_BATCHED_SENDING`

##### `PushAggregate`
* не содержит полей, так как пуши состоят из стандартных текстов, вне зависимости от количества и типа офферов и банов. 

##### `EmailAggregate`
* `count` -- количество офферов, попавших в аггрегат
* `banReasonTitles` --  название причины бана (берётся из пальмы по banReason). Это поле используется в шаблоне рассылятора только для писем с баном офферов, для expired и unban оно не нужно.

## Хранилище

`moderation_info` – хранит предыдущее состояние оффера / юзера. Предыдущее состояние нужно, чтобы понимать, поменялось ли что-то. Например, если статус был banned и в новом сообщении banned, то нотификацию повторно отправлять не нужно.  
- `entity_id: Utf8` – id оффера/юзера
- `proto: Array[Byte]` – proto [модель]() с информацией о модерации оффера(OfferModerationInfo)/юзера(UserModerationInfo)
`PK = (id)`<br>

`banned_offer_ids` -- список ИДишников, забаненных офферов. Таблица выполняет единственную цель, хранить ИДишники офферов, пока таска BanExportTask не выгрузит их в S3. ИДишники выгружаются в S3, чтобы search-scheduler вычитал их и забанил офферы в обход индексации.
- `offer_id` -- ID оффера
- `updated_at` -- когда забанен

`notifications_queue` -- очередь нотификаций, ожидающих отправки
- `shard_id` - ИДишник шарда
- `type` - тип нотификации (email / push)
- `timestamp` - время создания записи
- `proto` - бинарный протобаф, содержащий информацию о нотификации (Email / Push)

`notifications_batch_queue` -- таблица аггрегированных нотификаций
- `shard_id` -- ИДишник шарда 
- `destination` -- значение места, куда отправляется нотификация (example@ya.ru или 12345678)
- `destination_type` -- тип места, куда отправляется нотификация (email или userId)
- `event_name` -- название аггрегированного ивента 
- `bucket_id` -- рандомный ИДишник, предназначеный для уменшения контеншена при одновременной обращении к одной записи
- `created_at` -- время создания записи
- `aggregate` -- аггрегированная информация по нотификациям

 
## Флоу отправки нотификаций

### Нотификации по бану офферов:
В OffersUpdateHandler хаммер подписывается на кафку госта с изменениями офферов (в частности проставлением бана офферам в следствии ивента от модерации). Сообщение, полученное из кафки, с помощью OfferUpdateBuilder трансформируется во внутренее представление хаммера -- нотификацию для отправки. Но нотификация не отправляется сразу, а кладётся в notifications_batch_queue, чтобы не спамить юзеру по каждому его офферу, а отправлять аггрегированное сообщение раз в какое-то время. Эти аггрегированные сообщения выгребаются из таблицы, когда они достаточно наагрегировались (сейчас это определяется по условию createdAt < now - 1h), и кладутся в таблицу notifications_queue. Из notifications_queue выгребают и отправляют нотификации EmailEmitter и PushEmitter.

##### Чуть подробнее про процесс аггрегации:
* Агрегат хранится в базе в notifications_batch_queue.aggregate в бинарном представлении протобафной модели NotificationAggregate. Для каждого типа аггрегата должен быть реализован способ агрегации (сейчас это в ru.yandex.vertis.general.hammer.model.NotificationsBatchQueueRecord.merge).
* В агрегат нотификации кладётся только необходимая информация. Поэтому `PushAggregate` не содержит полей, а `EmailAggregate` содержит количество офферов и названия банов.  
* Ныне существует всего три вида агрегации: бан, анбан, протухание оффера -- три возможных значения eventName. Но от модерации может прийти 1000 и 1 причина бана, их приходится прямо в коде мапать в eventName: анбан в анбан, expire в expire, всё остальное считается баном (в коде можно посмотреть в OfferUpdateBuilder).  

### Нотификации по бану юзеров:
Флоу похож на флоу офферов. В UsersUpdateHandler хаммер подписывается на кафку, видимо, от сервиса users. С помощью UserUpdateBuilder трансформирует изменения юзера в нотификацию (Email или Push), кладёт в таблицу notifications_queue. Из notifications_queue выгребают и отправляют нотификации EmailEmitter и PushEmitter. 

### Общая часть флоу:
- `EmailEmitter` -- выгребает записи типа Email из notifications_queue и отправляет имейл пользователю через рассылятор.
- `PushEmitter` -- выгребает записи типа Push из notifications_queue и отправляет пользователю пуш.
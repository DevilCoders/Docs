# Shop - сервис управления доп услугами Я.Вертикалей

Сервис управляет жизненным циклом дополнительных платных(почти всегда) услуг, которые предоставляют сервисы Я.Вертикалей.

## Глоссарий

**ВАС** - дополнительная услуга на сервисе(от анг. [Value-added service](https://en.wikipedia.org/wiki/Value-added_service)).
В [модели](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/shop/model.proto) представлен объектом `Goods`.

**Продукт** - набор васов. 
В [модели](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/shop/model.proto) представлен объектом `Product`

**Таргет** - цель применения продукта, если продукт предполагается применять к чему-то(офферу/юзеру). Состоит из target_type и target_id.
В [модели](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/shop/model.proto) представлен объектом `GoodsTarget`

**Purchase** - операция покупки одного или нескольких ВАСов (транзакция).
В [модели](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/shop/model.proto) представлен объектом `Purchase`

**Payment Gate** - платежная система, использующаяся для оплаты покупки целиком или ее части.
В данный момент поддерживается только одна платежная система - trust. Доку по платежам через trust можно найти [тут](trust.md).

**Платеж** - операция списания средств с пользователя в конкретной платежной системы.

**Рефанд** - операция возврата денег за покупку.

**Композитный платеж** - это покупка, средства за которую списываются с нескольких источников средств пользователя.
Например баллы Яндекс.Плюс и банковская карта.

## Описание

### Задачи
- Хранение списков доступных к покупке продуктов
- Хранение активных продуктов пользователя
- Хранение купленных продуктов пользователя
- Предоставление апи для покупки и рефанда продуктов
- Хранение и управление жизненным циклом транзакций  
- Управление жизненным циклом купленных/активированных продуктов (протухание, автопродление)

В задачи сервиса не входит:
- Валидация объектов применения продуктов (сервис не знает что такое оффер в авто.ру, для него это просто строка)
- Валидация юзеров, выполняющих покупки (хотя платежные системы "под" shop-api наверняка будут это делать)
- ценообразование (для этого есть [howmuch](https://github.com/YandexClassifieds/verticals-backend/tree/master/billing/howmuch))

### Реестр продуктов
Персистентное хранилище продуктов.

Каждый продукт имеет номер ревизии - уникальный идентификатор.
В моменте только одна ревизия продукта активна.
Любое изменение состава продукта - это новая ревизия и время, с которого эта версия актуальна.

**В первом приближении база доступных продуктов будет захардкожена прям в коде**

### Котел активных продуктов
Активным продуктом считается продукт, примененный к некоторому таргету. Он обладает датой применения и опционально датой окончания.
Активными ВАСами считается суперсет из всех ВАСов активных продуктов.

В будущем предполагается, что продукт может быть активирован не сразу после покупки, но сейчас это не так.

### Purchase
Все транзакции по покупке продуктов всех пользователей и сервисов хранятся в персистентном хранилище в Ydb.
При этом, в рамках одной покупки пользователь может купить несколько продуктов, примененных к нескольким таргетам.

На что стоит обратить внимание в модели покупки:

`id покупки` - присылается сервисом потребитилем при инициализации платежа. Таким образом мы даем возможность сервисам самим обеспечивать 
механизмы **идемпотентности** по тем правилам, по которым им удобно.

`status` - статус всей покупки целиком, в отрыве от статусов платежей конкретных платежных систем.

![states](states.png)

`refundStatus` - статус рефанда всей покупки целиков, в отрыве от статусов рефанда входящих платежей

![refund_states](refund_states.png)

`subjects` - список продуктов и таргетов к которым эти продукты применять

`paymentDetails` - разметки платежей, входящих в покупку.
В данный момент поддерживается только одна платежная система - trust. Доку по платежам через trust можно найти [тут](trust.md).
<br/>Стоит сказать что разметка данных о конкретных платежах не приведена к единой модели. В частности нет единой системы статусов платежей.
Пока мы имеем одну платежную систему это, естественно, не вызывает проблем, но в будущем стоит подумать в эту сторону.

### Композитные покупки
В текущий момент многокомпонентные покупки предполагается реализовывать с помощью механизма, похожего на [Саги](https://docs.microsoft.com/ru-ru/azure/architecture/reference-architectures/saga/saga).

В каждом объекте Purchase хранится список PaymentDetails.
PaymentDetails содержит в себе детали платежа и явно или неявно статус платежа. В данный момент поддерживается только [trust](trust.md).
При этом, если платежные системы поддерживают двухфазный коммит - мы должны по максимуму использовать это в обработке наших платежей.

В отличие от классических саг нам необязательно сохранять порядок выполнения и отката отдельных частей транзакции.
Нас интересует только eventual consistency - в какой-то момент времени в будущем все части покупки должны быть выполнены или должны откатиться.

Что осложняет нам жизнь в текущий момент:
- purchase хранит в себе одновременно статус покупки и статус рефанда.
  Поэтому, в теории, покупка может оказаться в неконсистентном состоянии. Например одновременно откатывать неудавшийся платеж и выполнять рефанд по этому же платежу.
  Нам приходится явно контролировать недопустимость таких ситуаций на уровне кода, а не данных, что существенно усложняет разработку.
- отсутсвует единая система состояний платежа. Для каждой платежной системы состояние вычисляется неявно из деталей этого платежа.
Например: если в TrustPaymentDetails присутсвует поле paymentToken - значит корзина уже создана и т.п.
- Невозможность вернуть в апи детали по нескольким платежам одновременно. 
  В текущей схеме апи мы даем пользователю предоставлять данные по платежам исключительно по очереди.

### Очередь задач
Очередь задач, запланированных на какое то время реализована в виде отдельной таблички в Ydb, 
в которой различные реализации трейта `TaskProcessor` могут оставлять заявки на выполнения своих задач.

Задачи в сервисе представлены type классом `ProcessingTask` и должны обладать уникальным идентификатором задачи `operation_type`,
а так же должны уметь сериализовать и десериализовать `entity_id` с которым они хотят работать. 

### Экспорт событий
В данный момент сервис экспортирует только изменения активных продуктов в топик [ProductEvent](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/log_model.proto)
 Вертикального [брокера](https://github.com/YandexClassifieds/etc-mono/tree/master/services/broker).
Брокер в свою очередь транслирует сообщения в кафку.

## Компоненты

### Api
Предоставляет gRpc сервисы для работы с 
[активными услугами](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/shop/goods_service.proto),
[продуктами](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/shop/product_service.proto) и 
[покупками](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/shop/purchase_service.proto)

**Disclaimer**
```
Cхема апи была написана по старым чертежам, составленым еще Русланом Соколовым.
Часть методов до сих пор не реализована и/или используется не так, как предполагалось изначально.
В комментариях в схеме описаны известные несоответсвия
```


Так же предоставляет http api для работы с платежными системами(например с [trust](trust.md))

### Scheduler
Выполняет периодические задачи по обработке сущностей shop.

Например:
- снятие активных продуктов с истекшим временем существования.
- обработка транзакций, покупок в нетерминальном состоянии
- экспорт изменений активных продуктов в брокер

## Storage
Данные хранятся в YDB.

`active_products` – активные продукты пользователей
- `shard_id: Uint32` - hash от userId - для размазывания данных по таблеткам
- `project: Utf8` - id проекта из [схемы](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/common_model.proto#L6)
- `user_id: Utf8` - id пользователя, присланный сервисом-потребителем
- `target_type: Utf8` - тип объекта, к которому применен ВАС
- `target_id: Utf8` - id объекта, к которому применен ВАС
- `product_code: Utf8` - код активного продукта
- `purchase_id: Utf8` - id связанной транзакции
- `start_time: Timestamp` - время активации
- `finish_time: Timestamp` - время деактивации

`PK = (shard_id, project, user_id, target_type, target_id, product_code)`
#

`purchases` – транзакции
- `shard_id: Uint32` - hash от id транзакции
- `id: Utf8` - id транзакции. Генерируется на стороне сервиса-потребителя
- `project: Utf8` - id проекта из [схемы](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/billing/common_model.proto#L6)
- `user_id: Utf8` - id пользователя, присланный сервисом-потребителем
- `status: Utf8` - статус покупки
- `refund_status: Utf8` - статус рефанда
- `last_update_time: Timestamp` - время последнего обновления
- `proto: String` - данные в protobuf-формате

`PK = (shard_id, id)`

`INDEX = (project, user_id, status, refund_status)` - для запроса активных транзакций пользователя(он, кстати, не работает)

`INDEX = (status, refund_status, last_update_time)` - для запроса зависших транзакций
#

`processing_queue` – таблица с запланированными на выполнение задачами
- `shard_id: Uint32` - hash от entity_id
- `operation_type: Utf8` - тип задачи
- `entity_id: Utf8` - id объекта, с которым нужно произвести изменения
- `process_time: Timestamp` - время, на которое запланировано выполнение задачи

`PK = (shard_id, operation_type, entity_id)`

`INDEX = (shard_id, operation_type, process_time)` - для запроса следущих задач на выполнение
#

`active_products_export_queue` – таблица экспорта изменений активных продуктов
- `shard_id: Uint32` - hash от change_time
- `change_time: Utf8` - время изменения продукта
- `product_id: Utf8` - id продукта
- `event_type: Utf8` - тип события
- `proto: String` - данные в protobuf-формате

`PK = (shard_id, change_time, product_id, event_type)`

## ToDo
Известные проблемы и варианты их исправления.

- Purchase содержит внутри себя одновременно статус покупки и статус рефанда. Значительно усложняет разработку композитных платежей.
Я бы разделил Purchase и Refund на 2 разных композитных сущности(аля Саги).
  
- Публичное апи содержит много старых сущностей и идей. Хорошо бы его почистить и разобраться "как должно быть".

- Приложение работает с одним client-tvm-id, поэтому траст использует только терминал Я.Объявлений.
Придется писать какой то свитчер, который будет использовать разные твм ид для разныx Project.
  
- Неэффективные индексы по базам. В частности индекс активных покупок(решается разделением Purchase и Refund),
  индекс по пользователю(не совсем эффективно работает пагинация), индекс по статусу для поиска "зависших покупок"(сильно перекошен в сторону одного шарда).
  
- Покупки по сути не являются сейчас композитными. Данные предполагают наличие нескольких PaymentDetails.
  Но по факту предполагаем только строго один TrustPaymentDetails.
  
- Нет разделения UserId и AccountId. Поэтому один пользователь не может платить с двух разных счетов. 
  В изначальном дизайне предполагался некий `AccountService`, но мы его так и не реализовали. (Возможно это и не нужно никому)
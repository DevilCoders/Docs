Схема таблиц вынесена в отдельный [файл](schema.sql).

# Реестр продуктов

Персистентное хранилище продуктов.

Каждый продукт имеет номер ревизии - уникальный идентификатор.
В моменте только одна ревизия продукта активна.
Любое изменение состава продукта - это новая ревизия и время, с которого эта версия актуальна.
Есть возможность задать ревизию продукта в будущем - "с 1-го января 2025 года продукт X имеет такой-то состав".
Есть возможность "отключить" продукт для конкретного сервиса начиная с какой-то даты. 

Сразу же нужна будет админка.

Пока плотно не думал над реализацией.
Возможно тут получится сделать это на Пальме. 

**В первом приближении это будет описанные в коде/конфиге продукты.**


# Котел активных услуг

Представляет из себя слепок активных услуг на данный момент.
Все неактивные услуги будут вычищаться из этого котла.

Неактивные услуги:
- отмененные посредством возврата
- достигшие finish_time
- one_shot услуги, факт применения которых мы доставили до потребителя

Котел активных услуг представлен в YDB таблицей **active_goods**.


Вопросы:
- Нужна ли свежая история активных услуг или будет достаточно таблицы в YT?
- для one_shot услуг может не стоит сразу удалять из котла, а ждать например сутки?

# Котел купленных услуг

Представляет из себя множество купленных услуг, которые будут применяться по переданному расписанию (покупки впрок или пакетные продукты).
Каждая услуга имеет счетчик активации, при полном исчерпании активации услуга удаляется из котла.

Котел купленных услуг представлен в YDB таблицей **purchased_goods**.


# Покупка

**Покупка** - это факт приобретения корзины с продуктами пользователем.

Статус покупки отражает ее состояние:
- APPLIED - добавлена в котел активных услуг или в котел купленных услуг
- PURCHASED - оплачена 
- PAYMENT_REQUIRED - еще не оплачена
- HOLD - захолдирована
- CANCELLED - платеж зареджечен
- REFUNDED - возвращенная покупка или частично возвращенная
- FAILED - техническая ошибка во время покупки

**basket** - корзина продуктов. Для каждого продукта есть контекст цены и опциональная цель, к которой будет применены услуги из это продукта.

**purchase_settings** - "настройки" платежа. Основная настройка это разметка покупки с композитным платежом.

**Композитный платеж** - это платеж, средства за который списываются с нескольких источников средств пользователя.
Например баллы Яндекс.Плюс и банковская карта.
Функционал композитного платежа Trust предоставляет из коробки.

Помимо Trust'овых методов оплаты у нас еще есть промокоды на деньги, которые мы так же хотим атомарно списывать при проведении покупки.

Такой распределенный композитный платеж мы проводим в два этапа:
- первым этапом холдируем необходимые средства во всех системах (пока это Trust и Promocoder)
- после успех подтверждаем холд

Покупки представлены в YDB таблицей **purchase**.

# Платеж

**Платеж** - списание средств с пользователя.

Платеж имеет статус, который описывает его текущее состояние.

**payment_details** - детали проведения платежа. Если платеж был отклонен платежной системой, то полезно хранить причину отклонения платежа.
**amount** - сумма платежа.
**markup** - разметка платежа, может быть несколько источников средств (композитный платеж).
**refund_amount** - сумма возвращенных средств по платежу, можем вернуть часть средств (частичный возврат).
**refund_markup** - разметка возврата, можем по-разному возвращать средства в случае композитного платежа.
 
Платежи представлены в YDB таблицами **gate_payment**.
Под каждый платежный гейт (ЮKassa, Trust) будет отдельная таблица в YDB с соответствующим префиксом.

# Очередь задач

Это очередь задач в классическом ее понимании.

От сервиса платежей в первую очередь мы хотим надежности и реактивности.

Очередь будет решать проблему надежности. Все асинхронные действия (отправка факта применения услуги, отправка факта покупки услуги и др)
предлагается проводить реактивно, но так же дублировать задачей в очередь.

**Обработчик** - процесс, который отвечает за выполнение задач.

Очередь задач представлена в YDB таблицей **queue**.


# Процессы

## Покупка

![Процесс покупки](http://www.plantuml.com/plantuml/png/ZP5DQiCm48NtEeMM3gGNwA84kYXT14n33o3aIIEgdrGpK-Zjws0952R8NWg_z_Jfym79PEBWbI977lJ8sLuCWbAlta4a_VIYJv1_dOLd_G4_34ZwcjF4bb2VKzPayXUGAg5RVZH_OQvkgjrdxsuRIxoTNg2QRttEPLm7e4kQS9rHLBfy9NeiKOaf8Wzfg_AX-jaNEVjASpJvcw-x7l_saTeKMs-6sY4J4aTPRy8zZi_iU-w69ZTVKGxlqqvQx8IhJl68cLcGDD1r6DbQG5GhZwfd7HEvixE6N8gF_kIi-qI668SMKffUAKXlGk_Iah94GXqWJXoy-WS0).

Это полный цикл покупки.
Если оплата выполняется рекуррентным способом оплаты (например, привязанная карта), то никакого подтверждения оплаты и ввода данных метода оплаты от пользователя не нужно.
Пользователь сразу получит результат оплаты.

### Покупки впрок и наложение услуг

В продукте есть опция _able_to_rebuy, которая говорит можно ли купить продукт впрок.
Если нельзя, то при наличии полного списка услуг это продукта в котле активных услуг, мы не позволяем купить этот продукт по заданному _target_.
И не возвращаем этот продукт в списке доступных для покупки.

### Идемпотентность
Сервис при покупке предает ключ идемпотентности, который мы можем использовать в качестве идентификатора покупки.
 
Если с подобным ключом не было покупок, то инициируем новую. 

### Автопродление

Автоматическая покупка продукта при истечении срока действия услуг от предыдущей покупки.
Если продукт имеет свойство автопродляемости, то во время покупки это продукта можно включить автопродление этой покупки.

Так же у пользователя есть возможность отключить автопродление.

### Активация услуги

Процесс применения услуги на _target_.
Если в процессе покупки был передан _target_, то услуга будет сразу же применена либо отложена в котел купленных услуг, если уже есть такая же активная услуга.

При отсутствующем _target_ услуга попадает в котел купленных услуг, откуда ее можно будет применить, к конкретному _target_.

### Деактивация услуги

Деактивация (удаление из котла активных услуг) услуги происходит в двух случаях:
- в случае возврата соответствующей покупки
- по достижению конца срока действия услуги

Непосредственно перед деактивацией услуги мы проверяем наличие автопродления и купленных услуг, которые находятся в ожидании применения.
Продляем/применяем, если таковые есть.

Отправлять факт деактивации в потребителя в таком случае не стоит, дабы не было швов.

### Нотификации потребителям

Все нотификации отправляем через Брокер.
Думаю стоит завести единую очередь событий.
Отправлять планируем:
- факт покупки (успех/неуспех)
- факт возврата
- факт активации (применения) услуги
- факт деактивации

Вопрос:
Брокер не умеет в порядок событий, не станет ли это проблемой тут?

### Покупка с композитным платежом

Композитный платеж я бы разделил на 2 вида, распределенный и нераспределенный.

Распределенный это когда композитный платеж проходит в рамках нескольких внешних сервисов.

Например мы проводим оплату через Trust и при этому списываем промокоды с пользователя.

В этом случае мы холдируем средства во всех системах, и при успехе мы подтверждаем холда, в случае неуспеха одного из холдов мы делаем отмену (дефект) успешных холдов.




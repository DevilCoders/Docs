# Pica
*Мета* - метаданный изображения, например результат обработки компьютерного зрения (КЗ).

*Хост* - хостнейм урла изображения.

Сервис аккумулирует логику по работе с изображениями:
- ассинхронная скачивание изображений
- хранение результата скачивания
- контроль доступных ресурсов

Под капотом сервис использует [Аватарницу](https://wiki.yandex-team.ru/mds/avatars/).

Изображение в Пике, в отличие от Аватарницы, адресуется по кортежу _(неймспейс, url изображения)_.
Неймспейс соответствует неймспейсу в Аватарнице.

По сути Пика представляет из себя кеш Аватарницы на стеройдах.

Но почему тогда не ипользовать напрямую Аватарницу?

Помимо кеширования Пика предоставляет:
- более удобное апи с адресацией изображения по его урлу
- дедупликация изображений по урлу
- тротлинг нагрузки по хостам
- уведомления о результате прокачки
- проверка изображения на актуальность (head запрос по урлу изображения)

## Компоненты
`Api` - grpc-api по работе с Пикой.
`Controller` - обработка очереди задач.

## Api
Обработка клиентских запросов.

## Controller
Скачивание изображения происходит в асинхронном режиме.
Из Api запрос на скачивание изображения попадает в очередь задач, которая разгребается воркерами.

## Хранение данных
В качестве стораджа используется YDB.
Для каждого неймспейса используется отдельная директория.

Таблица с результатами скачивания изображений партиционированна по host.

## Очередь

2 варианта как реализовать очередь (Используем оба):
1. организована над таблицей с результатами скачиваяния, добавив индексное поле с временем, когда нужно обработать
2. отдельная очередь задач (по аналогии со спамолотом)

## Тротлинг
Насущной проблемой является скудные технические ресурсы наших партнеров.
Зачастую изображения скачивать с них можно нагрузкой не более чем в единицы rps.

Как писалось выше, работа по изображениям с одного хоста будет локализирована на одном воркере, поэтому тут можно будет использовать локальный лимитер.
(Если откажемся от партиционирования по хосту, то сделаем распределенный лимитер на основе YDB)

Лимитировать нагрузку на Аватарницу можно будет через распределенный лимитер либо об саму Аватарницу.

## Проверка изображения на актуальность
Делаем HEAD запрос на получение изображения и проверяем, что ничего не поменялось с момента последней прокачки.
Если поменялось, то отправляем изображение на перепрокачивание.

Как выбирать изображения на эту проверку - тут тоже пока 2 варианта:
- автоматически отправлять на проверку все изображения старше N 
- ленивая проверка, при get запросе изображения проверяем время его скачивания и если старше N дней отправляем на обработку.

Такую проверку введем для конфигурируемого списка хостов.

## Удаление изображения
Изображение можно удалить из сервиса через Api.
Оно будет удалено из сервиса и из Аватарницы, но из публичного Api Аватарницы оно будет некоторое время еще доступно.
При удалении удаляем синхронно из стораджа и атомарно с этим кладем задачу удаления из авы в персистентную ydb очередь
(та же, что используется для отправки в брокер).
Далее таск уже обрабатывает очередь на удаление и гарантированно удаляет изображение из авы.

## Перепрокачка изображения и обновление меты
Можно форсировать перепрокачку уже скачанного изображения.
В таком случае в Аватарницу это изображение будет загружено под новым именем, а старое будет удалено, при этом старое будет некоторое время доступно из публичного Api Аватарницы.

Так же можно пересобрать метаинформацию изображения.
Изображение не будет скачиваться заново, текущая метаинформация будет удалена из Аватарницы и загружена новая.

## Уведомление о результате обработки
[Отправляем результаты скачивания, удаления и получения меты в брокер](./broker.md)

# Совместимость схем в yt

# Статус

предложено

## Контекст

Валидные изменения в прото могут быть невалидны в yql, в этом случае регулярные процессы аналитиков не могут отрабатывать по таблицам за диапазон дат с разными прото-схемами.

### Как сейчас работает эволюция

Пишем в регулярные таблицы, держа локальный кэш версий, если версии нет в кэше, проверяем ыть, если надо - обновляем schema_versions и _yql_proto_fiels_column_name-ы на таблице. Те обновляются только дни, в которые пишут.
В часовых таблицах (иммутабельных) схема проставляется один раз при создании, равна схеме регулярной таблицы.
В перепартиционированных таблицах схема обновляется при каждом добавлении данных из регулярной.

Как это выглядит в ыте:

```
> warehouse/stream-path
корневая директория поставки

> warehouse/stream-path/1d
директория регулярных таблиц, кроме 1d может быть 1m/1y
> warehouse/stream-path/1d/2022-02-24
пример таблицы
> warehouse/stream-path/1d/2022-02-24/@schema_versions
атрибут со всем версиями, записанными в таблицу,
для каждой колонки выбирается прото-схема максимальной доступной версии (колонки могут удаляться)
> warehouse/stream-path/1d/2022-02-24/@schema_version
устаревший атрибут со старшей версией, нужно дропнуть перед тем, как делать что-то новое
> warehouse/stream-path/1d/2022-02-24/@_yql_proto_fiels_column_name
атрибут с прото-схемой колонки

> warehouse/stream-path/1h
директория часовых таблиц, кроме 1h может быть минутной, например 30m
> warehouse/stream-path/1h/2022-02-24_013
пример часовой таблицы

> warehouse/stream-path/1y
директория архивных таблиц, кроме 1y может быть 1m
> warehouse/stream-path/1y/2021-01-01
пример архивной таблицы

> warehouse/stream-path-repartitioned/1d
директория таблиц, перепартиционированных по другому таймстампу
> warehouse/stream-path-repartitioned/1d/2022-02-24
пример перепартиционированной таблицы

```

### Как будет работать

Если мы хотим поддерживать одну главную версию на все таблицы (включая архив и перепартиционированные), нужно держать информацию о максимальной версии потока, например в корне поставки.
Обновления таблиц не должны тормозить запись в новые дни.

Добавляем атрибут c версией стрима:

```
> warehouse/stream-path/@max_schema_version "v0.0.6001"
```

Здесь писатель в yt (broker-pipeline-lb-yt) транзакционно обновляет максимальную известную версию в потоке (проверяет по предыдущей что она действительно растёт).
Yops-процесс:

* запускает task, проверяет, настало ли время обхода
* последовательно обходит все директории и находит все, что нужно обновить, в цикле начинает обновлять батчами.
* если доходит до конца, запоминает время и увеличивает период обхода.
* при обновлении максимальной версии, мы сбрасываем период обхода (тут можно экспоненциально сделать 0, час, 5 часов, день).

```
> warehouse/stream-path/@evolution
{
    schema_version: "v0.0.6000", //версия, на которую нужно обновить ноды (список нод может быть пуст, если всё обновили)
    last_check: "2022-01-01 10:00:00"
}
```

### Дополнения

Что можно сделать чтобы снизить количество запросов в ыть.

#### Сохранять состояние yops-обходчика в атрибуте

Чтобы не переобходить дерево после рестарта/переезда лидера yops. Например так:
```
> warehouse/stream-path/@evolution
{
    schema_version: "v0.0.6000", //версия, на которую нужно обновить ноды (список нод может быть пуст, если всё обновили)
    last_check: "2022-01-01 10:00:00",
    nodes: {
        //ноды разбиты по типам, приоритет обновления задаётся в приложении (логичным кажется repartition-regular-archive)
        repartitioned: ["warehouse/stream-path-repartitioned/1d/2022-02-24"],
        regular: [warehouse/stream-path/1d/2022-02-24, warehouse/stream-path/1d/2022-02-23], //ноды упорядочены по приоритету, вначале новые
        holocron: [warehouse/stream-path-eod/1d/2022-02-24],
        archive: []
    }
}
```
yt-атрибут может хранить до 16мб, тут можно держать до 60к путей, вполне подходит.

#### Проверка об анубис

Можно дополнительно проверять что между версией эволюции и последней версией стрима существует yql-несовместимое расхождение, и обновлять только в этом случае. Это должно существенно снизить число обновлений, в большинстве случаев они не нужны.
Потребуется новый тип проверки в анубисе. Проверенную анубисом версию можно кэшировать в атрибуте @evolution чтобы снизить нагрузку на анубис.

# Центр уведомлений

Центр уведомлений – единая точка коммуникации с пользователями Авто.ру и Я.Недвижимости

Основные цели:
* Уведомления от сервиса, которые мы рассылаем пользователю, нужно складывать в интерфейс "Центр уведомлений" по типу fb/банковских приложений для эффекта отложенного перехода (просто пуши можно смахнуть и никогда больше не увидеть этой инфы, даже если хочется)
* Больше контроля над отключением уведомлений. ЦУ даст возможность контролировать нашу собственную назойливость с одной стороны (не слать подряд несколько уведомлений от разных источников), с другой - дать пользователям возможность точечно управлять каналами уведомлений (отписываться, настраивать желаемую частоту и время получения)

Центр уведомлений объединяет в себе все остальные (отличные от чатов и подписок) уведомления:
* транзакционные уведомления про офферы и деньги
* ручные рассылки через пушной и аппметрику (пробить разово кусок аудитории, типа – поучаствуйте владельцы тачек в конкурсе панорам)
* коммуникацию с пользователем из hipe (вернись и позвони!)
* коммуникацию маркетинга (сейчас это пуши через аппметрику и email рассылки)

## Компоненты
* grpc-api в виде отдельных сервисов для отправки, получения уведомлений и управления настройками пользователя
* контроллер, запускающий периодические таски по обработке операций отправки уведомлений и пушей

## API
#### Отправка сообщений
Поддерживаются массовые и единичные рассылки. Кроме того отправитель может указать дополнительные каналы для отправки уведомления – сейчас только пуши, в будущем - sms и email.

Отправка пуша, как и отправка сообщения в ЦУ происходит асинхронно, ответ апи означает что сообщение принято в обработку. Запрос можно поретраить с тем же айди нотификации, это не должно приводить к дубликатам.
Апи складывает запросы в [очередь](design.md#очередь) и отдельный обработчик дальше их обрабатывает.
В будущем добавятся размазывание отправки массовых рассылок по периоду, пользовательские расписания и троттлинг.

#### Конструктор уведомления
Содержимое уведомления может быть задано [конструктором](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/grpc/vertis/spamalot/model.proto#L47) или [шаблонами](https://github.com/YandexClassifieds/schema-registry/blob/master/proto/grpc/vertis/spamalot/model.proto#L48).

* Кроме заголовка и содержимого уведомления, конструктор позволяет задать медиавложения в виде ссылок - картинку, видео, файл. Предполагается, что отправитель уже загрузил контент куда-либо, ЦУ (пока?) не предоставляет api загрузки.
При этом для пушей будет использоваться только картинка (например, это может быть превью для видео). 

* Отправитель может задать действие (экшен) при нажатии на уведомление, а также кнопки, для которых задается текст и действие при нажатии. Пуши наследуют эти действия насколько возможно: например, для пушей есть ограничение в максимум 3 кнопки, на ios не поддерживаются кастомные кнопки (заголовки для них задаются категорией пуша).
Экшены представляют собой ссылку и пейлоад с полем, указывающим на тип (чтобы клиент знал, как парсить пришедший пейлоад). Предполагается, если клиент не понимает пейлоад, он просто открывает ссылку. Ссылки задаются отдельно под каждую платформу - web, android, ios.

* Категория пуша для ios задает зарегистрированный на стороне приложения шаблон для отображения пуша и задается отправителем, так как не может быть выведена из топика уведомления (преполагается, что уведомления одной тематики могут иметь разные шаблоны).
//Q: что будет, если не задано или задано несуществующее? 

* Так же есть возможность задать ограничение на версию приложения, поддерживающую отправляемый пуш - если версия не удовлетворяет условию, пуш отправлен не будет.

#### Отправка пушей
Транспортом для отправки пушей является [пушной](https://github.com/YandexClassifieds/pushnoy/blob/master/README.md) и, соответственно, [xiva](https://console.push.yandex-team.ru/#overview).

В качестве получателей выступают пользователи из пушного (как залогиненные, так и анонимные). Пуш будет отправлен на все устройства, привязанные к этому пользователю.

Пуши отправляются, если был указан соответствующий канал отправки уведомления, и рендерятся из пейлоада или шаблона в формат, подходящий для пушного. 

Подробно формат пуша описан [тут](push_format.md).

#### Получение сообщений
Клиенты могут получать сообщения по пользователю с фильтрами по топикам и статусу прочитанности и поддержкой страничности.

Так же есть возможность отдельным запросом получить счетчик непрочитанных сообщений.

Сообщение считается прочитанным при нажатии на пуш или при попадании в видимую область экрана. Клиенты могут отмечать прочитанными несколько сообщений батчем, все сообщения определенной тематики или вообще все сообщения.

#### Настройки пользователя
Пользователь может настраивать лимиты на получение сообщений определенной тематики, может полностью выключать получение уведомлений по определенным тематикам, а также задавать удобное время для получения и таймзону.

Все вышеперечисленное относится только к дополнительным каналам доставки уведомлений, в колокольчике они появляются по запросу с клиента.

В случае, если таймзона не задана, отправка будет осуществляться в соответствии с таймзоной одного из сохраненных в пушном девайсов. 

## Очередь
Очередь операций представляет собой таблицу в YDB, разбитую на 32 партиции. Обработка происходит параллельно по всем партициям, батчами до 512 операций.
Если в партиции был не полный батч готовых к обработке операций, обработчик партиции спит 30 секунд.
При обработке партиции операции берутся по возрастанию времени отправки (т.е. FIFO) с ограничением до настоящего момента.

Операция создания нотификации идемпотентна и выполняется at least once. Из операций создаются уведомления, обновляются счетчики непрочитанных, а так же планируются операции отправки пушей, если нужно.
После успешной обработки батча они удаляются из таблицы. Если операция удаления не выполнилась, она выполнится при следующем проходе.

Обработка пушей происходит по принципу at most once, т.е. операции отправки удаляются из очереди независимо от успешности их обработки, чтобы не продублировать пуши.
 
### Партиционирование
Для того, чтобы вставка новой операции не инвалидировала лок обработчика существующих операций, сделано 2 вещи:
* новые операции шедулятся не на текущее время, а на 30 секунд вперёд
* партиционирование осуществляется не по отрезкам, а по точкам, поскольку локи в ydb берутся на 1 непрерывный диапазон

Т.е., предположим у нас 2 партиции. Можно было бы для каждой операции писать partitionHash = hash(operation.userId) и выбирать для первой партиции операции c partitionHash в промежутке [Int.MinValue, -1], и [0, Int.MaxValue] для второй.
Но в этом случае select по партиции с дополнительным условием operationTs <= now заблокирует весь диапазон ключей по partitionHash.
 
Если же мы будем хранить для каждой операции partitionId, равный, например, начальной точке отрезка из первого примера (Int.MinValue для первой и 0 для второй), то запросы на подходящие по времени операции партиции не будут инвалидироваться вставкой новых операций в эти же партиции. И при высокой нагрузке на апи контроллер не будет делать ненужные ретраи.
Тест на это поведение можно найти в OperationsQueueStorageIntSpec. 

Можно было бы использовать не первую точку, а порядковый номер партиции, но в spamalot используется именно точка, для равномерного распределения значений по множеству int32
 
## Рэйтлимитер

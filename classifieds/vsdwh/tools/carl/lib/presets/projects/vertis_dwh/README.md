# Пресеты [Группы аналитической инфраструктуры](https://staff.yandex-team.ru/departments/yandex_personal_vertserv_internal_marketing_dep14131_dep57007/) Вертикалей

## [dm](dm)
Директория для пресетов графов, выполняющих заполнение витрин данных.


Помимо пресетов содержит модуль [dm_utils](./dm/dm_utils.py), предоставляющий вспомогательный класс `DmCleanUp` для пробрасывания в пресеты способов
предварительной очистки витрин данных. Поля класса:
* `cleanup_query_path: str` — относительный путь локальному к файлу или путь к ресурсу для очистки. Должен быть непустым и иметь расширение `.py` или `.sql`, в противном случае бросит ошибку при создании
* `query_extraction_action: tp.Callable[[...], tp.Union[VhExpr, str]] = expr_resource_opt` — функция, которая будет применена к `cleanup_query_path` в пресете для извлечения и преобразования содержимого. Должна возвращать строки или объекты `VhExpr`(=`vh3.Expr`) — объект `vh3` для описания Nirvana-экспрешенов.
* `cleanup_query_requires_input: bool = False` — булев флаг, который определяет, нужно ли скрипту генерации запроса очистки подавать данные на вход. Может быть `True` только с `.py` файлами, в этом случае YQL-запрос генерации витрины должен писать в выход output4 табличку с колонкой дат для использования в скрипте генерации.


Директория [dm_resources](./dm/dm_resources) содержит ресурсы с запросами и Python-скриптами для предварительной очистки витрин данных. Эти запросы наиболее ходовые, поэтому сохранены в ресурсах для переиспользования. При необходимости в `DmCleanUp` можно передать и локальный файл с каким-нибудь другим запросом/скриптом.

### [ch.py: ClickHouse](dm/load_ch_dm_from_yt.py)
Модуль для пресетов графов, выполняющих загрузку данных в витрины на ClickHouse:


#### **load_ch_dm_from_yt**
Выгружает данные из результатов YQL запроса с YT, (опционально) обновляет словари, загружает данные в витрину на ClickHouse.


**Важно:** использует кубик YQL-4, выходы этого кубика зарезервированы под следующие цели:
1. output1 — для обновления словарей, если нужно
2. output2 — для самого агрегата, отправляемого в витрину
3. output4 — для списка дат, если нужна очистка витрины по результатам запроса
Необходимо учитывать это при написании запросов.


**Важно:** для корректной работы пресета при описании графа carl-кодом должны быть заданы глобальные опции графа:
1. `target_database` и `target_table`: строковые опции, содержащие схему и название целевой таблицы-витрины
2. `yt_token`, `yql_token`, `mr_account`, `yt_pool`, `ch_host`, `ch_port`, `ch_user`, `ch_password`, `pg_host`, `pg_port`, `pg_user`, `pg_password` (для словарей)
3. `dm_date_field`, если нужа очистка витрины по датам, полученным из запроса


На данный момент лучше всего target_database и target_table добавлять руками через `GraphConfig`, а остальные брать из ресурса `projects/vertis-dwh/prod`.
##### Аргументы:
| Название | Тип | Описание | Значение по умолчанию |
|---|---|---|---|
| `yql_query_file` | `str` | Относительный (из директории скрипта с carl-кодом графа) путь до файла с YQL-запросом, результаты которого будут отправляться в витрину данных. | Обязательный аргумент |
| `yt_output_columns` | `List[str]` | Список колонок для выгрузки из таблички, полученной YQL-запросом. Порядок колонок должен совпадать с порядком колонок целевой таблицы-витрины. | Обязательный аргумент |
| `dm_ch_cleanup` | `Optional["DmCleanUp"]` | `None` или объект [DmCleanUp](./dm/dm_utils.py). Если `None`, то предварительная очистка не будет произведена, и выгруженные данные просто дозапишутся в целевую таблицу, иначе должен содержать в поле `cleanup_query_path` относительный (из директории скрипта с carl-кодом графа) путь до файла c запросом для предварительной очистки целевой таблицы-витрины, **обязательно** с расширением `.py` или `.sql`. В первом случае в граф будут добавлены кубики, генерирующие переданным Python-кодом скрипт для очистки витрины. Во втором случае будет исполнен на ClickHouse сам переданный SQL-запрос. Можно передавать ресурсы, объявленные в локальном [ya.make](../../ya.make) пресетов. Для `.py`-файлов и ресурсов возможно использовать список дат из запроса агрегации для витрины, за это отвечает флаг `DmCleanUp.cleanup_query_requires_input`. В поле `query_extraction_action` должна быть передана функция, которая будет вызвана для извлечения контента из поля `cleanup_query_path`. По умолчанию будет пытаться извлечь ресурс, можно передать `expr_file_opt`, если запрос хранится в локальном файле. При каких-то особых случаях можно передать кастомную функцию, если нужна какая-то индивидуальная логика извлечения контента. В поле `cleanup_query_requires_input` содержится флаг, отвечающий за использование результатов запроса формирования витрины для генерации скрипта очистки старых данных. Может быть `True` только в случае, когда в поле `cleanup_query_path` передан `.py`-файл или ресурс. Запрос очистки в таком случае должен быть аналогичен [такому](dm/dm_resources/clickhouse_drop_parts_by_input4_month.py) с таким же возвращаемым словарём, чтобы результат работы можно было передать динамической опцией в `Single Option To Text Output` (в пресете это произойдёт автоматически).| Обязательный аргумент |
| `yt_output_missing_value_sentinel` | `Optional[str]` | Определяет способ обработки пропусков в данных для кубика [MR Read TSV](https://nirvana.yandex-team.ru/operation/d23ec268-5a94-42f9-bd6b-5062dccbd3f5). Если передан `None`, то будет выбран режим `FAIL`, если передана какая-то строка, то будет выбран режим `PRINT_SENTINEL`, и пропуски будут заполняться этой самой строкой | `None` |
| `normalization_list` | `Optional[List[str]]` | Если передан `None` или пустой список, обновления словарей по расчитанным данным производиться не будет. Если передан какой-то список, то в граф будет добавлен подграф `wf_internal_load_yt_dicts_to_pg`, производящий обновление словарей по этому списку. Если требуется обновление словарей, это должно быть учтено в YQL-запросе: в `{{output1}}` он должен писать табличку с колонками, из которых будет производиться обновление словарей. Список этих колонок и должен быть передан в `normalization_list` в одном из двух форматов: если колонка называется `column_name`, а словарь — `column_name_d`, то в список достаточно добавить строчку `"column_name"`, в противном случае нужно добавить `column_name:dict_name`, чтобы погдраф понял, что значениями из колонки `column_name` нужно обновить словарь `dict_name` | `None` |
| `max_ram_mb` | `int` | В случае, если в витрину отправляется большой файл, можно передать значение этого параметра побольше, тогда всем кубикам, оперирующим этим файлом, будет проставлено это ограничение на оперативную память. | 1024 |
| `max_disk_mb` | `int` | В случае, если в витрину отправляется большой файл, можно передать значение этого параметра побольше, тогда всем кубикам, оперирующим этим файлом, будет проставлено это ограничение на дисковую квоту. | 4096|



### [pg.py: PostgreSQL](dm/load_pg_dm_from_yt.py)
Модуль для пресетов графов, выполняющих загрузку данных в витрины на PostgreSQL:


#### **load_pg_dm_from_yt**
Выгружает данные из результатов YQL запроса с YT, (опционально) обновляет словари, загружает данные в витрину на PostgreSQL.

**Важно:** для корректной работы пресета при описании графа carl-кодом должны быть заданы глобальные опции графа:
1. `target_database` и `target_table`: строковые опции, содержащие схему и название целевой таблицы-витрины
2. `yt_token`, `yql_token`, `mr_account`, `yt_pool`, `pg_host`, `pg_port`, `pg_user`, `pg_password`
3. `dm_date_field`, если нужа очистка витрины по датам, должен содержать название поля с датой в целевой витрине, чтобы использовать в DELETE-выражении

На данный момент лучше всего target_database и target_table добавлять руками через `GraphConfig`, а остальные брать из ресурса `projects/vertis-dwh/prod`.

##### Аргументы:
| Название | Тип | Описание | Значение по умолчанию |
|---|---|---|---|
| `yql_query_file` | `str` | Относительный (из директории скрипта с carl-кодом графа) путь до файла с YQL-запросом, результаты которого будут отправляться в витрину данных. | Обязательный аргумент |
| `yt_output_columns` | `List[str]` | Список колонок для выгрузки из таблички, полученной YQL-запросом. Порядок колонок должен совпадать с порядком колонок целевой таблицы-витрины. | Обязательный аргумент |
| `dm_pg_cleanup` | `Optional["DmCleanUp"]` | `None` или объект [DmCleanUp](./dm/dm_utils.py). Если `None`, то предварительная очистка не будет произведена, и выгруженные данные просто дозапишутся в целевую таблицу, иначе должен содержать в поле `cleanup_query_path` относительный (из директории скрипта с carl-кодом графа) путь до файла c SQL-запросом для предварительной очистки целевой таблицы-витрины. Если передан `None` или пустая строка, то предварительная очистка не будет произведена, и выгруженные данные просто дозапишутся в целевую таблицу. Если строка непуста, то запрос из переданного файла будет исполнен перед загрузкой данных в целевую таблицу. Поддерживает передачу в это поле ресурсов, объявленных в [ya.make](../../ya.make) пресетов. В поле `query_extraction_action` должна быть передана функция, которая будет вызвана для извлечения контента из поля `cleanup_query_path`. По умолчанию будет пытаться извлечь ресурс, можно передать `expr_file_opt`, если запрос хранится в локальном файле. При каких-то особых случаях можно передать кастомную функцию, если нужна какая-то индивидуальная логика извлечения контента. | Обязательный аргумент |
| `yt_output_missing_value_sentinel` | `Optional[str]` | Определяет способ обработки пропусков в данных для кубика [MR Read TSV](https://nirvana.yandex-team.ru/operation/d23ec268-5a94-42f9-bd6b-5062dccbd3f5). Если передан `None`, то будет выбран режим `FAIL`, если передана какая-то строка, то будет выбран режим `PRINT_SENTINEL`, и пропуски будут заполняться этой самой строкой | `None` |
| `normalization_list` | `Optional[List[str]]` | Если передан `None` или пустой список, обновления словарей по расчитанным данным производиться не будет. Если передан какой-то список, то в граф будет добавлен подграф `wf_internal_load_yt_dicts_to_pg`, производящий обновление словарей по этому списку. Если требуется обновление словарей, это должно быть учтено в YQL-запросе: в `{{output1}}` он должен писать табличку с колонками, из которых будет производиться обновление словарей. Список этих колонок и должен быть передан в `normalization_list` в одном из двух форматов: если колонка называется `column_name`, а словарь — `column_name_d`, то в список достаточно добавить строчку `"column_name"`, в противном случае нужно добавить `column_name:dict_name`, чтобы погдраф понял, что значениями из колонки `column_name` нужно обновить словарь `dict_name` | `None` |
| `max_ram_mb` | `int` | В случае, если в витрину отправляется большой файл, можно передать значение этого параметра побольше, тогда всем кубикам, оперирующим этим файлом, будет проставлено это ограничение на оперативную память. | 1024 |
| `max_disk_mb` | `int` | В случае, если в витрину отправляется большой файл, можно передать значение этого параметра побольше, тогда всем кубикам, оперирующим этим файлом, будет проставлено это ограничение на дисковую квоту. | 4096|

**Важно:** поле `cleanup_query_requires_input` объекта `dm_pg_cleanup` не используется в этом пресете, поэтому при описании графов этим пресетом можно не указывать его в конструкторе `DmCleanUp`, возьмётся дефолтный `False`. В поле `cleanup_query_path` объекта `dm_pg_cleanup` всегда нужно передавать `.sql`-файл, это проверяется на уровне пресета.

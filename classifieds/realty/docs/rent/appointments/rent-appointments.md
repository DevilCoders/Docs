# rent-appointments

Сервис для планирования и назначения выездов: физических встреч по адресу квартиры.

[Продуктовая документация](https://wiki.yandex-team.ru/yandex.arenda/vm-task-system/)

## Решаемые задачи
1. Хранение прошедших и предстоящих выездов
2. Создание новых и редактирование существующих выездов
3. Поиск доступных слотов для назначения нового выезда с учетом логистики (длительность поездки до места выезда)
4. Выгрузка истории изменений выездов в YT для целей аналитики
5. Выгрузка обновлений выездов в виде событий (используется для оповещения участников и обновления сделок в Amo)

Какие задачи сервис **не решает**:
1. Смена времени и порядка посещения существующих выздов для оптимизации работы сотрудников
2. Создание встреч/выездов в общем виде, а не только для нужд Я.Аренды

## Основные сущности
* `Appointment` - Выезд. Назначенная встреча по адресу квартиры Яндекс.Аренды.
Основные атрибуты:
    * Время
    * Адрес
    * Исполнитель
    * Статус (Будущий, Отменен, Проведен)
    * Тип выезда (приёмка, фото, показ и т.д.)
    * Id квартиры

* `Employee` - Сотрудник, участвующий в выездах. Основные атрибуты:
    * Точка старта и конца маршрута (домашний адрес)
    * Возможные типы выездов (множество)
    * Тип транспорта (Личный автомобиль, общественный транспорт)

## Архитектура сервиса

![rent-appointments architecture](img/rent-appointments-ver1.png)

Сервис состоит из одного приложения: `rent-appointments`.
Внутрнеее api сервиса сделано на базе gRPC.
Для внешнего api используется
[GraphQL](http://realty-graphql-server-api.vrts-slb.test.vertis.yandex.net/graphiql).

## Хранение данных

### Выезды

Для хранения выездов используется MySQL. Требования к базе данных свободные,
так как не планируются условно высокие нагрузки и нет необходимости ни в реляционности. Поэтому
в качестве альтернативы можно использовать практически любую другую БД, например, YDB.

Схема хранения для выездов:
```
TABLE appointment (
    appointment_id VARCHAR(32) PRIMARY KEY, -- уникальный id выезда
    appointment_time DATETIME(3) NOT NULL, -- назначенное время выезда
    subject_federation_id INT NOT NULL, -- id города в геобазе
    employee_login VARCHAR(32) NOT NULL, -- login на staff'е сотрудника, который будет проводить встречу
    flat_id VARCHAR(32) NOT NULL, -- id квартиры в rent-api (например, нужно для уведомлений)
    status ENUM ('NEW', 'CANCELED', 'COMPLETED') NOT NULL, -- статус выезда
    appointment_type ENUM ('PHOTO', 'SHOWING' ...) NOT NULL, -- тип выезда
    data MEDIUMBLOB NOT NULL, -- адрес квартиры, описание встречи и т.д.
    data_json MEDIUMTEXT NOT NULL,
    version INT NOT NULL, -- версия выезда, увеличивается при каждом обновлении. Упрощает работу с историей изменений в YT
    -- + поля, необходимые для работы watcher'а
    INDEX subject_federation_id_status_appointment_time_idx (subject_federation_id, status, appointment_time),
    INDEX flat_id_status_idx (flat_id, status)
)
```

### Данные о сотрудниках

Данные о сотрудниках изменяются редко. При этом все изменения будут производиться
менеджерами вручную. Чтобы не имплементировать свое API и свой UI для управления этими настройками,
предлагается использовать [palma](https://docs.yandex-team.ru/classifieds-infra/palma/info).

Примерная схема хранения:

```
message EmployeeData {
    // .. системные поля Пальмы

    message Point {
        double latitude = 1;
        double longitude = 2;
    }

    enum AppointmentType {
        UNKNOWN = 0;
        PHOTO = 1;
        SHOWING = 2;
        // ...
    }

    enum TransportationMode {
        UNKNOWN = 0;
        CAR = 1;
        PUBLIC_TRANSPORT = 2;
    }

    string staff_login = 1 [(.palma.field).key = true]; // Логин сотрудника на staff'е
    Point starting_point = 2; // "Домашняя" точка сотрудника
    repeated AppointmentType appointment_types = 3; // Типы выездов, которые может проводить сотрудник
    TransportationMode transportation_mode = 4; // Средство передвижение сотрудника
}
```

Возможно, в первоначальной версии было бы удобно дополнительно хранить ENUM
с городом сотрудника, чтобы не вычислять город исходя из точки. Данное решение в
первую очередь зависит от того, будут ли использоваться различные графики дежурств для разных городов.

### Графики дежурств

На момент запуска сервиса графики дежурств будут настраиваться и храниться в
дежурствах ABC: [дежурства 2.0](https://wiki.yandex-team.ru/intranet/abc/docs/dezhurstva-2.0/).
Дальнейшее развитие зависит от того, насколько данный инструмент будет удобен в использовании.

### Получение данных из ABC и из Palma

В первонавчальной версии сервиса графики дежурств и данные о сотрудниках
предлагается получать синхронно в момент обработки запроса на поиск доступных слотов.
В дальнейшем эти данные можно будет вынести в отдельные ресурсы,
которые будут собираться в фоновом процессе.

В перспективе года ожидается до 15 активных сотрудников в день в одном городе, поэтому синхронное получение сотрудников
из Palma допустимо использовать для MVP сервиса.

## Поиск доступных слотов

Поиск доступных слотов заключается в нахождении всех возможных вариантов
времени назначения выезда конкретного типа (накладывает ограничение на подходящих сотрудников) для конкретной квартиры в конкретный день.

В базовом виде, без учета эвристик и оптимизаций, процесс обработки таких запросов может выглядеть следующим образом:

1. Получить всех сотрудников, работающих в заданную дату, из ABC (или использование локального ресурса)
2. Получить информации по необходимым сотрудникам из Palma (или использование локального ресурса)
3. Получить адрес квартиры (географической точки) из `realty-rent-api`
4. Получить все активные выезды в данном городе в заданную дату
5. Получить длительность поездок от точек всех выездов и "домашних" точек сотрудников до рассматриваемой квартиры из [Матрицы расстояний](https://yandex.ru/dev/maps/distance_matrix/doc/).
6. Информация, полученная на предыдущих шагах, дает левые границы интервалов, в которые можно назначать выезд
(время завершения выезда/время начала работы + время пути до квартиры)
7. Осталось получить правые границы интервалов: "во сколько необходимо выхеать на следующий выезд" - (минус) длина выезда.

    Матрица расстояний не отвечает на "обратные" запросы (во сколько необходимо выехать, чтобы приехать к определенному времени).
Можно предположить, что время поездок не сильно изменяется в рамках небольшого интервала времени.
Тогда приблизительный ответ можно получить, запросив время поездки, например, используя время следующего выезда минус 1 час.

    Альтернативно, можно найти более точные ответы бинарным поиском (ничего не даст, потому
время в любом случае придется запрашивать с округлением, об этом написано далее)

8. Итоговые слоты -- непустые интервалы.

### Взаимодействие с Матрицей расстояний

К сожалению, api Матрицы расстояний не позволяет указать время отправления для каждой из точек
(время отправление общее на весь запрос). В связи с этим предлагается разбивать все запросы
на группы, в которых время отличается менее, чем на час (условно). При желании можно поставить эксперимент
и убедиться, что при таких округлениях время поездки в 99% случаев отклоняется не сильно
(от времени поездки, запрошенного без округлений).

### Бизнес-ограничения при поиске достуных слотов

При поиске доступных слотов необходимо учитывать некоторые специфические для сервиса ограничения:
1. Два активных выезда по одной квартире не могут пересекаться по времени.
2. Если определенный сотрудник имеет выезд по квартире в рассматриваемый день, то другие выезды по этой квартире
могут назначаться только на того же сотрудника (если ключи от квартиры находятся у него)
3. Недопустимо создание выездов, время в пути между которыми состовляет более X минут

### Упрощения для первой версии алгоритма

В первой версии сервиса планируется имплементировать поиск доступных слотов с некоторыми упрощениями при
работе с матрицей расстояний:
1. Любой сотрудник передвигается на общественном транспорте
2. Время отправления всегда константно

## Выгрузка обновлений выездов

Все обновления выездов (INSERT, UPDATE, DELETE) записываются в Kafka-топик `rent-appointments-diff-events`.
Гарантируется, что каждое событие будет записано в топик at-least-once.

Схема работы аналогична `rent-diff-events`:

1. Сырые события БД сервиса записываются в служебный топик с помощью [DataTransfer](https://docs.yandex-team.ru/cloud/data-transfer/)
2. События преобразовываются в более удобные для работы proto-сообщения с помощью `DiffEventGenerator`
(необходимо будет поддержать обработку нескольких топиков)
3. Итоговые proto-сообщения записываются в топик `rent-appointments-diff-events`

Данная выгрузка событий далее используется для следующих целей:
1. Отправка уведомлений собственнику/жильцу о назначенном выезде (в `realty-notifier`)
2. Добавление информации о выезде в сделку собственника в Амо (в `relaty-amohub`)
3. Последующая выгрузка данных в YT

## Выгрузка данных в YT

События из топика `rent-appointments-diff-events` вычитываются в
сервисе `rent-appointments` и отправляются [брокер](https://docs.yandex-team.ru/classifieds-infra/broker/info).
Брокер в свою очередь записывает данные в YT.


### Альтернативное решение #1

Попробовать репликацию Kafka -> YT через DataTransfer.
В таком варианте данные из топика `rent-appointments-diff-events` будут
попадать в таблицу YT минуя сервис.

#### Плюсы решения c DataTransfer:
1. Не требует написания и поддержки кода

#### Минусы решения c DataTransfer:
1. Нет автоматической доставки proto-схемы до таблицы YT
2. Нет валидации изменений схемы на уровне PR
3. По субъективному опыту Я.Аренды, Брокер надежнее DataTransfer'а

### Альтернативное решение #2

Можно записывать данные в Брокер не из топика `rent-appointments-diff-events`, а сразу
после создания `proto` сообщения в `DiffEventGenerator`, **вместо записи в Kafka**. Запись в Kafka при этом будет не нужна,
так как Брокер в свою очередь отправит данные и в Kafka, и в Yt.

## Фоновые процессы

### Создание и редактирование встреч в календаре

После создания встречи необходимо создавать встречу в календаре сотрудника.
Данная встреча должна поддерживаться в актуальном состоянии: должно изменяться
ее время и описание при изменениях в выезде; встреча должна быть удалена при отмене выезда.

Предполагается, что создание встречи и ее поддержка в актуальном состоянии будет обеспечиваться
за счет реакции на события из топика `rent-appointments-diff-events` в сервисе `rent-appointments`.

Альтернативно, данную логику можно имплементировать за счет стейджа для выездов.
Скорее всего, использования стейджа тут избыточно, посколько изменять выезд не требуется
 (сохранять `event_id` встречи не надо, так как Календарь поддерживает пользовательские `external_id`).

### Обработка обновлений квартиры

При некоторых изменениях в квартире необходимо обновлять все связанные выезды.
Например, необходимо отменять выезд при переходе квартиры в некоторые статусы.
Данная логика имплементирована за счет реакции на события из топика `rent-diff-events`
в микросервисе `rent-appointments`.

## Нагрузка

На все операции, не используемые внутренними процессами (поиск доступных слотов, назначение выезда),
максимальная нагрузка с учетом развития сервиса -- единицы рпс.

Для некоторых операций, которые теоретически могут использоваться другими сервисами
(получение выезда по ключу, получение выездов по id квартиры), стоит рассчитывать на максимальную
нагрузку в несколько десятков рпс.

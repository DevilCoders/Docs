## Сервис платежей

Сервис rent-payments предназначен для выставления счетов на оплату, совершения платежей и формирования чеков

### Функционал

1. Хранение информации о платежах в виде неизменяемой истории (формат event-ов)
2. Формирование платежей и их изменение
3. Осуществление оплат и выплат по платежам
4. Отправление чеков по совершенным платежам
5. Выгрузка событий в YT для аналитики (брокер)

### Архитектура сервиса

Сервис платежей позволяет формировать и оплачивать платежи, сохраняя все изменения в виде событийной модели. На основе
этой событийной модели строятся некоторые представления, которые впоследствии читаются другими сервисами. Взаимодействие
с Тинькофф банком, брокером и кэшбоксом осуществляется через сервис платежей.

![service_structure](img/service.png)

Подробнее:

[**Терминология и сущности**](./entities.md) - подробная информация о моделях.

[**Типы событий**](./event-types.md) - подробная информация о типах событий.

[**gRPC API**](./api.md) - подробная информация о ручках.


### Генерация сущностей

В бд добавляются только события, на основе которых в последующем генерируются сущности в следующем схематическом виде:

![entities_schema](img/entities-generation.png)

Таким образом, сущность `Order` содержит в себе множество связанных сущностей (`OrderItem`, `Transaction` и `Receipt`).

Генерация сущностей осуществляется через `OrderGenerator`. Генератор по `order_id` выгружает _все_ события из бд,
отсортированные по дате создания и соответствующие ордеру с таким id, а после формирует нужные сущности в зависимости от
типа: события ордера создают сущность `Order` и сущности `OrderItem`, события платежей создают сущности `Transaction`, а
события чеков создают сущности `Receipt`. Сущность `Order`, содержащая в себе сущности `OrderItem`, `Transaction`
, `Receipt` сервис возвращает по запросу внешним сервисам (например, Аренде). Порядок событий играет существенную роль в
формировании сущностей: некоторые события могут отменять предыдущие. Пример набора событий в отсортированном порядке:

- `OpenOrderEvent` с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`
- `CreateOrderItemEvent` c `order_id = 83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `order_item_id = 28a44983be57d002082e36454ffcbfb5` с АП = 10000
- `CreateOrderItemEvent` с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `order_item_id = 6c6421527911a9c16377e7576ba19e86` cо страховкой = 811
- `CreateOrderItemEvent`  с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `order_item_id = 4b7bbe0d9d8e901cdbd6883931940224` c комиссией = 7% * 10000
- `CancelOrderItemEvent`  с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `order_item_id = 28a44983be57d002082e36454ffcbfb5`
- `CreateOrderItemEvent` c `order_id = 83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `order_item_id = 882e1fa57955080ca0d628a1606114d5` с АП = 20000
- `InitTransactionEvent` с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `transaction_id = e4e14a3d32069851261dcad435a81626` (оплата полной суммы)
- `ConfirmTransactionEvent` с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `transaction_id = e4e14a3d32069851261dcad435a81626`
- `InitTransactionEvent` с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `transaction_id = 2cb0506dd34d2294aabf997d2270c9ca` (выплата собу)
- `ConfirmTransactionEvent` с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`,
  `transaction_id = 2cb0506dd34d2294aabf997d2270c9ca` (выплата собу)
- `CloseOrderEvent` с `order_id` = `83fe2cd1c2f0a7257149903a0ae1e9f5`

На основе этой совокупности событий мы генерируем `Order` с 3мя `OrderItem` (услуга `28a44983be57d002082e36454ffcbfb5`
была отменена при изменении АП в платеже): АП = 20000, S = 811, C = 7% * 10000, а также 2мя `Transaction`: полная оплата
жильцом всех услуг, а также выплата собу. Чеки еще не надо отправлять по каким-то причинам. Этот ордер соответствует
арендному платежу в статусе `PaidToOwner`. Ордер оплачен и закрыт.

Однако, иногда требуется получить не один ордер, а сразу целое множество. Это множество обычно представляет собой
некоторую ограниченную последовательность ордеров (например, последние 10 ордеров). Для этих целей в текущей реализации
предполагается выгружать все ордеры для конкретной сущности `entity_id` и уже фильтровать необходимые согласно требуемой
логике. Впоследствии, когда количество событий на одну сущность станет слишком большим можно будет реализовать
пагинацию, используя слой кэша, который хранил бы в себе вычислимые представления ордера. Это ускорит чтение, но добавит
задержку консистентности данных в ордере. Предполагается не реализовывать этот кэш в первой итерации.

### Триггерные события

Существуют события, которые должны генерироваться сервисом автоматически. К таким событиям можно отнести, например,
отправление чеков или выгрузки во внешние системы. Эти события возникают в результате некоторого триггера, например,
возникновения в бд некоторого триггерного события. Автоматическая генерация таких событий происходит асинхронно в фоне.
Для этого в бд будет существовать отдельная таблица обработки фоновых задач:

`Task` - задача, _изменяемая_ сущность, которую необходимо выполнить в фоне.

* `id` - id задачи
* `order_id` - id ордера, с которым связана задача
* `task_type` - тип задачи
* `data` - протобаф с необходимой информацией о задаче.
* `create_time` - время создания задачи
* `is_finished` - флаг "мягкого" удаления задачи

Для обработки этих задач используется `Task scheduler`. Реализовывать такой вотчер можно согласно новому механизму,
вынося `visit_time` в отдельную таблицу `task_watcher_queues` создавая различные очереди для каждого из стейджей
в `Task scheduler`. После обработки задача помечается завершённой (флаг `is_finished`). С точки зрения работы с
бд `Task scheduler` только добавляет новые `Event` и обновляет в `Task` поле `is_finished` и в `task_watcher_queues`
поле `visit_time`. Все задачи в `Task scheduler` должны обрабатываться _строго идемпотентно_.

Добавление задачи `Task` происходит вместе с регистрацией триггерного события `Event` в рамках _одной_ транзакции.
Добавление записей в `Event` через `Task scheduler` и обновление `Task` происходит в _одной_ транзакции (батчем).

#### Отправление чеков

Отправление чеков по совершённым платежам можно осуществлять через `Task scheduler` асинхронно. Триггерным событием для
создания задачи на отправку чеков будет регистрация события `ConfirmTransactionEvent`.

#### Выгрузки во внешние системы

Появление нового события по ордерам гипотетически должно выгружаться во внешние системы, такие как, например, YT.
Реализовать запрос на выгрузку можно посредством создания задачи по триггерному событию с её последующей обработкой
через `Task scheduler`

### Интеграция с Арендой

#### Генерация платежей

На текущий момент в Аренде генерируются периоды условий, из них генерируются периоды платежей. На основе периодов
платежей уже обновляются/создаются сами платежи. Здесь потребуется доработать обновление/создание платежей,
научив `ru.yandex.realty.rent.stage.contract.CreatePaymentStage` (или какой-то другой стейдж) взаимодействовать с новым
сервисом, а именно ходить в соответствующие ручки, которые будут генерировать определённые события (создание ордера,
добавление услуги, удаление услуги, изменение периода ордера). Сам генератор потенциально не требуется менять.

#### Поддержка текущего формата платежей

Предполагается, что при запуске этого сервиса платежи для старых договоров будут браться из бд, а для некоторых (
например, новых с определённой даты или же в формате A/B-тестирования некоторая выборка договоров) арендные сервисы
будет ходить в новый `rent-payments` и вытягивать платежи оттуда. Для интеграции с новым сервисом на стороне Аренды
необходимо будет сделать следующее:

1. Написать что-то вроде адаптера, который позволит сохранять/обновлять платежи через хождение в ручки нового сервиса (и
   формирование эвентов соответственно), а также получать платежи из сервиса, конвертируя его ответ.
2. Разделить хождение за платежами согласно какой-то логике. Мб здесь стоит добавить новую реализацию интерфейса
   PaymentDao, иначе зачем он там, если только не для этого?
3. Провести миграцию старых платежей на новый сервис. Для этого надо подумать над тем, как преобразовать текущие платежи
   в эвенты.
4. Переключить хождение старых договоров из бд на новый сервис
5. Выпилить платежи из аренды

Альтернативный путь поддержки старой логики:

1. Формировать платежи на стороне нового сервиса сразу в подходящем для Аренды виде. Потребуется еще один генератор,
   который из упомянутого ранее набора сущностей будет формировать арендный Payment (ну или вообще не использовать тот
   набор сущностей, но в таком случае пострадает простота).
2. Изменение платежей на стороне Аренды можно осуществлять не через обновление записи в БД, а через хождение в ручки
   нового сервиса, которые будут генерировать соответствующие события.

#### Работа с чеками

Предполагается выпиливание стейджа `ru.yandex.realty.rent.stage.contract.SendReceiptStage` и последующее использование
механизма с триггерными событиями в новом сервисе

#### Про регистрацию событий в брокере

Часть событий, которые мы посылаем в брокер, можно будет вынести в новый сервис. А именно:

1. Оплата аренды жильцом (`PAYING_BY_TENANT`) будет соответствовать событию `ConfirmEvent` входящего платежа,
   покрывающего все услуги в ордере, при отсутствии событий `ConfirmEvent` по исходящим платежам;
2. Выплата собу (`PAYOUT_TO_OWNER`) будет соответствовать событию `ConfirmEvent` исходящего платежа, покрывающего все
   исходящие услуги в ордере, при наличии входящего платежа.
3. Увеличение суммы штрафа (`PENALTY_INCREASED`) будет соответствовать событию `CreateItemEvent` входящего платежа.
4. Выплата по поручительству (`PAYOUT_UNDER_GUARANTEE`) будет соответствовать событию `ConfirmEvent` исходящего платежа,
   покрывающего все исходящие услуги в ордере при отсутствии `ConfirmEvent` входящего платежа.

На стороне Аренды можно оставить`PAYMENT_DATE_HAS_COME`, так как наступление даты платежа связано не с платежом как
таковым, а с наступлением даты в бизнес-логике

## Интеграция с Тинькофф

### Полезные ссылки

- [Документация EACQ Tinkoff API](https://acdn.tinkoff.ru/static/documents/merchant_api_protocoI_eacq.pdf) - по оплатам.
- [Документация E2C Tinkoff API](https://acdn.tinkoff.ru/static/documents/merchant_api_protocoI_e2c.pdf) - по выплатам.
- [Тестовые карты EACQ](https://st.yandex-team.ru/REALTYFRONT-10793#606475209ba2703c83bb9cef).
- [Тестовые карты E2C](https://st.yandex-team.ru/REALTYBACK-5555#60bfa5662baa591c65519099).
- [Документация Tinkoff СБП](https://acdn.tinkoff.ru/static/documents/sistema_bystryh_platezhej.pdf).
- [Документация EACQ с PCI DSS](https://acdn.tinkoff.ru/static/documents/merchant_api_protocoI_eacq_pci_dss.pdf) (сейчас не используется).
- [Безопасная сделка в Tinkoff](https://acdn.tinkoff.ru/static/documents/bezopasnaya_sdelka.pdf) (сейчас не используется).

Ещё пачка тестовых карт EACQ:
- 2201382000000880 cvv 123 срок 12/22
- 2201382000000112 cvv 123 срок 12/22 (говорят, лучше всего работает именно эта)
- 2200700134845170 cvv 123 срок 12/22

### Терминалы

Условное определение терминала тинька - то, через что проводит платежи конкретная организация, подписавшая договор с Тинькофф банком. У нас всего три терминала:
- EACQ Main - терминал оплат для веба (он отдаёт редирект-урлы на форму оплаты в браузере);
- EACQ App - терминал оплат для аппов (он умеет работать с Tinkoff SDK, который юзают наши аппы);
- E2C - терминал выплат.

В каждом терминале при первом использовании для данного юзера Аренды создаётся сущность Customer'a с данным `userId`. Для каждого Customer'a на каждом терминале можно сохранить множество привязанных карт.

### Оплата

Взаимодействие сервисов в оплате происходит по следующей схеме.

![payment services](img/payment-services.png)

Алгоритм оплаты выглядит так.
- Жилец видит в ЛК ссылку на оплату платежа в [одной из нотификаций](https://a.yandex-team.ru/arcadia/classifieds/realty/realty-rent/realty-rent-api/src/main/scala/ru/yandex/realty/rent/backend/converter/notifications/PaymentNotifications.scala?rev=r9523288#L332).
- По переходу по ссылке дёргается [ручка инициализации платежа](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#!/payment/initRoute).
- Если жилец оплачивает платёж впервые, то для него в тиньке создаётся сущность Customer'a с его `userId` (см. документацию тинька).
- Далее ручка инициализирует транзакцию в EACQ API тинька и сохраняет в платёж информацию о ней, а клиенту отдаёт ссылку на форму оплаты (или id транзакции в случае аппов).
- Клиент показывает жильцу форму оплаты, где тот вводит данные карты и оплачивает платёж.
- Тинёк вызывает наш [вебхук](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#!/notification/processNotificationRoute) и передаёт в него обновлённый статус транзакции (успешный или неуспешный).
- Мы обновляем статус транзакции и платежа в БД.
- Для оплаченного платежа в фоне выбиваются чеки вызовом в `realty-cashbox-api` (`SendReceiptStage`).

### Выплаты {#payouts}

Взаимодействие сервисов в выплатах происходит по следующей схеме.

![payout services](img/payout-services.png)

E2C API тинька требует подписывать все запросы в него настоящей электронной подписью, поэтому у нас здесь есть интеграция с Я.Подписью - шлюзом над инстансом КриптоПро. Построение правильного запроса в него было трудоёмкой задачей, но она была успешно решена, см. код `CryptoProManager` и `XMLDSigContentConverter`.

У процесса выплаты, как у платежа в целом, есть тоже свой статус - это поле `payout_status` в `PaymentData`:
- `NotStarted` - выплата ещё не начала, не пришло время;
- `RecoverableError` - было сделано несколько попыток выплаты, но все неудачные, сейчас идут ретраи раз в час;
- `UnrecoverableError` - выплату сделать не получилось (не привязана карта, или карт привязано больше одной, или достигнут максимум попыток выплаты).
- `PaidOut` - выплата успешно произведена.

Алгоритм выплаты примерно следующий (см. `PayoutStage` и `PayoutManager`).
- Если жилец оплатил платёж до 8:00 даты `payment_date`, то рескедулимся на 8:00 этого дня и тогда начинаем процесс выплаты.
- Если жилец оплатил платёж с 8:00 до 18:00 даты `payment_date`, то процесс выплаты начинается сразу же в момент после оплаты.
- Если жилец не оплатил платёж до 18:00 даты `payment_date`, то в 18:00 начинается процесс выплаты по поручительству.
- Проверяется наличие привязанных карт собственника вызовом метода E2C API тинька.
- Если карт нет или больше одной, выплата вываливается в ошибку.
- Если карта одна, то последовательно вызываются методы инициализации и проведения транзакции выплаты в E2C API тинька (здесь есть дополнительная логика дедубликации, см. следующий раздел).
- Если выполнить транзакцию не получилось, выплата вываливается в ошибку с ретраем (если количество ретраев не превышено).
- Даже если количество ретраев превышено, дополнительную попытку можно запустить с помощью экшена `RetryPayout` в [ручке апдейта платежа](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#!/moderation/updatePaymentStatus).
- Если транзакция прошла успешно, платёж меняет статус на `PaidToOwner` (или `PaidOutUnderGuarantee`, если по поручительству).

### Дедубликация выплат

В API тинька (и в EACQ, и в E2C) есть поле `OrderId`, в которое мы передаём `paymentId` нашего платежа и которое по своему замыслу должно использоваться на стороне тинька для дедубликации по принципу - **"для каждого `OrderId` можно провести не больше одной успешной транзакции"**. Однако важно знать следующее:
- в EACQ API это правило работает, и мы на него полагаемся;
- в E2C API **оно не работает!**

По этой причине при наивном использовании E2C API возникает риск задублировать выплаты собственнику. Чтобы такого никогда не случалось, в `PayoutManager` реализована дополнительная защита в виде таблички `payout_transactions` со следующими полями:
- `paymentId` - id нашего платежа (на стороне тинька это `OrderId`);
- `transactionId` - id транзакции тинька (на стороне тинька это называется `PaymentId`);
- `createTime` - время создания транзакции (нужно для выбора последней транзакции из всех созданных).

Дедубликация работает по следующей схеме.

![payout deduplication](img/payout-deduplication-schema.png)

- Перед тем, как инициировать новую транзакцию, мы ищем в табличке `payout_transaction` последнюю созданную.
- Если такая транзакция была, проверяем её статус через метод `GetState` E2C API, - если она уже была успешно завершена, мы просто меняет статус выплаты на `PaidOut`.
- Если такой транзакции не было, или если она не была успешно завершена, инициируется новая транзакция через метод `Init` E2C API.
- Далее id инициированной транзакции сохраняется в `payout_transactions` - важно, что делается это в отдельной транзакции БД, независимой от транзакции вотчера, поэтому даже если транзакция вотчера упадёт, мы всё равно точно не потеряем id инициированной транзакции тинька.
- Только после этого вызывается метод `Payment` E2C API для инициированной транзакции, - это синхронный вызов, фактически переводящий деньги собственнику.
- Далее в зависимости от успешности метода `Payment` меняется статус выплаты.
- Теперь если после успешного вызова `Payment` транзакция вотчера упадёт, при следующем ретрае выплата не задублируется, т. к. на первом шаге найдётся транзакция в `payout_transactions`.

### Привязки карт

В API тинька есть возможность привязывать карты. По умолчанию множества привязанных карт на разных терминалах - независимы друг от друга. Но для двух EACQ-терминалов у нас настроено так, что эти множества пошарены между собой, поэтому фактически у нас есть для каждого юзера всего два непересекающихся множества карт:
- привязанные карты жильца, с EACQ-терминалов (можно привязывать и отвязывать только на форме оплаты);
- привязанные карты собственника, с E2C-терминалов (для них есть [отдельный раздел](https://arenda.test.vertis.yandex.ru/lk/owner/payment-methods/)).

Для работы с привязанными картами есть [ручки ЛК](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#/user45cards) и [админская ручка](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#!/moderation/getUserCards). Они сделаны обобщёнными, но работают пока только для карт собственника (карты жильца не поддержаны).

E2C API тинька позволяет привязать много карт, но по нашей бизнес-логике собственник должен привязать ровно одну карту - чтобы было понятно, на какую карты делать выплаты. Тем не менее, даже через наш интерфейс возможно привязать несколько карт (если открыть формы привязки в нескольких окнах браузера), - в этом случае будет специфичная ошибка выплаты.

Т. к. при отсутствии привязанной карты мы хотим пушить собственника о необходимости её привязать, нам нужно уметь узнавать о моменте, когда карта была фактически привязана, чтобы поддерживать в актуальном состоянии `ownerCardsStatus` в [ручке получения юзера](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#!/user/getUser). В E2C есть вебхуки, но аудит не разрешил нам их использовать, поэтому у нас реализован поллинг статуса привязки - см. следующую схему.

![card bind status polling](img/card-bind-status-polling.png)

Привязка карты собственника работает так.
- Дёргается [ручка инициализации привязки карты](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#!/user45cards/addUserCard).
- Бекенд вызывает метод `AddCard` E2C API тинька, сохраняет в табличку `user_card_binds` полученный `RequestKey` (идентификатор привязки), получает ссылку на форму привязки и отдаёт её клиенту.
- Клиент показывает юзеру форму, юзер успешно или неуспешно привязывает карту.
- Форма тинька редиректит юзера на нашу страничку, где разово вызывается [ручка апдейта статуса привязки](http://realty-rent-api-main.vrts-slb.test.vertis.yandex.net/swagger/#!/user45cards/updateUserCardStatus).
- Т. к. нет гарантии, что эта ручка будет вызвана, дополнительно в фоне работает `UserCardBindsWatcher` - раз в 5-15 минут он тоже пытается проверить, что запущенные привязки завершились успешно и при необходимости обновить `ownerCardsStatus` (см. `GetCardListStage`).

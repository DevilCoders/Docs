
## Хорошие практики по формированию путей для http-api

#### Отправной точкой для ручки должна быть сущность, а не производимое действие
**Плохо:**
POST /export/offers.xls

**Хорошо:**
POST /offers/export/xls

**Почему:**
Во первых таким образом мы можем достаточно строго разделять ручки, во вторых пользователю, который хочет воспользоваться API, будет гораздо проще найти нужный url по сущности, чем "угадывать" название действия которое вы придумали

#### "Корнем" пути должно быть название сущности во множественном числе (если существует)

**Плохо:**
POST /event/log

**Хорошо:**
POST /events/log

**Тоже хорошо:**
POST /money/person/{uid}

**Почему:** Это один из глобальных best practice, т.к. работа из данной ручки ведётся со всеми объектами сущности а не только с одним

#### В случае многословности в url стоит использовать kebab-case

**Плохо:**
GET /phone/canCreateRedirect/{uid}

**Хорошо:**
GET /phone/can-сreate-redirect/{uid}

**Почему:** На самом деле нет разницы в каком стиле описан URL, главное - стандартизация записей.

#### В случаях, когда ручка ведёт работу только с одним объектом сущности, идентификатор необходимо указывать в прямо в пути, а не в параметрах
**Плохо:**
GET /offers/phones/?offerId={offerId}

**Плохо:**
POST /newbuilding/callback/ > передаем идентификатор внутри body

**Хорошо:**

GET /offers/{offerId}/phones

POST /newbuilding/{newbuildingId}/callback/

**Почему:** Идентификатор в url показывает что мы работает с конкретной сущность а не группой.

#### Не стоит смешивать разные сущности в одном секторе path.
**Плохо:**
GET /verbaDictionary.json

**Чуть лучше:**
GET /verba/dictionary

**Хорошо:**
GET /dictionaries/verba

**Почему:** Главное сущностью в данном пути является словарь. Во первых не стоит выделять особый тип словарей, во вторых нам понадобится новый раздел когда мы захотим добавить словарь Пальмы, а это усложняет понимание API.

#### Необходимо избегать слов "get", "create", "update",  в пути запроса:

**Плохо:**
POST /agent/createSaleRequest

**Хорошо:**
POST /agent/sale-request

**Плохо:**
GET /user/direct/{uid}

**Хорошо:**
GET /user/{uid}/direct

**Почему:** В данном случае тип метода (POST) означает создание новой сущности (sale-request) для агента. Для "get" есть метод GET, для update есть метод PUT. Вдвойне плохо противопоставлять метод и название.

#### Одна ручка должна работать только с одной сущностью:

**Плохо:**
GET /offerWithSiteSearch.json?

**Хорошо:**

Здесь правильнее иметь несколько ручек

GET /offers/

GET /newbuildings/

GET /villages/

**Почему:** Работа с несколькими несвязанными сущностями в одной ручке влечёт к большому количеству костылей, излишних параметров и предрасполагает к совершению ошибок при использовании такого API.


#### Антипаттерном считается использовать тип метода, не соответствующий действию, которое совершает данная ручка (GET для создания или обновления сущности, POST для получения сущностей). Однако есть оговорка, когда вычислительно затратные или логически сложные операции выполняются методом POST, этот момент должен быть отмечен в path указанием типа операции

**Плохо:**

POST /campaign/user/{user}/status - get campaign status

**Хорошо:**

GET /campaign/user/{user}/status

**Плохо:**

POST /campaign/user/{user}/status/change

**Хорошо:**

PUT /campaign/user/{user}/status/

**Допустимо:**

POST /campaign/user/{user}/search

**Почему:** Противоречие между типом метода и исполняемой операцией усложняет чтение и использование API, а также нарушает пользовательский опыт.

### Ожидаемая работа API

Из модифицирующей операции возвращать полное состояние сущности в формате запроса на чтение

**Плохо:**

POST /concierge/ticket

{% cut "Response:" %}

`{
   "response": {}
   }
   %%
   }>
   **Чуть лучше:**
   <{Response:
   %%(json)
   {
   "response": {
   "ticket": {
   "id": "1123121"
   }
   }
   }`

{% endcut %}

**Хорошо:**

POST /concierge/ticket

{% cut "Response:" %}

`{
"response": {
"ticket": {
"id": "1123121",
"url": "url",
"rgid": 557711,
"phone": "+79999999999",
"comment": "Rjvvt"
} } }`

{% endcut %}

**Почему:** Такого рода ответ является более ожидаемым и понятным для пользователя API. Кроме того в большинстве случаев он позволяет избежать повторного запроса на получение сущности.

На каждом уровне api должно работать с сущностями своего уровня, а не соседних.

**Пример:**

Предположим появилась задача добавить на сервис "Персонализированный поиск ЖК", в которой мы добавляем известные нам предпочтения пользователя по ЖК без его запроса, а затем возвращаем очень краткую карточку ЖК. Для этого на уровне gateway мы добавляем ручку:

/newbuildings/personalized

В realty-gateway мы добавляем некоторые параметры в запрос и шлём его в bnb, но выясняется что текущие ручки поиска bnb не поддерживают необходимый нам формат, поэтому на уровень bnb-серчера мы добаляем новую ручку, которая будет возвращать очень краткие карточки ЖК.

**Плохо:** /newbuildings/personalized

**Хорошо:** /newbuildings/simplified

**Почему:** на уровне bnb серчера мы не должны ничем знать о персонализированных поисках, мы оперируем только новостройками, и поэтому такой роут в дальнейшем не расширяем. Например нам так понравилась новая карточка, что мы решили её использовать не только в персонализированном поиске но и при поиске пинов, тогда задействовать при поиске пинов personalized будет некорректно, нужно будет писать точно такую же ручку, что, по сути, тоже некорректно.

### Формирование swagger-документации
* Разделы swagger должны соответствовать разделам сущностей, которые описаны в роутах (например для ручки offers/ необходимо помещать в сваггер раздел offers). Не допускается создание разделов под действие (например pointSearch для поиска точек ЖК, КП, офферов, все эти ручки должны быть помещены в разделы с соответствующей сущностью)
* Наименование раздела должно начинаться с маленькой буквы
* Допускается вынесение групп ручек по одной и той же сущности в отдельные разделы, например все ручки /user/{user}/personalization/ можно вынести из user в user personalization.

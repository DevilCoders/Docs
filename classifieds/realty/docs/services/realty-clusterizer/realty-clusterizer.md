### Назначение

Сервис будет заниматься кластеризацией объявлений - обогащать обьявления информацией о кластере в котором они находятся(clusterId, размер кластера, является ли объявление заголовком). Критерии похожести различны для разных категорий, но обычно должны совпадать адреса, быть похожей цена и площадь. Для новостроек объявлениям из одного кластера разрешается иметь разный этаж.

### Схема работы

![alt text](img/clusterizer.png)
На вход принимает поток изменений(топик kafka, offers_to_clusterize) от Unifier: upsert(Offer) | delete(Offer).
Для каждого оффера вычисляем clusterKey(groupId в старой схеме) и загружаем из базы ранее сохраненный. Актуализируем в базе clusterKey и
посылаем в топик для кластеризации(cluster_offers_to_clusterize, ключ партиционирования clusterKey):
* upsert(clusterKey, Offer) - если пришел upsert(Offer)
* delete(clusterKey, Offer) - если пришел delete(Offer)
* deleteFromCluster(clusterKey, Offer) - если для upsert(Offer) изменился clusterKey

Вычитываем топик cluster_offers_to_clusterize:
* для delete(clusterKey, Offer) - загружаем из базы все офферы по clusterKey, удаляем из нее оффер, запускаем кластеризацию, записываем в транзакции все изменения в офферах после кластеризации, посылаем апдейты в кафку
* для upsert(clusterKey, Offer) - загружает из базы все офферы по clusterKey, заменяем полученный unifiedOffer, запускаем кластеризацию, записываем в транзакции изменения после кластеризации, посылаем апдейты в кафку
* для deleteFromCluster(clusterKey, Offer) - загружаем из базы все офферы по clusterKey, удаляем из нее оффер, запускаем кластеризацию, записываем в транзакции все изменения в офферах после кластеризации, **не** посылаем апдейты в кафку для удаленного оффера.

```Альтернативой топику cluster_offers_to_clusterize может быть шардированная по clusterKey очередь в базе. Из плюсов - атомарные действия(обновить clusterKey + послать в очередь, удалить из очереди + обновить в базе кластер). Из минусов, придется писать больше кода для работы с очередью```

Для измененных | удаленных офферов в кластере шлем апдейты в топик unified_offers.

В каждый момент времени clusterKey обрабатывает только 1 консьюмер, поэтому raceCondition исключается.
Запись в базу + отправка в топик не атомарны, можно использовать паттерн transactional outbox. Но можно немного упростить схему отправляя изменения в кафку до коммита в базу.
В случае ошибки записи в базу, мы попробуем обработать сообщение повторно, продублируя сообщение в кафке. При этом гарантии доставки atLeastOnce не нарушаются.
Так как потребители на выходе не ходят в clusterizer, то проблем с тем что в кафке будет сообщение, для которого еще нет записи в базе clusterizer тоже не возникнет.

В качестве базы используем ydb так как она горизонтально масштабируется при увеличении нагрузки.

### Схема таблиц

Для хранения clusterKey по offerId используем таблицу:
```
shard_id = hash(offer_id)
CREATE TABLE cluster_key
(
shard_id Uint32,
offer_id Utf8,
cluster_key Uint32,
create_time Timestamp,
PRIMARY KEY (shard_id, offer_id)
);
```

Для хранения офферов внутри cluster_key используем таблицу:
```
CREATE TABLE cluster_offer
(
cluster_key Uint32,
offer_id Utf8,
payload string,
create_time Timestamp,
PRIMARY KEY (cluster_key, offer_id)
);
```

# Watcher2

## Описание основных классов

![watcher2-class-diagram](img/watcher2-class-diagram.png)

StageQueueDao — DAO для работы с очередями стейджей.
Не содержит никакой информации про обрабатываемые сущности, поэтому достаточно одного
инстанса на приложение. Интерфейс DAO не привязан к конкретной библиотеке работы с БД,
поэтому в теории возможно использовать Watcher2 с разными библиотеками (doobie, slick).

StageQueueManager — Слой абстракции над StageQueueDao, скрывает некоторые
детали работы со StageQueueDao, а так же содержит часть бизнес логики вотчеров.
Содержит информацию об обрабатываемой сущности (например, название сущности),
поэтому необходим отдельный инстанс StageQueueManager на каждую сущность.

Watcher2 — класс, содержащий непосредственную логику обработки объектов
(вычитваение очередей, запуск стейджей, сохранение обновлений и т.д.)

WatchableDao — Абстраткный класс, который наследуется всеми DAO обрабатываемых сущностей.

## Описание работы

### Очередь стейджей

Для каждого стейджа существует отдельная очередь обработки
(взаимодействие со всеми очередями происходит с помощью `StageQueueDao` и `StageQueueManager`). При этом запись для одного
объекта может находится в очереди не более одного раза. При попытке сохранения двух записей будет создана
запись с наименьшим `visitTime`.

### Процесс работы
Типичный процесс работы вочтера при обновлении какого-нибудь объекта выглядит так:
1. Вызывается метод обновления объекта в DAO. Данный метод DAO вызывает метод `entityUpdated`
в `WatchableDao`, который:

    a) Добавляет запись в очередь системного стейджа (``Watcher2::SystemStage``) с `visitTime = now`

    б) Инкрементирует версию объекта

    После выполнения `entityUpdated` объект с новой версией сохраняется в БД. Добавление запсиси
в очередь системного стейджа и сохранение объекта в БД происходит в одной транзакции.

2. `Watcher2` видит запись в очереди системного стейджа, извлекает объект из базы
и запускает системный стейдж на объекте. Системный стейдж проходит по всему списку стейджей сущности
и вызывает метод `Stage::shouldProcessNow`. Для стейджей с `shouldProcessNow = true` системный стейдж сохраняет
в очередь стейджей записи с `visitTime = now + random_delay`. Случайная отсрочка перед исполнением стейджа
призвана уменьшить конфликты оптимистичных блокировок при одновременной работе стейджей.

3. Когда для определенного стейджа наступает время обработки объекта, объект извлекается из БД и передается
в метод `process` стейджа. Стейдж после обработки может вернуть новый `visitTime` для объекта, а так же
обновленный объект (два возможных результата — `Untouched` и `Updated`).

    Если объект был изменен, то происходит
попытка сохранения новой версии объекта в БД с помощью метода `updateWithVersionCheck` в `WatchableDao`.
Данный метод обязан проверять, что версия объекта в БД совпадает с передаваемой версией (оптимистичная блокировка).
В случае, если версия отличается, обновление не производится и `visitTime` стейджа остается неизменным (что приведет
к повторной попытке запустить стейдж).

    Если же обновление успешно или результат стейджа `Untouched`, то
в очереди стейджа обновляется `visitTime`
(или же запись удаляется из очереди стейджей, если повторная обработка в будущем не требуется). При этом
обновление очереди стейджей тоже происходит за счет механизма оптимистичных блокировок (используется поле `version` в очереди
стейджей). Таким образом, если в процессе работы стейджа в очередь стейджа будет предпринята попытка записать новый `visitTime`
(не важно, больший или меньший текущего), то запись из очереди стейджей удалена не будет и объект обработается снова.

4. При сохранении новой версии объекта в БД с помощью метода `updateWithVersionCheck` снова вызывается метод
`Watcher2::entityUpdated` и создается запись в очередь системного стейджа (пункт 2). Процесс прекратится, как только
все стейджи станут возвращать `shouldProcessNow=false` или перестанут обновлять объект (будут возвращать `Untouched` из метода `process`).


## Как использовать Watcher2

1. Сущность должна иметь поле version и имплементировать интерфейс `EntityWithVersion`.
2. Сущность должна иметь уникальный идентификатор, однозначно приводимый к строке и из строки.
Для конвертацию в/из строки для Id сущности должен быть инстанс тайп-класса `EntityId`
3. DAO сущности должно наследовать абстрактный класс `WatchableDao`. Каждый метод DAO,
обновляющий или созающий новые объекты, должен перед сохранением объектов в БД вызывать `entityUpdated`/`entitiesUpdated`
и сохранять в БД результаты выполнения этих методов.
4. В каком-нибудь приложении (например, в имя-приложения-scheduler) необходимо запустить
`Watcher2ShardedTask`. В конструктор `Watcher2` должны быть переданы все стейджи
сущности, имплементированнная DAO и прочие необходимые параметры.

TODO: Дописать, как правильно реализовывать метод `updateWithVersionCheck`, - когда использовать батчовый и
небатчовый апдейт, с примерами.

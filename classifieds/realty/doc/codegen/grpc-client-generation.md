# Генерация gRPC-клиентов

Для наших внутренних gRPC-сервисов реализована генерация кода клиентов для Scala.

Генератор реализован в виде плагина для Gradle. Этот плагин можно добавить в какой-нибудь модуль, указать ему, сервисы из каких прото-файлов обрабатывать, и он напишет за вас немного кода.
- Для каждого сервиса он сделает отдельные клиенты — по одному trait и class с методами, соответствующими ручкам в сервисах.
- В будущем планируется генерировать также пару из trait и class для ClientSupplier для использования в BackendBuilder-ах.

## Где генерировать

В отдельном грэдловом модуле. Предлагается группировать клиенты в разных модулях, примерно соответствующих приложениям, предоставляющим сервисы. То есть, для всего API Аренды — один модуль, для геохаба — другой, и так далее.

Пока не решили иначе, модули предлагается складывать в `/clients`.

## Как добавить плагин в модуль

В gradle.build добавить две строчки:

```
import ru.yandex.realty.gradle.codegen.grpc.clients.GenerateGrpcClientsPlugin

apply plugin: GenerateGrpcClientsPlugin
```

## Как настроить генератор

Плагин добавляет в модуль сборку одну конфигурацию и одну таску.

```
dependencies {
    grpcClientDescriptors(project(path: ':realty-model', configuration: 'protoDescriptors'))

    api(project(':realty-model'))
    api(project(':realty-common'))
}
```

Конфигурация `grpcClientDescriptors` нужна для того, чтобы указать плагину, где взять собранный File Descriptor Set. Этот FDS включает в себя информацию как о наших внутренних сервисах (определенных в realty-model), так и обо всем, что может использоваться в их определениях (в первую очередь это протобафки из schema-registry). Сейчас мы собираем FDS один раз в модуле realty-model, используя возможности "стандартного" протобуфного плагина. В будущем по мере решения задачи о распиливании схемы, FDS мы, скорее всего, начнем генерить отдельно.

Помимо дескрипторов, вам понадобятся зависимости от скомпилированных классов `realty-model` и `realty-common`: как минимум для того, чтобы было откуда брать `Traced`. Аналогично, по мере распиливания common, возможно, список требуемых зависимостей изменится.

```
generateGrpcClients {
    includeProtoFilePrefixes = ['rent/']
    destinationPackage = 'ru.yandex.realty.clients.rent'
    classNamePrefix = 'Rent'
}
```

Таску тоже нужно сконфигурировать.

Для начала, через свойство `includeProtoFilePrefixes` нужно ограничить список файлов, в которых будет проводиться поиск сервисов. В свойство нужно сложить список префиксов "имен" файлов, причем именем считается полный относительный путь от корневой директории с протобуфками. Так, для сервисов Аренды достаточно указать `rent/` — это сматчит все сервисы из `realty-model/src/main/proto/rent/**` (а также сервисы из, например, `schema-registry/proto/rent/**`, если бы они там были). Если в префикс попадают лишние файлы, придется перечислить необходимые файлы поименно — механизм exclude не поддержан. По умолчанию список префиксов пуст, и в такой ситуации плагин вообще ничего генерировать не будет.

(Одного лишь попадания файла под фильтр недостаточно, чтобы для определенных в нем сервисов получились клиенты. Сервис нужно также проаннотировать; об этом см. ниже.)

Далее, необходимо указать в свойстве `destinationPackage` скаловый package, в который будут положены сгенерированные файлы.

Еще одно полезное опциональное свойство — `classNamePrefix`, по умолчанию равное пустой строке. Эта строка будет добавлена в начало имен всех сгенерированных классов.

## Как проаннотировать сервисы

```protobuf
import "realty_codegen.proto";                              // (1)

service GooseService {
  option (generate_client) = true;                          // (2)

  rpc dyorg(DyorgRequest) returns (DyorgResponse);

  rpc getPyos(GetPyosRequest) returns (GetPyosResponse) {
    option (generate_optional_result_in_client) = true;     // (3)
  }
}
```

Аннотации, используемы генератором, определены в файле `realty_codegen.proto` в `realty-model`. Чтобы их использовать, этот файл нужно импортировать, как сделано в `(1)`.

Чтобы для сервиса был сгенерирован клиент, сервис должен иметь аннотацию `generate_client`, как на строчке `(2)`. Если аннотации нет — клиента для сервиса не будет, даже если файл попадает в фильтр по имени.

У отдельных методов могут быть дополнительные настройки, влияющие на кодогенерацию. Пример такой настройки есть на строке `(3)`. Подробнее про них см. ниже в разделе про кастомизацию.

## Что будет сгенерировано

Для каждого сервиса будет сгенерирован Scala-файл с трейтом и реализацией клиента. Файл именуется по названию трейта. Название трейта генерируется из названия сервиса по шаблону `[Prefix]<ServiceName>Client` (у этого правила есть исключения, см. далее), название реализации — по шаблону `[Prefix]<ServiceName>ClientImpl`.

```scala
trait GooseServiceClient {
  def dyorg(q: DyorgRequest)(implicit t: Traced): Future[DyorgResponse]
}
```

В клиенте сервиса будет по одному методу для каждой ручки, определенной в сервисе. Метод будет называться так же, как называется ручка, с одной модификацией — первая буква приводится к строчой (т. е. для ручки `DyorgPyos` будет метод `dyorgPyos`). По умолчанию у метода будет два параметра: первый соответствует параметру ручки (Java-класс, сгенерированный из соответствующего message), второй — `implicit t: Traced`. Опять же по умолчанию возвращаемый тип — Java-класс возвращаемого мессаджа ручки, завернутый во `Future`.

```scala
class GooseServiceClientImpl(channel: io.grpc.Channel) extends GooseServiceClient {
  private val grpc = someGrpcThing(channel)

  override def dyorg(q: DyorgRequest)(implicit t: Traced): Future[DyorgResponse] =
    makeApiGrpcCall(grpc.dyorg, q)
}
```

В конструктор класса-реализации нужно будет передать один параметр типа `Channel`, инстансы которого обычно получаются из метода `ru.yandex.realty.grpc.client.GrpcChannelFactory.makeGrpcChannelFromEndpoint`. (Каналы можно переиспользовать между несколькими клиентами, например, в одном Supplier.) Каждый метод из трейта по умолчанию (т. е. в отсутствие дополнительных настроек ручки) получает свою реализацию на основе `makeApiGrpcCall`.

## Как кастомизировать сгенерированный код

### Индивидуальные настройки сгенерированных методов

У каждой ручки в сервисе могут быть свои опциональные настройки генератора. На данный момент есть такие настройки:
- `option (generate_optional_result_in_client) = true` предназначена для ручек, которые возвращают какой-то объект, которого может и не существовать. Вместо того, чтобы выкидывать эксепшен, клиентские методы для таких ручек будут возвращать `Option` результата. Пример: `def getPyos(q: GetPyosRequest)(implicit t: Traced): Future[Option[GetPyosResponse]]`. Реализация будет на основе `makeApiOptionGrpcCall`.
- Настройки контекста. Есть набор параметров запроса, которые нам часто хочется прокидывать через весь стек вызовов и между микросервисами. Это, например, название бранча, TVM user ticket, uid, uuid и так далее. Чтобы не делать отдельные параметры в каждой ручке и в каждом методе, такие параметры прокидываются через имплисит в составе объекта Request или его аналога. Требования к такому объекту указываются в виде набора трейтов, которые он должен реализовывать. Данные настройки включают требование того или иного трейта.
  - `option (requires_user_ticket) = true` указывает на ручки, требующие юзер-тикеты. В контексте должен быть `trait UserTicketWrapper`. 

### Добавление рукописного кода в клиенты

Как было указано ранее, по умолчанию трейт клиента имеет название, сгенерированное по шаблону `[Prefix]<ServiceName>Client`. Однако, если в рукописном коде модуля (`src/main/scala`) уже есть файл с таким названием, поведение генератора меняется:
- Сгенерированный трейт получает имя по другому шаблону: `[Prefix]<ServiceName>GeneratedClient` (отличие в слове `Generated`).
- Файл со сгенерированным кодом тоже называется по этому измененному шаблону.
- А вот класс-реализация все еще имеет старое название **и экстендит трейт с тем же названием, что и раньше**.

Таким образом, мы получаем:
```
trait GooseServiceGeneratedClient { ... } // сгенерированный
trait GooseServiceClient extends GooseServiceGeneratedClient { ... } // рукописный
class GooseServiceClientImpl(...) extends GooseServiceClient { ... } // сгенерированный
```

Автору рукописного трейта нужно не забыть заэкстендить сгенерированный, иначе `Impl` попытается заоверрайдить несуществующие методы.

Примеры, как это можно использовать:

**Для более эргономичного списка параметров метода:**
```
def dyorg(pyosId: String)(implicit t: Traced): Future[DyorgResponse] =
  makeApiGrpcCall(DyorgRequest.newBuilder().setPyosId(pyosId).build())
```

**Для более эргономичного возвращаемого типа** или какого-то хитрого преобразования:
```
def dyorgAndCount(pyosId: String)(implicit t: Traced): Future[Int] =
  makeApiGrpcCall(DyorgRequest.newBuilder().setPyosId(pyosId).build())
    .map(_.getDyorgedPyosList.size())(SameThreadEc)
```
В этом примере `SameThreadEc` — это `ru.yandex.vertis.util.concurrent.Threads.SameThreadEc`. Не следует пытаться запихнуть в клиент какое-то сложное преобразование, а для простого не страшно ненадолго занять тред из пула, обрабатывающего gRPC-вызовы. Есть альтернативные варианты:
- `ru.yandex.realty.util.lang.Futures.sameThreadExecutorContext` — почти то же самое, что `SameThreadEc`, только хуже;
- `ru.yandex.realty.util.thread.Threads.lightWeightTasksEc` — если вас грызет совесть и/или вы хотите UncaughtExceptionHandler, вырубающий приложение.

Расширять таким образом пока что можно только трейт, поэтому такое расширение не должен добавлять дополнительных "параметров клиента". Это ограничение сделано для того, чтобы облегчить в дальнейшем генерацию Supplier-ов. (Ну и сейчас, кажется, вообще нет клиентов, которым это нужно.) Однако при необходимости— хотя нет, это заслуживает отдельного заголовка.

# При необходимости всё описанное здесь можно поменять

Мы полностью контролируем этот код и поэтому его развитие ограничено лишь нашей фантазией, изобретательностью и свободным временем. Поэтому не стесняйтесь предлагать улучшения!

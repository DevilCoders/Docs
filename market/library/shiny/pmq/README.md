# PMQ aka Protobuf Message Queue
## Описание
**PMQ** – легковесный брокер протобуфных сообщений, предназначенный для использования внутри работающей программы, реализует паттерн PubSub; предназначен для передачи управляющих сигналов в event-driven architecture (не используется для тяжелых данных).

## Функциональность
**Гарантированный порядок следования сообщений** – сообщения будут получены подписчиком в порядке их отправления, а одно сообщение между разными подписчиками – в порядке регистрации подписчиков у брокера.

**Произвольный формат сообщения** – сообщением в системе является любое валидное protobuf-сообщение, других требований к формату нет

**Постоянное хранилище состояния** – если процесс, использующий PMQ упадет, то все необработанные сообщения сохранятся на диск (в т.ч. в человекочитаемом виде), а после перезапуска восстановится прежнее состояние; единственная неприятность – подписчик может получить одно и то же сообщение два раза, если краш произошел в процессе обработки сообщения.

**Ограничение потребления памяти** – PMQ на старте можно задать максимальный размер потребляемой памяти на сообщения; если лимит будет превышен, то публикация новых сообщений будет блокироваться до тех пор, пока память не вернется в лимит.

**Легковесность** – PMQ не претендует быть сервисом или распределенной системой, т.о. она не зависит ни от LogBroker, ни от других enterprise систем

## Особенности поведения
При аварийном завершении работы брокера, когда деструктор не вызывается, после перезапуска последнее вычитанное сообщение будет вычитано повторно.

Блокировка при превышении лимита памяти не действует в ситуациях публикации сообщений из Receive-метода – это предотвращает возникновение дедлока; при этом вызывается ```IMessageObserver::OnQueueSizeOverLimit```.

## Пример
```cpp
    /// Наследуемся от IMessageSubscriber, в качестве параметров шаблона передаем типы получаемых сообщений (protobuf message)
    class TMyService : public IMessageSubscriber<THelloMessage, TByeMessage> {
        void Receive(const TByeMessage& msg) override {
            /// логика обработки сообщения
        }

        void Receive(const THelloMessage& msg) override {
            /// логика обработки сообщения
        }
    };

    /// создаем наш сервис-получатель
    auto mySvc = MakeIntrusive<TMyService>();

    /// создаем брокера
    TMessageBroker broker ({
        100000,   /// лимит памяти в байтах
        "/tmp"    /// путь для хранения состояния
    });

    /// подписываемся на рассылку
    broker.Subscribe(mySvc);

    /// запускаем доставку сообщений для подписчиков
    broker.StartDispatch();

    /// посылаем подписчикам сообщения
    THelloMessage hello;
    broker.Publish(hello);

    TByeMessage bye;
    broker.Publish(bye);


# Шардирование (draft)

## Проблематика

В ближайшие три-четыре года ожидаем 100 кратный рост кол-ва обращений, а так же рост на порядок кол-ва заказов.
Примерный расчет: за этот год планируется 5 кратный рост обращений; за следующие два года рост ожидается примерно такой-же. Итого за 3 года 5*5*5*=125.

На данный момент максимальный размер БД в PGaaS составляет 4Tb, а кол-во CPU 64. Текущие наши лимиты: 1400 Гб (используем 700) на диске и 24 CPU (используем 16).

База данных у нас сейчас горизонтально не масштабируется в отличие от инстансов приложения (как обрабатывающих HTTP-запросы, так и выполняющих фоновые задачи).

Следовательно, нам необходимо научиться горизонтально масштабировать БД для возможности дальнейшего развития приложения.

## Что предлагается шардировать

1. Служебные таблицы, такие как, lock_service_locks и retry_task_service__tasks. Это позволит отдельно мониторить нагрузку на БД создающие служебную нагрузку.
1. Таблицы заказов чекаутера и Яндекс.Доставки.
1. Таблицы тикетов. При этом для хранения таблицы тикетов потребуется несколько шардов. Шардировать тикеты предлагается по очереди.
1. Все остальные таблицы хранить на отдельном шарде.

## Как предлагается делать

1. Сделать реестр шардов в конфигурационных файлах приложения. Конфигурация каждого шарда должна содержать уникальный идентификатор и параметры подключения к БД.
1. В метакласса добавить конфигурирования параметров шардирования. В тривиальном случае у метакласса будет указываться идентификатор шарда на котором будут храниться объекты этого метакласса.
1. Для каждого шарда поднимать отдельную hibernate sessionFactory, в которой будут только метаклассы этого шарда.
1. Поправить генерацию Entity для hibernate, а именно конфигурирование атрибутов типа ссылка на бизнес-объект, набор ссылок на бизнес-объекты, обратная ссылка. Если объекты хранятся на другом шарде, то в hibernate entity эти атрибуты описываются идентификатором объекта, а в Getter-e и Setter-е происходит преобразование в Entity и обратно.
1. Для объектов, которые разбиваются по нескольким шардам (например, тикеты) дополнительно необходимо поправить генерацию id-объекта (нельзя использовать последовательность) и уметь переносить объекты из одного шарда в другой.
1. Для правильной работы распределятора потребуется вести список тикетов находящихся в распределении на отдельном шарде. На этом шарде должна быть только информация необходимая для распределятора.
1. Потребуется переработать миграции на БД т.к. миграции будут привязаны к шарда, а некоторые миграции должны выполняться сразу на нескольких шардах (например, по таблице тикетов необходимо выполнить на всех шардах, где размещены тикеты).

![SessionFactory](ShardingSessionFactory.png "DbService и несколько SessionFactory")

## Возникающие ограничения

1. Не получится фильтровать таблицы по атрибутам связанных объектов находящихся на разных шардах (напримемр, шедулинг в правилах автоматизации и hql-запросы).
1. Отсутствие внешних ключей в БД.

## Разработка

1. Локальный запуск принципиально не будет отличаться от запуска на нескольких БД, но все SessionFactory будут ссылаться на один инстанс PostgreSQL.



# Учет времени

Ссистема позволяет учитывать время нахождения объекта в некотором состоянии, а так же расчитывать deadline-нахождения 
объекта в этом состоянии. Тривиальным примером является расчет времени к которому тикет должен быть решен.

Для учета времени система предоставляет два типа атрибутов: **счетчик времени** (timer) и **обратный счетчик** 
(backTimer). У каждого бизнес объекта может быть произвольное количество атибутов этих типов с различными настройками.

Назначение счетчика времени - это расчет продолжительности некоторого бизнес-процесса. С его помощью можно ответить 
 на вопрос: "Сколько времени продолжается процесс". В бизнес логике у счетчика времени есть два атрибута:
  - статус счетчика. Может быть ACTIVE (счетчик тикает), PAUSED (счетчик приостановлен), NOT_STARTED.
  - сколько времени прошло. 
  
В базе данных счетчик вемени хранит информацию в трех колонках:
  - статус счетчика;
  - время последнего запуска;
  - кол-во времени отсчитанного от момента последнего запуска или остановки.  

Назначение обратного счетчика - это определение остатка времени до  некоторого события (определение deadline-а). С его 
 помощью можно определить когда наступит deadline, а так же сколько времени до deadline-а осталось. В бизнес логике у 
 обратного счетчика времени есть три атрибута:
  - статус счетчика. Может быть ACTIVE (счетчик тикает, deadline не наступил), PAUSED (счетчик приостановлен), 
  STOPPED (счетчик остановлен. в отличае от PAUSED больше не запустится), NOT_STARTED (счетчик не начинал считать),
  EXCEED (наступил deadline).
  - deadline.
  - остаток времени до наступления deadline-а.
 
В базе данных обратный счетчик времени хранит инфомацию в четырех колонках:
  - статус счетчика;
  - время последнего запуска;
  - кол-во времени отсчитанного до момента последнего запуска или остановки;
  - deadline.
 
Счетчики времени (в т.ч. обратные счетчики) могут считать время по астрономическому времени или по времени обслуживания,
которое настроено в справочнике **Время обслуживания** (serviceTime). Например, нам надо посчитать время от момента 
  создания тикета, до момента взятия его в работу. Очередь, в которой создан тикет, обслуживается ежедневно с 9:00 
  до 17:00. Если тикет был создан в системе в 21:00, а взят в работу в 10:00 следующего дня, то при расчете по 
  астрономическому времени время взятия в работу будет 13 часов, а по времени обслуживания 1 час.

Пример добавления атрибута типа счетчик:
```xml
...
<m:attribute>
    <m:code>totalTimer</m:code>
    <m:title>
        <c:value>Счетчик суммарного времени обработки задачи</c:value>
    </m:title>
    <m:type code="timer">
        <m:property code="definition">ticketTotalTimer</m:property>
    </m:type>
</m:attribute>
...
```

Правила вычисления счетчика задается отдельной конфигуацией. В примере выше атрибут ссылается на нее по коду 
ticketTotalTimer.

Пример конфигурации счетчика времени (на примере тикета):
```xml
    <t:timer id="ticketTotalTimer" xsi:type="t:timer" metric="SERVICE">
        <t:title>
            <c:value>Конфигурация счетчик суммарного времени обработки тикета</c:value>
        </t:title>
        <t:description>
            <c:value>Считает время прошедшее с момента регистрации задачи до ее выполнения оператором</c:value>
        </t:description>
        <t:condition xsi:type="t:statusCondition">
            <t:status action="ACTIVATE" status="ticket@registered"/>
            <t:status action="ACTIVATE" status="ticket@processing"/>
            <t:status action="ACTIVATE" status="ticket@reopened"/>
        </t:condition>
        <t:source>
            <t:timeZone>timeZone</t:timeZone>
            <t:serviceTime>serviceTime</t:serviceTime>
        </t:source>
    </t:timer>
```
В этом примере счетчик времени считает нахождение тикета в определенных статусах [жизненного цикла](wf.md), а 
 именно в статусах registered, processing, reopened. Расчет времени ведется с учетов времени обслуживания. Это указано
 в атрибуте metric, у которого могут быть значения SERVICE или ASTRONOMICAL. В элементе source указано как определять
 временную зону и время обслуживания, в которых производить вычисления. Здесь timeZone - код атрибута тикета, в котором 
 находится информация о временной зоне, а serviceTime - код атрибута ссылающегося на время обсулуживания. Таким образом
 расчет счетчика времени поизводится независимо для кажого тикета.

Если объект не имеет жизненного цикла, то счетчик можно настройить с использованием правил его запуска и остановки. 
 Пример:
```xml
    <t:timer id="scriptTimerExample" xsi:type="t:timer" metric="ASTRONOMICAL">
        <t:title>
            <c:value lang="ru">
                Пример конфигурации счетчика времени, изменяющего свой статус на основании результата вычисления скриптов
            </c:value>
        </t:title>
        <t:condition xsi:type="t:scriptCondition">
            <t:startCode>startScriptCode</t:startCode>
            <t:pauseCode>pauseScriptCode</t:pauseCode>
            <t:stopCode>stopScriptCode</t:stopCode>
            <t:resumeCode>resumeScriptCode</t:resumeCode>
        </t:condition>
        <t:source>
            <t:timeZone>timeZone</t:timeZone>
        </t:source>
    </t:timer>
```
В этом примере startScriptCode, pauseScriptCode, resumeScriptCode и stopScriptCode - это коды скриптов из хранилища 
 скриптов, которые определяют необходимость запустить или остановить счетчик. В контексте выполнения скрипта доступен 
 бизнес-объект в котором определен счетчик.
Пример скрипта:
```groovy
"START_ME" == obj.timerSync
```
Где obj - это бизнес-объект, статус счетчика которого вычисляется, а timerSync - код атибута значение которого 
 определяет небходимость запустить счетчик.
 
Полный список возможных настроек счетчиков времени можно посмотреть в 
 [XSD-схеме](https://a.yandex-team.ru/arc_vcs/market/lilucrm/jmf/timing_engine/src/main/resources/xsd/timing.xsd).
 

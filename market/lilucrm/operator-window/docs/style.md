# Правила оформления кода

## Модули

Структура модуля подразумевает размещение всех java-классов в следующих пакетах.

    base.package - конфигурация модуля, основные интерфейсы и сущности
    base.package.impl - реализация сервисов
    base.package.http - контроллеры и др. классы, которые относятся к WebMVC (на данный момент имеет отдельный spring-контекст)

Ссылаться на классы из base.package.impl можно только из других классов этого модуля также размещенных в
base.package. Конфигурация модуля описывает `@ComponentScan` для пакета base.package.impl. и мы стараемся избегать
явного описания бинов в конфигурации модуля. При этом если модуль зависит от другого модуля, то в конфигурации модуля
должна быть также прописана эта зависимость через импорт конфигурации (аннотация `@Import`).

Если модуль содержит большое кол-во классов, то они могут быть размещенные по подпакетам описанным выше, но при этом
они должны соответствовать описанным выше правилам.

Пример:
```java
@Import({
    ModuleAConfiguration.class,
    ModuleBConfiguration.class
})
@ComponentScan({
        "ru.yandex.market.module.X.impl"
})
@Configuration
public class ModuleXConfiguration extends AbstractModuleConfiguration {
    public ModuleXConfiguration() {
        super("module/X");
    }
}
```

### Ресурсы модуля (конфигурационные файлы)

В системе реализованно автоматическое сканирование конфигурационных файлов приложения расположенных по следующим
пакетам:
  - `{module}/metadata/**/*.xml` - определение метаклассов
  - `{module}/wf/**/*.xml` - настройки жизненных циклов метаклассов
  - `{module}/ui/**/*.xm`l - настройки карточке объекта
  - `{module}/scripts/**/*.groovy` - скрипты
  - `{module}/entities/**/*.json` - инициализация бизнес-объектов, как правило, справочников
  - `{module}/triggers/**/*.xml` - настройки триггеров
  - `{module}/security/**/*.xml` - описание домена безопасности объектов (маркеров на которые будут выдаваться права)
  - `{module}/accessMatrix/**/*.xml` - конфигурирование прав выданных ролям
  - `{module}/bcp/**/*.xml` - правила создания, изменеия и удаления бизнес-объектов

Для включения автоматического сканирования ресурсов приложения необходимо чтобы конфигурация модуля расширяла класс
`AbstractModuleConfiguration`, в конструктор которого передается префикс размещения ресурсов. Важно что бы префикс
ресурсов не повторялся у разных модулей.

### Тесты

Рекомендуется на все тесты одного модуля иметь одну тестовую конфигурацию. Это позволяет сократить время прохождения
тестов за счет уменьшения кол-ва поднятий Spring-контекста (это не всегда оправдано, например, при тестировании
базовой функциональности). В любом случае рекомендуется тестовые конфигурации наследовать от
`AbstractModuleConfiguration`.

Пример:
```java
@Import({
    ModuleXConfiguration.class,
    // Для подтягивания конфигурации для тестов. Если основной модуль содержит зависимости от модулей,
    // то тестовая конфигурация должна зависеть от тестовых конфигураций соответствующих модулей
    ModuleATestConfiguration.class,
    ModuleBTestConfiguration.class
})
@Configuration
public class ModuleXTestConfiguration extends AbstractModuleConfiguration {
    public ModuleXTestConfiguration() {
        super("module/X/test");
    }
}
```

При написании тестов мы используем JUnit5 и по возможности переписываем старые тесты с JUnit4 на JUnit5.

Рекомендуется мокать клиенты сторонних сервисов, и минимизировать моканье реализации сервисов системы. Основной
библиотекой у нас является Mockito.

Если модуль зависит от каких-то параметров, которые внедряются через `@Value()`, то тестовая конфигурация должна
определять умолчания, подходящие для тестов. Эти умолчания нужно включать в тестовую конфигурацию модуля, чтобы
остальные модули, которые зависят от текущего, сразу имели эти параметры и не задумывались без необходимости об их
определении

Пример:
```java
@Import({
    ModuleXConfiguration.class,
    // Для подтягивания конфигурации для тестов. Если основной модуль содержит зависимости от модулей,
    // то тестовая конфигурация должна зависеть от тестовых конфигураций соответствующих модулей
    ModuleATestConfiguration.class,
    ModuleBTestConfiguration.class
})
@Configuration
@PropertySource(name = "moduleXTestProperties", value = "module/X/test/test.properties")
public class ModuleXTestConfiguration extends AbstractModuleConfiguration {
    public ModuleXTestConfiguration() {
        super("module/X/test");
    }
}
```

Если каким-то тестам необходимо переопределить какие-то параметры, нужно использовать `@TestPropertySource` на классе теста. Параметры из этой аннотации всегда более приоритетные, чем параметры из `@PropertySource` на конфигурациях

Пример:
```java
@SpringJUnitConfiguration(context = ModuleXTestConfiguration.class)
@TestPropertSource(properties = {
    "key1=value1",
    "key2=value2"
}, locations = "module/X/test/override.properties")
public class MyTest {}
```

## Скрипты

В скриптах крайне не рекомендуется ссылаться на java-код (делать импорты java-классов).
Рекомендуется использовать скриптовое АПИ (см. ScriptServiceApi). Так же к АПИ относятся коды метаклассов и атрибутов.

## Размещение бизнес-логики

В системе существует несколько способов размещения бизнес-логики:
- BCP-операции
- триггеры
- действия на вход/выход в статус жизненного цикла объекта

Действия на вход и выход в статус принципиально не отличаются от триггеров, но позволяют привязывать бизнес-логику
именно к жизненному циклу объекта. Триггером это эмулируется через условие срабатывания "статус изменился и стал равен"
(для действий входа в статус) или "статус изменился и был равен" (для действий выхода из статуса).

Выбор же между BCP-операцией и триггером более сложный:
- BCP-операции всегда выполняются синхронно с редактированием объекта. Триггер же может быть ассинхронным, что позволяет
  долгие операции выносить в отдельные транзакции.
- BCP-операции требуют меньше накладных расходов, например, если записывается история изменения объекта, то в случае
  BCP-операции будет одна запись в историю, а в случае триггера две.
- BCP-операции позволяют задавать порядок их выполнения и выстраивать сложные зависимости, триггеры же всегда
  выполняются после изменения значения всех атрибутов объекта, в т.ч. жизненного цикла, и до валидации.

Общая рекомендация: BCP-операции следуют использовать для системной бизнес-логики и для оптимизации производительности.

## Мелочи

- Мы сравниваем константы с переменной, а не наоборот. Пример, CONST.equals(var). Такой подход позволяет избежать NPE
  во время сравнения.
- Если функция возвращает коллекцию или stream, то функция не может возвращать null. Вместо null функция должна
  возвращать пустую коллекцию.
- Мы пользуемся ArrayList, ArrayDeque, HashMap, TreeMap, а также коллекции из fastutil. Не используем LinkedList
  (заменяем на ArrayDeque) и Vector (замена ArrayList).

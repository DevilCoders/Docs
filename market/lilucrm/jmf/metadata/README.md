# Metadata

Модуль предоставляет **[MetadataService](src/main/java/ru/yandex/market/jmf/metadata/MetadataService.java)**, позволющий получить
метаинформацию об бизнес-сущности. Структура конфигурационного файла описана в [metaclass.xsd](src/main/resources/xsd/metaclass.xsd).

## Метаклассы

Все бизнес-сущности описаны *[метаклассами](src/main/java/ru/yandex/market/jmf/metadata/metaclass/Metaclass.java)*,
которые содержат список *[атрибутов](src/main/java/ru/yandex/market/jmf/metadata/metaclass/Attribute.java)*.

Метакслассы представляют из себя иерархическую структуру, которая очень похожа на наследование java-классов.

Метаклассы бывают трех типов:

1) **Абстрактный** - полная аналогия абстрактного класса в java. Может расширять другие абстрактные классы. 
2) **Класс** - первое неабстрактное расширение метакласса. Может расширять абстрактные классы или ничего не расширять. 
3) **Тип** - метаклассы расширяющие Класс либо другой Тип.

Такая классификация метаклассов связана с организацией хранения бизнес-объектов, описанных метаклассами, в базе данных.
Так, Абстрактный метакласс не создает в базе данных никаких сущностей. На каждый Класс создается отдельная таблица в базе
данных, в которой храняться атрибуты Класса, Абстрактных классов, которые расширяет метакласс, и всех Типов этого метакласса.
Такой способ организации базы данных называется "Таблица на иерархию классов".

**[Идентификатор метакласса](src/main/java/ru/yandex/market/jmf/metadata/Fqn.java)** - это срока однозначно идентифицирующая
метакласс в системе. Для Типов состоит из двух частей: идентификатора Класса, к которому относится Тип, и уникальный
идентифкатор Типа внутри Класса. Например, **task$bugReport** обозначает, что Тип относится к Классу с идентификатором **task**, 
а код Типа **bugReport**.


## Дополнительные логики

Системную бизнес-логику (нельзя заскриптовать, например, из-за ее сложности) можно описывать в виде аггрегируемых в метакласс **логик**. Например,
жизненный цикл объектов в большинстве случаев будут иметь одинаковую реализацию независимо от метакласса. При этом для реализации жизненного
цикла объектов необходимо в метаклассе описать атрибуты *Статус* и *Время входя в статус*. Вынесение необходимых атрибутов и связанной бизнес-логики
в отедльную сущность **логика** позволяет аггрегировать ее в любой метакласс. См. модуль *[logic_wf](../logic_wf/README.md)*.


## Типы атрибутов

Типы атрибутов являются точкой расширения функциональности системы. Для подключения новых типов атрибутов необходимо реализовать интерфейс
**[AttributeType](src/main/java/ru/yandex/market/jmf/metadata/metaclass/AttributeType.java)** и
**[стратегию](src/main/java/ru/yandex/market/jmf/metadata/MetadataAttributeTypeInitializer.java)** его инициализации из конфигурационного
файла.

Реализация базовых типов атрибутов находится в модуле *[attributes](../attributes/README.md)*.

## Описание метаклассов

Метаклассы описываются в XML-формате, структуру которого можно посмотреть в *[XSD](src/main/resources/xsd/metaclass.xsd).
Пример описания:
```xml
    <m:metaclass>
        <m:fqn>employee</m:fqn> <!-- уникальный идентификатор метакласса -->
        <m:parent>bo</m:parent> <!-- fqn родительского метакласса, от которого будет унаследовано базовое поведение -->
        <m:title>
            <c:value>Сотрудник</c:value> <!-- название метакласса, которое будет использоваться в интерфейсе пользователя -->
        </m:title>
        <m:description>
            <c:value>Сотрудники компании</c:value> <!-- описание, которое поможет понять предназначение объектов -->
        </m:description>
        <m:attributes> <!-- перечисление доступных атрибутов объекта -->
            <m:attribute required="true"> <!-- добавляем атрибут для хранения фамилии сотрудника -->
                <m:code>lastName</m:code>
                <m:title>
                    <c:value>Фамилия</c:value>
                </m:title>
                <m:type code="string"/>
            </m:attribute>
        </m:attributes>
    </m:metaclass>
```

## Расширения метаклассов

Метаинформацией можно описывать не только базовое поведение системы, но и настраивать поведение любой части приложения.
Например, через метаинформацию задается объект, который необходимо показывать на втором мониторе (secondView).
Подобное поведение задается через расширения метакласса (вся работа с расширением реализуется в модуле его
реализовывающем). Для инициализации расширения необходимо реализовать стратегию 
*[MetadataExtensionInitializer](src/main/java/ru/yandex/market/jmf/metadata/MetadataExtensionInitializer.java)*, а 
для правильной инициализации зарегистрировать XSD описывающий расширение через *DefaultJaxbObjectFactoryProvider*.

Пример:
```xml
    <m:metaclass>
        <m:fqn>employee</m:fqn> 
        ...
        <m:extensions>
            <!-- модуль metadata ничего не знает об secondView-->
            <m:extension xsi:type="te:secondView" attribute="order"/>
        </m:extensions>
   </m:metaclass>
``` 

См. [описание](../module_default/src/main/resources/xsd/extensions.xsd) расширения secondView .
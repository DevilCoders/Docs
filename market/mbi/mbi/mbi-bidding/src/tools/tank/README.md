# Процедура нагрузочного тестирования

Данная процедура была выработана в ходе работы над [задачей стрельбы по измененной версии Bidding](https://st.yandex-team.ru/MBI-13358).

Процедура документирована в формате [Markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet "Синтаксис Markdown").

Для просмотра документа можно использовать любой доступный просмотрщик Markdown или воспользоваться удобным веб-интерфейсом [Dillinger](http://dillinger.io/).

На *Dillinger* можно сделать экспорт документа в PDF-файл.

Возможно что-то из комментариев к указанному выше тикету будет полезным в случае возникающих вопросов при ознакомлении с данной процедуры.

Для успешного проведения тестирования требуется подготовка, которая сводится в общем к следующим шагам:

- Составление профиля нагрузки (опционально)
- Подготовка данных для патронов
- Генерирование ленты с патронами
- Подготовка приборов
- Подготовка полигона
- Стрельба
- Анализ результатов

## Составление профиля нагрузки

Его можно оценить следующим образом.

Определяем основные операции с bidding.

На данный момент, это:

- **POST /bids** изменение ставок по offerId/title (далее PUT по ставкам)
- **POST /id-bids** получение ставок по offerId (далее GET по ставкам)

Определяем соотношение между операциями. Для этого помогут графики на телевизоре.

Надо присмотреться к графикам по RPS в разрезе по операциям.
На данный момент GET/PUT ~ 3/4, т.е. GET - 40%, PUT - 60%.

Далее, необходимо определить распределение по REQUEST SIZE, т.е. сколько ставок перечисляется в одном запросе.

Статистику можно собрать по логам *mbi-bidding.log*.

По GET:

- title (30%) 
  ```
  grep 'Count by feed' mbi-bidding.log | egrep -o '[0-9]+=[0-9]+$' | awk -F'=' '$1=="0" {print $2}'
  ```
- offerId (13%)
  ```
  grep 'Count by feed' mbi-bidding.log | egrep -o '[0-9]+=[0-9]+$' | awk -F'=' '$1!="0" {print $2}'
  ```

По PUT:

- title (6%)
  ```
  grep 'offer bids by title' mbi-bidding.log | awk '{print $(NF-4)}'
  ```
- offerId (51%)
  ```
  grep 'offer bids by id' mbi-bidding.log | awk '{print $(NF-4)}'
  ```

Примерное **соотношение** между GET-title/GET-id/PUT-title/PUT-id = **4/2/1/7**. Исходя из этого следует выбирать RPS.

Построить-посмотреть статистики можно с помощью R.

Например, пусть выборочные данные по GET-title находятся в файле *get_title.dat*, т.е. данные полученные на предыд. шаге.

```R
mydata = read.table("get_title.dat") - прочитать данные из файла в память
hist(mydata$V1, breaks=20) - гистограмма выборки
summary(mydata) - основные статистики
quantile(mydata$V1, c(0.05, 0.1, 0.5, 0.9, .95, 0.97, .99, 0.999)) - квантили
```

На данный момент **профиль размеров запросов** следующий:

- GET-title - 250
- GET-id - 500
- PUT-title/PUT-id - 40% - 1 ставка, 35% - 500 ставок, 25% - равномерно от 10 до 450

Выбираем **пиковый RPS как 200 req/s**. Исходя из этой цифры выбираем следующий состав по магазинам в SAMPLE-выборке:

- 10 самых крупных магазинов
- 80 мелких магазинов с кол-вом ставок от 250 до 500
- 60 средних магазинов с кол-вом ставок от 500 до 1000
- 50 крупных магазинов с кол-вом ставок от 1000 исключая 10 самых крупных

Кол-во ставок должно быть не более, чем 1000 для каждого из магазинов в выборке.

Ожидаемый максимум кол-ва ставок - 200 тыс. При среднем размере строки в 100 байт требуемое кол-во памяти с запасом для всей выборки ~ 200K*100*2=40M.

## Подготовка данных для патронов

**Выгрузка данных** из хранилища Bidding выполняется скриптом *extract.sh*.
Результат будет в файлах с суффиксом *.offers*.
В ходе работы скрипта **будет запрошен пароль к базе Oracle**.

**Потребуется** установленный инструмент сборки *gradle*, так как фактически выгрузка осуществляется gradle-скриптом *build.gradle*.

Запускать под **Java 8**.
Параметры конфигурирования gradle вынесены в файл gradle.properties.
Если вдруг потребуется перекрыть настройки, то можно при запуске extract.sh указать значение через -Pproperty=value.
Например, для перекрытия значения параметра ojdbcVersion (версия jdbc-драйвера oracle) 
```./extract.sh -PojdbcVersion=11.2.0.3.0```

```
export JAVA_HOME=~/tools/jdk8
export PATH=~/tools/gradle/bin:$JAVA_HOME/bin:$PATH
```

Для **конфигурирования параметров окружения** служит файл *setenv*.
**Переопределять переменные окружения** необходимо в локальном файле *setenv.local*.

Перед выгрузкой нужно определить **список тестовых магазинов**. Группа тестирования будет признательна, 
если ставки по тестовым магазинам не будут изменяться в ходе стрельб.
Список тестовых магазинов необходимо указать в файлах *id.offers.sql* и *title.offers.sql*.

Для **более качественной стрельбы** желательно иметь **профиль запросов** аналогичный продакшену.
Для этого возможно потребуется составить профиль. Для этого поможет раздел про составление профиля нагрузки.
**После изменения профиля** необходимо **скорректировать sql-скрипты в sql-файлах**. 

## Генерирование ленты с патронами

**Генерация ленты** выполняется скриптом *ammo.sh*.
Скрипт читает данные из *offers-файлов* и генерирует ленту.
**Результаты** будут в *gzip-файлах*.

Фактически вся работы выполняется python-скриптом *ammo.py*.
**Настройки скрипта** перечислены в файле *settings.py*. **Перекрывать** их, как правило, нужно в локальном *local_settings.py*. 

Следует **обратить внимание** на следующие **настройки**:

- **ACTION** - взять самый последний свеженький action id для auction_history, а иначе есть большая вероятность, что старый action был архивирован и удален
- **PLACES** - если добавились новые места, то следует добавить в settings.py и залить в репу
- **MAX_BID, MIN_BID** - если добавились новые места или изменились границы значений ставок по местам, то следует добавить в settings.py и залить в репу
- VHOST - FQDN хоста-балансировщика (для тестинга используется haproxy), который будет подставляться в http-заголовок *Host*
- AUTH - если вдруг поменялся пароль для доступа к Bidding API

VHOST выбирается равным хосту балансировщика намеренно, так как в конфигурации **clickphite** используется именно это значение для матчинга в файле *page-matcher.properties*.

Кликфит в свою очередь используется для построения метрик по nginx-логу для публикации их в *market-graphite*.

**Получить ACTION** можно с помощью SQL-запроса:

```sql
select max(action_id) from shops_web.v_migrate_auction_history where time > trunc(sysdate)
```

**Узнать хост** являющийся **лидер**ом можно с помощью:

```
http mbiddingha.market.yandex.net:38701/node-name
```

Пример приведен с использование [инструмента HTTPie](https://github.com/jkbrzt/httpie "Дружественный curl").

Если **изменился профиль** (см. составление профиля), то потребуется еще **поправить** *ammo.py* (см. метод *get_random_sample_by_profile*).

## Подготовка приборов

**Для создания дашборда** по основным приборам на *market-graphite* можно воспользоваться файлом *load_testing_dashboard.json*.

В данном файле находится конфиг, в котором **нужно изменить адрес цели** подставив вместо placeholder *$host например *mbidding01ft*

Перейти на [дашборд](https://market-graphite.yandex-team.ru/dashboard/ "Дашборд Графита Маркета")

Выбрать *Dashboard->Edit* и скопировать конфиг в форму, а затем нажать **Update**.

Выбрать опцию дашборда **Auto-Refresh** с *30-сек* интервалом и установить **Relative Time Range** на *1 час*.

## Подготовка полигона

**Создать тикет** для стрельбы в MBI. В тикете выбрать *Действие->Нагрузочное тестирование*.

### Загрузка ленты

Сгенерированные **ленты** потребуется **загрузить** в хранилище *Лунапарка*.

Для этого идем в [Лунапарк](https://lunapark.yandex-team.ru).
Затем выбираем **Пострелять**. Выбираем кнопку **Залить новый файл**, указываем ленту и даем ей название.

Например, названия *get_id_bids_150807_1550* или *put_title_bids_150807_1550*.

**Запоминаем названия**, чтобы использовать их затем в конфигурационном скрипте.

### Конфигурирование полигона для стрельбы

**Примеры конфигураций** приведены на [github](https://github.yandex-team.ru/netort/load_tools/tree/master/regression/market/mbi/bidding/configs).

Конфигурации:

- *load-imbalance.conf* - **стрельба на разладку**, т.е. для определения порогового RPS после которого сервис отказывает
- *load-const.conf* - **стрельба с постоянной нагрузкой** за указанный период
- *monitoring.xml* - конфигурация для мониторинга системы по отдельному целевому хосту
- *monitoring-group.xml* - конфигурация для мониторинга системы по группе хостов, что требуется использовать в случае стрельбы по всему кластеру bidding

Если хочется определить *пороговый RPS*, то следует сперва провести *стрельбу на разладку*.

Если требуется выполнить **сравнение с предыдущими стрельбами**, то нужно провести *стрельбу с постоянной нагрузкой* с тем же профилем по RPS.

Копируем нужный конфиг в [форму конфигурации](https://lunapark.yandex-team.ru/firestarter/).

Правим параметры конфига указывая **ссылки на ленты** (см. параметр ammofile). Ссылка выбирается через dropdown-список **Файл с патронами**.

Указываем **адрес цели** (см. параметр address). В случае стрельбы по кластеру нужно указать адрес балансировщика, значение которого на данный момент равно *mbiddingha.market.yandex.net*.

**Корректируем**, если необходимо, параметр нагрузки *rps_schedule* для каждой ленты согласно **профилю нагрузки**.

Указываем секцию *[monitoring]*, если необходимо смотреть на **системные приборы** для хоста-цели.

Параметры секции из которых важно выставить **config**. Например,

```
config=auto
```

Возможные значения:

- auto - мониторинг отдельного хоста по которому ведется стрельбы с параметрами по умолчанию,
- monitoring.xml - мониторинг отдельного хоста с параметрами в файле monitoring.xml (используется по умолчанию согласно конфигов на git)
- monitoring-group.xml - мониторинг группы хостов в случае стрельбы по всему кластеру через запросы к балансировщику

В поле **Задача (таск)** указываем номер тикета для нагрузочного тестирования.

## Стрельба

### Предварительно
 
Для **качественной стрельбы** просим индексацию на время стрельб **запрашивать дельты, снепшоты и отдавать результаты применения**.

Если **Индексатор недоступен**, то можно **самим** используя Exchange API периодически **выгружать snapshot и отдавать по нему ответ**.
**Файл с ответом по снепшоту** можно попросить у разработчиков Индексатора (например, **philimonov@**). Или найти их самим, например, на *mi01ht*.
Например, можно найти самый большой файл с ответом *.pbuf.sn* в папках типа */indexer/market/{yyyymmdd_HHMM}/input*.

```
ssh mi01ht
cd /indexer/market/20150817_1205
find . -name '*.pbuf.sn' | grep input | xargs -Iname ls -l name | sort -k5,5 -rn | head
```

А затем использовать данный файл следующим образом для публикации ответа.

```
http :3875/market/exchange/reply X-Bidding-Exchange-Generation:20141202_1430 < snapshot.mbi.result.pbuf.sn
```

где *X-Bidding-Exchange-Generation* - время ответа, т.е. *publication_time*.

Здесь на порт *3875* прокинут локальный порт *3870* хоста-цели через ssh

```
ssh -L3875:localhost:3870 mbidding01ft.market.yandex.net
```

Можно **самостоятельно** запрашивать дельты и снепшоты, а также формировать результаты и публиковать их через API.

Запрос дельты.

```
http --download -o delta.pbuf :3875/market/exchange/delta/1450195250
```

где 1450195250 - дата в unix epoch начиная с которой хотелось бы получить изменения по ставкам.

Дату в unix epoch можно получить через

```
date +%s
```

Тем же способом можно получить снепшот.

```
http --download -o snapshot.pbuf :3875/market/exchange/snapshot
```

В ответе по дельте будет распечатан http header *X-Bidding-Exchange-Time* значение которого нужно запомнить для получения следующей дельты.

Сформировать искуственный ответ можно с помощью скрипта *idxstub.sh*.

```
./idxstub.sh snapshot.pbuf
```

В результате чего будет создан файл с ответом *snapshot.pbuf.res* для отправки его в bidding через API (см. пример команды выше).

**Во время стрельб** сами или с помощью тестировщиков **ходим в партнерский интерфейс** для проверок по тестовым магазинам.

**Убедиться**, что во время стрельбы **не было переключений**. Справедливо в случае стрельбы по отдельному хосту-лидеру.

```
http mbiddingha.market.yandex.net:38701/node-name
```

В случае стрельбы по всему кластеру bidding нет смысла узнавать лидера.

Если будет переключение во время стрельбы, то сразу будет видно - пойдут сплошные 500-ки. 

### Основное действие

После подготовки полигона и создания конфигурации стрельбы жмем кнопку **Огонь**.

Ждем пока нагрузка **выйдет на плато**.

Затем **просим тестировщиков** выполнять запросы по тестовым магазинам и фиксировать проблемы в отчете.

Самостоятельно или через Индексатор **выполняем 2 выгрузки по снепшоту**, а также посередине между ними **отдаем результат по снепшоту**.

**При проблемах** следует связаться с командой по нагрузочному тестированию. В частности, с **netort@**. 

### Завершающие действия

Убедиться, что изменено ожидаемое кол-во ставок

```
select count(*) from shops_web.auction_entity_history where action_id = ACTION
```

Очистить журнал изменения ставок auction_entity_history, чтобы не допустить переполнения tablespace для журнала в тестинге.

```
delete from shops_web.auction_entity_history where action_id = ACTION
```

Очистить журнал применения ставок auction_rule от данных по снепшоту с номером GID 
(можно получить через запрос /log на порт 38701 или посмотреть в таблицу auction_generation_info).

```
delete from shops_web.auction_rule where generation_id = GID
```

## Анализ результатов

Выполнить сравнение полученных результатов с предыдущими стрельбами, если необходимо.

Проанализировать результаты можно на примере комментариев к тикету [MBI-14709](https://st.yandex-team.ru/MBI-14709).

В комментариях к тикету приводятся выводы, которые могут быть полезной отправной точкой для собственного анализа.

Полезные команды для получения данных из логов приведены в коментариях к [MBI-14851](https://st.yandex-team.ru/MBI-14851)
# Market Access Scheduler
В этом документе вы найдете архитектурное описание планировщика Market Access.

## Тезаурус
- Node (нода) -  конечный потребитель ресурсов -- машинка на которой работает workload
- Consumer (консюмер) - логическая группировка нод

## Консистентность обновления
При раскатывании ресурса на набор нод, планировщик в зависимости от настроек, реализует различные схемы обновления (deploy). Схемы обновления удобно классифицировать по консистентности -- согласованности установленных версий ресурса на нодах одного консюмера.

### Weak Consistency
Режим работы по умолчанию. Планировщик обновляет каждую ноду в отдельности на самую свежую доступную версию ресурса. В результате индивидуальная нода получает обновления с минимальными задержками, но при частой публикации новых версий, установленные версии на нодах консамера могут сильно разойтись.

### Strong Consistency
В консистентных  режимах планировщик обновляет ноды консюмера согласовано на одну и ту же версию. Раскатка версий заканчивается когда все активные ноды консюмера установят выбранную версию, при этом на время раскатки обновление на другие версии ресурса блокируется.

При консистентном обновлении ресурса планировщик создает именованные спецификации - *deployment*-ы, и явно их выполняет. Объект deployment описывается protobuf структурой **TDeployment**, список последних деплойментов и их состояния можно получить с помощью утилиты actl, так же с помощью actl пользователь может явно остановить активный deployment.

Сейчас реализованы два алгоритма консистентного обновления консюмера: AllAtOnce и Rolling.


#### AllAtOnce Deploy
Простой вид консистентного обновления -- ноды консюмера устанавливают выбранную версию одновременно, без дополнительной координации. При создании deployment-а планировщик запоминает список активных нод консюмера, и каждой ноде из списка выставляет в таргет выбранную версию ресурса. Установка считается завершенной, если версия установлена успешно или установка завершилась с ошибкой. Для этого анализируется флажок done=true для выбранной версии в стейте ноды. Спецификация задается  структурой **TAllAtOnceDeploy**

#### Rolling Deploy
Планировщик разрешает одновременную установку только фиксированному набору нод, которое не превышает размер install_window, для download – download_window. После того как нода обновилась, она убирается из окна и обновление разрешается для другой ноды. Из окна убираются только ноды с успешным статусом завершения. Пока есть хоть один успешно обновившийся сервер, окно будет двигаться. Если все окно заполняется нодами с плохим статусом установки версии, то планировщик помечает deployment как failed  и останавливает раскатку выбранной версии.

При создании deployment-а планировщик фиксирует в спецификации порядок обновления нод, максимальный размер окна, а так же какие ноды сейчас находятся в окне. Эти данные описаны в protobuf структуре **TRollingDeploy** и доступны для просмотра из actl во время раскатки версии.


### Условия завершения

При раскатке консистентных обновлений, необходимость координации всех нод порождает риски блокирования обновления кластера на неопределенное время. Для минимизации этих рисков планировщик реализует следующие стратегии

- Состав нод для обновления фиксируется всегда на этапе создания спецификации, обновление заканчивается когда версия будет раскатана на этот набор. Это защищает от ситуации много нод по одному появляются в системе после даунтайма.
- Планировщик отслеживает состояние ноды, заинтересованность в обновлении ресурса. При изменении статуса ноду пропускают.
- Чтобы защититься от semifailed (которые не могут установить ресурс, но явно не переходят в состояние failed) нод, планировщик учитывает настройки  TCompletionConditions, которые позволяют завершить обновление при досижении кворума, по таймауту и тд.


## Раскатка зависимых версий
Зависимости версий это (в общем виде): ситуация, при которой версия ресурса R1 для установки на консьюмер C1 ждет, пока версия ресурса R2 не будет установлена на консьюмер C2. Зависимости задаются через ConsumerGroup и dependecy ссылки между версиями.

### Consumer Group
Зависимость между консюмер-ресусрами описывается в системе через именованную сущность TConsumerGroup. Сущность создается пользователем, в теле фиксируется набор связанных ресурсов и консюмеров. При описании группы конкретный ресурс может встречаться только один раз, но допускается множественное вхождение одного консюмера.


### Group Deploy
Для раскатки зависимых версий планировщик создает специальные объекты TGroupDeployment, которые координируют обновление на уровне консюмеров. Планировщик на основе свзяей, доступных таблицы версий и описания из TConsumerGroup создается граф вершинами которого являются тройки (консюмер, ресурс, версия) а ребра задают нужный порядок установки. Граф проверяется на связность, ацикличность, обходом графа определяется порядок выполнения задач, учитываются распределяемые. Порядок и состав обновления консюмеров фиксируется в TGroupDeployment.

Каждый шаг из спецификации TGroupDeployment раскатывается планировщиком как обычный консистентный консюмер deployment (например как AllAtOnce или Rolling в зависимости от настроек). При завершении всех deployment-ов текущего шага, запускаются задачи из следующего и тд, пока вся спецификация не будет выполнена.


### Выбор версии ресурса
При выборе версии для обновления, планировщик смотрит на следующие источники в порядке уменьшения приоритета

- Версия вручную указанная в конфигурации пользователем
- Версия необходимая для поддержания инварианта зависимых версий
- Последнее опубликованная версия ресурса


# Управление выплатами (УВ), вид снаружи Биллинга

## Какие данные передаются в Биллинг и из Биллинга для УВ

Схема (лучше открывать в отдельном окне и увеличивать):
![alt Управление выплатами: вид снаружи Биллинга](../../../_assets/images/architecture/payment-control-ext.jpg)

## 613 рефанды

### Что такое 613 сервис

Обычно, если мы хотим вернуть деньги покупателю после клира платежа, Чекаутер создает рефанд. Но есть некоторые виды платежей, по которым нельзя создать обычный рефанд: постоплата, Тинькофф.Кредит и Тинькофф.Переуступка. Для этого, чтобы вернуть покупателю деньги после клира таких платежей, Чекаутер создает новый платеж в Трасте по 613 сервису. При этом в Чекаутере он выглядит как рефанд, и экспортируется в MB как рефанд.

> Может возникнуть путаница между 613 платежами и 613 рефандами. На самом деле, это одна и та же сущность, но в одних системах она хранится как платеж, а в других - как рефанд.


### Описание работы 613 рефандов

1. В MBI-Shops у магазина есть настройка PAYMENT_CONTROL_ENABLED, которая выгружается в ShopMetaData в Чекаутер и хранится в Чекаутере в таблице shop_meta_data.

2. В момент создания нового 613 рефанда Чекаутер создает в Трасте платеж по 613 сервису, и для каждой строчки корзины Траста указывает определенный service_fee.

    Значение service_fee, транслируемое в paysys_type_cc, используется для определения, требуется ли удержать деньги с магазина, и на какие счета распределений в OEBS попадет рефанд.

    | Значение service_fee | paysys_type_cc | Выплата покупателю | Удержание с магазина |
    |:-------------:|----------|------:|------:|
    | 1 | cash_item | да | да |
    | 2 | cash_loss | да | да |
    | 3 | ymarket_loss| да | нет |
    | 4 | ymarket_loss | нет | да |
    | 5 | cert_refund | да | нет |
    | 11 | acc_return_item | да | нет |
    | 12 | acc_return_extra | да | нет |
    | 14 | acc_return_refund | нет | нет |

    Для каждой строчки корзины Траста проверяется наличие всех условий:

    * рубильник в Чекаутере (613 рефанды по УВ) включен
    * 613 рефанд для этого магазина в рефанде должен идти по УВ (в shopmetadata)
    * исходный платеж для рефанда должен был идти по УВ

    Если все условия true, то Чекаутер указывает новые service_fee (11, 12, 14). Если хотя бы одно условие false, то Чекаутер указывает старые service_fee (1, 2, 4).

    Чекаутер в поле рефанда properties сохраняет массив ServiceFeePartition. Стоит обратить внимание, что на одну позицию в чеке (item_id или delivery_id) может быть несколько service_fee_partitions. Если все позиции в чеке идут не по УВ, то в properties ничего не сохраняется. Иначе в ServiceFeePartition будет разбивка для каждой позиции в чеке, причем service_fee на разные позиции чека могут быть как старые, так и новые.

    Если все значения ServiceFeePartition равны 4 или 14, то Чекаутер создаёт платеж в Трасте, но сразу бьется ивент RECEIPT_GENERATED, а рефанд переходит в статус Success. В этом случае рефанд готов для обработки в MB (можно переходить к п. 7). В противном случае MB на данном этапе рефанд пока не обрабатывает.

3. Траст передает 613 платежи в Баланс через LB.

4. Баланс обрабатывает каждую строчку корзины Траста.

    * для service_fee 1, 2, 4 *(`Удержание с магазина`:`да` в таблице выше)* создает для магазина рефанд (начисление + выплата)
    * для остальных *(`Удержание с магазина`:`нет`)* не создает для магазина рефанд начисления и рефанд выплаты

    Затем фильтрует строчки корзины Траста, убирая из нее строчки с service_fee 4 и 14 *(`Выплата покупателю`:`нет` в таблице выше)*.
    Все, что осталось - это деньги, которые надо выплатить покупателю. Эти строки экспортируются в OEBS, и затем Баланс начинает ждать, когда они попадут в ПП (что означает, что они выплатились покупателю).

5. Таска в Балансе *(pycron: `receipts_enqueuer`)* регулярно проверяет, ушло ли ПП с пользовательской выплатой покупателю.

6. Баланс идёт в Спирит и выбивает чек, после чего находит 613 платеж, из него получает URL HTTP REST API ручки Чекаутера, и вызывает этот URL, передавая URL чека. Чекаутер для данного рефанда создает событие RECEIPT_GENERATED и переводит рефанд в статус Success.

7. MB слушает поток ивентов по заказам из Чекаутера. Если приходит один из ивентов (RECEIPT_GENERATED, RECEIPT_PRINTED,
CASH_REFUND_RECEIPT_PRINTED), то считает, что рефанд можно обрабатывать в УВ, и идет в HTTP ручку Чекаутера за чеком для рефанда. Разбивка ServiceFeePartition из поля рефанда properties сохраняется в отдельную таблицу Oracle market_billing.service_fee_partition.

    * Общий принцип работы:

        Если для позиции чека смогли найти строчку (или строчки) в таблице market_billing.service_fee_partition, то берем только те строки, у которых service_fee = 11,12,14, и paysys_type_cc указываем один из cash_item, cash_loss, ymarket_loss. Если строку найти не смогли, то создаем начисление на сумму позиции из чека с paysys_type_cc как у исходного платежа.

    * Для начислений:

        Создается запись в таблице Oracle market_billing.accrual_trantime. Задача accrualMoneyFlowProcessingExecutor ее обрабатывает и сохраняет в таблицу Postgres market_billing.accrual. Затем строки собираются в 610 тлог и выгружаются в YT.

        Дата создания начисления - дата импорта рефанда в MB (что приблизительно равно переходу рефанда в статус Success).

        Для начислений указывается product = partner_payment и paysys_type_cc один из cash_item, cash_loss, ymarket_loss (или как у исходного платежа, если в таблице market_billing.service_fee_partition не смогли найти строчку).

    * Для выплат:

        Для каждого начисления джобой domesticPayoutFromAccrualExecutor проверяется наличие соответствующей записи в market_billing.order_payout_trantime (по связке order_id + partner_id). Если запись есть, то для начисления создаётся выплата (payout) в таблице Postgres market_billing.payout.

        Затем строки из market_billing.payout собираются в драфты команд на выплату (таблица Postgres market_billing.payment_order_draft), и далее по расписанию выплат формируется payment_order с учетом этого рефанда (таблица Postgres market_billing.payment_order). Затем строки собираются в 610 тлог и выгружаются в YT.


8. Баланс забирает начисления и выплаты из транзакционного лога по 610 сервису и экспортирует их в OEBS.

9. В начале следующего месяца OEBS создает Отчет Агента за предыдущий месяц, в котором учитывает начисления рефандов в строке "Возвращено денег пользователям", и учитывает выплаты магазину в строке "Переведено за отчетный период".



## Комментарии

Главный показатель успешности работы: выплаты мерчам корректные, полные, своевременные.

**Корректные:** каждая выплата происходит из каких-то состоявшихся заказов.
**Полные:** по всем заказам деньги мерчам выплатили.
**Своевременные:** мерч получает выплаты по тому расписанию, которое указал в ПИ.


## Ссылки

* [{#T}](payment-control-sequence.md)


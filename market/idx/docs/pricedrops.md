# Алгоритм генерации таблиц с автоскидками

С помощью этого алгоритма при валидации скидки получается учитывать не только снижение цены на оффер, но и реакцию пользователей на нее.
Учитывая историческую цену, конверсию и "кликабельность" оффера можем посчитать автоскидку, а так же добавить валидацию исторической цены.
Алгоритм с кликами применяется только на "карточные" категории (модели и кластера),
причем кластерные статистики рассчитываются для актуальных кластеров - мы берем текущий кластер оффера и смотрим статистику именно по этому кластеру
(не учитываем возможные переходы офферов между кластерами).
Для простых офферов (т. е. без модели или кластера) используется только критерий 5% скидки.
Историческая цена также проходит проверку на реакцию пользователей, в частности мы проверяем что она находилась "в рыночном диапазоне".
Мы будем считать историческую цену валидной, если по цене больше либо равно исторической было совершено >= 5% кликов за месяц (т. е. даже цена выше заинтересовала пользователей),
либо количество кликаутов по этой цене и выше достаточно для совершения 1 покупки (исходя из конверсии).

На Белом Маркете анализ валидности скидки делается для каждого отдельного оффера, а на Синем анализ проводится для всего MSKU, поэтому
алгоритм pricedrops подготовит две таблицы для валидации: одну для Белого Маркета, а вторую - для Синего.
Чтобы не запускать работу алгоритма два раза и не иметь две отдельные его версии для Синего и Белого,
готовим данные на вход особым образом, чтобы сразу сделать анализ для обоих цветов.

##  Входные таблицы
- клики (//home/market/production/mstat/logs/market-clicks-log/1d) - таблица маркет-стата, в которой хранятся клики по офферам
- конверсия категорий (//home/market/production/mstat/analyst/regular/cpc_conversion_for_Report/smoothed/last_complete)
- генлог (//home/market/production/indexer/stratocaster/offers/recent)
- белые исторические цены (//home/market/production/indexer/stratocaster/history/prices/hprices/last_complete)


## Выходные таблицы
- таблица с провалидированными историческими ценами и рекоммендоваными ценами для автоскидок (белая //home/market/production/indexer/stratocaster/history/prices/hprices_pricedrops/last_complete,
синяя //home/market/production/indexer/stratocaster/history/blue/prices/hprices_pricedrops/last_complete)
- partner_report сейчас не используется, но туда попадает много отладочной информации, по которой можно понять что пошло не так (белая //home/market/production/indexer/stratocaster/history/prices/hprices_pricedrops_partner_report/last_complete,
синяя //home/market/production/indexer/stratocaster/history/blue/prices/hprices_pricedrops_partner_report/last_complete)


## Шаг 0. Подготовка данных.
Шаг нужен для того, чтобы алгоритм pricedrops сгенерировал таблицу и для Синего Маркета тоже. Для Синего Маркета нужно
рассчитывать "валидность" исторической цены не относительно какого-то конкретного оффера, а относительно всего MSKU.
Искусственно подмениваем "синие" данные в генлог, клики и историю.
1) Генлог (результат //home/market/production/indexer/stratocaster/history/prices/pricedrops_input/genlog):
из генлога вытаскиваем белые оффера и перекладываем как есть, а
у синих офферов подменяем offer_id на market_sku, feed_id на 200344511, ware_md5 на md5(market_sku).
2) Клики (результат //home/market/production/indexer/stratocaster/history/prices/pricedrops_input/clicks):
из таблицы с кликами выбираем все записи для белых офферов (у них supplier_id == NULL) и перекладываем как есть, а
для кликов по синим офферам заменяем offer_id на msku, feed_id на 200344511, ware_md5 на md5(msku).
объединение шага 1 и 2 кладем в результирующую таблицу
3) История (результат //home/market/production/indexer/stratocaster/history/prices/pricedrops_input/hprices):
из таблицы с белой историей перекладываем все как есть, а
в таблице с синей историей меняем offer_id на msku, feed_id на 200344511.
Таким образом получим, что искусственно сгенерированная пара offer_id + feed_id для синих офферов являет собой не что иное как MSKU.


## Шаг 1. Построение промежуточной таблицы с данными по кликам, истории, конверсии ($CARD_OFFER_DATA)
$CARD_OFFER_DATA - это промежуточная таблица, которая собирает в себе данные по кликам, конверсии категорий и ценам.
В этой секции будет описан алгоритм подсчета $CARD_OFFER_DATA для офферов, для которых получилось определить или модель (model_id), или кластер (cluster_id).
Алгоритм будет разобран только для тех офферов, для которых получилось определить модель (для кластеров вычисления будут аналогичны).

1) Для каждого оффера с моделью (model_id) из генлога,
считаем по кликовым таблицам сколько кликов было сделано и по какой цене за месяц, собираем цены в список и сортируем по возрастанию.
Для каждого уникального оффера получаем запись с количесвом кликов и списком цен, по которым кликали за месяц.
2) Для каждой уникальной модели из генлога получаем суммарное количество кликов, которое было сделано по всем ее офферам,
максимальное количество кликов по какому-то офферу среди всех офферов модели, а так же список цен по всем офферам (собирается конатенацией списков цен из шага 1) за месяц.
3) Для каждой уникальной модели генлога, выбираем все цены по офферам из генлога, находим среди них самую маленькую цену из 10% самых дорогих офферов.
4) Для каждого оффера с моделью (model_id) из генлога находим историческую цену.
5) Для каждого оффера с моделью (model_id) из генлога находим запись из таблицы конверсии категорий.
Если для оффера нет ничего в таблице категорий, то количество кликов, необходимых для покупки будет выглядеть так 1.0/0.0245 (0.0245 - среднее значение конверсии на маркете),
иначе - 1.0/smoothed_conversion.

В результирующую таблицу ($CARD_OFFER_DATA) кладем:
 - ware_md5
 - feed_id
 - offer_idспс
 - hyper_id
 - cluster_id
 - title
 - price_raw
 - price
 - history_price - историческая цена (п. 4)
 - clicks_count_for_offer - количество кликов по офферу
 - clicks_enough_to_buyout -  количество кликов необходимых для покупки (п. 5)
 - prices_list - список цен из п. 2
 - max_clicks_count - максимальное число кликов по офферу среди всех офферов модели
 - sum_clicks_count - суммарное количество кликов по офферам модели
 - pricerange_max_price - вычисляется на основании исорической цены (п. 4), актуальной цены и списка кликов по офферам модели за месяц (п. 2).
   В диапазон между исторической и новой ценой должно попасть определенное число (%) кликов.
   Если кликов не достаточно, считаем что pricerange_max_price == 0, в этом случае оффер магазина не получит скидки по этому критерию,
   даже если решит торговаться бесплатно, такак как слишком мало кликов в диапазоне.
 - tentop_max_price - самая маленькая цена из 10% самых дорогих офферов модели
 - pricedrops_max_price - 95% от history_price


## Шаг 2. Выбираем оффера с моделью/кластером и ценой проходящей валидацию ($CARD_AFTER_PRICEDROPS).
На этом шаге выбираем оффера с моделью/кластером и ценой проходящей валидацию, то есть она достаточно маленькая и пользователи достаточно
кликали по этому предложениею.
В $CARD_AFTER_PRICEDROPS попадут оффера с моделью или кластером, для которых нашлась историческая цена и цена оффера <= 95% от исторической, и
по которым были клики и цены которых <= чем pricerange_max_price (см. шаг 1).
Количество кликов по офферу проверяется так: оно либо должно быть больше, чем число кликов по офферу необходимых для покупки,
либо больше чем 10% от максимального числа кликов по офферу среди всех офферов модели,
либо цена < самая маленькая цена из 10% самых дорогих офферов модели.

1) Из таблицы $CARD_OFFER_DATA построенной на шаге 1 выбираем такие записи, для которых верны все следующие утверждения:
- для модели оффера, есть хотя бы один оффер по которому кликали,
- цена оффера <= чем pricerange_max_price
- цена оффер <= чем 95% от history_price
- число кликов по офферу > 10% от максимального числа кликов по офферу среди всех офферов модели
  или число кликов по офферу >= чем число кликов необходимых для покупки
  или цена < самая маленькая цена из 10% самых дорогих офферов модели


## Шаг 3. Вычисление значения для валидации исторической цены и рекоммендованной цены для офферов без модели и кластера ($RECOMMENDED_SIMPLE_PRICE)
На этом шаге обработаем оффера без модели и кластера.
В $RECOMMENDED_SIMPLE_PRICE попадут оффера без кластера и модели.
1) Из генлога выбираем оффера, для которых не получилось определить ни модель, ни кластер
2) Для каждого оффера такого оффера из генлога находим историческую цену
3) По ней считаем рекоммендованную как 95% от history_price

В результирующую таблицу кладем:
ware_md5, feed_id, offer_id, hyper_id (0 так как нет модели), cluster_id (null так как нет кластера),
title, price_raw, price, history_price, valid_history_price (== history_price), recommended_price (95% от history_price)


## Шаг 4. Построение таблицы для валидации возможности добавлени офферу автоскидки ($FEED_OFFER_ID_WITH_PRICEDROPS)
На этом шаге собираем данные по всем офферам. В таблицу попадут только те оффера, цена которых проходит валидацию,
то есть можно ли будет назначить офферу автоскидку.
В $FEED_OFFER_ID_WITH_PRICEDROPS объединяются таблицы из шагов 2 ($CARD_OFFER_DATA) и 3 ($RECOMMENDED_SIMPLE_PRICE).
Причем из $RECOMMENDED_SIMPLE_PRICE будет взяты только такие такие оффера, для которых есть историческая цена, и цена оффера <= 95% от исторической цены.
Результирующая таблица будет использоваться для принятия решения о проставлении офферу рекоммендованной цены.

В результирующую таблицу кладем: offer_id, feed_id


## Шаг 5. Вычисление значения для валидации исторической цены и рекоммендованной цены для офферов с моделью/кластером ($RECOMMENDED_CARD_PRICES)
На этом шаге к таблице с данными по кликам, истории и конверсии добавим данные, по которым будет валидироваться историческая цена,
и рекоммендованная цена.
$RECOMMENDED_CARD_PRICES - эта таблица считается на основе $CARD_OFFER_DATA из шага 1.
Здесь нет никакой дополнительной фильтрации, но добавляются новые поля valid_history_price и recommended_price (ниже будут описаны только те, которых в $CARD_OFFER_DATA нету).

В результирующую таблицу кладем:
- поля $CARD_OFFER_DATA без изменений
- valid_history_price
  1) берем список цен собранных по кликам по офферам модели и соритуем по возрастанию
  2) вычислем 5% от числа всех кликов по офферам модели
  3) считаем минимум из (5% от числа всех кликов по офферам модели; число кликов необходимых для покупки) - clicks_required
  4) если clicks_required больше, чем у нас всего кликов было, то valid_history_price == 0
  5) из всех цен берем ту, что стоит на -1 * clicks_required месте (это как раз та цена, ниже которой нужно будет отфильтровывать исторический цены)
  6) если таких цен было несколько, то увиличивем ее на 1 (так как если было несколько кликов с одинаковой ценой, то мы можем брать не цену ниже найденной, а саму найденную)
- recommended_price
  1) если не нашлась историческая цена или если цен по кликам по офферам модели, которые проходят валидацию по истории, меньше 5%, то recommended_price = 0
  2) если были клики по офферу и было найдено максимальное число кликов по офферу среди всех офферов модели
  и (число кликов по офферу >= 10% от максимального числа кликов по офферу среди всех офферов модели
     или число кликов по офферу >= чем число кликов необходимых для покупки),
  то recommended_price = min(95% от history_price, pricerange_max (см. шаг 1))
  иначе - recommended = min(95% от history_price, pricerange_max (см. шаг 1), если нашлась самая маленькая цена из 10% самых дорогих офферов модели, если не нашлась - 0)


## Шаг 6. Построение таблицы со значение для валидации исторической цены и рекоммендованной ценой для всех офферов ($RECOMMENDED_TOTAL)
$RECOMMENDED_TOTAL - считается объединением двух таблиц полученных на шагах 3 и 5.
В этой таблице для оффера будут выбраны историческая цена, значение, по которому будет валидироваться историчекая цена, и рекоммендованная цена.

В результирующую таблицу кладем:
feed_id, offer_id, history_price, recommended_price_raw, recommended_price, price, ware_md5, hyper_id, cluster_id, currency, valid_history_price


## Шаг 7. Результирующая таблица price_drops. ($HPRICES_PRICEDROPS)
На последнем шаге формируется финальная таблица hprice_pricedrops, которая будет содержать исторические цены прошедшие валидацию,
а так же данные для простановки офферу автоскидки.
$HPRICES_PRICEDROPS строится на основе таблиц шага 4 и 6.

1) Для каждой записи из исторической таблицы hprices находим запись в $FEED_OFFER_ID_WITH_PRICEDROPS (см. шаг 4)
2) Для каждой записи из исторической таблицы hprices находим запись в $RECOMMENDED_TOTAL (см. шаг 6),
причем историческая цена из $RECOMMENDED_TOTAL должна проходить валидацю history_price < valid_history_price
3) У каждого оффера (Market.OffersData::Offer) заполняем специальные поля:
- recommended_price - если для записи в исторической таблице нашлась запись в $RECOMMENDED_TOTAL, то возьмем recommended_price из нее, иначе - 0
- pricedrops_tests_passed - если для записи в исторической таблице нашлась запись в $FEED_OFFER_ID_WITH_PRICEDROPS
- также добавляем в структуру исторической цены поле is_valid. Если историчская цена не прошла валидацию, выкидываем её в индексаторе (пробросив это поле дальше в репорт).
  Это необходимо чтобы отличать отсутствие исторической цены (оффер размещается менее 5 дней) от невалидной исторической цены (была установлена, но по ней и выше неё не кликали).

В результирующую таблицу (//home/market/production/indexer/stratocaster/history/prices/hprices_pricedrops/pricedrops_result) кладем: feed_id, offer_id, offer (см. п. 3), history_price (из исторической таблицы)


## Шаг 8. Разделение результата работы pricedrops на белый и синий.
Шагом номер 0 было совершено подмешивание синих данных во вход алгоритма pricedrops, последним шагом нужно произвести обратное разделение, чтобы
получить на выходе таблицы price_drops для белых и синих офферов.
1) Все оффера, у которых feed_id <> 200344511 - это белые оффера, их без изменений перекладываем в //home/market/production/indexer/stratocaster/history/prices/hprices_pricedrops/last_complete
2) Все оффера, у которых feed_id == 200344511 - это синие оффера, у них убираем feed_id, offer_id заменяем на msku, в сортированном по msku (!) виде перекладываем в //home/market/production/indexer/stratocaster/history/blue/prices/hprices_pricedrops/last_complete
Такое же разделение выполняется для partner_report.


## Для чего используется таблица price_drops?
1) по ней мы делаем валидацию oldprice по полю hitsory_price, чтобы скидка от магазина была честной
2) по ней задаем авто скидки, тем магазинам, который этого захотели
3) показываем магазинам рекомендуемую цену в отчете, чтобы магазин мог получить скидку самостоятельно (выставив рекомендуемую цену),
   и показываем что историческая цена была выкинута из-за отсутствия к ней интереса пользователей (кликов)



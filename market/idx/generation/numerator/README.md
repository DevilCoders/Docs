# Numerator (DRAFT)

Бинарник для проекта [Персистентный doc_id](https://st.yandex-team.ru/MARKETTECH-2196). На некоторый промежуток времени за каждым оффером закрепляется его позиция в индексе, что позволяет асинхронно готовить и обрабатывать данные.

Сам __Numerator__ раздает персистентные doc_id и shard_id всем офферам в поколении, поддерживает стейт для следующих поколений, контролирует версии.

Заметим, что для стейта поддерживается мульти-ДЦ работа, чтобы процессы индексации и раскладки были бесшовными. Схему работы мульти-ДЦ можно найти ниже, эта логика написана на Python.

# Принцип работы:
1) У каждого оффера есть свой уникальный ключ-кортеж ```<business_id, offer_id, shop_id, warehouse_id>```. За каждым уникальным ключом будет закреплена своя уникальная пара ```<shard_id, doc_id>```.
2) Стейт версионирован для обеспечения совместимости и персистентности.
3) Стейт может быть автоматически перестроен для экономии размера поискового индекса.
4) Мастер индексации, который последним обновил стейт, обязан обеспечить следующий мастер своим обновлением, иначе ликвидировать его.
5) Мета-информация об актуальном стейте хранится в zookeeper.

# Перестроение стейта

Причины перестроения стейта тесно связаны с частью про версионирование стейта.

## Добавление новых офферов
Если нумератор видит незнакомый ключ-кортеж, то добавляет его в свой стейт и выдает ему пару ```<shard_id, doc_id>```. В целях экономии, внутри одного шарда doc_id выдаются упорядоченно (следующий за максимальным).

Дополнительно реализован механизм TTL: если оффера не появлялся много поколений, то его doc_id будет отдан какому-то новому офферу.

## Автоматическое сжатие
Иногда необходимо сжимать стейт в целях экономии размера поискового индекса. Из стейта уходят оффера, но за ними остается doc_id. Это значит position-based файлы после genlog_dumper будут расти по размеру.
Если при добавлении новых офферов стейт слишком разрастается, то стейт принудительно перестраивается.

## Перешардирование (draft)
Зная версию шардирования и необходимые параметры оффера, вы можете узнать его шард. Этот интерфейс закреплен в специальной библиотеке, __Numerator__ тоже использует ее.
Вы можете поменять схему шардирования в индексе передав соответсвующий параметр на входе.

# Версионирование стейта
Версионирование стейта позволяет асинхронно готовить данные на индексаторе и пользоваться данными на репорте.

Версия обеспечивается 4 числами T.S.V.G:

- T (type): тип стейта или коллекции. Например, эта версия для синего маркета, турбо, вертикали и тд.

- S (schema): схема шардирования. Иногда индекс меняет схему шардирования, оффера перекатываются.

- V (version): версия перестроения. Меняется, если происходит сжатие стейта.

- G (generation): поколение (не обязательно привязано к поколению индексации). Увеличивается при добавлении новых doc_id в стейт.

Заметим, что если ваш стейт имеет версию T1.S1.V1.G1, а данные собраны на стейте T1.S1.V1.G2, причем G1 >= G2, то вы легко можете пользоваться этими данными благодаря персистентности. В остальных случаях данными пользоваться опасно.

Версионирование позволяет определить совместимость хранимого стейта и поискового индекса, асинхронных данных, а также подбирать нужный стейт из нескольких хранящихся.

Заметим, что generation здесь и в коде никак не связано с поколением индексации.

# Поддержание мульти-ДЦ
Представим централизованную систему, в которой зукипер это координатор, а мастера индексации просят координатор write-lock на стейт.
Мастер индексации, который последним подготовил стейт, обязан обеспечить следующий мастер своим обновлением, иначе данные признаются не валидными.

Что хранит координатор:
1) Информацию о последнем консистентном стейте (yt кластер и путь к стейту).
2) Информацию о мастере захватившем write-lock на стейт (имя мастера, время взятия лока, id лока как номер билета).

Если мастер получил write-lock:
1) Мастер копирует стейт на свой YT-кластер.
2) Запускает программу.
3) Сообщает координатору о своем статусе (если успех, то и даные о стейте) и номер билета.
4) Координатор по необходимости обновляет информацию о стейте и освобождает лок. Если координатор считает, что это таймаут, то сборка поколения прерывается и собранный стейт не валиден.

Если мастер получил отказ о write-lock:
1) Делает retry каждые N секунд, пока не получит владение.

Если координатор верит, что холдер стейта отвалился по таймауту (например, проблемы с ДЦ или YT):
1) Не обновляет информацию о стейте.
2) Освобождает лок.
3) Возможно, мастер обратится к координатору с новым стейтом, он получит отказ из-за устаревшего номера билета лока.

# Как запустить

```bash
./numerator \
--yt-proxy arnold \
--input-shops-dat-file-path shops-utf8.dat.report.generated \
--input-state-table //home/market/testing/indexer/users/state \
--input-offers-table //home/market/production/indexer/gibson/mi3/main/last_complete/work/offers_raw \
--intermediate-new-docs-table //home/market/testing/indexer/users/state_new_docs \
--intermediate-expired-docs-table //home/market/testing/indexer/users/state_expired_docs \
--output-state-table //home/market/testing/indexer/users/state_output_tmp \
--output-sharding-scheme 0 \
--output-primary-medium ssd_blobs \
--rebuild-state-force
```

Рекомендации по тестированию:
1) запускайте на пустых папках, где можно творить бардак.
2) запускайте под ыть-квотой престейбла с тачки мастера.
3) запускайте с --output-primary-medium ssd_blobs

Тестовые случаи для разработчиков:
1) --force-rebuild-state — ожидаем новый стейт, размер шарда равен размеру инпута по шарду.
2) Поколение превышает TTL, нет просроченных документов — новым документам раздаем новые doc_id (следующие за максимальным doc_id в стейте шарда).
3) Поколение превышает TTL, есть просроченные документы — новые документы получают doc_id от просроченных документов и следующий за максимальным в стейте шарда.
4) Срабатываение механизма перестроения стейта — см. пункт 0.
5) Основной случай без автоперестроения — новым документам раздаем новые doc_id.

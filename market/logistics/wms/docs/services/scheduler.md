# Шедулер

### Назначение
Сервис предназначен для периодического выполнения заданий, таких как архивация или очистка данных.
Сервис является развитием сервиса Scheduler из поставки Infor

### Структура сервиса, управляющая заданиями
Для запуска и выполнения заданий (джоб) используются следующие основные компоненты:
файл настройки расписания выполнения заданий, классы джоб, сервисов и дао для работы с БД, параметры (настройки) сервисов

### Настройка расписания выполнения заданий
Задания описываются в ```scheduler/src/main/resources/quartz_data.xml```, автоматически добавляются в БД после старта сервиса.
Для каждого задания обязательно должны быть заданы в теге ```job```, соответствующие имя, группа и запускаемый Java-класс джобы.
При установке параметра durability в false, запись о джобе автоматически удаляется из БД, если с ней не ассоциирован ни один активный тригер.
При установке параметра recover в true, прерванная во время исполнения по hard shutdown (ребут сервиса) джоба, автоматически перезапустится после старта сервиса.
Время и периодичность запуска задается тегом ```trigger```. Если джоба не должна запускаться по умолчанию после деплоя сервиса на всех локациях, то тригер не прописывается в ```quartz_data.xml```, а создается позднее вручную в интерфейсе ```UI -> Администрирование -> Настройки Scheduler -> необходимая джоба -> Создать триггер```

## Если выполнение задания зависло
Принудительно остановить конкретную джобу возможно только если она реализует интерфейс ```InterruptableJob```, а ее сервис реализует механизм остановки выполнения,
кроме того зависшая джоба может упасть по таймауту запроса в БД, если он установлен параметром (либо зависший запрос будет прибит спецальным механизмом), в иных случаях поможет только рестарт всего шедулера

### Особенности классов Джоб
Данные классы обычно не несут существенной логики и лишь помещают результат выполнения в JobDataMap в виде строки для дальнейшего сохранения в истории запуска.
В классе джобы допускается выброс единственно возможного класса исключений - ```JobExecutionException```, поэтому любые другие исключения обязательно должны быть обернуты.
Аннотация ```@DisallowConcurrentExecution``` добавляется перед классом для исключения многократного запуска джобы в один период времени (в том числе многопоточно).
Для мониторинга локов с помощью АОП необходимо наследовать джобу от ```SchedLockMonitoringSupport``` и сделать ее компонентом спринга.
Для возможности изменения параметров джобы, необходимо реализовать интерфейс ```ParametrizedJob```, а сервис должен отдавать список параметров

### Поддержка прекращения работы джобы с помощью UI или Graceful Shutdown
При завершении работы шедулера, всем выполняющимся джобам отправляется сигнал interrupt(), кварц будет ждать пока они завершатся.
Для возможности остановки выполнения джобы, ее класс должен реализовать интерфейс ```InterruptableJob```, а метод interrupt() должен останавнивать работу сервиса.
В интерфейсе ```UI -> Администрирование -> Настройки Scheduler -> необходимая джоба``` есть кнопка принудительной остановки джобы, использующая описанную ниже ручку

### Особенности классов Сервисов
Сервисы помещаются по логическим группам в соответствующие пакеты (например, archive или clean).
Сервисы, реализующие интерфейс ```CyclicWorkingService```, работают циклически с завершением выполнения цикла по истечении времени выполнения, либо по отсутствию данных для архивации/удаления.
В сервисах не используется ```TransactionTemplate```, являющий синглтоном, поскольку при изменении параметра Timeout одним сервисом, измененное значение используется всеми сервисами.
В этом случае если таймаут устанавливался меньше, чем необходимо для текущего запроса, возникало падение джобы из-за выбрасывания исключения.
Хорошей практикой для сервисов является улавливание исключений таймаута запроса и продолжение работы сервиса (либо проброс исключения на уровень выше в зависимости от условий)

### Параметры (настройки для классов сервисов)
Параметры, управляющие выполнением методов в классах сервисов и дао, достаются из БД с помощью DbConfigService,
должны задаваться миграциями в ```/liquibase/db/Scheduler/``` модуля ```db-migrations``` в таблицах ```Scheduler.dbo.CONFIG_PROPERTIES``` и ```Scheduler.dbo.CONFIG_PROPERTY_VALUES``` и иметь уникальное имя для каждого сервиса.
Параметры должны актуализироваться значениями из БД перед каждым выполнением джобы (например с помощью метода init()).
В классе сервиса параметры обычно используются в виде перечисления, реализующего интерфейс ```JobParam```.
Если сервис реализует интерфейс ```ParametrizedService```, а джоба ```ParametrizedJob```, параметры отдаются через ручку в ```SchedulerManagementController``` и могут быть изменены через интерфейс: ```UI -> Администрирование -> Настройки Scheduler -> необходимая джоба -> вкладка Параметры```.
Следует обратить внимание, что есть минимальное и максимальное значение по каждому параметру, если новое значение не будет соответствовать данному интервалу, то текущее значение не будет изменено

### Особенности классов Дао и решение проблем связанных с обращениями к БД
Для каждого Сервиса создается собственный Дао класс, вне зависимости от существования подобного класса в Common Spring или других модулях для корректной работы с таймаутами запросов.
**Для решения проблемы блокирующихся долгих запросов к БД используется установка таймаута на все запросы (в том числе SELECT) в JdbcTemplate.**
Для целостности данных методы переноса (копирования и удаления) данных между двумя таблицами или схемами БД помечаются ```@Transactional```.
Использующийся бин ```NamedParameterJdbcTemplate```, является прототипом, поэтому создается новый экземпляр для каждого класса Дао.
Поскольку Н2 не поддерживает создание двух схем БД для одного источника данных, методы Дао классов, работающие с двумя схемами БД, не могут быть протестированы с помощью интеграционных тестов.
**Настоятельно рекомендуется не использовать в Дао классе несколько разных JdbcTemplate, работающих с различными Datasource (например, с основным и архивным).**
Если это все же необходимо, требуется предусмотреть чтобы для методов, выполняющихся в транзации, использовался не только менеджер транзакций для основного Datasource, но и менеджеры транзакций для остальных подключений.
Взаимодействие между несколькими менеджерами транзакций реализуется с помощью ChainedTransactionManager, без этого при прерывании транзакции возможны случаи неконсистентности данных.

## Мониторинг выполнения заданий
Для мониторинга используется информация от HealthSchedulerController об имеющихся проблемах с запуском и выполнением джоб, описанная ниже

### Хранение и изменение настроек мониторинга
Настройки мониторинга хранятся в таблице ```Scheduler.dbo.job_monitoring_config``` в виде параметров ,
а также отображаются в интерейсе: ```UI -> Администрирование -> Настройки Scheduler -> необходимая джоба``` **(в скобочках указаны имена столбцов таблицы в UI)**:
* ~~Сколько последних запусков джобы учитывается для мониторинга (данный параметр устарел)~~:
    * ```runs_number_to_consider``` ~~(Количество учитываемых зап.)~~
* Количество последних запусков джобы, учитытываемых для мониторингов долго не запускавшихся и долго выполняющихся или неуспешно выполняющихся джоб:
    * ```runs_number_to_consider_for_hanging``` (Кол-во учитываемых последних зап. по длит. вып.)
    * ```runs_number_to_consider_for_failing``` (Кол-во учитываемых последних зап. по неусп. вып.)
* Проверяет превышен ли порог между запусками джобы. Если порог превышен, то возвращает ошибку с таймстемпом последнего запуска:
    * ```max_delay_time``` (CRIT врем. порог между зап.) в секундах
    * ```warn_delay_time``` (WARN врем. порог между зап.) в секундах
* Проверяет превышен ли порог по длительности работы. Если порог превышен, то возвращает ошибку с максимальным временем работы и таймстемпом начала:
    * ```max_execution_time``` (CRIT порог по длит. вып.) в секундах
    * ```warn_execution_time``` (WARN порог по длит. вып.) в секундах
* Проверяет превышен ли порог по неуспешным запускам. Если порог превышен, то возвращает ошибки по всем запускам (из числа отслеживаемых):
    * ```max_failed_runs``` (CRIT порог по неуспешным зап.)
    * ```warn_failed_runs``` (WARN порог по неуспешным зап.)

## Настройка параметров мониторингов и устранение критических проблем
Для каждой джобы, имеющей триггер, автоматически запускается мониторинг со следующими дефолтными настройками:
CRIT врем. порог между зап. = 86400, WARN врем. порог между зап. = 86400,
CRIT порог по длит. вып. = 60, WARN порог по длит. вып. = 60,
CRIT порог по неуспешным зап. = 1, WARN порог по неуспешным зап. = 1,
~~Количество учитываемых зап. = 1~~, Количество учитываемых последних запусков по длительности выполнения = 1, Количество учитываемых последних запусков по неуспешным выполнениям = 1.
Отключить джобу от мониторинга можно только удалив триггер.

При необходимости можно изменить дефолтные параметры мониторингов в БД, либо в интерфейсе, кликнув на таблицу с параметрами мониторинга и отредактировав их в форме согласно следующим рекомендациям:
*   Время между запусками джобы, указанное в cron выражении триггера, должно быть менее чем ```CRIT врем. порог между зап.``` (корректируем значение cron либо параметры мониторинга).
*   Время выполнения джобы должно быть менее чем ```CRIT порог по длит. вып.``` (при необходимости увеличиваем порог).
*   Количество неуспешных запусков в последних нескольких запусках джоб, установленных параметром ```Количество учитываемых зап.```,
    должно быть меньше, чем параметр ```CRIT порог по неуспешным зап.``` (если джоба падает часто, изменяем параметры, описанные ниже).
*   Все джобы с триггерами не должны быть поставлены на паузу, их приостановка является критическим событием (снимаем джобу с паузы)

## Параметры джоб, влияющие на мониторинги и настройка их значений
*   Таймауты - максимально возможное время в секундах после которого запрос (или вся транзакция) прерывается, а джоба падает с ошибкой: archivingTimeout (архивации), selectionTimeout(выборки), deletingTimeout (удаления).
    Значения таймаутов запросов определяются опытным путем на проде, на сложные запросы SELECT обычно устанавливаются в пределах 10-30 секунд, на INSERT и DELETE порядка 3-5 секунд.
    Если джоба часто падает по таймауту, необходимо немного увеличить соответствующие таймауты и протестировать полученный эффект.
*   Для исключения долгих блокировок таблиц, удаление и архивация данных проводится небольшими частями, устанавливаемыми параметрами batchSize (размер выборки всех ключей, обычно это несколько десятков тысяч)
    и partitionSize (размер партиции - части данных из выборки, архивируемых или удаляемых в рамках одной итерации, обычно в пределах 500-1000 значений).
    Важно заметить, что для партиций максимальный размер ограничивается в 2100 элементов, по максимальному их количеству для оператора IN (...).
    Если джоба падает на выборках значений, стоит уменьшить batchSize, если джоба падает на копировании или удалении, стоит уменьшить partitionSize (каждая итерация будет быстрее выполняться).
*   Для циклически работающих сервисов реализован счетчик количества выброшенных исключений таймаута запросов maxRetryAttemptsNumber (обычно 3),
    чем он больше, тем больше раз джоба будет пробовать повторить выполнение, при исключении таймаута без полного падения и остановки джобы.
    При улавливании исключения таймаута запроса, происходит засыпание на время, установленное параметром failureSleepTime, заданного в миллисекундах (обычно около 10000) для разблокировки таблиц БД.
*   Для большинства джоб реализовано ограничение максимального времени выполнения с помощью параметра timeLimit, заданного в миллисекундах.
    При частых критических сообщениях от мониторингов о долгом времени выполнения джобы стоит уменьшить данный параметр


### История выполнения джоб
История выполнения джоб пишется в таблицу```Scheduler.dbo.QRTZ_HISTORY```.
Последние 10 запусков джобы можно увидеть в интерфейсе: ```UI -> Администрирование -> Настройки Scheduler -> необходимая джоба -> вкладка История```


## Ручки для мониторингов

#### Список долго выполняющихся или давно не запускавшихся джоб
GET http://host/scheduler/health/hangingJobs

#### Список джоб с превышением порога по неуспешным запускам
GET http://host/scheduler/health/failedJobs

#### Список отключенных (поставленных на паузу) джоб
GET http://host/scheduler/health/pausedJobs

#### Статус Health Check
GET http://host/scheduler/scheduler/hc/ping

Проверить на живость БД и активность сервиса, можно запросив статус выполнения cпециальной джобы, выполняющейся каждую минуту и ничего не делающей:
GET http://host/scheduler/health/failedJobs/archive/canary
GET http://host/scheduler/health/hangingJobs/archive/canary

#### Получение параметров конфигурации мониторинга
GET  http://host/scheduler/health/configs/{jobGroup}/{jobName}

#### Изменение параметров конфигурации мониторинга
PUT  http://host/scheduler/health/configs/{jobGroup}/{jobName}

#### Удаление параметров конфигурации мониторинга (установка дефолтных значений)
DELETE  http://host/scheduler/health/configs/{jobGroup}/{jobName}


## Ручки для получения информации

#### Создать джобу
POST http://host/scheduler/manage/job-group/{jobGroup}/jobs

#### Посмотреть информацию о джобе
GET http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}

#### Список джоб
GET http://host/scheduler/manage/jobs
параметр fireTime - время следующего запуска


## Ручки управления выполнением

#### Поставить на паузу
POST http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/pause

#### Возобновить
POST http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/resume
В списке джоб на паузе имеет state = PAUSED. Мониторинг отрабатывает по поставленным на паузу джобам.

#### Запустить джобу разово
POST http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/execute?p1=v1
Параметры запроса будут переданы в jobDataMap как есть и могут использоваться для управления джобом или переопределения параметров из БД

#### Принудительно остановить
POST http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/interrupt
Работает только для джоб, реализующих интерфейс ```InterruptableJob``` и приостановку исполнения кода классов сервиса и дао

#### История запусков
GET http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/history?limit=10


## Ручки управления тригерами и параметрами

#### Создать триггер
POST http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/create-trigger

#### Удалить триггер
DELETE http://host/scheduler/manage/trigger-group/{triggerGroup}/triggers/{triggerName}

#### Найти триггер
GET http://host/scheduler/manage/trigger-group/{triggerGroup}/triggers/{triggerName}

#### Изменить триггер
PUT http://host/scheduler/manage/trigger-group/{triggerGroup}/triggers/{triggerName}

#### Получить параметры
GET http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/params

#### Изменить параметры
PUT http://host/scheduler/manage/job-group/{jobGroup}/jobs/{jobName}/params


## Описания некоторых джоб (список расширяется)

#### Джоба частичной или полной отмены заказа - RemoveItemCancelOrderJob
Основная документация: https://wiki.yandex-team.ru/users/antandtim/scheduler-must-die/removeitemcancelorderjob/
Определяем заказы, у которых не хватает товаров на стоке.
Берем все заказы, у которых время отгрузки лежит в пределах ближайших 7 часов, после чего проверяем их балансы.
Если по каким-либо товарам не хватает балансов, то мы либо убираем товар, либо отменяем заказ.
Критерии того, что можно убрать товар:
* Товар имеет значение true в поле RemovableIfAbsent.
* До отгрузки осталось меньше 7 часов.
* При удалении товара сумма потерь стоимости заказа не должна быть в процентах больше maxAbsentItemsPricePercent, который сейчас по умолчанию везде стоит 99%.

В этом случае у товаров проставляется статус -5, заказ статус не меняет (точнее сказать уходит в -5 и сразу же возвращается обратно).
* Критерии того, что можно отменить заказ:
* Товар имеет значение false в поле RemovableIfAbsent.
* До отгрузки осталось меньше 6 часов

#### Джоба разделения заказов по зданиям - BuildingMarkingJob
Основная документация: https://wiki.yandex-team.ru/users/antandtim/scheduler-must-die/buildingmarkingjob/
Для запуска джобы нужно поменять YM_BUILDING_MARKING_JOB на 1 в таблице NSQLCONFIG.
Данная джоба определяет заказы, которые пора брать в обработку (то есть те, у которых время отгрузки лежит в пределах параметра LT_REPL_HR из таблицы NSQLCONFIG) и для которых отсутствует значение (ORDERS.BUILDING is null) в каком здании этот заказ должен выполняться.
* Если заказ нельзя собрать в одном здании, то он разбивается на несколько заказов по зданиям в зависимости от того, в каком здании какие есть товары.
* Если заказы потенциально можно собрать в нескольких зданиях, то идет расчет балансов товаров, если товаров хватает в одном здании, то заказ отправляется туда, если нет, то заказ делится между зданиями в зависимости от наличия товаров, приоритетно (по возможности) распределяя в минимальное количество зданий.
* Если заказ можно собрать только в одном здании, то заказ маркируется этим зданием.

Все заказы, попавшие на разделение удаляются из дальнейшей обработки, они будут обработаны при следующем запуске джобы

# Сервис отчетов

## Создание отчетов

Каждый отчет в Reporter представлен отдельным классом, реализующим интерфейс [`ru.yandex.market.wms.reporter.reports.Report`](src/main/java/ru/yandex/market/wms/reporter/reports/Report.java) и расположенном в пакете `ru.yandex.market.wms.reporter.reports` или его подпакетах.
Кроме того, у класса должна быть аннотация [`@ru.yandex.market.wms.reporter.reports.WmsReport`](src/main/java/ru/yandex/market/wms/reporter/reports/Report.java), в которой указываются метаданные, необходимые Reporter для регистрации отчета.

В момент запуска приложения класс отчета будет зарегистрирован как бин Spring, поэтому в нем можно использовать инъекцию зависимостей.
Скорее всего одной из таких зависимостей будет DataSource, настроенный на базу "SCPRD".
Для получения этой зависимости нужно использовать `@Qualifier("scprd") DataSource ds`.

Для представления в пользовательском интерфейсе название и группа отчета будут получены из аннотации `@WmsReport`, а параметры должен вернуть метод `Report#getParams`.

Для получения файла отчета пользователь выберет подходящий отчет, задаст параметры отчета и запустит задачу его генерации. Состоит она из двух шагов.

На первом шаге создается только _каркас_ отчета.
Условно его можно считать промежуточной структурой данных, из которой можно сформировать уже нужный нам отчет в пользовательском формате (PDF, XLSX, HTML и пр.), но без обращения к внешним источникам (базе данных).
 
При написании Reporter предполагалось, что получение данных может быть долгим, поэтому оно выполняется асинхронно, а пользователь после "заказа" отчета может пойти пить чай.

Формирование каркаса выполняется методом `Reporter#generate(List<ReportParam>)`, который должен вернуть результат в виде одной из реализаций `ReporterOutput`.
Reporter использует этот класс, чтобы сериализовать данные каркаса в хранилище.
На данный момент есть две реализации этого класса:

* `JsonReportOutput`.
Предназначен для простых случаев, когда данных у отчета мало.
Сохраненный в нем объект будет сериализован в JSON при помощи Jackson, поэтому на классе можно применять аннотации этой библиотеки для настройки сериализации.
Учитывайте, что память Reporter ограничена, поэтому передача структур в десятки мегабайт таким способом нежелательна.
* `TempFileReportOutput`.
Предназначен для случаев, когда создаваемый каркас может быть очень большого размера.
Для снижения требований к памяти и избежания `OOM`, реализация отчета должна сохранять данные каркаса во временный файл, буферизуя в памяти только незначительную их часть в каждый момент времени.
Располагать этот временный файл желательно в папке, путь к которой возвращает метод `ReporterSettings#getWorkingDir()`.
Когда формирование каркаса завершится, путь к этому файлу передается в `TempFileReportOutput`.

После формирования каркаса Reporter сохранит его данные в хранилище.

Для начала следующего этапа жизни отчета требуется действие пользователя.
Когда он увидит, что задача по получению данных для отчета завершена, то сможет выбрать ее и получить файл отчета, указав необходимый формат.
В этот момент Reporter загрузит сериализованные данные из хранилища и вызовет последовательно два метода:

1. `Report#generateHardCopyName(ReportTask)`.
Метод должен вернуть имя для файла отчета.
Расширение добавлять не нужно.
Reporter сделает это самостоятельно в зависимости от формата.
Также желательно имя файла сделать уникальным для каждой задачи. 
Проще всего этого добиться, добавив в имя файла ID задачи, доступный в переданном `ReportTask`.

1. `Report#generateHardCopy(ReportOutput, ReportFormat, OutputStream)`.
В этом методе выполняется преобразование каркаса отчета из внутренней структуры данных в пользовательский файл.
Тут тоже нужно учитывать, что если отчет имеет значительный размер, то нужно постараться формировать его поточно, не сохраняя в памяти большие куски данных. 

На этом обработка отчета завершается. Подводя черту, жизненный цикл задачи по формирования отчета состоит из следующих шагов:

```
шаг 1. запуск задачи по формированию отчета: → выбранный отчет и параметры его запуска
шаг 2. формирование каркаса: отчет + параметры запуска + внешний источник данных → каркас (долгий процесс)
шаг 3. формирование файла отчета: каркас + выбранный формат → файл отчета (быстрый процесс)
```

### Библиотеки для формирования файлов отчета

Хотя ручное написание кода по формированию файлов отчета предоставляет максимальную гибкость, часто проще воспользоваться существующими менее гибкими решениями, упрощающими этот процесс.
В Reporter их предусмотрено два:

1. [JXls](http://jxls.sourceforge.net/) для формирования файлов Excel из размеченных специальным образом файлов XLS/XLSX.
Пример можно посмотреть в отчете `CanaryReport`.
Учтите, что эта библиотека оперирует XLS в памяти, поэтому она подходит только для отчетов, размер которых гарантированно будет небольшим.

2. [JasperReports](https://community.jaspersoft.com/project/jasperreports-library) для формирования отчетов в форматах PDF, XLSX, HTML и пр.
Пример можно посмотреть в `OpsExecEffectivenessReport`.

#### Использование JasperReports

Если для отчета будет использоваться JasperReports, то для этапов генерации каркаса и файла отчета удобно использовать классы `JasperParameterMapper` и `JasperReporter`.
Примеры их использования можно посмотреть в `OpsExecEffectivenessReport`.

`JasperParameterMapper` упрощает отображение параметров отчета Reporter (`List<ReportParam>`) в используемый в Jasper (`Map<List, Object>`).
Выглядит это примерно так:
```
DbConfigService configService = ...;
mapper = JasperParameterMapper.Builder.mapper(configService)
        .addMappingAsJavaUtilDate("reportParam1", "P_PARAM1")
        .addMappingAsJavaUtilDate("reportParam2", "P_PARAM2")
        .addMappingAsInteger("reportParam3", "P_PARAM3_1")
        .addMappingAsBigDecimal("reportParam3", "P_PARAM3_2")
        .build();
...
List<ReportParams> reporterParams = ...;
jasperParams = mapper.map(reporterParams);
```  

`JasperReporter` это бин в контексте Spring, который упрощает этапы создания каркаса и файла отчета.
Используемый движок Jasper настроен на использование виртуализации для отчетов, которые больше приблизительно 100 страниц.
Это сильно снижает риск получения `OOM` даже для больших отчетов.

Для формирования каркаса используется группа методов `JasperReporter.generateReport(String, Map<String, Object>, DataSource)`.  

Для генерации файла отчета используется группа методов `write*HardCopy`:

* `writeHardCopy`.
Формирует отчет в формате, переданном в `ReportFormat`.

* `write<Format>HardCopy` (`writeXlsxHardCopy` и прочие).
Формирует отчет в соответствующем формате, но в отличие от первого метода позволяет настроить генерацию отчета через переданный объект-конфигурацию.

### Использование дизайнера JasperReports

Для создания дизайна отчета Jasper используется JasperReports Studio.
Студия это обычный WYSIWYG-редактор, очень простой в освоении.
Для установки можно либо скачать дистрибутив [сайта Jasper](https://community.jaspersoft.com), либо под MacOS установить командой
```
brew install --cask tibco-jaspersoft-studio
```

В зависимости от сети может потребоваться настройка студии для работы по IPv6.
Задается она в файле `Jaspersoft Studio.ini`.
На MacOS он будет расположен в `/Applications/TIBCO Jaspersoft Studio *.app/Contents/Eclipse`.
В случае IPv6 нужно установить следующие параметры запуска JVM:
```
-Djava.net.preferIPv4Stack=false
-Djava.net.preferIPv4Addresses=false
-Djava.net.preferIPv6Addresses=true
```

В приложении есть уже настроенный проект для студии, который можно использовать для разработки:

1. Вызываем "File" → "Import..." → "General" → "Existing Projects into Workspace"
1. Выбираем в "Select root directory" папку `reporter/reporter-app/jaspersoft_studio`, жмем "Finish"
1. После завершения импорта проекта нужно вызвать `sync_fonts.sh` (расположен в корне проекта, для запуска нужна Java 11)

В проекте прилинкованы следующие папки:
* `jasper` — к `reporter/reporter-app/src/main/resources/jasper`, для шрифтов, картинок и пр.
* `reporter-app_classes` — к скомпилированным классам reporter-app, чтобы студия видела наши классы при компиляции отчета
* `reports` — к `reporter-app/src/main/jasperreports`, именно в этой папке нужно создавать отчеты

Так как настроенные папки являются внешними, то студия не будет автоматически синхронизовать изменения, если они не выполнялись самой студией.
Для ручной синхронизации нужно вызвать "Refresh" из контекстного меню проекта. 

#### Настройка шрифтов

JasperReports для генерации отчетов в формате PDF использует iText, который по умолчанию не умеет отображать символы, не входящие в латиницу.
Так как в наших отчетах почти везде используется кириллица, то необходимо выполнить дополнительную настройку отчета для внедрения пользовательских шрифтов в документ PDF.
Сейчас в Reporter добавлен шрифт Roboto для поддержки кириллицы, но скорее всего их скоро станет больше.

Новые шрифты добавляются через `reporter/reporter-app/src/main/resources/jasper/fonts/fonts.xml`.
Чтобы студия увидела новые шрифты, надо синхронизовать настройки студии с этим файлом при помощи скрипта `sync_fonts.sh`.
Так как студия использует только абсолютные пути к файлам шрифтов, для каждого окружения настройки проекта будут меняться.
Коммитить эти изменения нет необходимости.

Если для отчета планируется использовать единый шрифт, то проще всего это сделать через глобальный стиль.
Создается он в узле "Styles" в представлении "Outline".
Перейдите в настройки нового стиля, включите чекбокс "Default Style" и задайте необходимый шрифт.

#### Рекомендации

Ниже будет ряд рекомендаций или пояснений, которые будут полезны при создании нового отчета:

**Пункт 1**

В студии лучше сразу создать адаптер (источник данных) под названием "WMS".
Так как имя используемого адаптера записывается в дизайн отчета, одинаковое название у всех разработчиков позволит отчету работать "из коробки".
Для создания адаптера откройте контекстное меню проекта → New → Data Adapter.
В качестве названия укажите "WMS.xml", тип — "Database JDBC Connection", далее настройте подключение к подходящей БД.
При тестировании отчетов используйте этот адаптер.

В дальнейшем может потребоваться создание дополнительных адаптеров к БД других систем, но для них тоже желательно использовать единые названия у всех разработчиков отчетов.

**Пункт 2**

Страница любого отчета состоит из различных заголовочных и итоговых блоков, а также из одного или нескольких блоков "Detail".
Основные элементы отчета создаются именно в блоках "Detail".
Нужно учитывать, что эти блоки создаются для каждой строки, возвращаемой главным датасетом (задается через представление "Outline" → контекстное меню на корневом узле отчета → "DataSet and Query...").
Если основной датасет не задан или возвращает 0 строк, то блок "Detail" также не будет создан, и отчет будет пустым.
 
**Пункт 3**

При рисовании отчетов лучше использовать фиксированную сетку с привязанным к ней расположением элементов.
Это упростит создание аккуратных отчетов с выровненными относительно друг друга элементами.

Настраиваются параметры сетки в основном окне с дизайном отчета в меню кнопки "Settings" в верхнем правом углу.
Там необходимо включить пункт "Snap to guides", а также любые другие необходимые ассистенты для выравнивания элементов.
Задать размер шага сетки можно через пункт "Grid size...".

Отдельно отмечу формат отчета XLS.
Для него желательно использовать сетку с шагом по высоте 16 пикселей.
Эта высота овпадает со стандартной высотой строки в Excel.
В качестве шага по ширине можно использовать также 16 пикселей, но это не обязательно.

В процессе рисования отчета полезно проверять, что границы всех элементов совпадают с сеткой.
Если есть сомнения, или не удается задать подходящий размер мышкой, то это можно сделать через свойства элемента, раздел "Appearance".

Почему это важно для XLS?
В этом формате границы каждого элемента должны приходиться на разделитель между колонками и строками.
Если границы элементов не будут совпадать на пару пикселей, то это приведет к созданию дополнительных колонок и строк также размером в пару пикселей для выравнивания границ элементов.
Такие узкие колонки и строки затрудняют работу с таблицей и портят внешний вид отчета.
По возможности их лучше избегать.

**Пункт 4**

По умолчанию любой отчет разбивается на страницы как для печатных документов.
Если отчет будет выводиться и в страничный формат и в формат, предполагающий непрерывное отображение (XLS), то _не_ следует использовать параметр отчета "Ignore Pagination", так как после этого отчет станет одностраничным для всех форматов.

Вместо этого нужно для каждого из форматов, где не нужно постраничное разбиение, задать специальную конфигурацию через `JasperReporter.write*HardCopy`, которая визуально объединит страницы.

Например, для XLS это указание настройки:

```
conf.setCollapseRowSpan(true)
``` 

С ней из отчета будут удалены пустые строки, но удалятся не только "межстраничные" пустые строки, но и те, которые были оставлены в отчете специально.
Чтобы это не происходило, в "нужные" пустые строки можно поместить блок статического текста, в котором текст выводится белым цветом.

Пример этого подхода можно посмотреть в отчете `OpsExecEffectivenessReport`.

**Пункт 5**

Для упрощения выражений (expressions), можно глобально импортировать в отчет необходимые классы в свойствах корневого узла отчета, поле "Imports".

**Пункт 6**

Если выражение (expression) не удается записать в одно выражение или его нужно переиспользовать в отчете или отчетах, то можно использовать статические методы.
Если он может пригодиться в разных отчетах, его можно объявить в `ru.yandex.market.wms.reporter.reports.JasperFunctions`.
Но для статических функций можно использовать любой класс приложения Reporter.

**Грязный хак номер 7**

(так лучше не делать, на больших данных в jasper studio падает java heap space, в reportter-app падает 500)
Если вам нужен xls отчет с несколькими страницами (sheets), то следует в отчете указать net.sf.jasperreports.export.xls.one.page.per.sheet=true.
Для перехода на новую страницу добавляем элемент break.
Переход также будет происходить, когда на странице закончилось место.
Чтобы такого не происходило, ставим огромный размер pageHeight у элемента jasperReport, пример waste.jrxml.

### Заметки

Если требуется переделать уже существующие отчеты, созданные для движка BIRT, то удобнее анализировать их структуру при помощи специализированного дизайнера.
Его поддержка давно завершилась, но последнюю сборку для Windows/Linux/MacOS можно скачать по ссылке: http://download.eclipse.org/birt/downloads/drops/R-R1-4.8.0-201806261756/
Нужно брать файл c названием _birt-report-designer-**all-in-one**-..._
Старые отчеты лежат в папке `infor-sce/reports/custom`

Это приложение генерирует пайплайны для обновления WMS на серверах и добавляет нотификации в телеграм чаты.

Генерируются пайплайны для обновления:
* Infor (релизный и хотфиксный сценарий)
* сервисов WMS
* схем БД

## Внесение изменений в пайплайны

Структура каждого пайплайна описывается в коде, но повторяющиеся блоки в каждом пайплайне (или даже экземпляры пайплайнов) создаются на основе конфигурации.

Грубо, области внесения изменений можно разделить так:

* если открывается новый склад или изменяется текущий, то изменений вносятся в [environments.json](src/main/resources/environments.json).
Подробности о его структуре можно найти в комментариях в [EnvironmentsConfigs.java](src/main/java/ru/yandex/market/wms/pipelinebuilder/pipeline/deployment/EnvironmentsConfigs.java);
* если создается новый сервис или изменяется текущий, то изменения вносятся в [services.json](src/main/resources/services.json).
Подробности о его структуре можно найти в комментариях в [ServiceConfig.java](src/main/java/ru/yandex/market/wms/pipelinebuilder/pipeline/ServiceConfig.java);
* если нужно изменить структуру пайплайнов или их логику, то надо исправлять классы, генерирующие пайплайны.
Это различные реализации интерфейса [WmsPipelineBuilder](src/main/java/ru/yandex/market/wms/pipelinebuilder/pipeline/WmsPipelineBuilder.java).

### Внесение изменений в структуру пайплайнов

Код генераторов:
* релизный пайплайн Infor — [WmsNormalPipelineBuilder](src/main/java/ru/yandex/market/wms/pipelinebuilder/pipeline/common/WmsNormalPipelineBuilder.java);
* хотфиксный пайплайн Infor — [WmsHotfixPipelineBuilder](src/main/java/ru/yandex/market/wms/pipelinebuilder/pipeline/common/WmsHotfixPipelineBuilder.java);
* обновление схем БД — [WmsDbMigrationPipelineBuilder](src/main/java/ru/yandex/market/wms/pipelinebuilder/pipeline/dbmigration/WmsDbMigrationPipelineBuilder.java);
* пайплайн обновления сервисов WMS — [WmsPerServicePipelineBuilder](src/main/java/ru/yandex/market/wms/pipelinebuilder/pipeline/perservice/WmsPerServicePipelineBuilder.java).

Все пайплайны генерируются по приблизительно одной схеме: часть пайплайна для каждой фазы исполнения создается с отдельном одноименном методе, а внутри этого метода создаются кубики и объединяются в граф по порядку их исполнения.

Создаются кубики при помощи подобных команд, их очень много в генераторах пайплайнов:
```
PipelineJobViewModel productionStatus = builders.builder()
    .point(point)
    .upstreams(startStableJunction)
    .manuallyTriggered()
    .whenAnyCompletes()
    .model(ticketsStatusProduction())
    .buildAndBind();
```
* в `point` передается текущая координата, где должен быть кубик (про это чуть ниже), заполнять нужно всегда;
* в `upstreams` передаются предыдущие кубики (в UI это кубики, из которых потоки входят в создаваемый кубик).Заполняется у всех кубиков, кроме самого первого;
* методы `manuallyTriggered` ("гендальф" на кубике) и `whenAnyCompletes` (запуск при условии "any") не обязательные.
По умолчанию кубики запускаются, когда завершились все предыдущие.
* в `model` передается класс, описывающий то, что кубик будет делать (модель)
* `buildAndBind` создает кубик и добавляет его в пайплайн.

Создаваемые модели кубиков располагаются либо в классе `*Blocks` в том же пакете, где и редактируемый пайплайн (если модель нужна только в этом пакете) или в классе `JobModelTemplates`, если модель используется в разных пакетах. Если среди существующих моделей нет подходящей, то описание классов, которые нужно использовать, можно посмотреть в описании пайплайна после редактирования в UI.

Для управления координатами, в которых создаются кубики, используется класс CanvasPoint.
Это immutable-класс с двумя основными методами:
* `advance` — переходит к следующей позиции на один шаг вправо.
Есть версия метода, куда передается количество шагов (1 — один шаг вправо, -1 — один шаг влево);
* `slot(n)` — возвращает ячейку, смещенную по вертикали относительно текущей точки (1 — ячейка выше, -1 — ячейка ниже).

Например, нужно построить следующую структуру:
```
              +-----+
         _____|  2  |_____
+-----+ /     +-----+     \ +-----+
|  1  |/                   \|  4  |
+-----+\      +-----+      /+-----+
        \_____|  3  |_____/
              +-----+
```

Код "шагания" будет выглядеть так:
```
CanvasPoint point = ...

PipelineJobViewModel block1 = builders.builder()
    .point(point)
    ...
    .buildAndBind();

point = point.advance(); // делаем шаг вправо, теперь мы посередине между будущими блоками 2 и 3

PipelineJobViewModel block2 = builders.builder()
    .point(point.slot(1)) // создаем координату на "слот" выше. Можно брать дробные слот, например 0.5
    .upstream(block1)
    ...
    .buildAndBind();

PipelineJobViewModel block3 = builders.builder()
    .point(point.slot(-1)) // создаем координату на "слот" ниже
    .upstream(block1)
    ...
    .buildAndBind();

point = point.advance(); // еще раз шагаем вправо, к координате блока 4

PipelineJobViewModel block4 = builders.builder()
    .point(point)
    .upstream(block2, block 3)
    ...
    .buildAndBind();

```

**Важно!** У каждого кубика в пайплайне должно быть уникальное название (поле `title`).
Это нужно, чтобы при перегенерации знать, какие значения UUID кубиков исходного пайплайна привязывать в каким кубикам в новом пайплайне.
Это сокращает количество расхождений, которые отображаются при ревью изменений в UI ЦУМ.
Если названия будут дублироваться, в логе будет запись об этом, но это не приведет к ошибке.
Внимательно проверяйте лог генерации перед коммитом доработок.

## Запуск генератора

Перед запуском генератор необходимо собрать командой
```bash
ya make
```
, а потом запустить командой
```bash
./update_pipelines.sh
```

## Настройка загрузки/сохранения пайплайнов

Загрузка и сохранение пайплайнов настраивается через переменные окружения:

```bash
WMS_GEN_MODE=LOCAL ./update_pipelines.sh
```

* `WMS_GEN_MODE` — режим работы работы: `LOCAL` (по умолчанию), когда пайплайны загружаются и сохраняются в файлы, предназначенные для UI ЦУМа, и `REMOTE`, когда пайплайны загружаются и сохраняются прямо в ЦУМ через его API.
* `WMS_GEN_TSUM_TOKEN` — токен для доступа к API ЦУМ.
Необходимо указывать, если выбран режим работы `REMOTE`.
Наш токен хранится в этом секрете: https://yav.yandex-team.ru/secret/sec-01fctx2h6a00c2sgnb61qd4cg2/explore/versions
* `WMS_GEN_PIPELINE_ID` — идентификатор пайплайна, который будет генерироваться.
По умолчанию — когда переменная не задана — перегенерируются все пайплайны.
Если нужно перегенерировать только один пайплайн, нужно указать его ID в этой переменной.
Это удобно на этапе тестирования доработок в удаленном режиме, так как иначе при каждом запуске будут созданы новые версии для двух десятков пайплайнов, которые нужно будет удалять при каждой итерации.

Если генератор запускается в удаленном режиме, то результатом работы будут новые версии пайплайнов в состоянии "draft".

Для запуска в локальном режиме, требуется совершить несколько ручных операций: скачать нужные пайплайны из интерфейса просмотра пайплайна (кнопка "Export pipeline configuration"), сохранить пайплайны в папку `pipelines/current`, запустить генератор, создать новую версию пайплайна в ЦУМ, импортировать в нее сгенерированный пайплайн из папки `pipelines/updated` (кнопка "Import pipeline configuration").

## Пайплайн обновления пайплайнов

У нас есть пайплайн, который запускает перегенерацию из транка: https://tsum.yandex-team.ru/pipe/projects/wms/delivery-dashboard/wms-update-gen-pipelines

Он запускает в сэндбоксе задачу перегенерации.
После нее нужно проверить в логе задачи `log1/program.out.txt`, какие пайплайны были обновлены, проверить их в UI и активировать изменения.


## Обновление нотификаций
Обновление нотификаций реализовано через отдельное приложение NotificatonsUpdater.
Для запуска нужно установить две переменные окружения:
* `WMS_GEN_TSUM_TOKEN` — токен для доступа к API ЦУМ.
* `WMS_GEN_PIPELINE_ID` — идентификатор пайплайна, на который будут добавлены нотификации.
По умолчанию — когда переменная не задана — нотификации будут добавлены во все пайплайны.
Для запуска в локальном режиме, кроме указания переменных окружения дополнительных действий не требуется
ВНИМАНИЕ! При локальном запуске приложение ходит в продакшен ЦУМ-а, возможна перезапись настроек нотификаций.


## Запуск обновления нотификаций

Перед запуском приложение необходимо собрать командой
```bash
ya make
```
, а потом запустить командой
```bash
./update_notifications.sh
```

## Добавление нотификаций
Для добавления новой нотификации ее нужно добавить в notifications.json и конфиг NotificationsConfig.java
Чат, в который будет отправляться сообщение прописан для каждого склада в environments.json в telegramChatId.

# Инфра для прогноза эластичности (спроса на msku как функцию от "цена")

## Запуск lastic для ДЦО

Для обучения и сравнения нескольких моделей:
```
# msku elastic curve
./scripts/run_dp_validate.sh
# personal corrections to msku elastic curve
./scripts/run_person_2021-12-02.sh
```

Для обучения одной именованной production модели:
```
# msku 
./scripts/run_dp_train.sh
# person
TODO
```

Для ежедневного обновления оптимальных цен для msku (дата вычисляется внутри как `today - 2 days`):
```
./scripts/run_dp_opt_price_prod_dynamic.sh 
```

Для генерации исходных сырых таблиц (без регуляризованной кривой)

```
./scripts/run_dp_predict_1d_dynamic.sh 
```


Для генерации таблиц с регуляризированными кривыми

```
./scripts/run_dp_curves_dynamic.sh 
```


Линк на latest msku прогноз (дата, соответствующая имени директории, вычисляется внутри скрипта):
```
./script/link_latest.sh
```
или
```
./script/prod_hourly.sh
```
где больше вещей делается.

## Запуск lastic для ПРОМО

ПРОМО имеет три фиксировнных валидационных месяца.
И для каждого месяца сделана своя команда.
Для обучения и сравнения нескольких моделей:

```
./scripts/run_promo_validate_DATE.sh
```

Для обучения одной именованной production модели:
```
./scripts/run_promo_train_DATE.sh
```

Для получения прогноза от одной именованной production модели:
```
./scripts/run_promo_predict_DATE.sh
```


## Описание

Проект содержит два разных прогнозатора (два `model_type`s):
- `msku` – прогнозатор спроса msku в один день, с лагом `target_lag` относительно `forecast_date`,
    среди факторов прогнозатора последний фактор особенный – это `rel_price = price / d42_price`
  - `price` – цена в таргетный день 
  - `d42_price` – средняя цена по продажам за последние 42 дня
  Таргетная колонка с продажами называется `msku_r_target_d1_items`. 

  Отступ `target_lag` дней соответствует
  `target_date = forecast_date + (1 + target_lag) days`. 
  Дата `forecast_date` – это как бы день, когда мы делаем прогноз. Предполагается, что в логах 
  данные за `forecast_date` не актуальны, а данные за `forecast_date - 1 day` уже актуальны.
  
  Для таргета `dn_target_d1_items` отступ равен `target_lag + dn_target_lag + 1`.
  Значение _дополнительного_ отступа `dn_target_lag` в каждой строчке трейнсета задаётся "случайно", как функция от
  значения `hash(msku, forecast_date)` и принимает значения от 0 до 58.
  Имя колонки с таргетом задается опцией `--target`.

- `person` – прогнозатор поправки к спросу, который прогнозирует `msku`-прогнозатор; 
  эту поправку нужно добавлять к логарифму прогноза первого, а потом снова брать экспоненту;
  этот прогнозатор имеет на входе фичи про пользователя.
 
Проект построен как самодостаточный код, в котором есть возможность запускать графы 
  - обучения;
  - валидации (сравнения моделей, выявление лучших);
  - прогноза.

Графы берут исходные сырые данные из регулярных таблиц на YT и кладут результат на YT (сами обученные модели и прогнозы).
Используются таблицы:
  - `//home/market/production/mstat/analyst/regular/cubes_vertica/fact_new_order_item_dict_flattened`
  - `//home/market/production/mstat/dictionaries/stock_sku/1d`
  - `//home/market/production/mstat/analyst/regular/cubes_vertica/dim_ssku_flattened`
  - `//home/crypta/public/matching/by_id/puid/crypta_id`
  - `//home/market/production/monetize/dynamic_pricing/parsing/ref_prices`
  - `//home/market/production/mstat/analyst/regular/mbi/blue_prices/dco_upload_table`

Команда `validate` обучает и сравнивает несколько моделей на нескольких фолдах 
(метрики на тест-сете пишутся в таблицу `cros_val`).
Команды 
  `train`, 
  `predict`, `predict_1d`,
  `opt_price`, `opt_price_only` 

работают с  **именованными моделями**, 
имена которых задаются списком через запятую в аргументе `--predict_model`.
Для этих команд нужно ещё указывать аргумент `--predict_model_dir` – имя директории (дата),
в которой лежит или будет лежать обученная модель.
Именованные модели задаются словарем `named_model_tasks`, 
а неименованные – словарём `train_model_tasks`.
Ключом первого уровня в этих словарях является значение опции `model_type`.

## Тип ассортимента

Команды получают важный параметр `--assort_type` равный `all` (всё, что продаётся) 
или `dp` (ассортимент для ДЦО, aka dynamic pricing).

## Структура файлов

Для понимания `msku` модели и связанной с ней задачей вычисления оптимальных цен нужно посмотреть файлы
  - `lib/data_preparation/sql/build_msku_dataset.sql` – файл с YQL кодом для получения датасета для `msku`
    прогнозатора; 
    в нём используется стандартная библиотека forecast_utils/utils/sql/counters_lib.sql, а именно,
    subquery, генерирующий поток данных о продажах по заданному ключу (например, msku) 
    с информацией про цены, скидки, OOS и др. Эта библиотека поддерживается и гарантируется работоспособность 
    это библиотеки, актуальность используемых таблиц и полей;
  - `lib/data_preparation/build_msku_dataset_task.py` – нирвановская таска, которая запускает YQL выше;
  - `lib/data_preparation/train_msku_model_task.py` – нирвановская таска, способная выполнять задачи обучения, 
    валидации (сравнения разных прогнозов) и прогноза на заданные даты;
  - `lib/data_preparation/optimal_price_task.py` – нирвановская таска, создающая таблицу с оптимальными ценами
    для заданного набора msku-s. Она выполняет YQL `lib/data_preparation/sql/build_optimal_price.sql`;
  - `lib/cli.py` – файл с конфигурацией моделей для обучения, сравнения и применения.

Прогнозатор `person` устроен аналогично `msku`, только там другой target, другая loss-функция, другие фичи.

Файлы в директории `torch_lib` нужно указывать в `ya.make` как ресурсы и перечислять их в методе `import_resources`
тасок обучения и валидации. Содержимое этих файлов будет добавлено в скрипт `torch_script.py`, запускаемый 
на машине в облаке.

Таски `Train*` работают в режиме `predict`, если аргумент `train_dataset_path` пустая строка.

Отметим важную специфику текущего кода lastic:
- Одна таска для создания как train, так и prediction датасета. 
  Отработан вариант YQL тасок с несколькими результирующими таблицами.
- Одна функция для построения графа c булевыми аргументами do_create_ds, do_validate, do_train, do_predict, ... 
- Один класс для train, validate и predict и он наследует от TorchTask.
- Пути, которые подаются на вход в таски, представляют собой шаблоны, в которых может быть `{end_date}`. 
  Каждая таска получает аргумент `{end_date}` и занимается подстановкой этого аргумента в шаблон путей
  (для автоматического решения этой задачи есть готовый декоратор `format_paths`).
  Это обеспечивает простоту параметризации всего графа – нужно менять лишь один узел с именем `end_date`, 
  и его можно читать из глобальных опций графа. Сам граф чистый и не зависит от now().

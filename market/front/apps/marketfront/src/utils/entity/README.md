# Эффективная работа с объектными структурами данных

Сгруппированные данные удобнее всего хранить в простом объекте Javascript. При этом нередко возникают ситуации, что при
изменении значений свойст объекта, необходимо выполнить какое-либо дополнительное действие (или side-effect), н-р,
изменить другое значение или перерендерить шаблон.    
Современные версии стандарта Javascript позволяют обеспечить контроль над чтением свойств объекта и записью в них с
помощью конструкции Object.defineProperty() (ES5) и класса Proxy (ES6), благодаря чему современные реактивные фреймворки
(н-р, Vue) осуществляют перерендер шаблона при изменениях в данных.   
Сложное API как Object.defineProperty(), так и Proxy не дает большой гибкости и удобства для описания и
объединения всех возможных сайд-ффектов. Однако требуемую гибкость и удобство может обеспечить [паттерн проектирования
"Наблюдатель"](https://ru.wikipedia.org/wiki/Наблюдатель_(шаблон_проектирования)) Суть паттерна заключается в том, что
одни объекты бросают события, а другие объекты могут на них подписаться и среагировать так, как им нужно.   

Классы данного пакета реализованы по паттерну "Наблюдатель" и содержат дополнительную функциональность, необходимую для
упрощения взаимодействия со сложными объектами.

## Класс Observable

Это базовый класс, содержащий минимальный набор методов и свойств для реализации паттерна "Наблюдатель". Класс не
предполагает самостоятельного использования, другие классы должны быть унаследованы об Observable.

**Методы:**
* subscribe(event: string, handler: Function) - добавление обработчика handler на событие с имененем event.
* notify(event: string ...eventData: any): any - вызвать все обработчики события event с опциональной передачей параметров
eventData. Может вернуть результат, который необходимо обработать внутри объекта Observable.
* unsubscribe(event: string, handler: Function) - удаление обработчика handler на событие с именем event. Должна быть
передана та же ссылка на обработчик, что был добавлен в методе subscribe!
* unsubscribeAll(event?: string) - удаление всех обработчиков на событие eventName. Если eventName не указан, то удаляет
все обработчики. Использовать с осторожностью!
* destroy() - удаление объекта и всех связанных с ним обработчиков.

**Свойства:**
* _eventHandlers - словарь всех обработчиков событий, где ключами являются имена событий. Обработчики событий вызываются
последовательно в порядке добавления.

### Особенности работы обработчиков событий

При генерации события можно (но не обязательно) добавить параметры, обусловленные логикой данного события и упрощающие
его обработки. Например, при изменении высоты объекта можно дополнительно передать новое значение высоты. Эти параметры
передаются объектом Observable явно в аргументе eventData метода notify().
В дополнение, объект Observable, сгенерировавший событие, может ожидать какой-то результат от конечных обработчиков и
обработать его самостоятельно. Например, всплывающее окно может бросить событие с разрешением на закрытие, а
внешний код, управляющий логикой всплывающего окна, может запретить закрытие, если какие-либо данные не консистентны,
либо спросить об этом пользователя.   

При этом у события может быть произвольное количество обработчиков, а вызываются они последовательно, что может
приводить к ситуации, когда в действительности нужно получить результат от обработчика, добавленного ранее. Для этимх
целей был создан вспомогательный класс дескриптора события EventObject, объект которого передается первым параметром
в каждый обработчик события.

Таким образом, когда объект myObject типа Observable бросает событие через notify('onResize', 200), каждый обработчик
resizeHandler добавленный, через myObject.subscribe('onResize', resizeHandler) будет иметь следующую сигнатуру.
```
resizeHandler(eventObject: EventObject, height)
```
Где в height будет записано 200.   
Если конкретному обработчику нужно записать свой результат для передачи myObject, он это может сделать через
eventObject.setResult(handlerResult). Получить значение предыдущего обработчика можно через eventObject.setResult()

> **Обработчики события вызываются последовательно и должны быть синхронными!** Если вам нужна асинхронная логика, используете
Promise в eventObject.setResult().

### Класс EventObject

Обеспечивает возможность получить от конкретных обработчиклв результат, который должен обрабатываться внутри объекта
Observable.

**Методы:**
* setResult(result: any): void - сохранить результат текущего обработчика события.
* getResult(): any - получить сохраненный результат обработчика события.

**Свойства:**
* from: Observable - ссылка на объект Observable, бросивший событие. Может быть полезно, когда используется общий
обработчик для нескольких объектов.

## Класс Model

Класс, расширяющий возможности базового объекта Javascript функциональностью подписки на изменение значений свойств, а
также добавляющий вычисляемые свойства (в разработке).

**Методы:**
* get(propertyName: string): any - получить значение свойства propertyName
* set(propertyName: string, value: any) - записать значение свойства propertyName. При этом будет брошено событие
onPropertyChange

**События:**
* onPropertyChange({propertyName: string, value: any}): void - Событие об изменении свойства propertyName в модели.

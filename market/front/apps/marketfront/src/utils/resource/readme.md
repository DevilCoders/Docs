## Ресурсы

- Исторически обертку над бекендом называем "ресурсом"
- Ресурсы делятся на два типа:
  - [legacy-ресурсы](https://github.yandex-team.ru/nodules/resource).
  - bcm-ресурсы. Концептуально похожи на предыдущие.
    - Под собой используют [bcm2](https://github.yandex-team.ru/market/monomarket/tree/master/lib/lib/bcm2)
    - Под собой используют классы определенные в [mandrel](https://github.yandex-team.ru/market/monomarket/tree/master/lib/lib/mandrel/src/bcm)

## Как правильно написать bcm-ресурс

- Пример тут: `@self/root/src/resources/history`
- Пример тестов на ресурс тут: `@self/root/src/resources/history/__spec__`
- Пример тестов на резолверы, которые используют bcm-ресурс: `@self/root/src/resolvers/history/__spec__`

На что важно обратить внимание в конфиге:
- У конфига обязательно нужно указать поле `logName`
- У конфига есть необязательное поле `Backend`
  - Если тебе нужен tvm-бекенд, необходимо указать соответствующего родителя в это поле
  - По умолчанию в этом поле указан `MarketHttpBackend`

На что важно обратить внимание в схеме:
- По сравнению с ресурсами-методами, появляется обязательное поле `config`
  - В него надо прописать конфиг ресурса. Это осуществит провязку метода-клиента и бекенда (см. терминологию bcm2)
- У схемы обязательно нужно указать поле `name`


## Как правильно переезжать на bcm-ресурсы

В случае legacy-ресурса, вероятно, понадобится целиком обновить интерфейс,
нормализовать ответ бекенда, покрыть типами, написать тесты.

В случае ресурса-метода:
- В схеме метода указываем поле `config`, в которое кладем _внезапно_ конфиг ресурса
- В схеме метода обязательно указываем поле `name`, в которое пишем _внезапно_ имя метода


## Кодирование тела запроса и ответа

Важными параметрами являются:
- encodeBody - определяет как должно обработаться bcm-ом тело запроса (проставляются соответсвующие заголовки и т.д.)
- parseBody - определяет простешую предобработку ответа (влияет на заголовки accept запроса, конвертирует некоторые пришедшие данные в выбранный формат)

Также стоит обратить внимание что при выборе например формата 'raw' bcm добавит в headers.accept = 'text/html', а вы можете ожидать json. Поэтому необходимо добавить этот заголовок вручную в блоке prepare.

Для передачи файлов на сервер рекомендуется использовать модуль **form-data**. Примеры есть в `src/resources`. Для получения бинарных данных испольуется `parseBody='buffer'`.

# Фишки, плюшки

## Переопределение

- `_resource:${resourceName}=my.backend.com:8080` - переопределение хоста и порта. Работает из урла, из куки,
   и из заголовка (читай код за подробностями)
- `_resource_timeout:${resourceName}` - переопределяет timeout на бэкенд
- `_resource:${resourceName}:${methodName}:params` или `_resource:${resourceName}:params` переопределяет или добавляет
  параметры в запрос к бэкенду. Принимает JSON
- Можно переопределять куски пути. Для этого нужны настройки бекенда в config-файле. Ищи по `overrides`

## Мокирование

bcm методы можно бодро мокировать - удобно, если надо разработать ручку, бэкенд к которой еще не готов.
Для этого в конфиг прописывается кастомный BCM-бэкенд (`FakeMarketBackend`) с помощью фабрики `makeFakeMarketBackend`
из `@self/root/src/utils/resource/FakeMarketBackend`.

Возможности:
- С точки зрения мандреля-сотоварищи поход в бэк случится - его можно будет увидеть в логах
- Можно гибко настроить таймаут и время ответа, т.е. сэмулировать настоящий поход в сеть
- Можно настроить код ответа, тело ответа, заголовки в зависимости от параметров в запрос
- В зависимости от параметров можно не мокировать, а сходить в реальный бэкенд (`bypass: true`)

Как пользоваться: читай типы в `FakeMarketBackend.js`, там есть комментарии

Ограничения:
- Это не кадаврик. Никакой сессии, если только сам в замыкании не сообразишь чего-нибудь
- TVM бэкенд не поддержан. Как минимум `bypass` отомрет

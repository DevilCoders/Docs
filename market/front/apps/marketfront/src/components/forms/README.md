# Быстрое создание форм

Современные фреймворки позволяют не только удобно описывать верстку компонентов, но и декларативно привязывать данные
к ней. Чем декларативнее код, тем проще его понимать, писать, подерживать и расширять.   
Стандартные формы на заре Javascript следуют этому декларативному подходу, т.к. разработчику было достаточно добавить атрибуты name на элементы типа input и select, а непосредственно отправка формы выполнялась стандартными средствами браузера.
Однако затем появился AJAX, значительно возрос функционал Web-страниц и повысились требования к UI.   

Современные формы в крайне редких случаях состоят только из нативных браузерных элементов типа input и select,
намного чаще используются компоненты фреймворка, которые под капотом могут содержать (или нет) нативные input и select
и имеют более сложные со стороны технической реализации UI и логику. При этом концептуально механизм отправки формы не изменился - необходимо получить объект с данными формы и отправить его на сервер по нужному URL.   

Чтобы декларативно разрабатывать формы на компонентах, необходимо иметь следующее:
1. единый объект с данными формы.
2. компоненты полей ввода.
3. механизм биндинга (привязки) свойств объекта данных формы к полям ввода.
4. механизм валидации значений.

Рассмотрим отдельно каждое из этих составляющих.

**1. Единый объект с данными формы**

В качестве такого объекта может выступать обычный объект Javascript. Такой объект удобен для чтения и записи значений,
но лишен возможности отслеживать изменения. Для отслеживания можно использовать существующие в Javascript возможности
виде Object.defineProperty() или класс Proxy, а можно воспользоваться реализацией паттерна "Наблюдатель".
Такой реализацией является src/entity/Model, которое бросает событие onPropertyChange при каждом изменении свойства.
Подробности - в соответствующем README.md

**2. Компоненты полей ввода**

Существует множество видов полей ввода разной степени сложности: 
* простое поле ввода, работает с простым текстом. Тип значения: string
* более специфичное поле ввода, работает с датами, числами, номером телефона и т.д. Тип значения: string, Date, number
и т.д.
* чекбокс. Тип значения: boolean.
* комбобокс с выпадающим списком. Тип значения: {id: number, displayName: string} и множество производных
* саджест (suggest), активно взаимодействующий с бекендом по мере того, как пользователь вводит что-либо.
Тип значения: {id: number, displayName: string} и множество производных, в зависимости от логики саджеста.

Как видно выше, разные поля ввода имеют разную настройку и работают с разными типами данных, но можно организовать их
API таким образом, чтобы имена общих опций (пропсов) и событий совпадали (н-р, опция value и событие valueChanged со
значением в поле ввода), а специфичная настройка каждого из них передавалась отдельно. Такой подход позволит упросить
механизм биндинга (привязки) данных в полях ввода к объекту данных формы для отправки на бекенд.

**3. Механизм биндинга (привязки) данных**

Каждое из полей ввода реализует единое API в виде опции value и события valueChanged, а единый объект данных Model также
умеет сообщать об изменениях значений свойств через событие onPropertyChange. Поэтому для биндинга значения свойства
в Model к полю ввода достаточно:
1. Знать, с каким свойством модели работает поле ввода.
2. Слушать событие с поля ввода и менять соответствующее значение в модели. И наоборот, т.к. нередко возникают ситуации,
когда на форме присутствует несколько связанных между собой полей ввода. При наличии единого источника правды в виде
модели организовать такую связь проще.

Реализовать подобный механизм биндинга можно с помощью компонента-обертки над компонентом поля ввода, который получит
ссылку на модель и внутри себя инкапсулирует логику привязки, передавая новое значение опции value в компонент поля
ввода при изменениях в модели и устанавливая новое значение свойства в модели при получении события от поля ввода.

**4. Механизм валидации**

Во многих сценариях необходимо проверить введенные пользователем значения на корректность. Например, что стоит галочка
напротив "Соглашения об обработке персональных данных", или введенная пользователем дата попадает в нужный промежуток.
Сделать это можно в разное время: сразу после того, как пользователь убрал фокус с поля ввода или только когда он нажал
на общую кнопку отправки формы. При этом список валидаций при отправки может быть шире, чем суммарный список валидаций
над всеми полями ввода, и дублировать валидации кажется не совсем правильным подходом.

Чтобы реализовать такой расширямый механизм валидации над каждым из полей ввода + дополнительные валидации при отправке,
можно также создать компонент-обертку над каждым из компонентов полей ввода, который будет запускать валидации при
получении события valueChanged. По окончании валидации компоненту будет передана опция validationStatus, которая будет
его подсвечивать нужным образом. Также необходимо отобразить сообщение об ошибке errorText, и эта логика уже может быть
включена как в сам компонент поля ввода, так и в валидирующем компоненте-обертке.

Для исключения дублирования валидации при отправке, а также не запуск отправки при невалидных данных должен отвечать
отдельный компонент - контроллер всей формы, который сможет внутри себя зарегистрировать все валидации по каждому из
полей ввода, а также позволит добавить валидации из внешнего кода, не связанными напрямую с компонентами полей ввода.
Данный контроллер также будет получать ссылку на модель, которую передаст вниз всем компонентам-оберткам над полями
ввода для обеспечения биндинга.

**Итог**

Все рассмотренные выше элементы позволят быстро разрабатывать новые и расширять существующие формы декларативным для
конечного разработчика способом, т.к. ему будет достаточно создать модель данных и организовать иерархию из
предоставляемых компонентов-оберток и контроллеров вида

```jsx
<FormController
    model={myModel} {/** Инстанс /src/entity/Model */}
    onSubmit={(model) => { /** Вызов метода отправки данных из Model, валидация гарантированно пройдена */ }}
>
    {({isSubmitting}) => ( /** Чтобы сделать элементы неактивными во время отправки формы */
        <Form> {/** Тег <form> с обработчиком onSubmit из FormController */}
            <FormFieldWrapper
                field="firstName" {/** Поля в модели для привязки */}
                Component={TextField} {/** Компонент поля ввода, реализующий API */}
                componentProps={{size: 'm'}} {/** Любые опции конкретного компонента, не связанные с API*/}
                validators={[isRequired, cyrylicOnly]} {/** Список валидаторов над полем ввода */}
            />
            <div className="row"> {/** Добавим красивой вестки */}
                <div className="col-xs-12 col-md-6">
                    <FormFieldWrapper
                        field="address" {/** Поля в модели для привязки */}
                        Component={GeoSuggestWrapper} {/** Обертка над компонентом GeoSuggest, реализуюшая API. */}
                        componentProps={{address: 'https://ya.ru/geo'}} {/** Любые опции конкретного компонента, не связанные с API*/}
                        validators={[isRequired]} {/** Список валидаторов над полем ввода */}
                    />
                </div>
                <div className="col-xs-12 col-md-6">
                    {/** Остальные поля ввода */}
                </div>
            </div>

            <Button
                type="submit" {/** Вызов метода onSubmit по клику */}
                variant="action"
                width="full"
                size="l"
                state={isSubmitting ? 'pending' : 'normal'} {/** Блокируем кнопку при запущенной отправке */}
            >
                Оправить
            </Button>
        </Form>
    )}
</FormController>
```

Как видно из примера выше, внутренняя верстка формы может быть любой сложности, т.к. контракты между
компонентами-обертками и контейнерами регламентируют только взаимодействие на уровне данных.

## Реализация

Большинство необходимых абстракций было наглядно проиллюстрировано в примере выше. Отсутствует лишь компонент-обертка
для валидации, т.к. она находится внутри компонента-обертки FormFieldWrapper.

### Компонент FormController

Ядро формы, получает ссылку на объект модели и обеспечивает связь между остальными компонентами.

**Пропсы:**
* model - инстанс /src/entity/Model с данными формы. Должен быть создан во внешнем коде, который интегрирует форму.
* onSubmit: () => Promise<void> - колбек на отправку данных формы. Срабатывает только если пройдена валидация.
* children: (params: ParamsFromController) => React$Node - верстка формы с компонентами-обертками над полями ввода.
Объект ParamsFromController пока содержит едиственное свойство isSubmitting, означающее, что в данный момент выполняется
отправка формы

**Методы:**
* registerValidationController(controller: ValidationController) - регистрация контроллера валидации,
который будет вызван при каждой полной валидации формы (н-р при отправке). ValidationController - интерфейс, имеющий
единственный метод validate(): boolean.
* unregisterValidationController(controller: ValidationController) - удаление зарегистрированного контроллера валидации.
* validate(): boolean - запуск полной валидации формы (всех контроллеров валидации)
* submit(): Promise<boolean> - отправка формы на бекенд. Если валидация не пройдена, вернет Promise.resolve(false);

### Класс контекста FormContext

Объект FormController также создает соственный контекст React.Context для того, чтобы вложенные компоненты получали
нужные данные из него без необходимости их явной передачи со стороны прикладного разработчика.

**Значения в контексте**
* model: Model<T> - инстанс модели
* registerValidationController: (controller: ValidationController) => void - регистрация контроллера валидации для поля
ввода.
* unregisterValidationController: (controller: ValidationController) => void - удаление контроллера валидации для поля
ввода. Н-р, при удалении компонента из верстки.
* onSubmit: (event: SyntheticEvent<HTMLFormElement>) => Promise<boolean> - обработчик события отправки формы, то же
самое, что и formController.submit()

### Компонент Form

Отображает тег <form>, которому добавляет обработчик onSubmit из FormContext.Consumer. Содержит проп
children: React$ChildrenArray для отображения произвольной верстки самой формы.

### API компонента поля ввода

Для корректной работы валидации компонент поля ввода должен подерживать следующие пропсы API-контракта.

* value?: any - установка значения в поле ввода
* onChange: ?(value: any) => void - обработчик события изменения значения в поле ввода
* onBlur?: (event: SyntheticFocusEvent<HTMLInputElement>) => void - обработчик ухода фокуса с поля ввода, при котором
запускается валидация.
* state?: ValidationState - состояние валидации компонента, принимает значения 'normal' (валидация не запущена),
'error' (валидация не пройдена), 'complete' (валидация пройдена)
* error?: Node - произвольная ошибка валидации, которую необходимо отобразить. Я бы исключил из API компонента такую
функциональность и вынес бы ее внутрь ValidationWrapper, но т.к. она уже существовала, то не хотелось ее реализовывать
заново.

Это обязательный набор пропсов, которые должен поддерживать каждый компонент поля ввода. При этом компоненты могут
иметь и другие пропсы, передача значений которых проксируется. Если нужный вам компонент имеет отличающееся API, то
создайте обертку над ним, поддерживающую данное API.

### Компонент ValidationWrapper

Компонент-обертка над полем ввода, который добавляет возможность валидации оборачиваемому полю ввода, поддерживающему
API. Компонент ValidationWrapper подписывается на событие onBlur поля ввода и запускает валидацию через метод
validate().

**Пропсы:**
* Component: React$ComponentType<ComponentProps> - компонент, поддерживающий API
* componentProps?: $Shape<{}> - пропсы компонента поля ввода, не являющиеся частью API. Проксируются вниз до поля ввода.
* validators?: ValidateFunction[] - список функций-валидаторов
* value: any - значение в поле ввода
* onChange?: (value: any) => void - обработчик события изменения значения в поле ввода

**Методы:**
* validate(): boolean - запустить валидацию значения в поле ввода.

### Типы ValidateFunction и ValidationError

ValidationFunction - функция, которая принимает в аргументах value и:
* Если валидация успешная, то ничего не возвращает (void)
* Если валидация неуспешная, возвращает объект ValidationError

**Структура ValidationError:**
* message - сообщение об ошибке, выводимое пользователю
* code - код ошибки

### Компонент ModelFieldWrapper

Компонент-обертка над ValidationWrapper, который обеспечивает биндинг между свойством модели и значением в поле ввода с
помощью механизма подписки на изменение свойств модели.

**Пропсы:**
* model: Model<M> - инстанс модели
* field: string - свойство в модели
* Component: React$ComponentType<ComponentProps> - компонент, поддерживающий API
* componentProps?: $Shape<{}> - пропсы компонента поля ввода, не являющиеся частью API. Проксируются вниз.
* validators?: ValidateFunction[] - список функций-валидаторов

**Методы:**
* validate(): boolean - запустить валидацию значения в поле ввода.

### Компонент FormFieldWrapper

Компонент-обертка над ModelFieldWrapper, который получает модель из FormContext.Consumer и передает ее в
ModelFieldWrapper. Также регистрирует вложенный инстанс ModelFieldWrapper в качестве контроллера валидации в
FormController, что происходит благодаря наличию колбеков registerValidationController и unregisterValidationController
в FormContext.Consumer

**Пропсы:**
* field: string - свойство в модели
* Component: React$ComponentType<ComponentProps> - компонент, поддерживающий API
* componentProps?: $Shape<{}> - пропсы компонента поля ввода, не являющиеся частью API. Проксируются вниз.
* validators?: ValidateFunction[] - список функций-валидаторов

# Определяемся с моками

Для того, чтобы написать кадавризированный тест, необходимо вначале понять, какие моки следует для него написать.

Для этого:

1. Запустить приложение с использованием Кадаврика - (см [здесь](https://docs.yandex-team.ru/marketfront/test/kadavrique/running-tests)).
2. Если необходимо переписать существующий тест - выполнить его в боевом или тестовом окружении. Если предполагается создание нового теста, следует вручную воспроизвести шаги из кейса на своей рабочей копии приложения.
3. Проанализировать логи приложения и Кадаврика. Составить список запросов к бекендам, от которых зависит успешное выполнение автотеста.
4. Полученный список, сгруппированный по бекендам, поможет узнать, какие моки их подменяют. Реализации моков находятся в репозитории Кадаврика ([здесь](https://a.yandex-team.ru/arcadia/market/front/apps/kadavrique/mocks) и [здесь](https://a.yandex-team.ru/arcadia/market/front/apps/kadavrique/src/mocks)). Скорее всего, имена моков будут соответствовать ресурсным. Если нужного мока нет, его нужно будет реализовать.

## Анализ работы бекендов для написания мока

В кадаврике есть несколько фич, которые могут помочь проанализировать работу теста и бекендов.

### Метрики по хождению в бекенды

Существует [таблица](https://yql.yandex-team.ru/Operations/629e34ecbab7930595e9d9e9) хождений в бекенды в рамках выполнения e2e тестов:

**testId** - идентификатор теста.

**testName** - название теста (сейчас не заполняется).

**backendHost**, **path** - информация о бекенде, в который тест идет через Кадаврик.

**mock** - класс мока, который был использован (может быть пустым, если Кадаврик не нашел мок).

**mockMethod** - метод класса мока, который был использован (может быть пустым, если Кадаврик не нашел мок).

**isProxied** - true, если запрос был спроксирован в реальный бекенд.

**success** - успешно ли был спроксирован запрос.

Применений у данной таблицы много:

- найти фейлящиеся бекенды.
- найти тесты, которые ходят в нужный бекенд.
- найти фейлящиеся бекенды в рамках какого-то скоупа тестов.
- и т.д.

### Логгирование информации о незамоканных бекендах в Кадаврике на логрусе

Чтобы не искать информацию напрямую в логах приложения, в Кадаврике есть возможность включить режим логгирования бекендов. В данном режиме информация по каждому запросу в реальный бекенд будет сохранена в директории приложения. Что нужно сделать:

1. Запустить на логрусе Кадаврик с env переменными `kadavr_block_network=false kadavr_trace_backends=true`. Например сделать:
    ```
    export kadavr_block_network=false
    export kadavr_trace_backends=true
    ```
2. Запустить [тесты как обычно](https://docs.yandex-team.ru/marketfront/test/kadavrique/running-tests), указав в качестве Кадаврика запущенный на логрусе.
3. В директории Кадаврика на логрусе появится папка backendTraces.

Пример содержимого:

```
├── bluemarket-2797 // id теста
│   ├── marketfront.s3.mdst.yandex.net // хост незамоканного бекенда
│   │   ├── GET__daily_bonuses_promo_feature_config.json // HTTP метод и путь
│   │   │   └── 56279429-c412-4415-be63-41d385340bfb // uid вызова метода (просто для названия папки)
│   │   │       ├── request_info.txt
│   │   │       ├── response_info.txt
│   │   │       └── response.interface.ts
│   │   ├── GET__promo_flash.json
│   │   │   └── 248ec2a3-c485-44c5-b436-c771acba1645
│   │   │       ├── request_info.txt
│   │   │       ├── response_info.txt
│   │   │       └── response.interface.ts
│   │   └── GET__referralProgramConfig_data.json
│   │       └── 372fa113-0100-4811-a1ae-b523f7c5431c
│   │           ├── request_info.txt
│   │           ├── response_info.txt
│   │           └── response.interface.ts
│   └── pers-author.tst.vs.market.yandex.net
│       └── GET__expertise_dictionary
│           └── e9e66a49-0215-495d-b9ac-d7c75e06cb28
│               ├── request_info.txt
│               ├── response_info.txt
│               └── response.interface.ts
...
```

**request_info.txt**, **response_info** - информация о запросе и ответе соответственно
**response.interface.ts** - сгенерированный интерфейс респонса бекенда. 1 в 1 использовать в новом моке его скорее всего не получится, но как отправная точка для анализа бекенда и написания мока, может помочь.

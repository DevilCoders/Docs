# Тесты с использованием testing-library

Мы пишем тесты имитирующие поведение пользователя, поэтому для написания тестов мы игнорируем разметку возвращаемую `apiaryLayer` при маунте виджета и используем `screen` из testing-library, выбирая элементы через `screen.getByText(...)` и тд.

Тот факт, что мы хотим имитировать поведение пользователя, значит что мы не пишем тесты на детали имплементации. Под деталями имплементации подразумеваются пейдж обжекты, классы и прочее. Мы пишем тесты подобно тому как пользователи взаимодействуют с интерфейсом, такие тесты более стабильны, надежны и дают больше уверенности.

## Надежные DOM селекторы

`testing-library` предоставляет [3 вида селекторов](https://testing-library.com/docs/queries/about):
1. `getBy*` - возвращает найденный элемент. Бросает ошибку если элемент не был найден или на странице больше одного элемента. Этот тип запросов используется в большинстве случаев.
   ```js
   expect(screen.getByRole('button', {name: /принять/i})).toBeInTheDocument()
   ```
1. `queryBy*` - возвращает первый найденный элемент. Не бросает ошибку, если ничего не нашлось. Используем только для проверок на отсутствие/скрытие.
   ```js
   // Некорректно
   expect(screen.queryByRole('button', {name: /принять/i})).toBeInTheDocument()

   // ✅ Правильно
   expect(screen.getByRole('button', {name: /принять/i})).toBeInTheDocument()
   expect(screen.queryByRole('button', {name: /принять/i})).not.toBeInTheDocument()
   ```
1. `findBy*` - возвращает промис, который резолвится с найденным элементом или реджектится, если ничего не нашлось.

   Используется в случаях, когда мы хотим дождаться появления элемента на странице.
   ```js
   // Некорректно
   const submitButton = await waitFor(() =>
      screen.getByRole('button', {name: /принять/i})
   );

   // ✅ Правильно, `findBy*` селекторы принимают те же параметры, что и `waitFor`.
   const submitButton = await screen.findByRole('button', {name: /принять/i})
   ```
1. `getAllBy*`, `queryAllBy*`, `findAllBy*` - то же самое, что выше, но возвращают все найденные элементы.

## Приоритеты селекторов

1. `getByRole` в большинстве случаев мы используем именно его (или соответствующих `queryByRole`, `findByRole`). У большинства элементов должна быть роль. Если этой роли нет, но элемент не является простым текстом, то стоит эту роль добавить и тем самым улучшить доступность виджета.
1. `getByText` - используется для текстовых элементов, у которых нет роли (дивы, спаны, параграфы).
1. `getByTestId` - используется в редких случаях, только если у нас нет роли и мы не можем выбрать по тексту (например когда текст динамичный).
1. `getByLabelText` `getByPlaceholderText` могут использоваться для форм/инпутов.

Бывают случаи, когда нужно проверить элементы с учётом вложенности, для этого существует утилита [within](https://testing-library.com/docs/dom-testing-library/api-within/).

Тут выделены основные применения селекторов DOM элементов, для полного референса используем [документацию](https://testing-library.com/docs/queries/about#priority).

{% note info %}

Если не получается выбрать элемент с `*byRole` селектором, то вероятно ваш компонент не выполняет требования доступности. Постарайтесь сделать его доступным для всех пользователей. Ссылки как сделать компонент доступным в конце страницы, включают практики для тултипов, попапов и других элементов.

Если возникают сомнения - то приходите в [accessibility чат маркета](https://t.me/+A8ajv95-hLljODky), где делятся опытом разработчики как маркета, так и других сервисов яндекса.

Переезд тестов с гермионы - отличная возможность улучшать доступность там, где она хромает.

{% endnote %}

## Имитация действий пользователя

Пара примеров и советов как вызывать события. [Документация](https://testing-library.com/docs/dom-testing-library/api-events).

```js
// событие скролл
fireEvent(
    window,
    new Event('scroll')
);

// событие тач
fireEvent.touchStart(rating, {
    touches: [{pageX: 250}]
})
```

Каждое событие - это сайд эффект, мы не оборачиваем сайд эффекты в `waitFor`, потому что коллбэк в `waitFor` предназначен для проверок которые имеют задержку (например, появление тултипа) и коллбэк параметр может быть вызван несколько раз.
```js
// Неправильно
await waitFor(() => {
  // пока мы ждём обновления списка, этот коллбэк, а вместе с ним и `fireEvent`
  // могут быть вызваны несколько раз
  fireEvent.keyDown(input, {key: 'ArrowDown'})
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})

// ✅
fireEvent.keyDown(input, {key: 'ArrowDown'})
await waitFor(() => {
  expect(screen.getAllByRole('listitem')).toHaveLength(3)
})
```

Если видите ошибку, `not wrapped in act(...)` - то не стоит сразу оборачивать вызов fireEvent, потому что внутри либы он уже обёрнут в act. Стоит разобраться, вероятно в тесте может быть что-то неочевидное, у автора testing-library есть [отдельный пост](https://kentcdodds.com/blog/fix-the-not-wrapped-in-act-warning) с решением этой проблемы.



## Избегаем тестирования деталей имплементации
### Уходим от `pageObject`'ов
`pageObject` являются деталями имплементации и приносят пользу только в контексте гермионы. Условно, у нас был следующий компонент:
```
OrderCardWithInfo
    __pageObject
        index.js
    index.js
```

Мы его разделили на два, при этом генерируемая разметка осталась прежней
```
OrderCard/
    index.js
OrderInfo/
    index.js
```
Результат: тест падает, хотя пользователь продолжает корректно видеть/слышать информацию.

_Как сделать лучше:_ не создаём пейдж обжект, а пишем тест подобно тому, как пользователь взаимодействует с интерфейсом, выбирая элементы по их роли на странице или по тексту.
```js
// ✅
it("Кнопка Подробности должна быть доступна", () => {
    expect(screen.getByRole("button", {name: /подробнее о заказе/i})).toBeInTheDocument();
});

// ✅
it("Заголовок заказа должен быть доступен", () => {
    expect(screen.getByRole("heading", {name: /заказ оформлен/i})).toBeInTheDocument()
});

// ✅
it("Информация о кешбэке должна быть доступна", async () => {
    // Текст подгружается после маунта виджета, и появляется не сразу.
    await screen.findByText(/Начислено 120 баллов/i);
});
```
### В тестах не используем классы, атрибуты, а утилизируем методы из jest-dom.
Допустим у нас есть разметка, видимость которого регулируется через класс "opened/close".
```html
<div className="opened | closed">Содержание тултипа</div>
<button onClick={handleClick}>Подробнее</button>
```
Тесты на это можно написать двумя способами:
```js
describe('Тултип', () => {
    const questionMarkIconButtonToHoverOn = screen.getByRole('button', {name: /подробнее/i});

    // ❌ Некорректно, ненадёжный тест завязан только на класс
    it("Тултип должен появляться по наведению", () => {
        fireEvent.mouseOver(questionMarkIconButtonToHoverOn);
        await waitFor(() => {
            expect(content).toHaveClassName('opened');
        });
    });

    // ✅ Правильно
    it("Тултип должен появляться по наведению", () => {
        fireEvent.mouseOver(questionMarkIconButtonToHoverOn);
        await waitFor(() => expect(screen.getByRole('tooltip')).toBeVisible());
    });
    it("Тултип должен скрываться по наведению", () => {
        fireEvent.mouseOver(questionMarkIconButtonToHoverOn);
        await waitFor(() => expect(screen.getByRole('tooltip')).not.toBeVisible());
    });
})
```
Тест в котором тестируются только классы пропустит баг, если мы условно добавим `display: none` на атрибуты DOM узла или в стили. Поэтому используем метод [toBeVisible](https://github.com/testing-library/jest-dom#tobevisible), который тестирует на видимость как стили, так и атрибуты. С другими подобными методами стоит ознакомиться в документации `jest-dom` [по ссылке](https://github.com/testing-library/jest-dom)).

## Дебаг
При вызове `screen.logTestingPlaygroundURL()` внутри своего теста кейса, библиотека сгенерирует ссылку на плейграунд с разметкой всего виджета. Там можно будет подебажить и попробовать селекторы. Так есть подсказки с выбором корректного селектора и подсказки по пользовательским событиям.

Если того, на что мы пишем тесты ещё нет в продакшне и это NDA, то используем `screen.debug()`, который логирует разметку в консоль.

Так же существуют [расширения для браузера](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano/related), которые помогают выбрать правильный селектор из элементов на странице в браузере.

`testing-library` так же выдаёт список доступных элементов, если селектор ничего не нашёл по запросу. Там можно увидеть элементы с их ролями/названиями в виджете:
```
Here are the accessible roles:

heading:
Name "Итого":
<h3 class="totalPriceText" />

--------------------------------------------------
button:
Name "Доставка не выбрана":
<div
  class="clickable"
  role="button"
  tabindex="0"
/>
```

## Полезные ссылки
* [Список самых распространённых ошибок](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library) в использовании testing-library от автора библиотеки.
* Краткие описания a11y ролей [MDN](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles).
* [Основные паттерны и практики](https://www.w3.org/WAI/ARIA/apg/patterns/) по доступности, например [попап](https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/). Здесь так же то, как компоненты должны вести себя при навигации с клавиатуры.
* Полная спецификация по доступности [WAI-ARIA](https://w3c.github.io/aria/).



# Расширенный гид

Этот раздел помогает построить выдачу с нуля.

## Apiary — это бойлерплейт

Каждого разработчика фронта на старте встречают тренировочным заданием. Каноничное решение этой задачи было [рассказано на техновстрече](https://wiki.yandex-team.ru/market/frontend/meetings/log/2021-q2/#apiari-jetoprobojjlerplejjt).

В концепции Apiary каждый виджет является независимым от остальных и от окружения. Тем не менее виджеты большой системы хочется уметь синхронизировать. Для этого на фронте создается служебная коллекция `VisibleSearchResult`/`CartState`/`GeoState`, которая является единой точкой правды для всех виджетов. Так как все виджеты подписаны на redux-стор, они слушают изменения этой и внутренних коллекций, реагируют и обновляются. При этом `VisibleSearchResultId` нужен именно для подписки на конкретную выдачу на странице.

При этом сами виджеты данные выдачи не хранят. Они знают только ссылку на свой `StateId`.

Подробнее о таком подходе можно послушать в докладе "Apiary — это бойлерплейт".

## Фильтры

С точки зрения Репорта есть два типа фильтров: мбошные и репортовые. Других нет, а эту пару они преобразуют к итоговому виду. И этот итоговый вид используется Репортом везде: поисковые фильтры ("суть агрегат над свойствами офферов выдачи"), "фильтры" (свойства) офферов, "фильтры" моделек, карта переходов (JumpTable) sku.

Наконец, фильтры в "непожатом" виде занимают очень много места. Это хочется оптимизировать.

На фронте фильтры разделены на три части-сущности:
- **Filter** — описательная часть фильтра, его тип название и id. Для всех вариаций фильтров эта часть является общей. При нормализации она должна схлопнуться.
- **FilterValue** — значение фильтра. id-шник, собственно значение и лейбл для значения.
- **FilterToValue** — сущность в которой хранится маппинг, какой фильтр находится в каком значении/значениях.

Важно понимать, что то, какое значение фильтра выбрано внутри фильтра не принадлежит фильтру. Это характеристика выдачи или оффера/sku в случае jumpTable. Более того, даже набор значений может варьироваться от выдачи к выдаче. Соответственно, в эту сущность попадет список возможных значений фильтров, выбранные значения фильтра, группировки значений и прочее с привязкой к конкретной сущности (visibleSearchResult, offer, sku).

В дополнение, необходимо учитывать, что существует несколько типов фильтров. Тут происходит сознательный отказ от типов Репорта, потому что они содержат слишком много нюансов и неточностей. Все фильтр сведены к четырем фронтовым типам: Enum, Boolean, Radio, Range. JumpTable целиком укладывается в тип Enum.

## Поиск и данные

Выдача фронтенда — это интерфейс для взаимодействия с выдачей бэкенда (Репорт), а тот, в свою очередь, является интерфейсом для данных в MBO. Функционирование поиска, фильтрации, сортировок, пагинации — это роль Репорта. Роль фронта — лишь отобразить информацию.

Все сложные подсчеты, перестановки, сортировки и группировки выполняются на стороне Репорта. Однако исторически так сложилось, что подсчет заголовка страница или дедупликация данных выполняется частично или полностью на стороне фронтенда. Это дорогая ошибка проектирования.

Репорт может ответить на запрос фронтенда либо товарами, либо ссылкой на редирект. Таким образом Репорт сам определяет, является ли текстовый запрос "красный" запросом по тексту, или запросом в категории ("смартфон" редиректит в категорию "Мобильные телефоны").

## Пустая выдача

Если запрос для поиска был не просто неточным, но не нашлось вообще ничего (например, по запросу "zzzzzzzzz"), Репорт ответит фронту, что ничего не найдено. Тогда фронт сообщает: "Ничего не найдено по запросу", и показывает рекомендации.

## Мультисерч

Была такая фича выдачи: мультикатегорийный поиск. Не стоит путать его с поиском по нескольким категориям, как, например, запрос "черное платье".

Мультисерч — это поиск по нескольким категориям, хидам (`hid`, `CategoryId`). Без текста. То есть это как обычный сценарий поиска внутри категории, только в нескольких.

Попасть на такую выдачу из строки поиска нельзя. Можно было попасть из `yandex.ru`, а [можно из промо-страниц](https://market.yandex.ru/promo/skidki-po-promokodu?utm_source_service=web&clid=703&src_pof=703&icookie=XT7cqLK6pvvxSfSbOZTSDkYPaDpNY6s%2Bzljb160vFbfNgSY9SosoT9RyzrC0WvWtrmlp8BFCsIDDHydSMYUms%2FqvaFo%3D&baobab_event_id=kveaec0vsx).

Мультисерч было очень тяжело поддерживать, из-за него постоянно возникали условные конструкции. А заходило на такую выдачу всего 10 тысяч человек к месяц. Если сейчас попробовать перейти на мультисерч, произойдет редирект на обычную выдачу в общей категории ([пример](https://market.yandex.ru/multisearch?hid=237418&hid=90580&hid=90581&hid=237420&hid=90584&hid=15450081&hid=765280&hid=90588&hid=90595&hid=4954975&hid=90591&hid=14137194&hid=90589&hid=90586&use-default-offers=1&promo-type=promo-code&onstock=1&local-offers-first=0), [еще пример](https://market.yandex.ru/multisearch?glfilter=7893318%3A6468830%20&cpa=1&hid=91662&hid=91651&hid=15221861&hid=91650&hid=6038878&hid=91650&onstock=0&local-offers-first=0)).

## Результаты поиска и количество сниппетов

Центральный виджет выдачи — результаты поиска (`SearchSerp` или `SearchResults`). В качестве результатов Репорт может вернуть различные типы объектов, а именно:
- `product`,
- `offer`,
- `sku`,
- `adultWarning`,
- `regionalDelimiter`,
- `materialEntrypoint`,
- и другие.

Каждый из типов ответа выдача фронта умеет отображать по-разному. Поэтому задача нарисовать результаты поиска такая сложная.

По-умолчанию в десктопе страничная выдача отображает 48 сниппетов, в то время как выдача на промо-страницах — 24 сниппета.

В таче страничная выдача — 8, промо — 12.

## SearchMode и ViewType

У каждой выдачи есть свой `SearchMode`:

```js
export const GRID: ‘grid’ = ‘grid’;
export const LIST: ‘list’ = ‘list’;
export const YANDEX_GO: ‘yandex-go’ = ‘yandex-go’;

export const MODES = /* ::Object.freeze(*/{
    GRID,
    LIST,
    YANDEX_GO,
}/* ::);*/;

export type Mode = $Values<typeof MODES>;
```

Дефолтными значениями являются `GRID` либо `LIST`, которые соответствуют начальному виду отображения выдачи (`ViewType`) - `grid` или `list`. Другие значения SearchMode (например, `YANDEX_GO`) являются кастомными и определяются отдельно при возникновении такой необходимости.

`ViewType` же имеет фиксированный и неизменяемый набор значений:
```js
export const VIEWTYPE= {
    GRID: 'grid',
    LIST: 'list',
};

export type ViewType = $Values<typeof VIEWTYPE>;
```
Этот набор зафиксирован, так как его значения - это значения параметра `viewtype` с которым мы ходим в репорт при запросе выдачи.

`SearchMode` и `ViewType` при начальной инициализации связаны между собой прямым отображением:
```js
export const SEARCH_MODE_TO_VIEW_TYPE = {
    [MODES.LIST]: VIEWTYPE.LIST,
    [MODES.GRID]: VIEWTYPE.GRID,
    [MODES.YANDEX_GO]: VIEWTYPE.LIST,
};
```

Так как имена `SearchMode` (GRID/LIST) и `ViewType` (GRID/LIST) - совпадают и между ними есть прямое соответствие (в начале) - возникает некоторая путаница, и ошибочно можно подумать, что это одно и тоже (т.е `SearchMode === ViewType`), но это не так! И вот почему:

SearchMode связан не только с видом отобржаения выдачи (`ViewType`), но и еще с конфигом сниппета на этой выдаче  и некоторыми дополнительными данными, все это инкапсулируется под `MODE_CONFIG’ом`:

```js
export const MODE_CONFIG: {[Mode]: ModeConfig} = {
    [GRID]: {
        gridSize: 4,
        snippetConfig: DEFAULT_SNIPPET_CONFIG,
    },
    [LIST]: {
        gridSize: 1,
        snippetConfig: {
            ...DEFAULT_SNIPPET_CONFIG,
            theme: 'siete',
        },
    },
    [YANDEX_GO]: {
        gridSize: 1,
        snippetConfig: {
            ...YANDEX_GO_SNIPPET_CONFIG,
        },
        listRoute: {pageId: PAGE_IDS_YANDEX_GO.SEARCH},
    },
};
```

Отсюда получается, что `SearchMode` - это комбинация `ViewType` (гридовая или листовая выдача, при этом вид может быть изменен с помощью интерфейса на клиенте) + `ModeConfig` (конфиг сниппета, постоянен и неизменен за все. время сесси).  И все это знание о том, какому `SearchMode` соответствует текуущая выдача и какой `ViewType` сейчас активен находится внутри`SearchView`:
```js
export type SearchView = {
    id: SearchViewId,
    searchMode: Mode,
    viewtype: ViewType,
    // and other fields...
};
```

Поэтому, если пользователь с клиента руками меняет вид выдачи, например, с листа на грид - то должно обновиться поле `viewtype: ViewType` внутри `SearchView`, а сам `searchMode: Mode` обязан остаться неизменным

## Врезки и Блендер

Кроме отдельных товаров среди результатов поиска могут отображаться сложные сущности: реклама, статьи и другие. Это более сложные сущности относительно остальных (далее "врезки"). Для удобного управления такими сущностями был придуман механизм — Блендер.

Блендер — это микросервис, отвечает за работу с врезками. Блендер определяет, какие врезки и на каких позициях показывать (факторы для принятия решений могут быть разными). Результат ответа Блендера — ответ Репорта с подмешенными врезками.

![Врезки в ответе репорта](./_assets/blender-in-report-response.png)

Особенности врезок:
- Могут располагаться на любой позиции, на любой странице
- Могут располагаться не только внутри выдачи, но и вне ее
- Могут обновляться в ответе Репорта при применении фильтров или пагинации

### Реализация на фронте

Техническая сложность построения врезок заключается в монолитности виджета выдачи. Вот некоторые детали, которые важно принимать во внимание при проектировании реализации врезок:
- Родительский виджет выдачи, Serp, виртуализирован: для пользователя рендерится только та часть выдачи, которую он видит на экране.
- В выдаче может существовать большое количество различных сниппетов или врезок: это код, который не всегда нужен пользователю
- Новые врезки могут создаваться в рантайме, приезжая в ответе Репорта
- Врезки — большой компонент страницы выдачи со своими коллекциями и, возможно, дополнительными данными
- Нужна техническая возможность сказать выдаче "рисуйся всегда без врезок", тогда лишняя логика не должна исполняться совсем

Для того чтобы использовать инструменты прогрессивной загрузки, независимости виджетов, error-boundary'ности, чанк-сплиттинга врезки в выдаче строятся посредством виджетов. **Каждый тип врезки — отдельный виджет.**

При подготовке врезок можно столкнуться с некоторыми ограничениями архитектуры:
- Слоты можно создавать только на сервере. То есть нельзя на клиенте вызвать `Widget.create`, создав новый виджет для врезки. Пусть врезка находится только на второй странице, а в браузере была запрошена первая. Тогда по клику "Показать еще" на клиенте должен быть создан новый слот с врезкой. Однако Apiary так не умеет: создать новый виджет можно только на сервере. Например, открыв вторую страницу в браузере, а затем обновив страницу.
- Заранее не известно, сколько и каких врезок пользователь может встретить, попадая на выдачу.

### Реализация генерации слотов

- Так как типов врезок ограниченное количество, можно заранее заготовить слоты. При этом так как они не будут зарендерены сразу, их коннекторы не будут исполняться. Нагрузка на фронт в этом случае получается минимальной.
- Слоты, которые не попадают в первый экран, нужно рендерить на клиенте (`bare: true`). Так как контейнер выдачи виртаулизирован, эти слоты не будут зарендерены.
- Слоты, которых вообще нет на текущей выдаче, нужно создать, но держать в фоне. Они будут висеть так до тех пор, пока не будут вызваны.
- Виджет врезки в качестве аргументов принимает общие параметры врезки и индекс — ключ, на основе которого этот виджет можно будет переиспользовать. Ключ — нуммерация виджета, а не позиция врезки.
- Когда выдача будет обновлена, внутри родительского виджета `Serp` будут отрисованы нужные слоты с врезками. Виджет `Serp` сам расставит врезки на нужные позиции. Виджеты врезок начнут слушать стейт и на основе этих данных обновят разметку.

Ахиллесова пята такого подхода: нельзя показать больше виджетов, чем было запланировано заранее. Если на фронте было определено, что врезок типа А может быть только 5, шестая врезка нарисована просто не будет.

![Врезки внутри выдачи визуально](./_assets/incuts-explained.png)

Пример:
- Существует выдача в гридовой сетке, в экран пользователя помещается два сниппета по вертикали
- Фронт готов нарисовать 3 врезки типа А и 2 врезки типа Б одновременно
- При первой загрузке Репорт вернул 6 сниппетов, 2 врезки типа А
- Фронт рисует только первые 3 сниппета и 1 врезку типа А, так как только они помещаются в первый экран
- При скролле необходимые компоненты будут рисоваться налету
- 3 виджета врезок существуют на странице, но не слушают стейт
- После обновления выдачи (применения фильтров) Репорт вернул 7 сниппетов, 1 врезку типа А, 1 врезку типа Б
- Родительский виджет Serp рисует слот врезки Б, Апиари подключает коннектор этой врезки
- Коннектор врезки Б отрисовывает себя
- Родительский виджет Serp перестает рисовать второй слот врезки А, коннектор отключается от стора

**Важное замечание: если Репорт вернет 4 врезки типа А одновременно, фронт сможет нарисовать только первые 3 из них.** Фронт не сможет нарисовать те врезки, о которых он не знает.

### Врезочный бойлерплейт

Чтобы код для определения врезок не был избыточным, были созданы удобные фабричные хелперы.

Пример описания врезки:
```js
import {Widget} from '@yandex-market/apiary';

import visibleSearchResult from '@self/root/src/entities/visibleSearchResult/reducers';
import searchResult from '@self/root/src/entities/searchResult/reducer';
import searchIncut from '@self/root/src/entities/searchIncut/reducer';
import visibleEntity from '@self/root/src/entities/visibleEntity/reducer';
import {INCUT_TYPE_CONFIGS} from '@self/root/src/entities/searchIncut/constants';
import CmsGrowingCashback from '@self/root/src/containers/search/incuts/CmsGrowingCashback';

import {createIncutWidgetController} from '../common/c0ntroller';
import {createIncutWidgetConnector} from '../common/view';
import {createIncutWidgetReducers} from '../common/reducers';
import {createIncutWidgetEpics} from '../common/epics';

export default Widget.describe({
    name: '@marketfront/CmsGrowingCashback',

    controller: createIncutWidgetController({
        incutTypeId: INCUT_TYPE_CONFIGS.CMS_GROWING_CASHBACK.ID,
        collectionsKeys: [
            'visibleSearchResult',
            'searchResult',
            'searchIncut',
            'visibleEntity',
        ],
    }),

    view: createIncutWidgetConnector(CmsGrowingCashback),

    reducers: createIncutWidgetReducers({
        collections: {
            visibleSearchResult,
            searchResult,
            searchIncut,
            visibleEntity,
        },
    }),

    epics: createIncutWidgetEpics(),
});
```

Такой подход может показаться сложным, однако в течение двух первых месяцев своего существования доказал свое удобство для новых врезок и незнакомых с подходом коллег.

Каждая фабрика создана таким образом, чтобы ее легко можно было отцепить. Написать свой контроллер не составляет труда, никаких расширений и переопределений.

Удобный бонус: нельзя прокинуть в виджет врезки никакой проп сверху:
- Любые данные выдачи можно взять из контекста.
- Скалярные значения можно получать, используя `searchPlace`.

## Деление на виджеты

Фреймворк Apiary позволяет делить контент страницы на виджеты. Теоретически деление как можно атомарнее важно для скорости отдачи страницы по нескольким причинам.

- Каждый виджет в таком случае будет привозить только необходимые данные, меньше будет размер патча, патч первого виджета будет обработан раньше.
- Зачастую благодаря делению можно родительский виджет делать статическим. Так вся разметка не будет привозить патч, а вместе с тем и гидрироваться. Кроме того, появляется возможность делать статическими любые виджеты из частей исходного.
- Рендеринг и отдача в Apiary повиджетная. Это означает, что как только виджет полностью готов, он может быть сразу отдан. В таком случае сложный для рендеринга контент будет показан как можно раньше.
- Деление большого нестатичного виджета на более мелкие позволяет не создавать long-таски при гидрации. Таким образом с интерактивность с первой частью виджета будет достигнута раньше, а event-loop лага не создастся.

![Загрузка врезки](./_assets/serp-loading.png)

## Две выдачи на одной странице

Может так случиться, что продуктово нужно показать две разных выдачи на одной странице. Для таких целей был придуман параметр `searchPlace`.

SearchPlace — это ключ дедупликации выдачи, строка. Если есть необходимость завести вторую выдачу, нужно завести для нее отдельный SearchPlace.

Кроме этого, `SearchPlace` является ключом для CMS. Через этот ключ можно получить дополнительные параметры выдачи в конфиге, которых настраивается в CMS.

## Дедупликация запросов

В совокупности единый резолвер и `SearchPlace` являются достаточными требованиями, чтобы построить группы виджетов с единым походом бэкенды.

![Дедуплицированная система сломана](./_assets/not-deduped-at-all.png)

В традиционной системе один (или несколько) резолверов данных вызываются из разных виджетов. При этом параметры для таких резолверов формируются внутри этих виджетов явнымм образом, как на этом рисунке.

Такая система не является дедуплицированной, будут созданы дополнительные походы в бэкенд, даже если этого не хочется.

![Дедуплицированная система работает](./_assets/deduped-but-fragile.png)

Наивным решением является унификация таких параметров во всех местах так, чтобы поход в бэкенд остался единым. Однако такую систему невозможно контролировать. Она может быть сломана новым виджетом или новым параметром.

![Решение проблемы с дедпликации](./_assets/deduped-strong.png)

Альтернативным решением является перестать формировать параметры на уровне виджета совсем. В такой системе у единого резолвера нет дополнительных параметров, ключей. Поэтому дубликации не происходит.

При этом если виджету внизу страницы нужны какие-то особые данные из этого резолвера, все виджеты будут ожидать, пока эти данные не придут. Очень важно это понимать, поэтому если какой-то виджет выдачи требует данные из другого источника, стоит:
- вызывать эти контроллера виджета, а не из резолвера выдачи;
- по возможности отложить поход за этими данными, вызывать через remote-резолвер с клиента.

Очевидная проблема такого похода заключается в том, что если виджет выдачи получал какие-то данные, а потом был удален, однозначной связи между ним и параметром Репорта не будет. Поэтому так важно документировать все параметры и функции виджетов.

## Порядок виджетов важен

Apiary позволяет отдавать страницу прогрессивно. А именно повиджетно, сверху вниз, слева направо. Это означает, что если какой-то виджет уже был готов, Apiary не сможет его отдать до того, пока не были отданы все предыдущие.

Поэтому так важно на критическом пути отдачи виджетов приоритизировать важный контент, неважный откладывать.

На выдаче виджет результатов поиска располагается справа относительно фильтров. Но мы считаем, что продуктово важнее показать сниппеты как можно раньше, а фильтры — это второстепенный контент. При этом в DOM дереве фильтры расположены выше.

Здесь возникает хак: при помощи CSS-свойства `flex-direction: row-reverse` можно развернуть контент так, что результаты поиска визуально будут справа, но в DOM дереве будут выше. И пользователю этот виджет покажется раньше.

### Критический путь и клиент

Большие сложные виджеты имеют свойство обогащаться новой продуктовой логикой, данными, которые приходят в дополнительных запросах в бэкенды.

Стоит данные виджета на две части: критические и отложенные. К примеру цена на сниппете — важные данные, а рекламный бейджик — второстепенные.

В таком случае не стоит догружать данные бейджика на сервере: нужно дозапросить данные с клиента используя remote-резолвер как только event loop браузера будет свободен.

Время, затраченное на получение бейджиков в виджете результатов поиска будет влиять на время отдачи виджета фильтров. Текст подсказок в виджете фильтров будет влиять на тайминг отдачи контента под выдачей.

## Критический путь на сервере

Очень важно следить за тем, как и в каком порядке на сервере выполняются запросы за данными. Не нужно получать те данные, которые впоследствии будут не нужны. Не стоит делать последовательно ту работу, которую можно делать параллельно.

{% note tip %}

Простые правила и договоренности, которые используются на выдаче:
- Чтобы получить CategoryId (`hid`) и NavnodeId (`nid`), достаточно сходить в каталогер. За выдачей идти не нужно.
- Чтобы получить начать рисовать разметку, требуется убедиться, что не произошло редиректа или не случилась пустая выдача.
- Если запрос зависит от данных выдачи, и может быть вызван с клиента, его нужно выполнять с клиента. Иначе нужно сделать этот запрос на сервере как можно раньше.

{% endnote %}

Пример запросов, которые не зависят от данных выдачи (но могут зависеть от состояния выдачи: редирект, пустая или с товарами):
- Сравнение
- Вишлист
- CMS-фильтр
- Шины
- Таблица размеров

Пример данных, для которых нужна выдача:
- Сео-эксперименты (нужен исправленный спеллчекером текст)
- Описание фильтров (нужен список фильтров)
- Бейджики с сниппетах (нужен список товаров и некоторые их характеристики)

Первые два запроса очень быстрые, их можно выполнить на сервере последовательно с выдачей. Запрос за бейджиками нужно делать с клиента, если он не кэширован через мэмкэш (или очень быстрый).

Проблема скорости заключается в том, что мы не можем начать запрашивать данные, независимые от выдачи до того, как не узнаем, случился ли редирект или выдача пустая. В таком случае можно пойти на хак: ввести эвристику.

Исходные условия:
- Репорт отвечает редиректом в 75% случаев
- Репорт отвечает редиректом за 600мс в 99 перцентиле
- Доля пустых выдач ~7%

Таким образом можно предположить, что если Репорт не ответил за 600 мс, то он готовит ответ с товарами. В этом случае можно заранее начать готовить виджеты выдачи.

Пример трассировки до:

![Пример трассировки до](./_assets/trace-hack-before.jpeg)

Пример трассировки после:

![Пример трассировки после](./_assets/trace-hack-after.jpeg)

{% note warning %}

Это плохой, но действенный способ оптимизировать TTLB страницы. Эта метрика очень критична для пользователя, так как размер клиентского бандла насколько большой, что DCL случается раньше завершения загрузки JS.

{% endnote %}

## Скрытие виджетов

Частая проблема при разработке большой страницы — уметь не показывать некоторые блоки. При этом в CMS-разметке указывается один вариант: богатая выдача.

В таком случае виджет должен сам определить: может ли он быть нарисован в зависимости от контента.

### Синхронный `return null` в контроллере

Самым быстрым способом скрыть виджет является синхронный возврат в контроллере объекта `null`.

```js
export default function controller(
    ctx: Context,
    options: Options
): WidgetSchema<Context, Data, Collections> {
    const isWidgetAvailable = resolveWidgetAvailableSync(ctx);
    if (!isWidgetAvailable) {
        return null;
    }
}
```

В таком случае виджет будет закончен максимально быстро, не начав свой рендеринг.

### Асинхронный `renderIf` во вьюхе

Если не удается получить знание о возможности нарисовать виджет синхронно, вернуть в одном из полей данных виджета это знание.

```js
export default function controller(
    ctx: Context,
    options: Options
): WidgetSchema<Context, Data, Collections> {
    const isWidgetAvailablePromise = resolveWidgetAvailable(ctx);

    return {
        data: isWidgetAvailablePromise.then(isWidgetAvailable => ({
            doNotRender: !isWidgetAvailable,
        })),
    };
}
```

Затем во вьюхе этого виджета через хок `renderIf` можно выбрать, стоит ли рендерить этот виджет.

```js
export default compose(
    connect(mapDataToProps),
    renderIf(props => props.doNotRender !== true),
    withVisibilitySensor(),
    withWidgetWrapper
)(View);
```

Это не самый изящный способ, и, если возможно, нужно всегда использовать синхронный вариант.

## Асинхронный контроллер

Одной из особенностей виджетного контроллера является возможность подписаться отдельно на поля `data`, `collections`, `slots`, `job` и `static`. При этом под капотом Apiary для обработки поля `slots` не нужно ждать, например, поле `data` и наоборот. И это работает достаточно оптимально: Apiary выбирает удачный порядок для обработки контроллеров и рендеринга виджетов.

Однако бывает, что внутри контроллера неизвестно содержимое слотов или джоб. И эти данные можно получить только если дождаться асинхронного действия.

В таком случае можно воспользоваться опцией "асинхронный контроллер".

Стоит помнить, что асинхронные контролеры препятствуют оптимальной работе Apiary, и не дают заранее обработать виджеты внутри поддерева. Поэтому нельзя использовать асинхронные слоты, например, для скрытия виджетов.

## Конструктор выдачи и Хаб отзывов

Выдача — очень богатый способ представить данные. Потому что это поиск по параметрам. К примеру, код выдачи используются даже для того, чтобы показывать рекомендательные карусели.

Поэтому продукту исторически было очень важно создавать необычные выдачи.

Если зайти на страницу выдачи с query-параметром `show-reviews=1`, сниппеты примут другой вид, исчезнут фильтры, скроется большая часть настроек. Останутся сортировки и пагинация, а сниппеты будут обогащены отзывами. Эта страница называется Хаб отзывов.

![Скриншот хаба отзывов](./_assets/reviews-hub.png)

Таких выдач на сервисе много, и всеми ими хочется легко управлять как на сервере, так и в рантайме.

Прежде был использован подход, при котором в каждом контроллере виджетов выдачи разработчик запрашивал из контекста, удовлетворяет ли запрос его условиям.

```js
/**
 * Добавляет в отзывы голоса текущего пользователя.
 */
const decorateReviewsWithUserVotes = async (ctx, searchResultElements) => {
        if (getSoleParam(ctx, 'show-reviews') !== '1') {
            return;
        }

        try {
            const userVotes = await resolveUserVotes(ctx);
```

Такой подход в прошлом. Все множество выдачей кластеризовано, декларативно и единообразно описано.

- Центральная сущность выдачи `VisibleSearchResult` содержит поле `searchFeature`. Это объект всех возможных вариаций выдачи. Это именно чекбоксы, поэтому выдачи технически могут пересекаться.

```js
export type SearchFeature = {
    fesh?: true,
    outOfStock?: true,
    reviewsHub?: true,
    shopInShop?: true,
};
```

- Каждая выдача содержит свой CMS-конфиг. Так можно переопределить параметры поиска, скрыть часть фильтров или уменьшить количество сниппетов.

```js
export const CMS_CONFIG: CmsDeclaration = {
    ...generateCmsConfigHead(),
    name: 'search-reviews-hub-page',

    searchParams: [
        'no-search-filters=1',
        'no-intents=1',
        'show-reviews=1',
        'count=24',
        `viewtype=${VIEWTYPE.LIST}`,
    ].join('&'),
};
```

- Каждая выдача может содержать свой кастомизированный лэйаут. Например, без фильтров.

- Между всеми фичами установлено ранжирование. Так у хаба отзывов наивысший приоритет.

При запросе на страницу выдачи поле `searchFeature` определяется из контекста синхронно, на его основе готовятся параметры Репорта и лэйаут. Обращение за контекстом происходит единообразно.

```js
const visibleSearchResult = selectVisibleSearchResultById({collections}, visibleSearchResultId);
const searchFeature = getSearchFeature(visibleSearchResult);

if (searchFeature.reviewsHub) {
    slug += ': отзывы покупателей';
}
```

## Сложные вычисления на сервере

Несправедливо считать, что любая сколь угодно сложная операция может быть перенесена с клиента на ноду. Бывает, что операция может быть настолько сложной, что единственное место для нее: бэкенд (в нашем случае Репорт).

### Опции доставки

На страничной выдаче есть часть функционала, для которой нужно получить с Репорта опции доставки (`pickup-options`). Ранее это был развернутый массив данных, среди которого выбиралась лучшая опция через сортировку, а потом брался первый элемент.

Буквально:

```js
const pickupOptions = [...];
const bestPickupOptions = pickupOptions.sort(...)[0];
```

В таком случае недостаточно было просто заменить решение с сортировки на поиск максимума. Лучшим решением является перенести логику поиска лучшей опции на сторону бэкенда, то есть Репорта.

### Сортировка фильтров

В ответе выдачи приезжает набор фильтров в виде массива. То есть порядок фильтров заранее определен на стороне Репорта.

Продуктово возникла потребность этот порядок изменить: так возникла задача сортировки фильтров. Причем постановка задачи сама по себе не верна: нужна была перестановка, а не сортировка.

Идеального способа решить эту задачу не было, поэтому утилит для перестановки фильтров возникло целое множество (аж четыре), часть под флагами мертвых экспериментов.

Кроме того, так как все называли перестановку именно сортировкой, возник такой код:

```js
const FASHION_FILTERS_ORDER = {
    FASHION_FILTER_ID_1: 0,
    FASHION_FILTER_ID_2: 1,
    FASHION_FILTER_ID_3: 2,
    FASHION_FILTER_ID_4: 3,
    FASHION_FILTER_ID_5: 4,
};

const sortedFilters = filters.sort((firstFilterId, secondFilterId) => {
    const firstFilterName = getName(filter[firstFilterId]);
    const secondFilterName = getName(filter[secondFilterId]);
    return (
        FASHION_FILTERS_ORDER[firstFilterName] -
        FASHION_FILTERS_ORDER[secondFilterName]
    );
});
```

Две важные детали относительно перестановки фильтров:
- Если порядок фильтров известен заранее, операцию определения порядка нужно перенести на сторону бэкенда.
- Заботиться о производительности горячего кода очень важно.

### Не получать то, что не нужно

По-умолчанию Репорт возвращает большой объем данных о выдаче и товарах. Возможно, такой объем не требуется. Например, если для сниппетов скроллбокса требуется выполнить гарсон с поиском, а потом нарисовать только товары, сортировки, фильтры, интенты и другие дефолтные поля ответа Репорта просто не нужны. И вместо того, чтобы не использовать их на фронте, лучше позаботиться о нагрузке на Репорт, и в запросе к нему попросить эти данные не считать вообще.

![Размер фильтров в ответе Репорта](./_assets/report-unused-data.png)

Например, параметр `no-search-filters=1` укажет Репорту, что фильтры не нужно считать вообще. В таком случае Репорт ответит значительно быстрее.

Нагрузка на Репорт в одном месте влияет на производительность всех страниц сервиса.

### Скрытие фильтров

Другая задача, которую можно решить на стороне Репорта: скрытие фильтров. Чтобы не показывать фильтр, не нужно скрывать его в Реакт-компоненте. Гораздо эффективнее эти данные вообще не получать и не обрабатывать.

## Кастомный фильтр

Одна из способностей Apiary — грамотно распараллелить работу относительно всех частей страницы. Причем чем гранулярнее страница разделена на виджеты, тем эффективнее у Apiary получается это делать.

У продукта возникла потребность для акций сделать новый фильтр. При этом на Репорте этот фильтр заводить не стали. Положили акцию на S3, а в данные Репорта просто допушивали этот фильтр по условию.

За счет того, что впоследствии этот виджет был вынесен в отдельный виджет, были достигнуты следующие результаты:
- снизился рендеринг большого Реакт-компонента: виджета фильтров;
- снизилась гидрация виджета фильтров;
- появлась возможность сделать виджет промо-фильтра динамическим, и привозить в основной бандл по условию;
- пропала задержка в получении данных фильтров для виджета фильтров: теперь остальным виджетам выдачи не надо ждать промо-фильтр;
- логически виджет фильтров перестал зависеть от фильтров.

В конце концов:
- "промо-фильтр" — это не фильтр Репорта;
- функционал промо-фильтра нужно было делать на стороне Репорта сразу.

## Кастомные интенты
У продукта возникла потребность показывать менее конкретные уточнения категории.
Например, Мужская/Женская/Детская одежда вместо длинного списка мелких уточнений из разных категорий -

![Скриншот интентов](./_assets/clarified-intents.png)

В `visibleSearchResult` добавили сущность `customClarifyIntentIds`. Если это поле не пустое, интенты из этого списка будут показаны в виджете уточнения категории.
Получаем `customClarifyIntentIds` из сырого результата `fetchPrime` с помощью стратегий, такая потребность может возникнуть не только в одежде, но и в других категориях, поэтому был введен механизм со стратегиями:
```js
export const CUSTOM_CLARIFY_INTENTS_STRATEGIES: Strategy[] = [
    {
        predicate: rawResponse => rawResponse.search.isMostlyFashion === true,
        processor: getCustomClarifyIntentIds,
    },
];
```

## Query-параметры в рантайме

Контроль за query-параметрами — крайне непростая задача. Контролировать урл из каждого виджета, или из какого-то глобального эпика по загрузке данных очень сложно. Кроме того, эта опция нужна не всегда. Например, на промо-странице или в веб-вью такой функционал вообще не нужен.

Поэтому контроль параметров вынесен в отдельный виджет `@marketfront/SearchUrl`. Виджет не содержит вьюху, только эпик. На любое обновление выдачи происходит парсинг урла, получение данных из стейта выдачи, финальная обработка и запись в историю.

## Костыли и итерации

Плохой код обрастает только плохим кодом. А хороший код тоже когда-нибудь станет плохим. Важно заботиться об экосистеме вокруг свежих решений, избегать условных конструкций, использовать паттерны.

Именно поэтому при проектировании нового кода стоит задуматься над тем, что будет, когда появится новая опция или костыль.

## Виртуализация

Большие виджеты с большим количеством DOM-узлов сложно рендерить. Чтобы отрисовать все результаты поиска на странице выдачи (48 сниппетов), требовалось 1_500 мс в 99 процентиле. Серверный рендеринг (а потом клиентская гидрация) — синхронные операции в рамках одного виджета. Они приводят к лонгтаскам, что влияет на производительность всего сервиса.

Если часть контента виджета заходит за границы видимой области, существует подход к исправлению этой проблемы: виртуализация виджета.

При виртуализации стоит ответить на такие вопросы:
- известна ли заранее высота/ширина контента, который будет отрендерен;
- нужно ли сохранить возможность искать по странице при помощи встроенного поиска;
- оптимизирован ли React контента внутри виртуализируемой области;
- если виртуализуются виджеты, как будет работать эвристика для `{bare: true}`.

## Композиция резолверов

Основная серверная бизнес-логика сосредоточена в коде резолверов. Этот код переживал различные этапы своего развития, хотя инструмент очень прост.

```js
const f = () => {...};
const g = () => {...};
```

Для простоты примера `f` и `g` — обычные резолверы.

Обычно если нужно реализовать связь между резолверами, она строится через проброс результата одного резолвера в другой через парараметры.

```js
f(g())
```

Однако такого подхода можно избежать, если вызывать одни резолверы из других.

```js
const f = () => {...};
const g = () => {
    const params = f();
};
```

В таком случае:
- код родительского компонента получается тонким;
- резолвер `g` получает продуктовый оттенок;
- существенно дедуплицируется общий код, лучше кэшируются общие компоненты страницы.

![Пример распутывания связей резолверов](./_assets/resolers-structure.jpeg)

### Пример с параметрами категории

Содержимое категорийной выдачи определяется узлом с айдишником категории, в котором находится пользователь. Например, "Одежда", "Электроника" и другие.

Знание о текущей категории прилетает в параметрах `hid` и `nid` в урле.

```js
const resolveSearchData = async (ctx, {hid, nid}) => {
    const compass = await resolveCompassInfo(ctx, {hid, nid});
    // ...
};

const controller = async (ctx) => {
    const hid = getSoleParam(ctx, 'hid');
    const nid = getSoleParam(ctx, 'nid');
    const searchData = await resolveSearchData(ctx, {hid, nid});
}
```

Утверждается, что вместо этого следует:
- сделать резолвер параметров `hid` и `nid`, чтобы обработать эти данные один раз;
- сделать резолвер компаса для выдачи;
- избавить верхнеуровневое представление данных (контроллер) от низкоуровневых знаний о query-параметрах.

```js
const resolveSearchCompassInfo = async (ctx) => {
    const hid = getSoleParam(ctx, 'hid');
    const nid = getSoleParam(ctx, 'nid');
    return resolveCompassInfo(ctx, {hid, nid});
}

const resolveSearchData = async (ctx) => {
    const compass = await resolveSearchCompassInfo(ctx);
    // ...
};

const controller = async (ctx) => {
    const searchData = await resolveSearchData(ctx);
}
```

Резолверы `resolveSearchCompassInfo` и `resolveSearchData` приобрели улучшенное покрытие кэшом, а также получили продуктовый смысл.

Объявляя резолверы, зачастую важнее делать их не абстрактными, а простыми и кэшируемыми. Не стоит экономить на их количестве, если это положительно повлияет на кэширование.

## Нуклеарные сущности

Данные, получаемые с различных бэкендов, принято нормализовать. Это необходимый этап, чтобы максимально эффективно распределить большой массив данных по всем участкам приложения, а также организовать оптимальные связи меджу его частями.

Предположим, в ответе Репорта в товаре появляется новое поле. В том случае, если это поле нескалярно (например, в виде объекта), его обязательно нужно нормализовать.

Положительный эффект:
- если остальные виджеты, зависящие от этой коллекции, не используют это поле, количество данных, передаваемых по сети, снижается;
- снижается время обработки патчей предыдущих виджетов;
- в том случае, если этот функционал нужно будет отключить, его можно будет оторвать по кнопке;
- в том случае, если этот функционал на стороне бэкенда переедет на микросервис, его не нужно будет адаптировать.

## Историческая справка

Исторически так сложилось, что вместо редактирования код клонировался, характеристики менялись, а суть оставалась прежней. Сначала появился тач [mobile](https://github.yandex-team.ru/market/mobile), затем Беру [marketplace](https://github.yandex-team.ru/market/marketplace), а затем все три репозитория слились в один.

Поэтому сейчас выдач существует несколько. Процент общего кода постепенно растет, но архитектурно выдачи между собой сильно отличаются. По этой причине нельзя итеративно перевести старую выдачу на новую архитектуру.

Всего есть три подмножества выдач.

### Синяя выдача

Это выдача Яндекс Go, выдача на промо-страницах, новая выдача десктопа. Код этой выдачи используется в мобильных приложениях (FAPI).

Была разработана за два месяца в Беру на чистом энтузиазме.  Позднее была перенесена в Маркет вместе с переносом промо-страниц Беру. Заменять ею страничную выдачу не захотели.

Умеет все то же самое, что и старая выдача.

### Старые десктопная выдача и выдача тача

Модель данных скопирована с синей выдачи. Однако получение данных завязано на старых технологиях (например, Стаут).

Фильтры десктопной выдачи не являются апиарным виджетом. Синхронизация с остальной выдачей обеспечивается через отдельный redux-стор.

Очень сложна для погружения и разработки новых фичей.

---

Из всего множества выдач правильным решением является развивать одну — синюю.

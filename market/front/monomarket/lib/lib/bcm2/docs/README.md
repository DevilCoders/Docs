BCM2 / [Exports](modules.md)

[![oko health](https://oko.yandex-team.ru/badges/repo.svg?repoName=market/monomarket&vcs=github&repoFilter=lib/lib/bcm2)](https://oko.yandex-team.ru/github/market/monomarket?repoFilter=lib/lib/bcm2) [![oko health](https://oko.yandex-team.ru/badges/pkg.svg?pkgName=bcm2)](https://oko.yandex-team.ru/pkg/bcm2)

# Backend/Client/Model
[Спецификация](docs/modules.md)

Это библиотека для организации сложной логики работы с различными бекендами.

Библиотека содержит несколько базовых классов с помощью которых можно удобно описывать различные структуры взаимодействий и запросов.

Иерархия:

  - Context
  - BaseModel
    - Backend
    - Transport
      - HttpTransport
    - Model **<--- магия происходит тут**
      - Client

Вспомогательные функции:

  - memoFunction **<-- магия происходит отсюда**
  - memoisable
  - memoMethods **<-- магия происходит отсюда**
  - memoClass, MemoClass **<-- магия происходит отсюда**
  - функции *Retry 

## Установка

Библиотека доступна через внутренний npm:

```bash
npm install --save bcm2 --registry='http://npm.yandex-team.ru'
```

Для того, чтобы использовать версию из github'а требуется сперва установить все зависимости, выполнить `npm run build` и после этого в месте где, вы намерены её использовать, указать путь до директории `dist`, получившейся после сборки.

## Концепция и философия
Основная идея данной библиотеки - предоставить удобный, легко-читаемый интерфейс для реализации логики работы с различными бекендами. В данном случае за основу берётся концпеция разделения всей логики на 3 типа сущностей: Бекенды, Клиенты и Модели. 

### Бекенд
Сущность, которая описывает общую логику взаимодействия с каким-то бекендом. Логика может включать в себя выставление каких-то общих для всех запросов заголовков, параметров запроса, частей пути и т.д. Плюс к тому здесь можно как-то предварительно обрабатывать ответы. Например некоторые бекенды записывают в ответ в поле response - для таких случаев имеет смысл подготовить ответ, вернув из запроса сразу значение данного поля, а не весь ответ.

### Клиент
Сущность, которая описывает конкретные API предоставляемые бекендом. В общем случае для больших бекендов имеет смысл создавать сразу несколько разных клиентов для одного бекенда, объединяя в них методы относящиеся к одной сущности или теме. Клиент идеологически является просто интерфейсом для общения с бекендом, т.е. в нём должно содержаться минимальное количество бизнес-логики, т.е. код клиента должен содержать только форматирование запроса и получение значимых полей из ответа. Некторые бекенды (не будем показывать пальцем), отправляют часть данных в заголовках, часть в теле ответа, а ещё активно используют статус-коды.

### Модель
Сущность, которая содержит бизнес-логику взимодействия с различными бекендами. Достаточно часто для запроса в какой-то бекенд, требуется собрать дополнительные данные из других бекендов (или даже из того же самого, но из другого метода). В этом случае на помощь как раз приходят модели, которые позволяют описать логику последовательности запросов за данными. Концептуально модели должны вызывать методы только других Клиентов и Моделей, напрямую использовать Бекенды запрещено.

### Мемоизация и потоки данных
Чтобы данная концпеция успешно работала, требуется активно использовать мемоизацию ответов в методах Моделей и Клиентов. Это требуется, потому, что при сильной изоляции логики между множеством различных сущностей, неизбежно будут возникать подобные ситуации:

```
                /---> method2 ---> method4  
---> method1 --| 
                \---> method3 ---> method4
```

Без мемоизации `method4` будет выполнен 2 раза. Мемоизация позволяет дедуплицировать подбные запросы, не задумываясь о сложной структуре сущностей и порядке их вызова. Однако при использовании мемоизации требуется задумываться о ключах кэширования. В целом следует соблюдать всего одно правило, при проектировании - ключ кэширования должен быть меньше данных, которые он кодирует. Это проще объяснить на примере.

Скажем у нас есть клиент, который умеет возвращать авторизационные данные пользователя (большой словарь с кучей полей с информацией о пользователе). И скажем мы хотим получить информацию о uid'е текущего пользователя. Один из классических подходов - написать некий селектор, который вернёт нам нужные данные. Однако, если данный селектор будет методом модели, то получится, что мы передаём в него здоровенный объект и получаем на выходе короткую строку. Ключ больше данных. Это не хорошо. Если же селектор положить отдельно от модели, его будет не так удобно использовать в остальной части иерархии bcm-сущностей (потребуется знание о дополнительном репозитории методов, у которых скорее всего будет менее структурированная иерархия, и знание о том откуда требуется взять данные для данного селектора). В концепции BCM данную проблему правильнее решать с другого конца. Здесь есть мемоизация - у нас уже есть метод, который обменивает некий авторизационный ключ на целую кучу данных о пользователе. Этим и стоит воспользоваться. Вместо написания селектора стоит сделать метод получения uid'а пользователя, который сам вызовет метод получения авторизационной информации и выберет оттуда нужное поле. Т.к. запрос за пользовательскими данными мемоизуется - данный подход не породит дополнительной нагрузки на сеть/базу/диск/процессор/etc.

Этот пример довольно утрирован, однако достаточно наглядно иллюстрирует то, как данные должны переходить от одной сущности к другой. Всегда стоит стремиться к методам с минимальным количеством аргументов, минимального размера. Не стоит бояться ходить за какими-то данными из любого клиента или модели - если эти данные нужны, они либо уже лежат в кэше мемоизатора, либо за ними действительно стоит сходить и сохранить в кэше мемоизатора.

Чтобы голова не болела от проблемы инвалидации кэшей, вводится такая сущность как контекст. Все кэши связанны с контекстом. Контекст живёт столько сколько длится запрос из браузера на сервер. Новый запрос -> новый контекст -> новый набор кэшей -> не надо ничего инвалидировать. Бывают редкие случаи, когда в рамках одного клиентского запроса требуется получить какие-то данные повторно (например прочитать, модифицировать, проверить целостность) - в этом случае можно либо сбросить кэш всех задействованных методов (если есть знание про все методы), либо просто создать новый контекст. Однако подобные случаи почти всегда являются архитектурной ошибкой и стоит внимательно подумать и поискать решение при котором не потребуются подобные ухищрения.

### Чистота и ленивость
BCM представляет из себя симбиоз ООП и функционального программирования. В том плане, что классы используются для структурирования логики, но методы этих классов ближе по концепции к функциональному программированию. Все вызовы максимально ленивы, если какие-то данные не требуются в данный момент, они не будут получены. Все вызовы являются чистыми и мемоизуемыми - вся информация сохраняется только в кэше, и нигде больше (иначе мемоизация станет нам врагом, а не другом). В случае если чистота нарушается, метод сохраняет какие-то данные куда-то и использует их для своей работы - мемоизация будет работать некорректно, про это важно помнить при проектировании.

## Описание базовых классов

### Context

Вспомогательный класс. Описывает контекст выполнения клиентского запроса. Напрямую связан с инстансом запроса из браузера. Однако для различных целей может существовать более одного инстанса контекста на один инстанс запроса из браузера.

### BaseModel

Не содержит почти никакой бизнес-логики, просто некий базовый класс. Содержит свойство Context, и фабрику, которая возвращает инстанс класса связанный с контекстом. Соотношение контекст-инстанс 1:1.

 ```typescript
import {Context, BaseModel} from 'bcm2';

function example(context: Context) {
    const model1 = BaseModel.factory(context);
    const model2 = BaseModel.factory(context);
    
    model1 === model2; // true
    model1.context === context; // true
}
```

Кроме этого содержит статический метод connect, который создаёт дочерний класс с геттер-фабриками других классов.

```typescript
import {BaseModel} from 'bcm2';

class Model1 extends BaseModel {
    firstMethod() {}
}

class Model2 extends BaseModel {
    secondMethod() {}
}

class SuperModel extends BaseModel.connect({
    firstModel: Model1,
    secondModel: Model2,
}) {
    superMethod() {
        return this.firstModel.firstMethod() + this.secondModel.secondMethod();
    }
}

// SuperModel будет иметь в данном случае примерно такую структуру:

class SuperModel extends BaseModel {
    get firstModel() { return Model1.factory(this.context); }
    get secondModel() { return Model2.factory(this.context); }
    
    superMethod() {
        return this.firstModel.firstMethod() + this.secondModel.secondMethod();
    }
}
```

### Model
Тоже самое что и BaseModel, но с магическими свойствами. Все методы данного класса и его потомков автоматически мемоизуются. См. описание memoClass.

Является базовым классом для сущностей, реализующих всякую бизнес-логику. 

### Backend
Базовый класс описывающий общие методы работы с конкретным бекендом:
  - транспортный слой, который нужно использовать (сейчас реализован только HTTP, в планах HLS и gRPC)
  - общая подготовка всех запросов, типа добавления заголовков, форматирования тела запроса, добавления базовых параметров и т.д.
  - общая подготовка всех ответов, типа бросания ошибок, записанных в полях ответа, вытаскивания полезных данных ближе к корню и т.д.
  
Наследники данного класса не должны содержать описания методов конкретного бекенда - только общие свойства запросов и ответов.

```typescript
import {Backend, HttpTransport, HttpTransportParams, HttpTransportResponseError} from 'bcm2';
import {SomeSmartModel} from 'SomeSmartModel';

class MySuperPuperBackend extends Backend.setup(HttpTransport, "super-puper-backend", {
    host: "http://some.hostname.ru:32109",
    pathname: "/base/api/path",
    query: {common: "param", more: ["p", "A", "r", "A", "m", "s"]},
    headers: {"x-requested-by": "bcm"},
    proxyHeaders: ["user-agent"],
    followRedirect: false,
    decompress: true,
    encoding: "utf8",
    encodeBody: "json",
    parseBody: "json",
    timeout: 1500,
    retry: 3,
    retryDelay: 100,
    retryAllowed: function(error) { return error instanceof HttpTransportResponseError && error.statusCode >= 500; }
    acceptStatusCode: function(code: number): boolean { return code >= 200 && code < 300; }
}).connect({
    someSmartModel: SomeSmartModel,
}) {
    async prepareRequest(params: HttpTransportParams): Promise<HttpTransportParams> {
        const [prepared, smartHeader] = await Promise.all([
            super.prepareRequest(params),
            this.someSmartModel.getSmartHeader(),
        ]);
        
        prepared.headers.smartHeader = smartHeader;
        
        return prepared;
    }
    
    async prepareResponse(response, request) {
        const prepared = await super.prepareResponse(response, request);
        return prepared.result.deep.nested.value;
    }
}
```

### Client
Базовый класс для описания клиентов. В принципе это та же модель, но с узкой специализацией. Метод connect данного класса требует обязательный агрумент backend с типом Backend. Наследники данного класса описывают конкретные методы данного бекенда. Главная концпеция в том, чтобы клиент не содержал какой-то бизнес-логики, а только подготавливал данные запроса и как-то минимально подготавливал данные ответа (переименование свойств из snake_case в camelCase например). Вся бизнес-логика должна находиться в моделях.

### Transport 
Базовый класс для описания транспортных слоёв. Отвечает за реализацию передачи данных. Настолько абстрактный, что тут и добавить нечего.

### HttpTransport
Транспортный слой для HTTP запросов. В целом всё достаточно очевидно из описания типов [HttpTransportOptions](src/http/transport-types.ts) и [HttpTransportParams](src/http/transport-types.ts).

Однако есть несколько неочевидных вещей:
  - опция `retryDelay`. Данный метод позволяет выставить задержку между ретраями. Принимает один аргумент - номер предыдущей попытки. Возвращает время в миллисекундах. По-умолчанию задержка всегда 100ms.
  - опция `retryAllowed`. Данный метод позволяет определить разрешён ли ретрай. Принимает в качестве аргумента ошибку запроса и сам запрос. По-умолчанию разрешено ретраить ошибки со статусом `408, 413, 429, 500, 502, 503, 504, 'ECONNRESET', 'ECONNREFUSED', 'EPIPE', 'ENOTFOUND', 'ENETUNREACH', 'EAI_AGAIN'`.
  - опция `acceptStatusCode`. Данный метод позволяет определить, какие статус-коды ответа не будут считаться ошибкой. По-умолчанию разрешены все статус-коды меньше 400.

## Вспомогательные функции

### memoFunction
Собственно функция, которая лежит в основе всей магии мемоизации. Функция принимает в качесте аргумента другую функцию и возвращает её мемоизованную версию. Для тонкой настройки передаваемой функции можно добавить свойства:

  - memoStorage - функция, которая должна вернуть объект кэша, который будет использовать при мемоизации.
  - memoKey - функция, которая должна вернуть ключ кэширования. Эта функция будет вызвана в том же контексте и с теми же аргументами, что и исходная функция.
  
У мемоизованной функции становятся доступны свойства:

  - dromMemo - точечный сброс кэша. Возвращает ключ кэширования, должна вызываться с теми же аргументами и контекстом, что и вызов сброс которого требуется выполнить.
  - clearMemo - полный сброк кэша. Т.к. у объектов класса WeakMap нет метода clear, для сброса просто создаётся новый объект кэша, это следует учитывать.

Так же стоит учитывать, что все перечисленные свойства являются символами, а не строками - их нужно импортировать из библиотеки.

### memoisable
Хелпер для настройки мемоизуемых функций. Принимает 3 аргумента:

  - функцию memoStorage,
  - функцию memoKey
  - непосредственно саму функцию, которую затем можно передавать в memoFunction
  
Возвращает новую функцию со свойствами memoStorage, memoKey.

### memoMethods
Функция для мемоизации методов передаваемого объекта. Принимает в качесте аргумента объект, возвращает объект с применённой к нему Proxy. При первом вызове метода объекта к нему будет применена memoFunction, если у него не выставлено свойство dontCache (тоже символ). Данная функция не мемоизует методы из `Object.prototype`, а также свойство `constructor`.

Стоит отметить, что при этом подходе в результате получается объект, который можно использовать в `Object.create` - при этом у результата тоже сохранится свойство мемоизации методов. Для нового инстанса будет создан новый объект кэша (т.е. кэши оригинального объекта и нового инстанса не будут пересекаться). 

### memoClass
Функция для придания методам класса свойства мемоизуемости. Принимает в качестве аргумента класс, возвращает этот же класс с применённой к нему Proxy. При создании инстанса класса автоматически применяет к нему memoMethods.

### *Retry
Набор функций для настройки свойства `retryDelay`.

#### constantRetry
Возвращает функцию, которая просто всегда возвращает заданное число. Используется для ретраев с одинакой задержкой между попытками.

#### quadraticRetry
Возвращает функцию, которая возвращает результат квадратичной функции. Используется для ретраев с относительно быстро возрастающей задержкой между попытками.

#### logariphmicRetry
Возвращает фукнцию, которая возвращает результат логарифмической функции. Используется для ретраев с плавно возрастающей задержкой между попытками.

#### exponentialRetry
Возвращает функцию, которая возвращает результат экспоненциальной функции. Используется для ретраев с очень быстро возрастающей задержкой между попытками.

#### manualRetry
Возвращает функцию, которая возвращает значение из переданного массива или заданную константу, если индекс за рамками массива. Используется для тонкой ручной настройки интервалов между попытками.

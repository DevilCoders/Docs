# Unit-тесты

На этой странице описано, когда и зачем нужно или не нужно писать unit-тесты на разные части ПИ.

В общем случае unit-тесты проверяют, что код в заданных условиях ведёт себя ожидаемым способом.

## Глоссарий

* [elvis-оператор (optional chaining)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)
* glob pattern / шаблон поиска ([гайд ENG](https://www.malikbrowne.com/blog/a-beginners-guide-glob-patterns), [реализация в jest](https://github.com/micromatch/micromatch))

## Общие пожелания по unit-тестам

### jest and tips

Пишем тесты на `jest`.

- [docs](https://facebook.github.io/jest/docs/en/getting-started.html)

Tips:

- [Как тестировать HOC (см. аналогичный вопрос в Tips)](./dev/client.md#Components)

### istanbul ignore

Желательно использовать ```/* istanbul ignore next */```, а не ```/* istanbul ignore file*/```.

#### Как НЕ надо

Был файл

```javascript
/* istanbul ignore file*/

// Не хотим считать coverage для этой функции.
export function oldOne(params) {
  // some old code
}
```

в него добавили новую функцию

```javascript
/* istanbul ignore file*/

// Не хотим считать coverage для этой функции.
export function oldOne(params) {
  // some old code
}

// Новая функция
export function newOne(params) {
  // some new code
}
```

За счёт игнора всего файла новая функция тоже игнорируется при подсчёте coverage - это неочевидно для автора новой функции, об этом легко забыть, из-за чего часть кода будет исключена из coverage "случайно".

#### Как НАДО

Был файл

```javascript
// Не хотим считать coverage для этой функции.
/* istanbul ignore next */
export function oldOne(params) {
  // some old code
}
```

в него добавили новую функцию

```javascript

// Не хотим считать coverage для этой функции.
/* istanbul ignore next */
export function oldOne(params) {
  // some old code
}

// Новая функция
export function newOne(params) {
  // some new code
}
```

За счёт точечного игнора старой функции новая функция будет учитываться в подсчёте coverage автоматически. В отчёте разработчик увидит влияние этой функции на общий процент покрытия тестами.

## Клиентская часть страниц

### view-компоненты - библиотечные компоненты

**Для чего нужны unit-тесты в этом случае?**

Проверяют, что правки не ломают поведение библиотечного компонента.

**Когда покрываем или не покрываем?**

Покрываем индивидуально в зависимости от правил/договорённостей конкретной библиотеки, в которой правится код. Если есть сомнения, что нужно покрывать, а что - нет, то лучше спросить об этом явно в чатике или обсудить на одной из общих встреч с внесением обновлений в эту страницу.

### view-компоненты - бизнес-логика

**Для чего нужны unit-тесты в этом случае?**

Быстрее проверить свои правки (новый и старый код).
Удостовериться, что ничего не сломано.

**Когда покрываем или не покрываем?**

Пишем unit-тесты всегда даже в тривиальных случаях с понятными комментариями.

Для компонентов с бизнес-логикой (что-то сложнее elvis-оператора):
- всегда пишем unit-тесты
- НЕ пишем snapshot-тесты или тесты на render-функцию

Для компонентов без бизнес-логики:
- пришем snapshot-тесты или тесты на render-функцию - на выбор
- при появлении бизнес-логики snapshot-тесты/тест-на-render-функцию удаляются, пишутся обычные unit-тесты

В случае самого простого компонента без логики можно написать простой тест, который проверяет, что компонент рисуется и не выбрасывает исключения.

### view-компоненты - корневые компоненты - App.js , index.js в рутах страниц

**Для чего нужны unit-тесты в этом случае?**

Эти файлы по умолчанию исключены из coverage.

**Когда покрываем или не покрываем?**

Никогда.

### mapStateToProps/connect

**Для чего нужны unit-тесты в этом случае?**

В mapStateToProps не нужно тестировать потому, что в ней должны быть только простые чтения стейта.
Если в mapStateToProps есть какая-то бизнес-логика и какие-либо вычисления на основе стейта, то эти бизнес-логику и вычисления вынести в отдельный HOC/селектор.

**Когда покрываем или не покрываем?**

Никогда.

### enhance, etc

**Для чего нужны unit-тесты в этом случае?**

Проверяем правильную комбинацию подготовленных пропсов:
- преобразование данных из стейта в пропсы
- добавление в пропсы внешней функциональности (i18n/etc)
- события и экшены, которые производят побочные эффекты - правильность работы побочных эффектов (мокаем экшены и прочие внешние части)

**Когда покрываем или не покрываем?**

Всегда

### reducer, selector

**Для чего нужны unit-тесты в этом случае?**

Проверить правильность сложных преобразований данных.

**Когда покрываем или не покрываем?**

Для селекторов:
- при наличии бизнес-логики (что-то больше, чем elvis-оператор) - покрываем всегда;
- при тривиальном чтении не покрываем;
- если в тривиальном селекторе появляется бизнес-логика, то убираем игнор и пишем тесты.

Для редьюсеров:
- при наличии бизнес-логики (что-то больше, чем elvis-оператор) - переделываем/рефакторим/декомпозируем/etc - редьюсеры должны быть тривиальными;
- при тривиальном редьюсере не покрываем.

Требования для  селекторов и редьюсеров, которые позволяют не писать тесты в тривиальных случаях:
- должна быть сохранена типизация (optional chaining).

### epic

**Для чего нужны unit-тесты в этом случае?**

Так как в epic'ах всегда сосредоточена бизнес-логика, то тестировать их нужно всегда - проверяем свою бизнес-логику.

**Когда покрываем или не покрываем?**

Экспериментально можно использовать marble-тесты (подробности есть у команды вендоров, начать можно с [Саши Качесова](https://staff.yandex-team.ru/kachesov-a).

## Серверная часть страниц

### resolver, resource

**Для чего нужны unit-тесты в этом случае?**

В резолверах может быть бизнес-логика по вызову нескольких ресурсов.

**Когда покрываем или не покрываем?**

Ресурсы не покрываем тестами - в них не должно быть логики, это просто конфиги для вызова бекенда. Если в ресурсе есть какая-то логика, то её нужно вынести в резолвер и покрыть тестами этот новый резолвер.

Для резолверов:
- при наличии сложной бизнес-логики (что-то больше, чем elvis-оператор/spread) покрываем всегда;
- в случае тривиальных вызовов ресурсов не покрываем.

### getInitialState / buildInitialState

**Для чего нужны unit-тесты в этом случае?**

Иногда в getInitialState/buildInitialState есть бизнес-логика.

**Когда покрываем или не покрываем?**

Для getInitialState/buildInitialState покрываем при наличии сложной бизнес-логики (что-то больше, чем elvis-оператор/spread).

# Общие ценности и прочие кейсы

#### Когда покрываем?
Наличие логики явно должно повышать вероятность того, что нужны тесты. Ветвления, циклы, доступ по индексу и прочее.

#### Когда не покрываем?
Если типизация явно покрывает кейс - достаточно вместо ```path(['foo', 'bar', 'baz'], state)``` написать селектор с elvis-оператором испрятать его в папке selectors и не тестировать mapStateToProps, например.

#### Когда использовать `shapshot`?
Редко. Основная цель снепшотов - не проверить правильность работы тестируемого кода, а то, что результат не изменился непреднамеренно. То есть когда нам не столь важно значение, сколько то, что оно не изменилось (сообщение об ошибке, верстка (но тут аккуратно) и т.д.). Причем снепшот должен быть очень маленьким и понятным, взять и запихнуть туда глубокую и сложную структуру данных - не вариант. Тесты же на конкретные значения лучше писать именно на ассертах.

#### Как прогнать нужные тесты и отобразить покрытие только на нужные файлы?
> В данном контексте под "паттерном" понимается шаблон поиска или glob pattern (см. [глоссарий](#глоссарий)).

Команда `npm run coverage` прогоняет тесты и собирает покрытие в соответствии с [jest.config.js](https://github.yandex-team.ru/market/partnernode/blob/master/jest.config.js). Её стандартное поведение можно изменить при помощи дополнительных аргументов (или флажков):

* `npm run coverage <паттерн пути до файла/папки>` — прогоняет только нужные тесты. \
Через пробел можно указать несколько паттернов: `npm run coverage <паттерн пути до файла/папки> <паттерн пути до файла/папки> ...` - тогда тесты будут запущены в соответствии с ними

* `npm run coverage <...> -- --collectCoverageFrom='["<паттерн пути до файла/папки>"]'` - собирает покрытие только для нужных файлов. \
Через запятую можно указать массив паттернов `--collectCoverageFrom='["<паттерн пути до файла/папки>", "<паттерн пути до файла/папки>", ...]'`

* `npm run coverage <...> -- --collectCoverageOnlyFrom=<путь до файла>` - собирает покрытие только для нужного файла (одного!) посредством указания пути (не паттерна!). \
Вроде как считается устаревшим, так что лучше использовать флажок из предыдущего пункта (оба флажка являются взаимоисключающими).

* `npm run coverage <...> -- --coverageReporters="text"` - отображает результаты покрытия прямо в консоль

В базовом случае имеем следующую команду:
```bash
npm run coverage <паттерн пути до файла/папки> -- --collectCoverageFrom='["<паттерн пути до файла/папки>"]' --coverageReporters="text"
```
Она тестирует только нужные файлы, собирает покрытие также только для нужных файлов и отображает результаты прямо в консоли.

##### Примеры

```bash
# Пример 1: протестировать один файл и показать только его покрытие в консоли
npm run coverage app/stout/pages/html/HtmlFulfillmentSupply/spec/getInitialState.spec.js -- --collectCoverageFrom='["app/stout/pages/html/HtmlFulfillmentSupply/getInitialState.js"]' --coverageReporters="text"

# Пример 2: как пример 1, только устаревший
npm run coverage app/stout/pages/html/HtmlFulfillmentSupply/spec/getInitialState.spec.js -- --collectCoverageOnlyFrom=app/stout/pages/html/HtmlFulfillmentSupply/getInitialState.js --coverageReporters="text"

# Пример 3: прогнать тесты и собрать покрытие для папки с файлами
npm run coverage app/stout/pages/html/HtmlFulfillmentSupply -- --collectCoverageFrom='["app/stout/pages/html/HtmlFulfillmentSupply/*.js"]' --coverageReporters="text"

# Пример 4: прогнать тесты и собрать покрытие для нескольких папок с файлами
npm run coverage app/stout/pages/html/HtmlFulfillmentSupply app/stout/pages/html/HtmlFulfillmentWithdraw -- --collectCoverageFrom='["app/stout/pages/html/HtmlFulfillmentSupply/*.js", "app/stout/pages/html/HtmlFulfillmentWithdraw/*.js"]' --coverageReporters="text"

# Пример 5: как пример 4, только лаконичнее
npm run coverage app/stout/pages/html/HtmlFulfillment{Supply,Withdraw} -- --collectCoverageFrom='["app/stout/pages/html/HtmlFulfillment{Supply,Withdraw}/*.js"]' --coverageReporters="text"
```

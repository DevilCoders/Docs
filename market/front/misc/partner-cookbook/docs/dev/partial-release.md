# Открытие функциональности на часть аудитории и АБ-тесты

## Проблематика и выбор

### Открытие функциональности на часть аудитории

Релизный пайплайн ПИ подразумевает, что весь код, который выложен на прод, доступен для исполнения всем магазинам. Соответственно, все фичи кабинета по умолчанию доступны всем магазинам (бизнесовые ограничения - по типу магазина, правам конкретного пользователя и прочее - пока оставим за скобками).

Но иногда нужно проверить какую-то гипотезу или выкатить в прод функциональность, которая готова лишь частично. В этом случае нам приходится в коде расставлять `if` и по каким-то признакам решать, доступна ли целевая функциональность конкретному магазину/пользователю при текущих условиях.

Исторически первый подход - хардкод условия такого `if` в коде. Например, хардкод списка магазинов, которым мы хотим показать эту функциональность, или проверка на "внутреннюю" сеть ("внутренняя" сеть - заходы из сетей Яндекса (wifi/провод/vpn), к которым магазины/пользователи не имеют доступа, то есть функциональность будет доступна только сотрудникам Яндекса).

Проблема этого подхода в том, что изменение условий (дополнить список магазинов или убрать ограничение на "внутреннюю" сеть) требует правок в коде и релиза ПИ. Так как требуются правки в коде, то подразумевается полный жизненный цикл задачи - правка кода, проведение ревью и регресса, тестирование, попадание в релиз и ожидание попадания релиза на прод. Это долго, и этот процесс сложно контролировать - если нужно открыться в среду ровно в 15:00 потому, что именно в это время начинается доклад на какой-то конференции, то подготовить и выложить релиз ПИ точно в нужное время является нетривиальной задачей.

Таким образом, в идеале вычисление условий доступности функциональности должно происходить таким образом, чтобы изменение этих условий происходило и применялось быстро.

### АБ-тесты

Вокруг ПИ АБ-тесты часто упоминаются как синоним частичного открытия функциональности, но на самом деле эти понятия нельзя подменять.

АБ-тест - это контролируемый эксперимент, когда мы проверяем нашу гипотезу на части аудитории.

Например, сейчас кнопка серая. А мы думаем, что если кнопку перекрасить в зелёный цвет, то это повысит конверсию кликов на эту кнопку. Тогда мы проводим АБ-тест - выделяем две группы среди всей нашей аудитории, фиксируем ожидаемое поведение метрик и срок проведения теста. Эти группы должны быть максимально похожими друг на друга (размер и характеристики участников). Одна группа продолжает видеть старую серую кнопку. Другая группа видит кнопку в новом зелёном цвете. Подождав заранее оговоренное время, мы смотрим на метрики и делаем вывод, помогло ли перекрашивание кнопки в зелёный цвет поднять клики по этой кнопке. Если помогло, то удаляем из кода эксперимент и перекрашиваем кнопку в зелёный для всех. Если не помогло, то просто удаляем из кода эксперимент и работаем дальше.

### Открытие функциональности на часть аудитории vs АБ-тесты

Ключевые отличия АБ-тестов от частичного открытия функциональности:
- состав групп
  - при частичном открытии у нас две группы - те, кто видят новую функциональность, и все остальные, и эти группы чаще всего не равны, и пользователи/магазины постепенно переходят из второй в первую;
  - при АБ-тестах одинаковость групп является критичным условием для правильной интерпретации метрик и результатов эксперимента;
- кульминация
  - кульминация АБ-теста состоит в принятии решения и модификации исходного кода - `if` будет удалён, и в коде останется только один из вариантов, чтобы применить изменения на всех или откатить к старому варианту (по крайней мере АБ-шница (см. ниже) рекомендует не раскатывать одну из веток АБ-теста на 100%, а удалять условие из кода);
  - кульминация частичного открытия - открытие функциональности на 100% аудитории, выпил `if` из кода является техническим долгом команды;
- назначение
  - АБ-тест нужен, чтобы проверить некоторую гипотезу, и потом действовать в зависимости от результатов теста;
  - частичное открытие функциональности нужно, чтобы провести "бета-тест" функциональности, получить обратную связь от пользователей/магазинов как можно раньше;

Таким образом:
- если у тебя есть гипотеза, которую нужно проверить через метрики, то тебе нужен АБ-тест;
- во всех остальных случаях тебе чаще всего требуется частичное открытие функциональности.

Применение АБ-тестов в ПИ - редкий случай, поэтому скорее всего он тебе не нужен.

## Частичное открытие функциональности

### Хардкоды в коде

Если тебе ок менять условия открытия функциональности через релизы ПИ, то ты можешь хардкодить эти условия в `if` прямо в коде по старинке. Но общепринятыми считаются описанные ниже методы.

### cocon

Подробно про cocon написано [здесь](../COCON.md).

#### Полезные чекеры для описания условий в cocon

На данный момент в cocon есть следующие чекеры, которые можно использовать для частичного открытия функциональности:
- `IS_INTERNAL_NETWORK` - возвращает `true`, если запрос пришёл из "внутренней" сети
- `ALLOWED_FOR_USERS` - возвращает `true`, если логин пользователя входит в заданный список
- `PROD_CAMPAIGN_ID` / `PROD_BUSINESS_ID` - возвращает `true`, если на проде/престейбле campaignId/businessId соответственно входит в заданный список, на деве и в тестинге всегда возвращает `true`
- `PROD_CAMPAIGN_IN_BUSINESS` - возвращает `true`, если на проде/престейбле campaign ID принадлежит бизнесу из заданного списка, на деве и в тестинге всегда возвращает `true`
- `???` - возвращает `true`, если campaignId/businessId попадают в указанный процент распределения, будет сделано в https://st.yandex-team.ru/MARKETPARTNER-41523

#### Частичное открытие страниц

Чтобы предоставить доступ к странице ограниченному кругу пользователей, нужно описать нужно условие в `states` этой страницы.

Если страница присутствует в боковом меню, то могут быть нюансы с открытием доступа на разные модели - при возникновении проблем лучше обсудить проблему в чате и обновить эту доку.

#### Частичное открытие функциональности на странице

Допустим, мы хотим частично открыть доступ к кнопке. Тогда для страницы в cocon можно описать новую `feature`, в `states` которой указать условие доступа к кнопке. В коде нужно добавить `if` с проверкой доступности новой фичи через `isFeatureAllowed`.

### Бункер

#### settings

В [динамических настройках](./settings.md) можно описать новую настройку с описанием условия доступности функциональности в произвольной форме. А в коде добавить получение и анализ значения этой настройки.

#### makeCheckFeatureFlagInBunker

Эта функция является обёрткой над [динамическими настройками](./settings.md) специально для частичного открытия фичи.

Для начала нужно создать новую динамическую настройку вида
```(javascript)
{
  /** Открыть только на внутреннюю сеть. */
  enabledForInternalNetwork: false,

  /**
    Список ID, на которые открывается функциональность.
    Это могут быть как shopId, так и campaignId, и businessId.
    Подробнее будет написано ниже.
  */
  enabledFor: [123, 456],

  /**
    Список ID, на которые принудительно отключается функциональность.
    ID такие же, как в enabledFor.
  */
  disabledFor: [777, 888],

  /**
    Процент магазинов, на которые открывается функциональность.
    Подробности в https://st.yandex-team.ru/MARKETPARTNER-41522
  */
  enableForPercentage: 33,

  /** Открыть функциональность на всех. */
  enabledForAll: false,
}
```

В коде нужно вызвать функцию `makeCheckFeatureFlagInBunker`, передав ей название созданной настройки и номер тикета на выпил настройки. Функция вернёт новую функцию-геттер значения флага открытия. Функция-геттер на вход получает Мандрель-контекст и ID сущности (shopId / campaignId / businessId), этот ID будет учитываться при обработке enabledFor / disabledFor).

Пример:
```(javascript)
// Настройка в Бункере - 'my-super-setting'
const bunkerSettingValue = {
  ticketToRemove: 'MARKETPARTNER-45678',
  enabledForInternalNetwork: true,
  enabledFor: [2312432, 2123322, 2355533, 112243432, 1123232],
  enableForPercentage: 10
};
// Это значение следует читать как:
// - при заходе из внутренней сети - открыто
// - если к нам пришёл магазин с campaignId одним из 2312432, 2123322, 2355533, 112243432, 1123232 - открыто
// - если campaignId попал в 10% - открыто (подробности в https://st.yandex-team.ru/MARKETPARTNER-41522)
// - во всех остальных случаях функциональность недоступна

// Получение факта открытия.

// На сервере
const checkIsFeatureOpen = makeCheckFeatureFlagInBunker('my-super-setting', 'MARKETPARTNER-45678');
const isFeatureOpened = await checkIsFeatureOpen(ctx, {id: campaignId});

// На сервере или на клиенте
if (isFeatureOpened) {
  // Рисуем кнопку или делаем что-нибудь - функциональность доступна.
}
```

После того, как функциональность открыта на всех, и решено, что обратного закрытия уже не будет, то нужно удалить использование настройки из кода, а потом удалить настройку из Бункера в рамках указанного в вызове `makeCheckFeatureFlagInBunker` тикета.

### cocon vs Бункер

Если нужно настроить частичное открытие целой страницы, то нужно использовать cocon.
Если нужно настроить частичное открытие функциональности на странице, но функциональность имеет бизнесовые ограничения на доступ (например, только для FBS), то нужно по возможности использовать cocon, чтобы не размазывать условия доступа до фичи по двум хранилищам (cocon и Бункер).
В остальных случаях можно использовать как cocon, так и Бункер.

Но нужно понимать, что и cocon, и Бункер имеют свои недостатки и достоинства:
- релиз настройки Бункера занимает несколько минут
- релиз настройки cocon занимает от часа до дня - зависит от очереди релизов и проблем на тестинге

## АБ-тесты

### АБ-тесты через АБшницу

АБшница - это внутренний сервис Яндекса для проведения АБ-тестирования. Подробнее [здесь](https://docs.yandex-team.ru/experiments/experiments-guide/).

Интеграция с АБшницей делается в https://st.yandex-team.ru/MARKETPARTNER-38448

По результату интеграции эта дока будет дополнена.

### АБ-тесты через YT-таблицу

Для организации АБ-тестов(экспериментов) в Партнерском интерфейсе необходимо:
1. Добавить эксперимент в таблицу в YT (можно сперва для тестинга `environment=testing`, потом для продакшена `environment=production`.
   Договорится с аналитиками о вариантах(сплитах) нового эксперимента.
   Сейчас эксперименты в разрезе магазинов загружаются в таблицу в YT.
   [Текущая таблица в YT](https://yt.yandex-team.ru/hahn/navigation?path=//home/market/production/mstat/analyst/regular/experiments/splits). Проконсультироваться можно с Ритой Голуб [@ritagolub](https://staff.yandex-team.ru/ritagolub)
2. Из YT данные по экспериментам по расписанию регулярно забираются таскером и складываются в соответствующий бакет в mds (в тестовую ветку:
   `https://s3.mds.yandex.net/marketpartner/taskr/jobs/partner-experiments/testing`)
   Код таскера с докой от Артура [тут](https://github.yandex-team.ru/market/taskr).

   Интерфейс, где можно увидеть проверки есть ли изменения и забор данных, находится [здесь](http://pvl4xz4kjvzsvrqj.sas.yp-c.yandex.net/queues). Пример данных по экспериментам, приходящим из YT:
   ```
   [
      {
         client_id: 325076,	// если понадобится эксперимент в разрезе клиентов, то он сведётся к заданию данных всем магазинам одного клиента
         date_from: '2021-07-01',
         date_to: '2022-10-11',	// завершенные эксперименты не заираем в mds
         environment: 'testing',   // testing/production - для разграничения для какой среды эксперимент
         exp_id: 18025,	// id эксперимента
         is_active: 1,	// 1 - активный эксперимент, 0 - не активный. Забираем только активные эксперименты
         shop_id: 774,
         test_id: 936294   // вариант(id) теста/ветки/сплита эксперимента
      },
      {
         client_id: 325076,
         date_from: '2021-07-01',
         date_to: '2021-12-11',
         environment: 'production',
         exp_id: 11111,
         is_active: 1,
         shop_id: 774,
         test_id: 555555
      },
      {
         client_id: 325076,
         date_from: '2021-07-01',
         date_to: '2021-12-11',
         environment: 'testing',
         exp_id: 11111,
         is_active: 1,
         shop_id: 774,
         test_id: 555555
      }
   ]
   ```

   При изменении YT-таблицы данные выгружаются в тестовую ветку в MDS автоматически и становятся доступными в ПИ примерно через 5-10 минут.
   Для публикации в продакшн надо в интерфейсе нажать кнопку выгрузки для partner-experiments (меню слева: partner-deploy -> таб: DELAYED -> кнопка с обратной стрелкой: promote для экспериментов именно). [скриншот](https://jing.yandex-team.ru/files/alexkhait/2021-10-11T10:57:42Z.55fb007.png).
   При этом обновится бакет в mds (продакшн ветка: `https://s3.mds.yandex.net/marketpartner/taskr/jobs/partner-experiments/production`).

   Полезные ссылки по mds
   - wiki: https://wiki.yandex-team.ru/mds/
   - Telegram support chat: https://t.me/joinchat/Bbsak0DREDckUOGhK-m3aw
   - Telegram Emergency chat (в случае срочных проблем затрагивающих живых пользователей в production): https://t.me/joinchat/Lz2_8w1qRw7-PDRGLP3b3w
   - графики:
   https://yasm.yandex-team.ru/template/panel/s3_mds_nginx/bucket=marketpartner
   https://yasm.yandex-team.ru/template/panel/s3_client/bucket=marketpartner;owner=31528/8/?range=2592000000

3. Из mds данные забираются Партнёркой
- при сборке приложения
- по расписанию, проверяя были ли изменения

4. В HtmlPage данные по экспериментам попадают в State в отдельную ветку experiments, откуда их дальше можно использовать.
   Есть [хелперы](https://github.yandex-team.ru/market/partnernode/blob/master/shared/utils/experiments) для определения в какую ветку эксперимента попал магазин.
   Есть [селектор](https://github.yandex-team.ru/market/partnernode/blob/master/client.next/components/Experiment/selectors.tsx) и [компонент](https://github.yandex-team.ru/market/partnernode/blob/master/client.next/components/Experiment/index.tsx) для отрисовки элемента интерфейса, в котором определяется попали ли в нужный вариант и нужно ли его показать.

5. Разработчику необходимо реализовать заказанные варианты блоков интерфейса или поведения для разных веток эксперимента. Пример использования компонента:
   ```jsx
       <Experiment
           exp={EXAMPLE_EXP_1}
           testId={EXAMPLE_EXP_1.branches.EXAMPLE_BRANCH_1}
           impl={<ExpExample1ComponentV1 />}
       />
       <Experiment
           exp={EXAMPLE_EXP_1}
           testId={EXAMPLE_EXP_1.branches.EXAMPLE_BRANCH_2}
           impl={<ExpExample1ComponentV2 />}
       />
       <Experiment exp={EXAMPLE_EXP_1} testId={EXAMPLE_EXP_1.branches.EXAMPLE_BRANCH_3} defaultTest={true} />
   ```
   подробнее пример в коде [тут](https://github.yandex-team.ru/market/partnernode/pull/14587/files).
   Что бы покрыть все магазины, включая, например, новые, один из сплитов(веток эксперимента) назначается дефолтным `defaultTest=true` и будет использоваться как для магазинов, попавших явно в этот вариант, так и для тех, кто не попал никуда.
   Для конкретной ветки может быть как отрисован свой вариант интерфейса, так и не отрисовано ничего.

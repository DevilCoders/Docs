# Кэширование в удалённых резолверах

В ПИ есть возможность кэшировать результаты данных, полученных через remote resolvers из mandrel.
Это механизм позволяет сократить количество обращений к бэку, что может существенно сэкономить время. В лучшем случае это может привести к исключению похода по сети, минус бизнес-логика бэка, минус поход в БД на бэке.

В то же время с великой силой приходит великая ответственность, о чем позже.

## Параметры кэширования

В нашем случае кэширование определяется тремя параметрами - уровень кэширования, ключ кэширования и иногда время жизни кэша.

Доступно [три уровня](https://github.yandex-team.ru/market/mandrel/blob/cec6b514a3dc4041a0ab7f35fdab92c7d92dd584/src/resolver/index.js#L51-L81) кэширования - request, worker и shared. Механизмы реализованы в нашей библиотеке [market/cache](https://github.yandex-team.ru/market/cache).

### Request

Как легко догадаться, это кэш, чьё время жизни связано с временем жизни запроса. Можно считать, что в рамках одной трассировки каждая ручка будет вызвана только один раз. Ну, для каждого из ключей кэширования, разумеется.

В рамках [объекта запроса](https://github.yandex-team.ru/market/cache/blob/a402c26bff1916a971c079bfdf89b0cad912172f/src/request.js#L11) создаётся объект.
С помощью переданной функции makeKey вычисляется ключ и такое значение [ищется в объекте](https://github.yandex-team.ru/market/cache/blob/a402c26bff1916a971c079bfdf89b0cad912172f/src/request.js#L27).
Функция `key` помечена в мандреле как [mixed](https://github.yandex-team.ru/market/mandrel/blob/cec6b514a3dc4041a0ab7f35fdab92c7d92dd584/src/resolver/index.js#L61), но это, судя по коду, не так, и она должна отдавать строку.

```javascript
export const fooSuggestResolver = createResolver(
    async (ctx: Context, dto: Args): Promise<string[]> => {
        ...
    },
    {
        name: 'fooSuggestResolver',
        cache: {
            level: 'request',
            // Формируем ключ на основе имени сервера, имени дёргаемой ручки, id кампании и поисковой строки
            key: (_, dto: Args) => ['yandexShmetrica', 'fooSuggestResolver', dto.campaignId, dto.searchString || ''].join('-'),
        },
    },
);
```

Идеален, когда не хочется заботиться о времени жизни значений в кэше и в то же время происходит ряд мелких одинаковых запросов.

Хороший пример: Извлечение shopId по campaignId. Когда ради построения страницы приходится сходить в 50 ручек и 30 из них принимают campaignId, а 20 - принимают shopId и код в них выглядит как "сначала вызови getShopId(campaignId), потом с этим shopId уже иди в ручку". Резолвер getShopId стоит закэшировать на уровне request.

Плохой пример: Кэшировать то, что извлекается один раз за запрос, например, страница списка заказов. Будь то построение initial state или запросы страниц через удалённые резолверы - всё равно на один http-запрос будет только 1 обращение к ручке списка.

### Worker

Тип кэширования worker живёт в процессе ноды. То есть кэш потенциально сохраняется до перезапуска (с учётом ttl) и доступен только в одном инстансе. Включает в себя уровень кэшировани request, то есть любое значение, которое мы запрашиваем, сначала будет искаться в request и если не найдено - то будет искаться в lru-кэше, живущем в процессе ноды. Кэш привязывается к name резолвера, так что его тоже важно указывать, если не хотим пересечений. Для lru-кэша надо указать сколько значений будем держать в памяти (свойство capacity в настройке кэша).

```javascript
export const fooSuggestResolver = createResolver(
    async (ctx: Context, dto: Args): Promise<string[]> => {
        ...
    },
    {
        name: 'fooSuggestResolver',
        cache: {
            level: 'worker',
            // ёмкость lru-кэша
            capacity: 50,
             // пять минут живёт кэш
            ttl: 60 * 5,
            // Формируем ключ на основе имени сервера, имени дёргаемой ручки, id кампании и поисковой строки
            key: (_, dto: Args) => ['yandexShmetrica', 'fooSuggestResolver', dto.campaignId, dto.searchString || ''].join('-'),
        },
    },
);
```

При выборе ёмкости надо отталкиваться от размера кэшируемых объектов, ибо память конечна. Также при выборе ёмкости надо помнить, что смысл lru кэша - это вытеснение редкозапрашиваемых значений. Соответственно, если у вас тяжёлые объекты, которых больше 10 в память не засунешь, и при этом вообще в базе их лежит 1000 штук, и при этом спрашивают их примерно равномерно, то кэшем никто не будет успевать пользоваться.

Хороший пример - кэшировать запрос типа "сколько заказов на маркете за день было создано". Чаще всего спрашивают, наверное, за вчерашний день. Ну ещё позавчерашний. Ну ещё значение типа "ровно 7 дней назад". Можно сделать кэш, где capacity = 10 и ключ - дата.

А вот кэшировать "сколько заказов было создано в конкретной кампании" в lru-кеше особого смысла также нет. Кампаний тысячи, спрашивать будут примерно равномерно, ключей вида `${campaignId}_${date}` будет очень много. Хотя можно капасити в 20000 установить, инты в память поместятся ))).

Плохой пример - это кэшировать какой-нить супер-объект содержащий список всех товаров пользователя. В память много таких списков не засунешь (ну, штук 10), при этом на конкретный инстанс с равной вероятностью может попасть любой из 1000 текущих пользователей, работающих прямо сейчас с партнёркой. В результате переиспользования кэша происходить не будет, новые запросы будут вытеснять старые данные. Только память зря потратим.

Также плохой пример - это кэшировать getShopId из предыдущего примера. Пусть размер данных невелик, но вероятность попадания запросов на машины примерно одинакова, соответственно, значения в кэшах будут постоянно вытесняться новыми значениями. Ну, либо нужно capacity сделать примерно равным числу активных кампаний.

> Вообще (мысли вслух), я сейчас не очень понимаю, насколько полезен кэш в воркере. У нас 30 инстансов, на каждом из которых 10 процессов ноды. Каждый из этих 300 процессов надо "прогреть". Если вы положили значение в 5-й процесс на шестом инстансе, а следующий запрос попал на 8-й процесс в 24-м инстансе, то, очевидно, запрос снова пойдёт в бэк за данными. Выглядит так, как будто в worker имеет смысл класть только то, что очень часто запрашивается (тогда все 300 воркеров быстро прогреются и быстро начнут отдавать данные из кэша). Хороший пример - значение какой-нить настройки "показывать ли в заголовке новую экпериментальную кнопку", извлекаемое из бункера. Для заголовка они будут запрашиваться на каждой странице. Или ещё пример - курс валют, выводящийся в футере.

### Shared

Тут используется сервис memcached, который у нас есть общий, для всего фронта маркета. В данном случае это означает, что если один инстанс во Владимире положил что-то в кэш, то воспользоваться этим значеним может не только соседний инстанс в том же Владимире, но и инстансы из Сасово, например.
Здесь также имеет смысл указание времени жизни кэша.
В функцию вычисления ключа, так же, как и в сам резолвер, передаются контекст и dto аргумента. На их основе надо сформировать уникальный ключ.
Помните, что если вы неверно сформируете ключ - например, забудете использовать в нём campaignId, - то данные одного магазина могут утечь в другой и показываться там. И исправить это можно только хотфиксом.
Можно почистить кэш (весь, или точечно). Пример есть у [mbi](https://wiki.yandex-team.ru/mbi/development/howto/flushmemcached/). Адреса серверов, очевидно, надо заменить на наши ([тестинг](https://github.yandex-team.ru/market/partnernode/blob/dc56d68ebd7d364394f82b8e0cedcfad2d8262f2/configs/testing/node.js#L58),[прод](https://github.yandex-team.ru/market/partnernode/blob/dc56d68ebd7d364394f82b8e0cedcfad2d8262f2/configs/production/node.js#L36)). Очевидно, сбрасывать memcached до выкатки хотфикса с правильным ключом, никакого смысла нет - оно будет вновь записано при первом же последующем обращении.

```javascript
export const fooSuggestResolver = createResolver(
    async (ctx: Context, dto: Args): Promise<string[]> => {
        ...
    },
    {
        name: 'fooSuggestResolver',
        cache: {
            level: 'shared',
             // пять минут живёт кэш
            ttl: 60 * 5,
            // Формируем ключ на основе имени сервера, имени дёргаемой ручки, id кампании и поисковой строки
            key: (_, dto: Args) => ['yandexShmetrica', 'fooSuggestResolver', dto.campaignId, dto.searchString || ''].join('-'),
        },
    },
);
```

Здесь хороших и плохих примеров не будет, потому что к shared можно относиться как к worker, но на стероидах. Про capacity можно считать, что оно бесконечное, это плюс. С другой стороны memcached это всё ещё lru-кэш, поэтому может оказаться, что ваш конкретный кэш чистится, но вы не знаете когда, это минус.
Хотя нет, хороший пример будет. Например, это описание параметров в категории товаров в каталоге. Категория "Мобильные телефоны", там 100500 параметров - и поддерживаемые диапазоны, и кол-во экранов, и размер памяти... Категорий конечное число, они общие на весь маркет, есть наиболее популярные, описание параметров категории это большой джисон и отдаётся с бэком с трудом - вот идеальный кандидат на shared кэширование.

Где следить за мемекешом: [прод](https://grafana.yandex-team.ru/d/000018137/market-memcached?refresh=1m&orgId=1&var-group=cache-bots0%3F%3F_market_yandex_net&var-port=21239), [тестинг](https://grafana.yandex-team.ru/d/000018137/market-memcached?refresh=1m&orgId=1&var-group=cache0%3F%3Ft_market_yandex_net&var-port=21239).
Начать проще всего с Bytes in memcached (заполненость мемкеша) и с Evictions (вымывания значений - в идеале их должно быть немного).


## Общие правила

Помните, что применять кэширование при post-запросах это точно не то, чего вы хотите. Даже у двух полностью одинаковых запросов может быть разный результат - первый вставит строку, второй скажет "такое значение уже есть". И вы хотите увидеть вот это "уже есть".

В ключе кэширования обязательно должно быть campaignId или shopId. Или хотя бы uid, если это какая-то общая не-кампанейская страница. Потому что показывать чужие данные это явно идея так себе.

Помните, что любая ошибка при кэшировании исправляется только новым релизом. Всё это время пользователи будут видеть неверные данные. Лучше пусть страница будет открываться 20 секунд или один раз из трёх, чем открываться мгновенно, но неверно.

Итого, **если есть сомнение, кэшировать или нет - значит не кэшировать**. Не форсируйте события, если не уверены. Пусть к вам придёт дежурный и скажет "всё пропало, надо что-то делать".

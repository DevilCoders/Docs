# Общие сущности

На файловой системе сущности хранятся в структуре вида:

- `entityName`
    - **actions** —  экшены, для управления общей коллекцией сущности. Например, здесь может быть экшен updateEntityCollection. А вот экшену для получения нового инстанса этой сущности из ресурсов тут не место, ведь после получения ответа появляется id сущности, который может быть необходим в бизнес-логике, а реакции общих сущностей не могут быть зависимы (импортировать модули) бизнес-логики (читай "страниц").
    - **atoms** — атомы сущности. Прежде всего, тут должен быть `entityAtom`. Общая договоренность гласит, что этот атом должен быть ассоциативным массивом с ключами сущностей и значениями в виде инстансов сущности, других полей и возможности их добавить тут быть не должно. Получается, тип хранилища этого атома — `EntityCollection`. Может быть подписан, например, на `updateEntityCollection`.
    - **getters** описывают получение полей из инстанса сущности. Крайне примитивны, имеют нейминг вида `getEntityProperty`.
    - **helpers** могут хранить более изощренные инструкции по взаимодействию над сущностью. Еще хелперы могут содержать типизированную инструкцию по нормализации данных.
    - **index** — модуль вида `export * from './module';`. Создается исключительно для удобства. Отдельного внимания заслуживает тот факт, что при взаимном импорте модулей друг друга могут возникнуть циклические зависимости.
    - **schema** — схема для normalizr для нормализации сущности с бэкэнда.
    - **selectors** — набор правил для извлечения сущностей из стора.
    - **types** — основные декларации TypeScript. Прежде всего, это `EntityId`. Это может быть как `number`, так и `string`. `Entity` — описание инстанса сущности после нормализации. Поля `id: EntityId` и `entity: 'entityName'` тут обязательны. Также тут может содержаться тип `DenormalizedEntity` для описание сырого ответа сущности с бэкэнда. Можно домешивать кастомные поля в фронтовую сущность, например, ссылки на другие сущности, даже если бэкэнд этого не предусматривает. Не обязательно примешивать все поля из денормализованной сущности во фронтовую сущность. Важно отметить, что отсутствие любого поля на бэке — это `null`. В JavaScript `null` обозначает отсутствие значения объекта, а `undefined`  для скалярных значений. Во фронтовых сущностях это правило нужно использовать: оно позволяет избегать ошибки при расширении инстансов.

Общий принцип таких сущностей: они могут импортировать друг друга, но не могут импортировать модули из ресурсов или страниц. Общие сущности — это независимое ядро, откуда начинается бизнес-логика.

Если нужно достать инстанс из коллекции, стоит пользоваться исключительно селекторами; если нужно достать значение из инстанса — геттерами.

Если сущность существует только на фронте (например, пока не сохранена, общепринятым решением считается добавление флага `isVirtual`. Пример: https://a.yandex-team.ru/arc/trunk/arcadia/market/infra/market-planner/webapp/src/pages/specials/containers/AddSpecializationButton/creatingSpecialization/actions.ts?rev=7517229#L22.

# Общий путь данных

Визуальные компоненты получают данные из атомов при помощи селекторов, данные попадают в атомы либо из страничных контроллеров, либо при эммите экшенов и обработкой редьюсерами тела атомов, те в свою очередь обращаются за данными в ресурсы.

Все атомы в проекте можно поделить на большие две части:

- **Общие атомы** (к ним относятся коллекции сущностей и абстрактные общие виртуальные сущности типо проверки форм)
- **Страничные атомы** (эти атомы содержат списки айдишников сущностей и атомы для мелкой бизнес логики типо получения данных при применении фильтра)

Данные в общих сущностях хранятся в виде ассоциативного массива, где ключ — уникальный айдишник сущности, а значение — инстанс сущности, открытый для чтения не расширения, но закрытый для удаления.  Любая часть приложения, имеющая доступ к стору, может получать эти данные по ключам.

## Нормализация
Данные из бэкэнда нужно нормализовать, следуя общей схеме. Для нормализации используется `normalizr`, однако его функциональности и типизации недостаточно. Поэтому для нормализации следует использовать хелпер `normalizeEntities`. Пример:
```(typescript)
import {DenormalizedDepartment, DepartmentCollection, DepartmentId} from './types';
import {departmentSchema} from './schema';
import {normalizeEntities} from '../utils';

const _normalizeDepartments = normalizeEntities<DenormalizedDepartment>([departmentSchema], ['department']);
export const normalizeDepartments = (rawResponse: DenormalizedDepartment[]): {
    result: DepartmentId[],
    collections: {
        department: DepartmentCollection,
    },
} => _normalizeDepartments(rawResponse);
```

Важно, что в текущем решении нужно вручную указать название сущностей из схемы (тут %%['department']%%), чтобы в случае отсутствия этих данных добавить пустые; кроме того, поле `result` из `normalizeEntities` -- всегда массив.

# Абстрактные сущности

Кроме продуктовых существуют и абстрактные общие сущности, которые можно хранить в коллекциях. Такими являются, например, `adjustment` и `fieldValidation`.

Если какой-то код повторяется из раза в раз и его можно представить в виде сущности, сохранив в сторе, стоит вынести его наверх в общую папку `entities`.

## Adjustment

Часто в бизнес-логике возникает задача временно изменить состояние конкретного инстанса сущности, но мутировать исходные поля инстанса запрещено. Для этого вполне подходит некий черновик, который можно сохранить в общем хранилище.

## FieldsValidation

Существует тонна подходов к проверке форм. Конкретно во фронте Планнера используется собственное решение, которое прекрасно дружит с Левитаном для отображения ошибок, при этом привязано к существующим сущностям.


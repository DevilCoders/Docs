# Что это
Утилита, которая позволяет подготовить логшаттер к нагрузочному тестированию.
В существующем сценарии нагрузочного тестирования данные должны литься в никем не используемые таблицы, схемы
которых эквивалентны некоторому подмножеству настоящих таблиц. Т.е. с одной стороны мы хотим работать с новыми
таблицами, о которых никто не знает из пользователей вельдеров, чтобы не испортить никому жизнь, заливая какой-то треш
в настоящие таблицы, по которым строит графики кликфит, например, или кто-то запускает через yql какие-то свои
аналитические запросы. А с другой стороны мы хотим, чтобы эти новые таблицы были эквивалентны по структуре
существующим таблицам, чтобы в них можно было заливать данные, похожие на реальные (вероятнее всего даже взятые из
реальных топиков логброкера). А для этого нам нужно иметь в health-ui отдельный проект `market-health-loadtesting`,
в котором бы хранились конфиги логшаттера для нагрузочного тестирования, которые бы были в основном эквивалентны 
конфигам, на которым они основаны, но при этом были бы отличия:
1. имя конфигов было бы таким же, как у оригиналов, но был бы добавлен суффикс `__market_health_loadtesting`. Т.е.,
например, при преобразовании конфига с именем `abo-bpmn` должен появиться конфиг с именем
`abo-bpmn__market_health_loadtesting`
2. вместо чтения из топиков, указанных в оригинальных конфигах, чтение у конфигов для нагрузочного тестирования должно
происходить из топика [loadtesting](https://lb.yandex-team.ru/logbroker/accounts/market-health-stable/loadtesting)
3. запись должна вестись в таблицу с таким же именем, как в оригинальном конфиге, но только с добавлением суффикса
`__market_health_loadtesting`. Т.е. если оригинальный конфиг пишет данные в таблицу `abo_bpmn_nginx`, то конфиг для
нагрузочного тестирования должен писать данные в таблицу `abo_bpmn_nginx__market_health_loadtesting`

# Как собрать
Находясь в примонтированном образе Аркадии в текущей папке (в которой находится данный README) выполнить команду:
```
ya make
```
Т.е. всё стандартно для Аркадии.
После выполнения сборки появится символическая ссылка `logshatter-configurer` на исполнимый файл, который можно
запускать.

# Что необходимо иметь перед запуском
Нужен OAuth токен для API Health.UI, про получение которого можно прочитать
[тут](https://wiki.yandex-team.ru/market/development/health/health-ui/#avtorizacija). Его необходимо будет записать
в переменную окружения `MARKET_HEALTH_OAUTH_TOKEN`. Т.е. выполнить в консоли вот такую команду:
```bash
export MARKET_HEALTH_OAUTH_TOKEN=значение_токена
```

# Как запускать
Утилита вычитывает из стандартного потока ввода построчно имена конфигов, для которых необходимо создать аналоги,
которые будут использоваться в нагрузочном тестировании, и создаёт их. Утилите необходимо передать обязательный аргумент
командной строки `env`, который может быть равен значениям `testing` или `production` - как и следует из названия, этот
аргумент определяет выбор балансировщика, с которым работает утилита. В случае `testing` работа будет происходить с
балансировщиком https://health-testing.market.yandex-team.ru, а в случае `production` с
https://health.market.yandex-team.ru. Пусть, например, в файле `configs.txt` выписаны названия конфигов, для которых
нужно иметь аналоги, котоые будут использоваться в нагрузочном тестировании. И пусть мы хотим создать их в тестинге.
В таком случае нужно выполнить следующую команду:
```bash
cat configs.txt | ./logshatter-configurer -env testing
```

После создания конфигов утилита их публикует и активирует. Если на момент выполнения утилиты целевые конфиги уже
существуют, то в них создаётся новая версия на основе текущей активной версии оригинальных конфигов. Если версия,
которая должна быть создана, эквивалентна текущей активной версии целевых конфигов, то новая версия не создаётся. Таким
образом утилита старается синхронизировать целевые конфиги с их оригиналами по состоянию на текущий момент и при этом
старается не создавать лишние версии, если можно этого не делать.

В конце работы утилита выводит статистику по количеству обработанных конфигов и выводит список тех, при обработке
которых произошли ошибки. Этот список можно прям брать и копировать в новый входной файл, который можно подавать на вход
утилите. Это может быть полезно, если ошибки были какие-то временные и можно снова попробовать. Информация об ошибках
также выводится.
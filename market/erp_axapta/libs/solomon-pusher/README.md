## Вводная про solomon-pusher
### Что такое solomon-pusher
По сути это набор python- и sql-скриптов для выполнения ряда задач по мониторингу различных данных.

### Что умеет solomon-pusher
Все основные функции так или иначе связаны с выполнением произвольного sql-запроса в произвольной реляционной БД и последующей обработкой результатов.

Что можно сделать с результатами выполнения sql:
1. Запушить данные в [Solomon](https://wiki.yandex-team.ru/solomon/) в качестве значения сенсора. Далее возможности расширяются до стандартных плюшек Соломона: можно настроить графики по значениям сенсора в Графане, можно настроить алерты, можно настроить нотификацию об алертах через e-mail, juggler, TG и др.
2. Отправить данные по e-mail в виде CSV-файла
3. Создавать/изменять/закрывать тикеты в StarTrek по данным из sql. Например, можно реализовать постановку тикета на исправление проблемы, которую обнаружил sql-запрос. Можно настроить, чтобы тикет автоматически обновлялся при изменении характера проблемы, или закрывался, если проблема "рассосалась".

Перечисленный функционал настраивается для регулярной работы с нужным расписанием (по крону).

## Структура проекта
### Сервисы
Все источники данных в проекте разбиты по т.н. сервисам (services). Например, sql-скрипты для получения данных из БД чекаутера принадлежат сервису checkouter, а для БД Аксапты - сервис erp. Поэтому все sql-скрипт и настройки источников данных лежат в папках **[services](services)/{название_сервиса}**

Для каждого сервиса обязательно присутствует конфигурационный файл **services/{название_сервиса}/{название_сервиса}.cfg**, содержащий настройки сервиса. Настройки сервиса определяют поведение скрипта, работающего в контексте этого сервиса.

В каждом сервисе как правило введена дополнительная иерархия подпапок, в которых хранятся уже непосредственно sql-скрипты. Это нужно для лучшей организации sql-кода. Обычно иерархия подпапок соответствует некой функциональной классификации внутри сервиса. Например, в сервисе [checkouter](services/checkouter) есть подпапки ff (функционал фулфиллмента), payments (платежи), delivery (доставка). Рекомендуется следовать этому принципу.

### crontab
В корне проекта расположен файл [crontab](crontab), в котором настраиваются все запуски скриптов solomon-pusher под конкретные нужды по обработке данных. Это стандартный файл для [unix-планировщика cron](https://ru.wikipedia.org/wiki/Cron). В каждой строчке содержится расписание запуска и команда для запуска.

## Конфиг
Для каждого сервиса обязательно присутствует конфигурационный файл **services/{название_сервиса}/{название_сервиса}.cfg**, в котором описываются настройки подключения к БД, Соломону, StarTrek и др. Дополнительно можно использовать локальный конфигурационный файл **services/{название_сервиса}/local-{название_сервиса}.cfg**, который оверрайдит настройки из основного конфига. Локальный конфиг не хранится в репозитории. Он полезен для дополнения или переопределения настроек на локальной машине (другие настройки подключения к БД, хранение секретных токенов и паролей). 

Конфигурационный файл имеет структуру:

```
[Имя_раздела_1]
key1=value1
key2=value2
...

[Имя_раздела_2]
key1=value1
key2=value2
...
```
Пример конфига: [services/checkouter/checkouter.cfg](services/checkouter/checkouter.cfg)

### Раздел Datasource
Раздел определяет настройки соединения с БД для выполнения SQL-запроса
```
[Database]
driver=psycopg2
connectURL=postgresql://user:pwd@host:port/db_name?ssl=true&sslmode=require
```
  * `driver` определяет драйвер БД:
    - `psycopg2` - Postgres
    - `pymssql` - MS SQL Server
  * `connectURL` определяет коннекшн-строку с указанием хоста, порта, имени БД, логина и пароля для соединения с БД; формат коннекшн-строки зависит типа БД

### Раздел Solomon
Раздел определяет настройки проекта в Соломоне, куда будут пушиться значения сенсоров
```
[Solomon]
project=marketplace
cluster=production
service=checkouter
```
  * `project` - название проекта в Соломоне; для Беру/Bringly используется проект `marketplace`
  * `cluster` - название кластера в Соломоне; сейчас заведен только один `production`
  * `service` - название сервиса в Соломоне

## Скрипты
### [push-sensor-value.py](push-sensor-value.py)
Выполняет sql-запрос и пушит результаты в Соломон в виде числового значения сенсора. Результат sql-запроса определяет набор сенсоров и их значений во времени, которые нужно запушить в Соломон. 

Для упрощения вызова скрипта есть shell-скрипт-напарник [push-service-sensor.sh](push-service-sensor.sh), принимающий следующие параметры:
  1. `-l` - опциональный параметр-флаг, включающий логирование скрипта в файл лога, находящийся в папке logs на машине выполнения
  2. <название_сервиса> - определяет конфиг и папку, в которой хранится sql-запрос
  3. <название_сенсора> - определяет путь к файлу sql-запроса относительно папки сервиса (без расширения .sql)
  
**Пример вызова скрипта:**
```
./push-service-sensor.sh -l checkouter /order-status/order-statuses
```
Такой вызов возьмет sql-скрипт [services/checkouter/order-status/order-statuses.sql](services/checkouter/order-status/order-statuses.sql) (запрос считает количество заказов в разрезе статусов и цвета), выполнит его в БД, указанной в конфиге сервиса checkouter [services/checkouter/checkouter.cfg](services/checkouter/checkouter.cfg), и запушит результаты запроса в Соломон.

SQL-запрос должен возвращать такие обязательные столбцы:
  * `sensor` - название сенсора в Соломоне; по соглашению название сенсора должно совпадать с путем к SQL-файлу (без расширения .sql), относительно папки сервиса
  * `ts` - unix-таймстамп для значения сенсора
  * `value` - числовое значение сенсора

Кроме обязательных столбцов можно дополнительно указать столбцы для разрезов (лейблов) значения сенсора. В примере с [services/checkouter/order-status/order-statuses.sql](services/checkouter/order-status/order-statuses.sql) разрезами являются статус, подстатус и цвет заказа. Соответственно для каждого разреза (лейбла) нужно возвращать отдельный столбец, указав ему название, которое будет запушено в Соломон в виде лейбла.

Таким образом каждая строка результатов SQL-запроса содержит данные для сенсора, который нужно запушить: имя сенсора, таймстамп значение, само значение сенсора и конкретные значения разрезов (лейблов).

### [sql-monitor.py](sql-monitor.py)
Выполняет SQL-запрос и отправляет данные по указанному каналу уведомлений. Есть различные типы каналы уведомлений, которые различаются форматом данных, способом из передачи и т.д. Подробнее про каналы написано [ниже](#каналы-уведомлений).

Для упрощения вызова скрипта есть shell-скрипт-напарник [service-sql-monitor.sh](service-sql-monitor.sh), принимающий следующие параметры:
  1. `-l` - опциональный параметр-флаг, включающий логирование скрипта в файл лога, находящийся в папке logs на машине выполнения
  2. <название_сервиса> - определяет конфиг и папку, в которой хранится sql-запрос
  3. <название_канала> - определяет канал, через который нужно отправить данные; канал должен быть определен в конфиге сервиса
  4. <путь_к_sql> - определяет путь к файлу sql-запроса относительно папки сервиса (без расширения .sql)
  
**Пример вызова скрипта:**
```
./service-sql-monitor.sh -l checkouter smtp-ff-packaging-team /ff/delayed-packaging-monitor
```
При этом в конфиге сервиса [services/checkouter/checkouter.cfg](services/checkouter/checkouter.cfg) канал `smtp-ff-packaging-team` настроен так:
```
[smtp-ff-packaging-team]
type=SMTP
sendTo=rkikot@yandex-team.ru, lna05@yandex-team.ru, gayane@yandex-team.ru, agorbatenko@yandex-team.ru
```

Такой вызов возьмет sql-скрипт [services/checkouter/ff/delayed-packaging-monitor.sql](services/checkouter/ff/delayed-packaging-monitor.sql) (запрос ищет заказы, которые задержались на этапе сборки на складе), выполнит его в БД, указанной в конфиге сервиса checkouter [services/checkouter/checkouter.cfg](services/checkouter/checkouter.cfg), сериализует данные в csv и отправит по e-mail указанным выше адресатам.

## Каналы уведомлений
Канал уведомлений определяет, куда и каким образом будут переданы результирующие данные выполнения sql-запроса. 

Сейчас реализованы такие типы каналов:
  * `SMTP` - результаты sql-запроса сериализуются в CSV-файл и отправляются по e-mail указанным в канале адресатам
  * `StarTrek` - по результатам sql-запроса создается один или несколько тикетов в СтарТреке; есть возможность обновлять ранее созданные тикеты, чтобы не дублировать их при повторном выполнении скрипта для одних и тех же результатов sql-запроса
  * `HTTP` - результаты sql-запроса сериализуются в CSV-файл и отправляются HTTP POST-запросом по указанному в канале URL'у

Каналы настраиваются в конфиге сервиса, каждый канал - в отдельном разделе конфига. Название канала - название раздела в конфиге. Обязательное поле - `type` - определяет тип канала. Пример настройки канала `smtp-delivery-team` в конфиге:

```
[smtp-delivery-team]
type=SMTP
sendTo=muslimaleksander@yandex-team.ru, wuddy@yandex-team.ru, evgenynikulin@yandex-team.ru
```

У каждого типа канала свое поведение и свои дополнительные настройки в конфиге.

### Тип канала SMTP
Результаты выполнения SQL-запроса отправляются по e-mail в виде приаттаченного CSV-файла. В CSV **не** сериализуются столбцы с названием, начинающимся с двух символов подчеркивания `__`. Если SQL-запрос не возвращает никаких данных, то письмо не отправляется.

Настройки канала определяются в конфиге в секции с названием канала:
  * `type=SMTP` - тип канала SMTP
  * `sendTo` - список адресатов через запятую
  * `subject` - тема письма; это необязательное поле - если не указано, то тема письма должна быть указана в самом SQL-запросе в столбце `__smtp_subject`
  
Общие настройки для всех каналов типа SMTP находятся в разделе `SMTP` конфига:
  * `sendFrom` - From-адресат письма

### Тип канала StarTrek
По результатам выполнения SQL-запроса создаются новые или обновляются существующие тикеты в СтарТреке. Значения для полей тикетов определяются в самом SQL-запросе. Там же определяется логика группировки результирующих строчек запроса в тикеты.

Название тикета, определенное в SQL-запросе, является ключом, по которому скрипт идентифицирует тикеты. Перед тем, как создать новый тикет, скрипт проверяет, не существует ли уже в очереди тикет с таким названием. Если его нет, то создается новый, а если уже есть, то тикет-дубль создаваться не будет: при необходимости существующий тикет будет обновлен (если в канале включена настройка `updateTickets`). 

При этом если в канале включена настройка `closeDuplicateTickets`, скрипт дополнительно может следить за наличием тикетов-дублей, возникших каким-либо образом, и закрывать их, оставляя открытым только один (самый ранний открытый).

Дополнительно скрипт может закрывать те тикеты в очереди, которым уже не соответствует ни одна строка из SQL-запроса (если в канале включена настройка `closeTickets`).

Для всех результирующих строк запроса с одинаковым названием тикета будет создан один тикет в СтарТреке. Если тикету соответствует более одной строки запроса, то все такие строки будут сериализованы в CSV-файл, который приаттачивается к тикету. В CSV **не** сериализуются столбцы с названием, начинающимся с двух символов подчеркивания `__`.

Столбцы SQL-запроса, определяющие поля тикета:
  * `__st_queue` - название очереди
  * `__st_summary` - название тикета
  * `__st_description` - описание тикета
  * `__st_tags` - теги тикета, список через запятую (нельзя использовать пробелы в тегах)
  * `__st_components` - числовые ид. компонентов тикета, список через запятую
  * `__st_weight` - вес тикета
  * `__st_customer_order_number` - поле "Номер заказа Беру" (блок полей "Беру.ру")
  * `__st_return_reason` - поле "Основание возврата" (блок полей "Беру.ру")
  * `__st_payment_method` - поле "Способ оплаты" (блок полей "Беру.ру")
  * `__st_customer_email` - поле "Email покупателя" (блок полей "Беру.ру")
  * `__st_cost_adv` - поле "Стоимость" (блок полей "Оценка задачи")

Настройки канала определяются в конфиге в секции с названием канала:
  * `type=StarTrek` - тип канала StarTrek
  * `updateTickets` - флаг (`true`/`false`), включающий обновление тикетов; если выключено, то существующие тикеты обновляться не будут; по умолчанию включено
  * `closeTickets` - флаг (`true`/`false`), включающий закрытие тикетов; если выключено, то существующие тикеты закрываться не будут; по умолчанию включено
  * `closeDuplicateTickets` - флаг (`true`/`false`), включающий дедубликацию тикетов; если выключено, то тикеты-дубликаты закрываться не будут; по умолчанию включено
  
Общие настройки для всех каналов типа StarTrek находятся в разделе `StarTrek` конфига:
  * `url` - URL АПИ СтарТрека
  * `login` - логин, под которым производятся действия в СтарТреке
  * `userAgent` - как скрипт представляется API СтарТрека

### Тип канала HTTP
Результаты выполнения SQL-запроса сериализуется в CSV и отправляется в теле HTTP POST-запроса с заголовком `Content-Type: text/csv`. В CSV **не** сериализуются столбцы с названием, начинающимся с двух символов подчеркивания `__`.

Настройки канала определяются в конфиге в секции с названием канала:
  * `type=HTTP` - тип канала HTTP
  * `url` - URL, по которому выполняется POST-запрос

## SQL-шаблонизатор
### Переиспользование SQL-кода
*TBD*

### Разворачивание SQL-шаблонов
*TBD*

### Кросс-БД запросы
*TBD*

## FAQ
### Как добавить новый график в solomon
1. Добавить sql в services/. Запрос обязательно должен содержать колонки sensor, ts и value. Все остальные колонки станут лейблами.
2. Добавить новую запись в crontab.

### Как задеплоить изменения
1. Зайти на braavos.market.yandex.net
2. cd /home/mkasumov/solomon-pusher
3. sudo -u mkasumov ./update.sh

### Где смотреть логи
Логи лежат на braavos.market.yandex.net в папке /home/mkasumov/solomon-pusher/logs

### Склеить SQL для мак в IDEA:
 * в идее Preferences -> Tools -> External tools
 * в name придумать название
 * Program: $PyInterpreterDirectory$/python2 - вместо $PyInterpreterDirectory$ подставить путь к питону в venv, если не пользуешься, должно быть что то другое
 * Arguments: $ProjectFileDir$/prepare_sql.py $ProjectFileDir$/$FileDirRelativeToProjectRoot$/$FileName$ $ProjectFileDir$/services/checkouter/util
 * Working dir: $Projectpath$

Сохранить. В Keymap - External tools - добавить shortcut.

### Склеить SQL в PyCharm:
 * File -> Settings -> Tools -> External tools
 * Добавить новый тул, в Name придумать название, например, SolomonPusher
 * Program: `python`
 * Arguments: `$ProjectFileDir$/prepare_sql.py $FilePathRelativeToProjectRoot$`
 * Working dir: `$ProjectFileDir$` 

Открываем нужный скрипт. Запускаем Tools -> External Tools -> SolomonPusher в окне вывода будет SQL. 
Так же SQL будет сразу скопирован в буфер обмена и его сразу можно всталять и исполнять.

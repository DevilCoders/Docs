Что здесь происходит? ORM что ли на*****кодили??
================================================

И да и нет :). Ниже есть раздел про мотивацию, где описано, что и зачем.

ТТХ
---
Библиотека позволяет очень просто делать операцию "сохрани Java объект в БД" (обнови, удали, ...) и "выбери Java объект из БД":
1. insert/update/delete/insertOrUpdate
2. поддержка генерации значений (первичных ключей) - через `returning ...`
3. поддержка работы с версиями, optimistic locking (умеет int и Instant)
4. работа со сложными типами `jsonb` и `enum`-ы
5. составные первичные ключи (* в части insert/update, select-ы пока немного сложнее)
6. и всё это "просто", т.е. `@Id @GeneratedValue`, `@Enum("pg_type")`, `@Jsonb` на полях
7. и всё это с immutable объектами (при генерации значений вернёт обновлённые копии) - создание через конструктор, идеально для `@Value` из Lombok и Kotlin
8. или mutable, через `@MutableStore`
9. ещё умеет в композицию объектов в одной строке через `@Embedded` - это когда у нас в БД одна большая строка, а в Java - составной объект.

Что не умеет:
1. `where` - пишется самостоятельно, кусками SQL, вида `return findManyWhere("status = :status", Map.of("status", statusValue))`. А что если я опечатаюсь? Пишите тесты на свой функционал, вызывающий этот код, это в любом случае полезно.
2. `join` - пишется самостоятельно (пример стоит уточнить), поддержаны мапперы, вытаскивающие данные
3. коллекции - вытаскивание, сохранение придётся писать руками (но если мы хотим "быстро" - то коллекций будет не очень много, а хендлить в любом случае лучше аккуратно, а если хотим много и не критично по скорости - то JPA в руки)

Пример
------
(вообще - см. тесты)
```java
@Value
class Category {
    @Id @GeneratedValue
    int id;

    String categoryName; // -> category_name

    @PgEnum("your_scheme.type")
    Status status;

    @Embedded("description_")
    Word description; // -> description_ru, description_en, может быть null - тогда оба поля = null

    @Embedded("title_")
    Word title; // -> title_ru, title_en

    @Jsonb
    ExtraData extraData;

    @Version
    Instant lastUpdated;
}

@Value
class Name {
    String ru;
    String en;
}

class CategoryRepository extends GenericMappingRepository<Category, Integer> {
    public static final String TABLE_NAME = "category";

    public CategoryRepository(NamedParameterJdbcTemplate jdbcTemplate, TransactionHelper th) {
        super(LightMapper.forClass(Category.class), jdbcTemplate, th, TABLE_NAME);
    }
}

class SomeService {
    public void someAction(CategoryRepository repo) {
        List<Category> categories = repo.findAll();
        repo.insert(new Category(/*...*/));
        // ...
    }
}
```

Мотивация
---------

**Задачи, обычно решаемые ORM-ами:**
1. Взять объект и засунуть в базу, разложив по колонкам и потом создать объект из результатов запроса в базу.
1а. Менеджмент всяких штук вроде генерируемых id, optimistic-locking (это не супер просто делать руками каждый раз, легко запутаться).
2. Некоторые умеют работать со связями и коллекциями так или иначе.
3. Коллекции и связи заставляют сделать несколько вещей:
   а) Добавить "Identity mapping" - одна строка в БД = один объект в памяти - без этого получается много разных приколов, например, добавили в коллекцию одному объекту, но рядом другой такой же при-join-енный, а там нет элемента.
   б) Коллекции и связи нужны не все и не всегда - нужны ленивые подгрузки (а для этого нужно сохранять "коннект к БД" в нужной транзакции).
   в) Но это порождает проблему с 1 + N запросами - поэтому нужны всё же планы выборки всего и сразу (а это или сложный API или язык запросов или прекрасный @BatchSize).
   г) Нужно добавить "Контекст" (Session) - т.к. нужны какие-то разумные границы, и в идеале - если мы один и тот же объект в а) достали разными запросами (а это легко, т.к. ленивая загрузка) - мы хотим, чтобы это был один и тот же объект
   д) У нас теперь меняется всё в разных непредсказуемых местах - отслеживать сложно => делают неявное сохранение - dirty checking тем или иным способом
4. Некоторые хотят ещё типа безопасные запросы - это порождает кодогенерацию (QueryDSL, Jooq, JPA Criterias).
5. Иногда мы понимаем, что настолько далеко ушли от БД, что хочется сделать свой язык запросов (JPAQL).

**Разложим, как это решено в разных местах (поправьте меня, если где-то вру):**
1. JdbcTemplate - ничего не решено :), просто чуть удобнее чем `javax.sql`.
2. Jooq - решает 1), 4), в каком-то ну очень простом виде с 2) на уровне выборки данных.
3. Spring Data JDBC - своеобразный зверь, решает 1, 2 (вроде как - но очень любопытно - всё или ничего, и всегда всё удалить и вставить при обновлении). В каком-то виде умеет в запросы, но в рантайме, как обычно в Spring Data.
4. JPA/Hibernate - решает вообще всё (ценой вообще всего - п. 3 добавляет много сложного и неявного в приложение).
5. Django (когда-то был опыт) - это немного ActiveRecord, т.е. сильно влияет на доменную модельку (нужно наследоваться и т.д.) - решает 1, 2, в каком-то виде свой язык запросов по сущностям (питон - соответственно всё в динамике). Интересно решены коллекции - ленивая подгрузка, но насколько я помню - явные сохранения. Нет identity mapping.
6. SQLAlchemy (python) - да поправят меня тут знающие люди - был похож на JPA/Hibernate в плане подходов, но со вкусом питона.

**Есть ещё несколько "измерений" в функциональности:**
1. работа с JSONB:
  - JPA - вроде может, но костылями, аннотациями, кастомными конвертерами и т.п.
  - JOOQ - может, но в нашей практике нужно прописывать каждое поле в конфиг кодогенерации и ворочать зависимости так, чтобы эти типы были видны в генерируемом коде
  - Spring Data JDBC - надо смотреть, вроде есть конвертеры, которые можно развесить
2. работа с Nullability:
  - JPA - надо изучать, теоретически должен мочь нормально
  - JOOQ - в том, что он генерирует - будут максимум аннотации, но поля будут Integer
3. работа с неизменяемыми сущностями (создаваемыми через билдеры или ещё как, Lombok, Kotlin и т.п.):
  - JPA - никак
  - JOOQ - вроде бы может, благодаря п. 2 - описывать скорее всего придётся самому

**Теперь про этот пакет**
Он про то, как из функциональности выше оставить только 1 и 1а, т.е. просто иметь сохранение в базу и запросы к ней.
Но так чтобы это работало просто, без кодогенерации и доп. сложностей. По сути можно в любой момент "откатиться" на уровень JdbcTemplate.

FAQ по решению:
1. как же генерация схемы?
   - мы всё равно пользуемся миграциями и автогенерация схемы почти бесполезна
2. как же так, писать условия where строчками?
   - пишите тесты с базой (мы ведь всё равно пишем, так?)
   - при этом мы остаёмся ближе к БД, а запрос на SQL всё равно читаемее заклинания на JOOQ и понятнее JPA (в плане доп. языков)
3. как же, я поменяю название поля и всё развалится?
   - пишите тесты, ну т.е. сразу станет понятно, что сломалось
   - правда, давно ли вы меняли название поля в БД в распределённой системе с возможностями отката релизов? это небольшой подвиг на несколько релизов, с какими-то триггерами и прочим, чтобы сделать это без даунтаймов и не протерять при откате
4. а как же связи и коллекции?
   - много работы с коллекциями и связями в проекте и не очень большая нагрузка/объёмы - я бы смотрел в сторону JPA - на таких задачах эта магия окупится
   - JOOQ - всё равно не работает по сути
   - так что да, руками
5. как сделать выборку связанных сущностей
   - придётся написать немного кода, но это возможно (нужен ручной join + select mapper1.getColumns("a"), mapper2.getColumns("b") и потом достать два объекта)
6. а что если надо выбрать коллекцию связанных данных? аналогично 5 - нужно потом переложить как считаете нужным (и кстати, выбор связей через join - так себе практика, при выборе двух 1:N можно очень круто попасть на перемножение - так что всё равно проще делать через доп. запрос по id и переложить).

JMH
====
Есть пакетик `test-jmh`, чтобы сравнить, что мы теряем. Результаты ниже. Приходите, если что-то не корректно.

Как читать:
- тип:
  - Composite - CompositeMapper
  - Mapper - LightMapper
  - ManualNamed - NamedParametersJdbcTemplate
  - ManualOrdered - JdbcTemplate и указание позиций
- нагрузка:
  - insert simple - в объекте нет сложных полей, только число, число и строка
  - insert - число, число, строка, Instant
  - insert json - число, число, строка, Instant, простой JSON
  - в insert - 1000 записей на операцию
  - в select - 10_000 записей на операцию
  - synthetic - это просто берём PreparedStatement и долбим в него значениями, без PG

Выводы (важно - это "худший случай" - тесты с локальным постгресом и рамдиском, на практике стоимость должна быть меньше):
- на insert-ах теряем порядка 1%
- на select-ах теряем:
  - 10% если мы хорошо оптимизировались в ручном варианте, читаем по индексам и объекты простые
  - 5-6% если достаём значения по названиям (что обычно пишут руками)
  - если у нас есть тяжёлые вещи, вроде json-а, то разница упадёт до
   и 3-4%, если есть json-ы - это с Postgres в памяти локально, при боевом использовании, если запросы будут чуточку дольше - разница сократится до 6% и 3-4%
- в то же время:
  - insert-ы "руками" не перезаписывают обратно id - просто это блин сложно напрограммировать (или развлекаемся с генерацией или делаем доп. запрос на получение партии id заранее)
  - optimistic locking руками также потребует отдельных приседаний
  - embedded объекты руками, в частности nullability на них при ручном программировании довольно дорогое упражнение

Сырые данные:
```
Benchmark                                           Mode  Cnt        Score       Error  Units
InsertBenchmark.insertItemsCompositeMapper         thrpt    5       25.345 ±     1.555  ops/s
InsertBenchmark.insertItemsManualNamed             thrpt    5       25.292 ±     0.567  ops/s
InsertBenchmark.insertItemsManualOrdered           thrpt    5       25.520 ±     0.486  ops/s
InsertBenchmark.insertItemsMapper                  thrpt    5       25.382 ±     0.551  ops/s
InsertBenchmark.insertJsonCompositeMapper          thrpt    5       22.008 ±     0.313  ops/s
InsertBenchmark.insertJsonManualNamed              thrpt    5       21.662 ±     0.247  ops/s
InsertBenchmark.insertJsonManualOrdered            thrpt    5       22.133 ±     0.428  ops/s
InsertBenchmark.insertJsonMapper                   thrpt    5       21.945 ±     0.391  ops/s
InsertBenchmark.insertSimpleCompositeMapper        thrpt    5       27.033 ±     0.640  ops/s
InsertBenchmark.insertSimpleManualNamed            thrpt    5       26.981 ±     0.268  ops/s
InsertBenchmark.insertSimpleManualOrdered          thrpt    5       27.242 ±     0.600  ops/s
InsertBenchmark.insertSimpleMapper                 thrpt    5       26.947 ±     0.244  ops/s
InsertBenchmark.syntheticSetStatementJsonManual    thrpt    5  1467839.012 ± 19800.276  ops/s
InsertBenchmark.syntheticSetStatementJsonMapper    thrpt    5  1196895.228 ± 13188.695  ops/s
InsertBenchmark.syntheticSetStatementSimpleManual  thrpt    5  3750764.022 ± 62293.012  ops/s
InsertBenchmark.syntheticSetStatementSimpleMapper  thrpt    5  2270550.942 ± 69528.780  ops/s
SelectBenchmark.selectJsonCompositeMapper          thrpt    5       46.294 ±     0.685  ops/s
SelectBenchmark.selectJsonManualNamed              thrpt    5       47.390 ±     1.105  ops/s
SelectBenchmark.selectJsonManualOrdered            thrpt    5       48.663 ±     0.792  ops/s
SelectBenchmark.selectJsonMapper                   thrpt    5       45.712 ±     2.989  ops/s
SelectBenchmark.selectSimpleCompositeMapper        thrpt    5       83.985 ±     1.437  ops/s
SelectBenchmark.selectSimpleManualNamed            thrpt    5       86.902 ±     1.175  ops/s
SelectBenchmark.selectSimpleManualOrdered          thrpt    5       91.609 ±     0.927  ops/s
SelectBenchmark.selectSimpleMapper                 thrpt    5       82.133 ±     1.793  ops/s```

Аудит через триггеры в БД
=========================

Плюсы:
- транзакционный - если действия откатили - то изменений в аудите не будет
- работает всегда - нельзя обойти - даже если меняем через SQL запросы - действия в аудит будут записаны (просто с null пользователем)
- работает тут же - т.е. не зависит от внешних сервисов
- очень дёшев в применении - добавление аудита = добавить тип в енум + вызвать 1 хранимку и табличка получает аудит изменений

Минусы:
- в реляционной БД - т.е. вряд ли подойдёт для большого объёма логов (частоменяющиеся таблицы на десятки миллионов записей)
- замедляет запись/обновление таблиц, т.к. нужно делать диффы и писать в табличку аудита
- хранит изменения в json-е, т.е. не очень оптимизирован по занимаемому месту

В целом, предполагается использование для различных данных, изменяемых пользователем.

Некоторые рассуждения о будущем:
- можно добавить сверху партиционирование по датам, чтобы можно было отвозить "в архив" старые данные
- можно также партиционировать по типу записи - в этом случае можно отделить "большие" таблицы от маленьких, чтобы не мешали друг другу

Формат хранения и основные поля
-------------------------------
- `entity_type` + `entity_key` - ключ записи, если ключ составной - то всё укладываем в `entity_key`, это строка
- `keys` - некоторый объект, который пишется к каждой записи, чтобы собирать туда какие-то внешние ключи, например, чтобы просто собрать все добавления/удаления по родительской записи
- `event_id` - некоторый внешний id события, который может собирать изменения разных сущностей в рамках одного действия
- `context` - некоторая строка, задающая доп. информацию, например, название треда (в котором будет executor, запрос и т.п.), потенциально может распухать аудит
- `user_name` - без комментариев
- `changes` - хранение изменений:
  - для insert/delete пишется полная копия объекта
  - для update пишутся изменения
  - для обычных полей пишется `[prev, next]` - массив из предыдущего и нового значения
  - для `jsonb` полей процедура рекурсивная:
    - если поле полностью исчезло/появилось, то будет `[null, val]` или `[val, null]`
    - если поле меняется внутри, то будет объект с ключами и уже внутри такая же структура, как в `changes`
    - списки меняются, как единое целое

Детали реализации - передача данных в триггеры
----------------------------------------------
Данные передаются через механизм `search_path` - идёт чтение из `audit_user` без указания схемы:
- процесс, если он знает данные создаёт временную таблицу `audit_user` - и она имеет приоритет над постоянной
- если её нет - то будет фолбэк на `public.audit_user`, без данных

Использование
-------------
1. Добавьте в ваш проект `PEERDIR(market/mbo/libs/mbo-pg-audit`
2. Добавьте в миграции:
   ```xml
    <property name="audit.schema" value="audit"/>

    <!-- Should be first to be used in other migrations -->
    <include file="classpath:/migrations/audit-sql/schema.sql"/>
    <include file="classpath:/migrations/audit-sql/audit.sql"/>
   ```
3. При создании DataSource-а нужно завернуть его в `InterceptingDataSource` + `DelegatingJdbcInterceptorSupplier` - это та точка, в которой для DML запросов будут инициализироваться данные с текущим запросом/пользователем.
    ```java
    @Bean
    public DelegatingJdbcInterceptorSupplier delegatingJdbcInterceptorSupplier() {
        return new DelegatingJdbcInterceptorSupplier();
    }

    @Bean
    public DataSource dataSource() {
        return new InterceptingDataSource<>(yourInternalDataSource(), delegatingJdbcInterceptorSupplier());
    }
    ```
4. Создать конфиг аудита, [вроде такого](https://a.yandex-team.ru/arc/trunk/arcadia/market/mbo/mbo-category/mboc-common/src/main/java/ru/yandex/market/mboc/common/config/AuditConfig.java).
5. Для установки на таблицу нужно добавить такую миграцию:
   ```sql
   --changeset yuramalinov:MBO-21037-msku_status-audit-type runInTransaction:false
   alter type audit.entity_type add value if not exists 'msku_status';

   --changeset yuramalinov:MBO-21037-msku_status-audit
   select audit.init_audit('msku.msku_status', 'msku_status', '$row.market_sku_id::text',
                        'jsonb_build_object(''market_sku_id'', $row.market_sku_id)');
   ```
   Последний `jsonb_build_object` нужен, если мы хотим добавить доп. "ключей", чтобы они были в каждой записи аудита - это могут быть ключи родительских сущностей и т.п.

   Для ключа (третий аргумент) важен каст в `::text`.
6. Напишите у себя тестик, что всё пробрасывается, как нужно [вроде такого](https://a.yandex-team.ru/arc/trunk/arcadia/market/mbo/mbo-category/mboc-app/src/integration-test/java/ru/yandex/market/mboc/app/availability/SeasonControllerTest.java#L138). Тут обычно достаточно для одной таблицы - просто что всё сконфигурировано норм и прицепляется хорошо.

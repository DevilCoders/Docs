# StorageKeyValue и рубильники

В МДМ есть простенькая табличка в Postgres формата "Ключ + Значение". В коде для доступа к ней мы используем `StorageKeyValueService`, а сама табличка называется `mdm.storage_key_value` (SKV).

В эту табличку мы записываем служебные значения для использования оных в рантайме. Например, последний обработанный таймштамп в какой-либо джобе или же так называемые *рубильники*.

*Рубильник* - булевое значение в таблице SKV, которое мы проверяем в рантайме и принимаем решение, активировать ли нижеследующую функциональность. Выглядит это чаще всего так:

```java
if (storageKeyValue.getBool(MdmProperties.FEATURE_X_ENABLED)) {
    doSpecificLogicForFeatureX();
} else {
    doBasicLogic();
}
```

**Правила работы с рубильниками**

- Все ключи для SKV следует класть в класс `MdmProperties`.
- В тестах не забывайте, что SKV-сервис кэширующий. Поэтому после вставки нужных значений в SKV вызовите метод обновления кэша.
- Не добавляйте рубильник, если после переключения его в одну сторону возвращение в обратную сторону невозможно или не имеет смысла.
- Не добавляйте рубильник, если просто "страшновато катить". Если страшновато катить, то напишите побольше тестов, хорошенько проверьте в деве и тестинге, подсветите ревьюверу самый подозрительный кусок ваших изменений на ревью.
- Если проверка рубильника происходит в цикле, то используйте `Cached`-версию методов SKV-сервиса.
- Старайтесь консистентно переключать ваш рубильник между окружениями. Сперва разрабатываем и проверяем в деве, затем переключаем в тестинге и проверяем там, затем в проде. Нередко возникает ситуация, когда рубильник активен в проде, но не поднят в других окружениях. Это приводит к сложности воспроизведения проблем в деве или тестинге, а также к неудобным вопросам, почему функциональность не была проверена :). Помните — на таблицу SKV навешен аудит, все ходы записаны.
- О грандиозных опасных переключениях просьба предупреждать в чат. Это сильно упрощает расследования инцидентов, когда надо быстро понять, в какой момент что-то могло сломаться, а времени гонять часовую YQL на аудит рубильников нет.
- Избегайте нескольких рубильников на одну функциональность. Даже с двумя рубильниками как правило из четырёх возможных комбинаций вам на самом деле нужно от силы две или три. Если процесс запуска вашей новой фичи многоступенчатый, то лучше сделайте один рубильник на всё, но многопозиционный. То есть не булевый, а enum. Пример такого enum - `YtStorageSupportMode`.
- Если видите неиспользуемый рубильник, то смело выпиливайте, причём из БД тоже. Ни в чём себе не отказывайте.

{% note tip %}

Если есть возможность не добавлять рубильник — не добавляйте рубильник.

{% endnote %}

**Когда использование рубильников оправдано**

- Если ваша фича действительно может жить в двух "версиях" и откат на предыдущую является валидным сценарием. Например, запуск хитрой вариации вычисления золота на отдельной категории. В этом случае, если дата-стюарды по метрикам качества данных увидят просадку, они могут попросить нас отключить эту фичу на категории или целиком.
- Если ваша функциональность должна быть активированная синхронно с другими компонентами. В этом случае действительно сложно как-то одновременно катнуть релизы и активировать свежие интеграции без риска даунтайма. В такой ситуации рубильники сильно выручают. Просьба учитывать, что если вы используете кэширующие методы, то профит может сойти на нет.
- Если активация функциональности — это небинарный многоступенчатый процесс с плавными переходами между стадиями. Например, переключение хранилища с Postgres на Yt. В этом случае у нас есть "мягкие" режимы переключения между двумя системами с возможностью вернуться обратно в любой момент (кроме конечной стадии).
- Если ваша функциональность носит временный характер. Например, джоба по разовой переливке бегемотиков из А в Б. Иногда бывает удобно написать джобу по крону, которая будет в несколько присестов поллить необходимую табличку или очередь и делать свою работу. Чтобы после завершения она не лупила запросы без толку, её можно выключить рубильником. Однако просьба после того, как вы закончили работу над этой задачей, убрать крон с джобы.

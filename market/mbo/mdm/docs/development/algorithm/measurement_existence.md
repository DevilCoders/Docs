# Наличие MEASUREMENT

На складах, за которые отвечает команда WMS, есть процедура точного обмера товара измерительной машинкой. Такие замеры являются самыми надёжными источниками ВГХ в Маркете и имеют `source_type == MEASUREMENT`. Мы получаем такие измерения через цепочку интеграций `WMS -> IRIS -> MDM`, а затем варим золото MSKU и SSKU, используя такие ВГХ с практически максимальным приоритетом.

**Проблематика**

Складские замеры — дорогостоящая процедура, использующая непосредственный физический ресурс склада. Поэтому есть желание избегать замеров товаров, если мы уже имеем полезные ВГХ с источником `MEASUREMENT` для данного оффера. МДМ хранит информацию о том, есть ли у оффера качественные складские замеры, и если такой флажок стоит, то склад не будет делать повторного переобмера.

**А почему сам склад не может запоминать то, что он измерил? Зачем тут МДМ?**

На это есть ряд причин.

- Складов на самом деле много, и каждый из них фактически изолирован от других. Да, есть компоненты вроде IRIS или LMS, которые имеют возможность как-то агрегировано работать с данными всех складов, однако их возможности ограничены.
- Склады работают с SSKU по сервисным моделям размещения. При этом у складов отсутствует информация о бизнес-оффере, а значит, нет возможности сгруппировать сервисы под одной базовой частью. Таким образом, если точный замер был сделан по одной сервисной SSKU, то склад никак не узнает, что у всех соседних сервисов автоматически должны быть те же самые ВГХ.
- Склады практически не работают с карточками MSKU. При этом в большинстве категорий включено приоритетное наследование ВГХ именно через MSKU. Таким образом возникает похожая ситуация, как и с сервисными офферами. Если под MSKU есть ряд офферов, и хотя бы на одном из них есть `MEASUREMENT` ВГХ, то по факту они должны быть и на всех соседних SSKU под этой карточкой.

А вот в МДМ есть вся необходимая информация, по которой можно понять, есть ли на SSKU эффективные ВГХ от точного складского замера.

## Алгоритм

**Краткое овервью**

1. Получаем от склада ВГХ с типом `MEASUREMENT` по сервисному офферу.
2. Перекладываем их в базовую часть оффера и сохраняем в серебро SSKU с `source_type == MEASUREMENT`.
3. Варим золото SSKU. В нём в препроцессоре `SskuSilverBlockPreProcessor` ищется блок ВГХ с `source_type == MEASUREMENT`. Если таковой есть, генерится новый блок `MeasurementExistenceBlock` с true-значением (факт наличия `MEASUREMENT`) и датой этого самого складского замера.
4. Этот новый блок добавляется в общую коллекцию всех блоков `silverBlocksByType` и отправляется в `GoldenItemService` на проварку.
5. Сама варка прогоняет блок as-is и схлопывает в "own"-версию `reference_item`.
6. Эта `reference_item` конвертируется в параметры и сохраняется в таблицу промежуточного золота. Эти параметры мы называем *наличием MEASUREMENT-а до наследования*.
   `HAS_MEASUREMENT_BEFORE_INHERIT`,
   `LAST_MEASUREMENT_TIMESTAMP_BEFORE_INHERIT`.
7. Варим золото MSKU. В нём подгружаем промежуточное золото и формируем `MeasurementExistenceBlock`.
8. Блок приходит в [варку MSKU](https://a.yandex-team.ru/arcadia/market/mbo/mbo-category/mbo-mdm-common/src/main/java/ru/yandex/market/mbo/mdm/common/masterdata/services/param/MskuGoldenItemService.java) и там выбирается true-блок с самой поздней датой замера.
9. Собираем блоки обратно в MSKU и сохраняем.
10. Снова варим SSKU. В этот раз мы используем MSKU как серебро для варки и получаем оттуда тот же `MeasurementExistenceBlock`.
11. Для блоков этого типа всегда применяем форсированное наследование с MSKU и записываем результат в итоговую `reference_item`. В зависимости от рубильников форсированного наследования выберется один из двух золотых вычисляторов SSKU - либо `WeightDimensionsGoldenItemService`, либо `WeightDimensionForceInheritanceService`.
Однако в обоих из них конкретно для данного блока наследование форсируется всегда. Параметры, спущенные с MSKU, мы называем *наличием MEASUREMENT-а после наследования*.
    `HAS_MEASUREMENT_AFTER_INHERIT`,
    `LAST_MEASUREMENT_TIMESTAMP_AFTER_INHERIT`.
12. Сваренные `reference_item` со значениями после наследования сохраняем в таблицу результирующего золота SSKU и отправляем потребителям.


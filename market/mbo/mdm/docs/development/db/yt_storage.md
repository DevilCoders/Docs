# Хранилища БМДМ в Yt

В МДМ часть сущностей хранится в Yt. Чтобы узнать, какие именно, можно обратиться к [перечню хранилищ](tables.md). За работу с этими хранилищами (стораджами) отвечает микросервис БМДМ `mdm-storage-api`.

Ключевые свойства:
- Универсальный бинарный формат
- Данные доступны в YQL
- Автоматический аудит при сохранении средствами `mdm-storage-api`

## Формат "MDM Entity" {#entity}

[Ой, а можно как-то покороче и попроще? Мне просто пару полей в YQL надо вытащить...](#yql)

А истинных ценителей прекрасного мы великодушно приглашаем посетить нижеследующий бордель интеллектуальных наслаждений.


### Поля в Entity

В Yt мы храним сущности в универсальном формате, который мы называем `entity`. В коде и в обиходе возможны вариации вроде `MdmEntity`, `mdm_entity` - это всё про одно и то же. Формат представляет собой [proto-сообщение](https://a.yandex-team.ru/arc/trunk/arcadia/market/mbo/mdm/proto/entity/MdmStorageBase.proto), хранящееся в Yt бинарно. Упрощённо, выглядит сиё чудо так:

```
message MdmEntity {
    uint64 mdm_id = 1;
    uint64 mdm_entity_type_id = 2;
    map<uint64, MdmAttributeValues> mdm_attribute_values = 3;
    ...
}
```

Разберём по полям:
- `mdm_id` - наш внутренний числовой ID сущности. Он никак не связан с физическим миром, то есть не может и не должен матчиться на `msku_id`, на `supplier_id` и прочие ключи из нашей предметной области. Он строго положителен, уникален. Однозначно идентифицирует сущность в таблице. Генерятся такие ID автоматически нашей системой при первичном сохранении объекта.
- `mdm_entity_type_id` - уникальный ID *типа сущности*. Все типы сущностей и их ID можно увидеть в нашем [Конструкторе](https://mdm.market.yandex-team.ru/constructor/mdm-entity-types/0). Так, для типа сущности [Склад](https://mdm.market.yandex-team.ru/constructor/mdm-entity-type/1042432961) поле `mdm_entity_type_id` будет равно `1042432961`.
- `mdm_attribute_values` - значения атрибутов этой сущности, то есть фактическая полезная начинка хранимого объекта.

{% note warning %}

Уже по данной структуре видно, что вся информация об объекте лежит в нём целиком. То есть, сложный объект хранится не в несколько строк в БД, а всегда в одной сущности. Таким образом, невозможно обновить кусочек этого объекта (какой-то один атрибут, например, один карготип на MSKU), не зацепив остальное. Любое изменение требует полного пересохранения всей сущности, и новая сохраняемая версия объекта и должна будет содержать нужные вам изменения. Такой подход кушает несколько больше памяти и процессорного времени, но зато гарантирует железобетонную консистентность сущности на фундаментальном уровне.

{% endnote %}

{% note tip "Пример" %}

Мы можем зайти в [АРМ](https://mdm.market.yandex-team.ru/arm/1042432961/) и открыть в нём тип сущности "Склад". Справа в таблице мы увидим справочник складов. При клике на любой из них увидим параметры склада и его ID справа вверху.

![Склад в ARM](../../_images/yt_storage_1.png)

Таким образом, пара `(mdm_entity_type_id, mdm_id) = (1042432961, 2356823146)` однозначно идентифицирует данный экземпляр склада у нас в системе.

{% endnote %}

Рассмотрим детальнее поле `map<uint64, MdmAttributeValues> mdm_attribute_values`. Оно представляет собой словарик, в котором на ID атрибута мапится набор значений этого атрибута.

```
message MdmAttributeValues {
    uint64 mdm_attribute_id = 1;
    repeated MdmAttributeValue values = 2;
    ...
}
```

По полям:
- `mdm_attribute_id` - тот же ID атрибута, что и в ключах словаря `mdm_attribute_values`, продублирован для удобства. Эти ID можно взять из конструктора, нажав на конкретный атрибут в типе сущности.
- `values` - сами значения. Поскольку у нас есть мультизначные параметры, мы позволяем здесь хранить список значений.

Рассмотрим, как выглядит конкретное значение `MdmAttributeValue`:

```
message MdmAttributeValue {
    oneof value {
        bool           bool             = 1;
        string         numeric          = 2;
        I18nStrings    string           = 3;
        uint64         option           = 4;
        MdmEntity      struct           = 5;
        uint64         timestamp        = 6;
        uint64         reference_mdm_id = 7;
        int64          int64            = 8;
    }
}
```

Пояснение: поскольку в МДМ мы используем и числовые, и строковые, и булевые, и enum-значения (какие мы молодцы!), то мы должны уметь хранить любое из них. Соответственно, у каждого *значения атрибута* заполнено ровно одно поле из этого списка, подходящее по типу.

{% note tip "Пример" %}

Предположим, что мы хотим хранить в нашем складе не только его приоритет и код, но и название. Например, "Софьино". Тогда псевдо-json, описывающая склад с именем, выглядела бы так:

```json
{
    "mdm_entity": {
        "mdm_id": 2356823142,
        "mdm_entity_type_id": 1042432961,
        "mdm_attribute_values": {
            "1131830965": {
                "mdm_attribute_id": 1131830965,
                "values": [
                    { // Это начало mdm_attribute_value
                        "string": "Софьино"
                    }
                ]
            }
        }
    }
}
```

Для атрибута "Название склада" мы позаимствовали ID из [конструктора](https://mdm.market.yandex-team.ru/constructor/mdm-entity-type/1042432961/1131830965). Формат строки немного упрощён для простоты восприятия, в реальности он посложнее из-за локализации (см. ниже).

{% endnote %}

**Подытожим**

- В Yt мы абсолютно все сущности храним в универсальном proto-формате, который называем `mdm_entity`.
- Формат Entity трёхъярусный. На самом верхнем хранятся идентификаторы сущности. На втором — словарик "атрибут vs значения". А на третьем — само единичное значение конкретного типа.
- ID сущности называется `mdm_id`, он уникален, генерится нашей системой и **не** связан с ключами объектов из нашего бизнес-домена.
- ID типа сущностей и ID атрибутов можно найти в Конструкторе БМДМ.

### Локализация

Внимательный читатель мог заметить, что формат конкретного значения для строк выглядит так:

```
message MdmAttributeValue {
    ...
    I18nStrings string = 3;
    ...
}
```

Но при этом в примерах выше мы проигнорировали странный объект `I18nStrings` и записали значение просто как `"string": "Софьино"`. Это не совсем правильно, так как строковые поля учитывают локализацию и содержат внутри указатели на то, какому языку принадлежит значение. Поэтому на самом деле строковое значение выглядит так:

```json
"values": [
    {
        "string": {
            "i18n_string": [
                {
                    "lang_id": 225,
                    "string": "Софьино"
                },
                {
                    "lang_id": 84,
                    "string": "Sof'ino"
                }
            ]
        }
    }
]
```

То есть, чтобы достать строковое значение, следует погрузиться в дополнительный уровень вложенности и указать, для какой локали вы хотите получить значение. В примере выше локаль `225` означает русский язык, а код `84` - английский (США).

{% note tip "Пример" %}

В 99.81% случаев в МДМ используется стандартная русская локаль с кодом `225`. Поэтому для большинства задач вы можете либо искать по ней, либо вообще брать первый попавшийся элемент коллекции строк. Так, для получения имени склада в МДМ в YQL можно обращаться к полю так:

```
select MarketMdm::MdmEntity2Json(mdm_entity).mdm_attribute_values.`1131830965`.values[0].`string`.i18n_string[0].`string` as name
from ...;
```

[Этот же пример в YQL](https://yql.yandex-team.ru/Operations/YmFjb9JwbLI3FhMAsbb-DaeeBSo8iEBIPJVy1QKBtTc=). Очень просто, понятно и почти влезает в одну строчку!

{% endnote %}

### Метаинформация

Помимо самих данных мы в entity также умеем хранить метаинформацию — таймштампы обновлений, тип и вид источника, версия и признак удаления (используется только для аудита).

Версионирование задаётся объектом вида:

```
message MdmUpdateMeta {
    uint64 audit_event_id = 1;
    uint64 from = 2;
    uint64 to = 3;
    bool deleted = 4;
}
```

В большинстве случаев вам понадобится только поле `from`, означающее время изменения. Источники же кодируются в таком формате:

```
message MdmSourceMeta {
    string source_id = 1;
    string source_type = 2;
    uint64 source_updated_ts = 3;
}
```

Мы можем докинуть MdmUpdateMeta или MdmSourceMeta рядом с нужным полем, и таким образом добавим туда полезную метаинформацию.

{% note tip "Пример" %}

Рассмотрим уже знакомый нам склад.

```
select MarketMdm::MdmEntity2Json(mdm_entity) as entity
from hahn.`home/market/production/mdm/storage/warehouse` view raw
where mdm_id = 2356823142;
```

[Этот же пример в YQL](https://yql.yandex-team.ru/Operations/YmFgagVK8CobPYeNVZ6YQnizrZL8RvXRncEGKfMqUl0=). Получаем:

```json
{
    "mdm_attribute_values": {
        "mdm_entity_type_id": 1042432961,
        "mdm_id": 2356823142,
        "mdm_update_meta": { "from": 1642160221779 },
        "1131830965": {
            "mdm_attribute_id": 1131830965,
            "mdm_source_meta": { "source_type": "AUTO" },
            "mdm_update_meta": { "from": 1642160221719 },
            "values": [
                {
                    "string": {
                        "i18n_string": [
                            {
                                "lang_id": 225,
                                "string": "Софьино"
                            }
                        ]
                    }
                }
            ]
        },
        //...остальные атрибуты...
    }
}
```

Здесь мы видим, что на самом верхнем уровне сущности лежит `"mdm_update_meta": { "from": 1642160221779 }`, указывающая на дату последнего обновления всей entity. В то же время параметр с именем "Софьино" имеет свою мету `"mdm_update_meta": { "from": 1642160221719 }` и время там другое, т.к. он мог не меняться после первичного сохранения. Там же для строкового атрибута лежит и source-мета `"mdm_source_meta": { "source_type": "AUTO" }`. Поскольку склады заводились тулой, здесь нет `source_id`, но чаще всего он имеется и лежит рядом с `source_type`.

{% endnote %}

Поле MdmSourceMeta имеет смысл только для значений атрибутов, и не имеет смысла для всей сущности, так как разные кусочки объекта могли меняться разными источниками.

### Пример в YQL {#yql}

В YQL для парсинга бинарной entity в J(Y)son используется функция `MarketMdm::MdmEntity2Json(ваша_колонка_с_entity)`. Далее вы можете доставать поля любой глубины по обычным правилам Yson/Json в YQL. Рассмотрим [пример](https://yql.yandex-team.ru/Operations/YmFvidJwbLI3FilYeNDTOaA0OqYZGrpc-osTd6yN50k=) конкретной сущности в YQL и прямо у полей укажем, что к чему.

```sql
select
    mdm_id,
    MarketMdm::MdmEntity2Json(mdm_entity) as entity,
    MarketMdm::MdmEntity2Json(mdm_entity).mdm_attribute_values.`1042361959`.values[0].numeric as warehouse_priority,
    MarketMdm::MdmEntity2Json(mdm_entity).mdm_attribute_values.`1042464959`.values[0].int64 as warehouse_id,
    MarketMdm::MdmEntity2Json(mdm_entity).mdm_attribute_values.`1131830965`.values[0].`string`.i18n_string[0].`string` as name
from hahn.`home/market/production/mdm/storage/warehouse` view raw
where mdm_id = 2356823142;
```

Результат:

mdm_id | entity | warehouse_priority | warehouse_id | name
:---|:---|:---|:---|:---
2356823142 | Json-ка, см. ниже | "300" | 172 | "Софьино"

```json
{
    "mdm_attribute_values": {
        "mdm_id": 2356823142, // уникальный внутри-МДМный ID, не привязанный ко внешнему миру
        "mdm_entity_type_id": 1042432961, // ID типа сущности из конструктора - https://mdm.market.yandex-team.ru/constructor/mdm-entity-types/1042432961
        "mdm_update_meta": { "from": 1642160221779 }, // дата последнего обновления всей сущности
        "1042361959": {
            "mdm_attribute_id": 1042361959, // ID атрибута "Приоритет склада" из конструктора для данного типа сущности
            "mdm_source_meta": { "source_type": "AUTO" }, // тип и ID источника (если есть)
            "mdm_update_meta": { "from": 1642160221719 }, // дата обновления конкретного атрибута
            "values": [ // значения. Для мультизначных атрибутов их может быть несколько.
                {
                    "numeric": "300" // типизированное значеньице
                }
            ]
        },
        "1042464959": {
            "mdm_attribute_id": 1042464959, // ID атрибута "WAREHOUSE ID" из конструктора
            "mdm_source_meta": { "source_type": "AUTO" },
            "mdm_update_meta": { "from": 1642160221719 },
            "values": [
                {
                    "int64": 172
                }
            ]
        },
        "1131830965": {
            "mdm_attribute_id": 1131830965, // ID атрибута "Название склада" из конструктора
            "mdm_source_meta": { "source_type": "AUTO" },
            "mdm_update_meta": { "from": 1642160221719 },
            "values": [
                {
                    "string": {
                        "i18n_string": [
                            {
                                "lang_id": 225, // русскоязычное локализированное значение
                                "string": "Софьино"
                            }
                        ]
                    }
                }
            ]
        }
    }
}
```

{% note warning %}

При использовании функции `MarketMdm::MdmEntity2Json` обязательно дописывайте после `from` дополнительное указание `view raw`, как в примерах выше. Иначе YQL некорректно распарсит entity и может откусить её часть.

{% endnote %}

## Структуры

В МДМ многие атрибуты собраны в некие логические блоки. Например, умозрительный блок "Срок годности" может содержать
- Числовое значение СГ
- Единицу измерения СГ
- Флаг отображения на фронте Маркета
- Флаг неограниченного срока годности
- Комментарий к сроку годности

Такие логические блоки мы можем завести как отдельный *тип сущности* в Конструкторе. При этом он подходит для сроков гарантии и службы в том числе.

![Тип сущности для сроков](../../_images/yt_storage_2.png)

"Вид типа сущности" `STRUCT` на примере выше говорит нам о том, что мы не можем создать самостоятельные экземпляры данного типа. Такой тип сущности используется только как контейнер для атрибутов внутри другой сущности. В proto формате entity контейнеры хранятся как и остальные значения:

```
message MdmAttributeValue {
    oneof value {
        bool           bool             = 1;
        string         numeric          = 2;
        I18nStrings    string           = 3;
        uint64         option           = 4;
        MdmEntity      struct           = 5; // вот туть
        uint64         timestamp        = 6;
        uint64         reference_mdm_id = 7;
        int64          int64            = 8;
    }
}
```

Обратите внимание, что поле `struct` имеет тип `MdmEntity`. Таким образом, наш формат рекурсивный и может хранить сущность в сущности в качестве значения атрибута. Глубина вложенности ограничена только здравым смыслом.

{% note tip "Пример" %}

В этот раз посмотрим на "резолюцию по золотой SSKU".

```json
{
    "mdm_id": 3621482860,
    "mdm_entity_type_id": 540772939,
    "mdm_update_meta": { "from": 1647079252483 },
    "mdm_attribute_values": {
        // атрибуты верхнего слоя: supplier_id, shop_sku, is_banned и подобные
        "536066942": {...},
        "536088947": {...},
        "540772941": {...},
        "540831935": {...},
        "540842937": {...},
        // вложенный контейнер "Вердикт"
        "536066944": {
            "mdm_attribute_id": 536066944,
            "values": [
                { // mdm_attribute_value
                    "struct": { // начинается вложенная сущность
                        //... нет метаданных и ID, т.к. это не самостоятельная сущность
                        "mdm_attribute_values": {
                            "540750943": {
                                "mdm_attribute_id": 540750943,
                                "values": [
                                    {
                                        "string": {
                                            "i18n_string": [
                                                {
                                                    "lang_id": 225,
                                                    "string": "Отсутствует значение для колонки '{{header}}'"
                                                }
                                            ]
                                        }
                                    }
                                ]
                            },
                            "540772943": {
                                "mdm_attribute_id": 540772943,
                                "values": [
                                    {
                                        "string": {
                                            "i18n_string": [
                                                {
                                                    "lang_id": 225,
                                                    "string": "{\"header\":\"Габариты в сантиметрах с учетом упаковки\"}"
                                                }
                                            ]
                                        }
                                    }
                                ]
                            },
                            "540801937": {
                                "mdm_attribute_id": 540801937,
                                "values": [
                                    {
                                        "string": {
                                            "i18n_string": [
                                                {
                                                    "lang_id": 225,
                                                    "string": "mboc.error.excel-value-is-required"
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    }
                }
            ]
        }
    }
}
```

Чтобы добраться до текстового значения во вложенной структуре [в yql](https://yql.yandex-team.ru/Operations/YmG0PtJwbLI3FqRJ1StZXvEb2kPenLh27x34XYxx4F8=), следует проложить полный путь:

```sql
select
    mdm_id,
    MarketMdm::MdmEntity2Json(mdm_entity).mdm_attribute_values.`536066944`.values[0].struct.mdm_attribute_values.`540801937`.values[0].`string`.i18n_string[0].`string` as tanker_code
from hahn.`home/market/production/mdm/storage/golden_ssku_resolution` view raw
where mdm_id = 3621482860;
```

mdm_id | tanker_code
:---|:---
3621482860 | "mboc.error.excel-value-is-required"


{% endnote %}

## Как работать с mdm_id {#mdm_id}

Маппинг между "внешним" ключом сущности из нашего бизнес-домена и внутренним `mdm_id` осуществляется через индексные таблицы в Yt. Индексная таблица — это вспомогательная табличка рядом с основной, которая обычно имеет формат

hash |внешний_ключ | mdm_id
:---|:---|:---

и находится по пути `//home/market/окружение/mdm/storage/основная_таблица` плюс суффикс  `_xxx_idx`. Внешний ключ по факту может быть составным, например `supplier_id, shop_sku`, и занимать несколько колонок индексной таблицы. Колонку `hash` можно игнорировать, она нужна для внутренних нужд.

{% note tip "Пример" %}

- Золотые резолюции (вердикты) SSKU лежат по пути `//home/market/production/mdm/storage/golden_ssku_resolution`.
- Индексная таблица для них лежит по пути `//home/market/production/mdm/storage/golden_ssku_resolution_ssku_key_idx`.

Соответственно, чтобы получить `mdm_id` по привычной паре `supplier_id, shop_sku`, вам нужно поселектить это из индексной таблицы `golden_ssku_resolution_ssku_key_idx`.

{% endnote %}

## Вопросы и ответы

**БОЖЕ ПРАВЫЙ, ПОЧЕМУ ТАК СЛОЖНО?????????????!!!!!!11111**

Ответ. Такой формат хранения был выбран вовсе не для того, чтобы быть удобным. Строго говоря, он вообще не предназначен для смотрения в него глазами живого органического человека. А то, что для него работает YQL, это скорее приятный бонус от хранения в Yt (который мы, впрочем, учли и на который заложились). Формат позволяет описывать произвольные сущности любой сложности, что в перспективе позволит нам безгранично расширять предметную область МДМ, фактически не тратя ресурсов на конфигурацию Yt под хранения очередного типа сущности.

**Есть ли возможность упростить доставание полей из entity?**

Ответ. Пока нет. Однако у автора сих строк есть смутные идеи, как бы такое можно было бы провернуть, добавив дополнительных вспомогательных функций в движок YQL, по аналогии с `MarketMdm::MdmEntity2Json`. Такие доработки имеют большой TTM из-за особенностей релизов YQL и сложности разработки, но если есть такая потребность, то вы всегда можете обратиться с предложением.

**В чём разница таблиц в Yt по пути mdm/storage от mdm/dictionaries?**

Ответ. Стораджи — это "живые", меняющиеся в реалтайме таблицы с актуальнейшими данными, то есть наша непосредственная БД для хранения объектов. А папка dictionaries содержит предподготовленные статичные суточные слепки в специальных форматах, которые понятны внешнему потребителю.

**Можно ли использовать таблицы стораджей для внутренних процессов, например, отчётности или DQ?**

Ответ. Можно, но осторожно. Эти таблицы живут и развиваются вместе с кодом МДМ и в любой момент могут изменить формат или обрасти новыми данными. Разумеется, разработчик обязан проинформировать дата-стюардов и команду о таких изменениях. Проблема скорее в том, что такое изменение может встать на критическом пути важного проекта, и в таком случае придётся экстренно корректировать запросы в отчётах и логику в DQ под новые реалии. Опять же, разработка будет стараться заранее закладывать такие сложности в оценку, но... вы поняли :)

**Можно ли использовать таблицы стораджей или их аудит в продакшен-процессах внешних сервисов/команд (не МДМ)?**

Ответ. Если речь идёт о периодических процессах, то *абсолютно исключено*. Для внешних потребителей мы предоставляем статические слепки в mdm/dictionaries, либо же динамические обновления через Datacamp. Если речь идёт о разовой YQL-ке для решения какой-то текущей частной проблемы, то конечно можно, приходите, select-ите на здоровье.

**Я обновил сущность в АРМ/UI, но в YQL не вижу изменений**

Ответ. В YQL есть некоторая задержка до 15 минут. На новых таблицах мы выставляем специальный атрибут, который это лечит, но часть таблиц исторически живёт без него.

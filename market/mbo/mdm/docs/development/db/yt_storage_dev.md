# Управление стораджами в Yt

Эта информация может быть наиболее полезна разработчикам.

## Контракты mdm-storage-api

- У всех хранимых типов сущности должен быть задан хотя бы один индекс по "внешнему" ключу из нашего бизнес-домена. Такой индекс называется первичным (primary).

  *Это, кстати, открытый дискуссионный вопрос - в будущем мы можем отказаться от этого ограничения и разрешить хранить сугубо внутренние МДМные сущности по их mdm_id без привязки ко внешнему миру и без первичного индекса.*

- При сохранении сущности проверяется её наличие по primary индексу или по `mdm_id`, если клиент его передал в составе сущности.
- Если сохраняемая сущность создаётся впервые (не найдена по индексу или `mdm_id`), то для неё генерится уникальный `mdm_id` и присваивается ей при сохранении.
- При любом успешном сохранении сущности ей присваивается версия, равная таймштампу транзакции сохранения.
- Если при сохранении нашлась предыдущая версия сущности (т.е. происходит update, а не insert), то происходит сравнение версий у пришедшей сущности и у её старого варианта.

    - Если версия сохраняемой сущности больше или равна уже существующей, то сохранение разрешено.
    - Если версия сохраняемой сущности меньше версии существующей, то произошло параллельное обновление и сохранять текущий экземпляр мы не можем - он устарел. В таком случае вернётся ошибка сохранения со специальным кодом.

- При сравнении старой и новой копии сохраняемой сущности производится сверка полей (атрибутов и метаинфомрации). Если фактических изменений не произошло, сохранение не происходит и возвращается `NO_OP`.
- При сохранении сущности используется оптимистичная блокировка. То есть поиск по индексу или `mdm_id` происходит транзакционно. Это означает, что даже если сверка версий прошла успешно, но после этого кто-то успел сделать параллельный апдейт, то транзакция это увидит и выбросит исключение параллельного изменения в момент сохранения. С точки зрения storage-api это штатная ситуация, и пользователь получит код ошибки, как в случае обычного параллельного обновления.
- При успешном сохранении в аудит транзакционно записывается diff изменений.
- Порядок возвращаемых статусов и ID сохранённых объектов **строго соответствует** порядку переданных клиентом entity, вне зависимости от успешности сохранения любых из них.

  *То есть, если вы отправили на сохранение объекты `[a, b, c]` именно в таком порядке, то в ответ вы получите статусы `[status_a, status_b, status_c]` ровно в таком же порядке.*

- Если в сохраняемом батче хотя бы одна сущность не сохранилась с ошибкой, сохранение откатывается для всего батча. При этом `NO_OP` не считается ошибкой и не мешает сохранению соседей.

## Создание нового стораджа под тип сущности

Создаём свой конфиг будущей таблицы [тут](https://a.yandex-team.ru/arc_vcs/market/mbo/mdm/mdm-storage-api/src/main/resources/yt_storage_settings).

{% cut "Пример конфига с пояснениями" %}

```yaml
---
development:  # Для разных окружений могут быть разные настройки таблицы, поэтому ниже будет почти копипаста для теста и прода.
  table_name: 'msku_gold'  # Именно это название будет у таблицы в yt
  mdm_entity_type_id: 215906716  # ИД типа сущности из конструктора, можно взять из URL
  auto_compaction_period: 21600000  # Интервал времени (в мс) для принудительной компактификации партиций, лучше не трогать
  tablet_cell_bundle_meta: 'market-mdm-development' # https://yt.yandex-team.ru/markov/tablet_cell_bundles/tablet_cells?activeBundle=market-mdm-production
  tablet_cell_bundle_replicas: 'market-mdm-development'  # Аналогично предыдущему. В общем случае на разных кластерах могут отличаться TCB, но у нас пока вроде совпадают.
  tablet_count: 1  # Число шардов/таблетов. В деве и тесте без надобности просьба выше 1 не подымать. В проде обычно ставим 10.
  compression_codec: 'LZ4' # r.y.m.yt.util.table.constants.CompressionCodec#name(). Степень сжатия, LZ4 ок, без сжатия не делаем.
  primary_medium: 'SSD_BLOBS' # r.y.m.yt.util.table.constants.Medium#name(). Если табличка не требовательна к скорости, лучше указать HDD.
  audit: true  # Включает или отключает аудит на эту таблицу. Если true, то рядом должен лежать yml-файлик для схемы аудитной таблицы.
  layout: # Если нужна репликация, отличная от формулы "Markov + Hahn + Arnold", то указываем этот атрибут.
    sync: "seneca-sas" # Приоритетная реплика, которая почти всегда будет синхронной.
    async: ["seneca-vla", "hahn", "arnold"] # Асинхронные реплики
    meta: "markov" # Мета-кластер (мастер). Практически всегда для нас это Markov.
  indices: # Описываем поисковые индексы.
  - index:
    primary: true  # Первичный индекс == индекс, используемый для дедупликации при сохранении. Чаще всего это PK из постгри - например, MSKU_ID или ShopSkuKey.
    name_postfix: '_msku_id_idx'  # Этот хвостик добавится к имени индекс-таблицы (в yt нет как таковых встроенных индексов и они создаются отдельными табличками рядом)
    columns:
    - search_column:
      name: 'msku_id'  # Имя индексной колонки.
      mdm_attribute_path: [271454716]  # Атрибутный путь до нужного значения в MdmEntity. В отличие от прото-апишки mdm-metadata, ИДшники типов сущностей в пути включать здесь не нужно.
      type: 'UINT64' # r.y.m.yt.util.table.model.YtColumnSchema.Type#name()
      mdm_type: 'INT64' # MdmAttributeDataType#name()


testing:
  # тут обычно почти полная копипаста с дева, отличие в Tablet Cell Bundle.

production:
  # и тут, в общем-то, тоже, но обычно больше таблетов.
```

Если включён аудит, то рядом следует положить и конфиг для аудитной таблицы. Обычно он короче, т.к. у этих таблиц стандартная схема и описывать индексы там не нужно:

```yaml
---
development:
  table_name: 'msku_gold_snapshot'
  mdm_entity_type_id: 215906716
  auto_compaction_period: 21600000
  tablet_cell_bundle_meta: 'market-mdm-development'
  tablet_cell_bundle_replicas: 'market-mdm-development'
  tablet_count: 1
  compression_codec: 'LZ4' # r.y.m.yt.util.table.constants.CompressionCodec#name()
  primary_medium: 'SSD_BLOBS' # r.y.m.yt.util.table.constants.Medium#name()


testing:
  ...

production:
  ...
```

{% endcut %}

Затем добавляем конфиг в коде [тут](https://a.yandex-team.ru/arc_vcs/market/mbo/mdm/mdm-storage-api/src/main/java/ru/yandex/market/mdm/storage/config/MdmStorageYmlLoaderConfig.kt). Если включён аудит, то не забыть включить и его в соответствующем бине. Запускаем mdm-storage-api в деве и проверяем, что таблички создались.

После релиза и создания таблиц во всех окружениях, следует их настроить. В консоли выполняем:
1. `YT_PROXY=markov.yt.yandex.net ya tool yt set //home/market/окружение/mdm/storage/ваша_таблица/@replication_collocation_id id_коллокации`. ID коллокации для тестинга — это `221d9-2313c-4050516-ab7d95`, для прода - `21dc9-b2d91-4050516-e91e89d1`. Это создаст нерушимую ментальную связь этой таблички с остальными нашими табличками, чтобы они одновременно переключались между репликами в случае проблем на одной из этих реплик.
2. И, собственно, настроим само переключение между репликами с приоритетом на нужный кластер. Обычно это `arnold`, однако в случае, если у вас ещё и `seneca`, синхронной следует делать именно одну из них. Выполняем

   ```
   YT_PROXY=markov.yt.yandex.net ya tool yt set //home/market/окружение/mdm/storage/ваша_таблица/@replicated_table_options/enable_replicated_table_tracker '%true'
   ```

3. И затем

   ```
   YT_PROXY=markov.yt.yandex.net ya tool yt set //home/market/окружение/mdm/storage/ваша_таблица/@replicated_table_options/preferred_sync_replica_clusters '["целевой_кластер"]'
   ```

## Управление

**Пересоздание**

Если в ходе экспериментов что-то пошло не так, то пересоздать таблицу просто:

— Удалите её руками с `markov` и кластеров-реплик
- Удалите в SKV по ключу `MDM_STORAGE_EXISTED_TABLES = "mdmStorageExistedTables"` все имена, связанные с этой таблицей
- Перезагрузите mdm-storage-api на любом одном хосте в нужном окружении. На старте приложения таблицы пересоздадутся

**Ручное переключение синхронной реплики**

```
YT_PROXY=markov.yt.yandex.net ya tool yt set //home/market/окружение/mdm/storage/ваша_таблица/@replicated_table_options/preferred_sync_replica_clusters '["целевой_кластер"]'
```

Это "мягкое" указание переприоритезировать одну реплику как предпочтительную синхронную. Но если это не сработает, то остаётся только вариант

```
YT_PROXY=markov.yt.yandex.net ya tool yt alter-table-replica --mode sync id_реплики
```

ID реплики можно посмотреть в атрибуте основной мета-таблицы: `yt get //путь/до/вашей/мета_таблицы/@replicas`. В этом случае возможен даунтайм на запись на то время, которое потребуется асинхронной реплике на догон лага репликации перед тем, как она сможет стать синхронной. В результате на Маркове на мета-таблице новая синхронная реплика должна получить флажок sync. Это может занять несколько минут для обоих способов.


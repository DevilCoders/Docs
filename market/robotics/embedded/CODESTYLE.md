## C

### Основные моменты:

* Явное лучше неявного, рекомендуется:
  * избегать сокращений в названиях имен переменных, функций и типов данных, 
  * избегать побочного поведения функций и операторо,
  * избегать сложных однострочных выражений.
  * Так как понимание пунктов выше субъективно, оценка их выполнения лежит на ревьюере.
* Для написания кода используется CamelCase. Функции начинаются с заглавной буквы, переменные со строчной. 
* Количество символов в строке не должно превышать 100 символов. 
* Оператор `goto` не используется.
* Глобальные переменные не используются. Исключения:
  * "локальные" глобальные переменные для создания экземпляра структуры модуля,
  * глобальные константы.
* Именовать любые сущности рекомендуется исходя из бизнес логики.
* Названия функций рекомендуется начинать с глагола. 
* Названия переменных **не** рекомендуется начинаться с глагола.
* В Си нет пространств имен, для их эмуляции все типы и методы програмного модуля должны начинаться с имени этого модуля и отделяться нижним подчеркиванием: 

```c
#ifndef __MODULE_NAME_H
#define __MODULE_NAME_H

#define MODULE_NAME_CONSTANT  10u

typedef struct {

} module_name_s;

void ModuleName_Init(module_name_s* self);
void ModuleName_Set(module_name_s* self, uint32_t param);

#endif /* __MODULE_NAME_H */

```

### Типы данных

* Пишутся в snake_case с суффиксом типа данных.
* Определение структур, объединений и перечислений осуществляются с использованием `typedef`:

```c
typedef enum {
    MODULE_NAME_STATE_UNDEF,
    MODULE_NAME_STATE_INITIALISATION,
    MODULE_NAME_STATE_WORK

} module_name_state_e;

typedef union {
    struct {
        uint8_t notInit   : 1;
        uint8_t someError : 1;
    },

    uint8_t field;

} module_name_status_u;

typedef struct {
    module_name_state_e state;
    module_name_status_u status;

} module_name_s;

```

* В случае, если необходимо создание именованной структуры (объединения, перечисления), рекомендуется имя структуры писать в snake_case без суффикса:

```c
typedef struct module_name {
    uint32_t someField;

} module_name_s;

```

* Указатели на функции в случае определеия типа с использованием `typedef` должны писаться в snake_case с суффиксом:

```c
typedef bool (*module_name_callback_f)(void* arg);

```

* В иных случаях использования `typedef` для создания пользовательских типов даннных рекомендуется использовать суффикс `_t`:


### Именованные константы

* Пишутся в SCREAMING_SNAKE_CASE 
* Должны содержать в названии имя модуля, к которому они принадлежат. 

К именованным константам относятся:
1. Макросы `#define OS_TYPE 'Windows'`;
2. Глобальные константы `const uint8_t ROBOT_SENSORS_AMOUNT = 10;`;
3. Перечисления `led_color_e ledColor = LED_COLOR_GREEN`.

### Переменные

* Пишутся в camelCase со строчной буквы.
* Не рекомендуется начинать имя с глагола.
* Объявление новой переменной всегда должно начинаться с новой строки.

```c
uint32_t amount;
char* name[10];
uint8_t arrayLength;
struct module robot;
```

#### Указатели

* Символ указателя "*" относится к типу данных и должен быть "приклеен" к нему:

```c
char* name = "Anton";
typedef struct module* module_t;
void Destroy(module_t* me);

```

* Указатели на функции следуют правилам именования переменных:

```c
void (*setVelocity)(uint32_t velocity);

typedef bool (*module_name_callback_f)(void* arg);

module_name_callback_f getAdcData;

```

#### Глобальные константы

* Следуют правилам написания именованных констант.
* Для локальных констант допускается не прописывать полное имя модуля.

```c
const uint32_t MODULE_NAME_SENSORS_AMOUNT = 10u;
static const uint32_t SENSORS_AMOUNT = 10;
```

### Функции

* Названия функций пишутся в CamelCase с большой буквы.
* Названия функций рекомендуется начинать с глагола.
* Аргументы функций следуют правилам именования переменных.

```c
void ModuleName_DoSomething(const char* argName2, uint8_t argName1);

static inline void DoSomething(void) {
  ...
}
```

### Перечисления

* Следуют правилам именованных констант.
* Элементы перечисления должны содержать в названии имя типа.
* Имя типа должно содержать в себе имя модуля.

```c
typedef enum led_color {
    LED_COLOR_GREEN,
    LED_COLOR_BLUE,

} led_color_e;
```

* Если для перечисляемого типа важно количество элементов или нужно отслеживать последний доступный элемент, то рекомендуется использовать шаблон "TYPE_NAME!!S_AMOUNT!!"

```c
typedef enum  {
    FETCH_TYPE_SIMPLE,
    FETCH_TYPE_RELFORM_DEBUG,
    FETCH_TYPE_ATR_DEBUG,
    FETCH_TYPE_SELECTED,
    FETCH_TYPE_ATR_SELECTED,
    FETCH_TYPE_LARGE_YA,
    
    FETCH_TYPES_AMOUNT
    
} fetch_type_e;

```

### Файлы и препроцессор

#### Файлы

* Имена файлов пишутся в snake_case: `file_name.h`
* Расширения для Си файлов:`.c`, `.h`, для С++: `.cpp`, `.h`.
* Если заголовочный и исходный файлы относятся к одному модулю, то находиться они должны в одной директории.

#### Препроцессор

##### Макроопределения

* Макроопределения всегда должны включать в себя имя модуля к которому относятся

```c
#define DEBUG
#define MODULE_NAME_MASK_ERROR  0x0F
```

* Необходимо явно указывать тип для беззнаковых констант в десятичной записи и чисел с плавающей точкой:

```c
#define UNSIGN_CONST    234123u
#define FLOAT_CONST     100.f
```

* Без указания типа допустимы: 

```c
#define HEX_CONST        0xFFAA20BB  ///< Может быть только беззнаковым
#define DOUBLE_CONST     100.0       ///< По умолчанию double
#define DECIMAL_CONST    100         ///< По умолчанию int
```


#### Макрофункции

* Используются для обобщенного программирования.
* Можно использовать только в ситуации, когда макрофункция позволяет избавиться от копипасты в участках кода с общей логикой, но разными типами данных.

#### Условная компиляция
* Крайне не рекомендуется использовать внутри тела функции.

### Форматирование

#### Комментарии 

* Оформляются в стиле Doxygen.
* Пишутся на английском или русском языке (UTF-8).
* Для однострочных коротких описаний используется (///...).
* Дли многострочных и подробных описаний - (/** ... */).
* Используем собаку "@" в качестве индикатора команды, а не обратный слэш "\". Например, @brief, а не \brief.
* Комментарии следует оставлять в крайнем случае, если можно переписать код и избавиться от комментария, то лучше поступить именно так. 

#### Отступы

Символы табуляции запрещены. Для отступа используются пробелы, нормативный сдвиг = 4. Сдвиг должен заполняться пробелами, даже если Вы и нажимаете на кнопку tab.

#### Стиль блоков

Для блочных операторов применяется стиль 1TBS
```c
if (something) { // K&R style
    One();
    Two();
} else {
    Three();
    Four();
}
for (int i = 0; i < N; ++i) { // K&R style
    // do something...
}
```

Многострочные условия являются исключением (если условие не помещается в одну строчку - это повод разбить его на несколько), они записываются так:

```c
if (a && b && c &&
    d && e)
{
    Op();
}
```

Для функций применяется:
```c
Func1(a, b, c) {
}
```

Либо:
```c
Func1(a, b, c) 
{
}
```

В пределах одного файла стиль расстановки фигурных скобок должен быть один.

##### Короткие блоки

Однострочные тела операторов, а также inline-функций должны начинаться с новой строки. Тела операторов и функции, объявленные в одну строку, доставляют неудобства при отладке. Тело оператора должно всегда быть в фигурных скобках.
```
if (something) {
    A();
}
```

Подчиненный оператор не должен быть пустым. Запрещено:
```c
for (int i = 0; i < 100; i++);
```

Причина: такой текст не отличим от опечатки, невылавливаемой на этапе компиляции.

##### Операторы

Запрещается использовать на одной строке несколько операторов.

##### Пустые строки

Рекомендуется оставлять пустые строки между отдельными логическими блоками кода. Это значительно улучшает его читаемость.

#### Пробелы

##### Знаки операций

Все знаки операций, за исключением унарных и операторов доступа к членам структур, отбиваются с обеих сторон пробелом:

```c
a = b;
x += 3;
z = a / 6;
```

В том числе и знак присваивания. То есть надо писать:
```c
if (!x.a || ~(b->c - e.d) == 0)
    z = 0;
```

##### Указатели

Для указателей звёздочка (`*`) приклеивется к типу данных.
```c
void Bar(int* p);
```

##### Скобки

После имени функции, после открывающей скобки и перед закрывающей скобкой пробел не ставится:
Func(a, b, c);
между оператором и скобкой пробел ставится:

```c
if ()
for ()
while ()
```

Пробелы внутри скобок выглядят так:

```c
Func(a, b, c);
(a + b)
```

Асимметричные пробелы не допускаются.

##### Конец строки

Пробелов в конце строки быть не должно. Для этого можно использовать опции вашего текстового редактора.

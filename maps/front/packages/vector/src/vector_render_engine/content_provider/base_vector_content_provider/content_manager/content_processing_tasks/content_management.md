##Полилинии
Полилинии бывают трех типов: текстурированные, просто сплошные цветные и пунктирные.
Они должны антиалиаситься и важен порядок наложения (сложные развязки, жд пути под и над дорогой и т.п.).
Текстурированные, понятно, могут не быть готовы сразу, до загрузки недостающей иконки.
По сложности (кол-во вершин в первую очередь и по среднему кол-ву в сцене) это самые тяжелые примитивы,
т.е. важна производительность.

Мотивируясь изложенным выше полилинии реализовались следующим образом: все типы рисуются одним шейдером, 
получая цвет из текстуры. Это позволяет групировать отрисовку. Для сплошных и пунктирных линий иконка 
готовится синхронно по мере необходимости, попиксельно, учитывая антиалиасинг. Такая иконка ничем  не отличается
от "нормальной", она имеет идентификатор (из цвета и ширины) и на нее так же ссылается тайл 
как на внешний ресурс. Для сплошной линии создается сглаженный кружок определенного диаметра, это позволяет
рисовать тело лиconst halfWidthSquared = halfWidth * halfWidth;
                                const displacementSquared = directionDisplacement * directionDisplacement;
                                const vDisplacement = halfWidthSquared / Math.sqrt(halfWidthSquared + displacementSquared);
                                iнии разрезом из середины и относительно дешево закругленные окончания. Для пунктирной линии
иконка представляет из себя закрашенную и пустую прямоугольную область заданных размеров (fill, gap),
также сглаженные.

Проблема того, что иконка может не быть загружена на момент подготовки буфера (мы не знаем ее размер, не знаем
где она лежит в атласе) решается так: шейдер устроен таким образом, что зависимость от конкретной иконки
сконцентрирована в двух атрибутах (позиция в атласе и размер пикселя), которые можно переписать одним тупым проходом.
Это позволяет записать буфер со всеми линиями сразу в правильном порядке, не дожидаясь всех иконок (недостающие
заменить произрачной иконкой, так, чтобы линия не была видна при рендеринге), а когда иконки придут, заалоцировать их 
и на место упомянутых атрибутов записать актуальную информацию. После такой перезаписи менеджер памяти
дергается, чтобы синхронизировать соответствующую область. Возникает проблема, что при создании примитива
необходимо указать атлас в котором лежит иконка, и этот атлас на момент записи иконки-заглушки (прозрачной)
неизвестен, но легко предсказывается: атлас большой, иконка маленькая и она будет загружена очень скоро, 
можно предположить, что и разместится она в текущем атласе. Если же этого не случилось просто удаляем текущие
примитивы и создаем их заново из уже записанной памяти, накладные расходы небольшие, но даже они будут возникать
нечасто. Порядок выдержан, дополнительных обременений для рендеринга на случилось.

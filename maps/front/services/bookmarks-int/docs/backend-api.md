# bookmarks-int API

API для управления публичными закладками пользователей геосервисов.
Включает в себя функционал для публикации списков гео-закладок, подписки на опубликованные списки и отмены указанных выше действий.

## Допущения

При проектировании некоторых ручек мы полагались на тот факт, что композиция ключей `uid` + `record_id` всегда уникальная для любого списка и не пересекается ни с одним другим списком ни одного другого пользователя.

Также мы расчитываем, что клиенты способны получить из DataSync следующие [данные](https://wiki.yandex-team.ru/maps/dev/core/geobookmarks/#dbscheme):
```ts
interface DataSyncItem { // Общие для списка и закладки поля
    record_id: string;
    title: string;
    tags: string[];
}

interface DataSyncBookmark extends DataSyncItem { // Поля закладки
    uri: string;
    description: string;
}

interface DataSyncList extends DataSyncItem { // Поля списка
    children: DataSyncBookmark[];
}
```

## Общие положения

### Сервисы-потребители

Планируемые основные потребители сервиса:

- БЯК
- МЯК

### Авторизация

Все клиенты авторизуются с помощью [юзер-тикетов](https://wiki.yandex-team.ru/passport/tvm2/user-ticket/) и [сервис-тикетов](https://wiki.yandex-team.ru/passport/tvm2/stbrief/) TVM.
Обмен OAuth токенов, переданных с клиентов, на юзер-тикеты осуществляется в сервере БЯК и мобильном прокси.

### Как работает синхронизация списков

При обновлении списков смотрим на их ревизию (поле `revision` берется клиентами из DataSync).
Если пользователь изменил любой открытый список - клиент должен дождаться обновления облачной DataSync БД и отправить все открытые списки на обновление с новой ревизией.
Если пользователь обновил закрытый список - этого делать не нужно.
`bookmarks-int` всегда сохраняет изменения с бОльшей ревизией, а в случае конфликтной ситуации (ревизия в запросе <= ревизии в БД бэкенда) бэкенд вернет актуальныей сохраненный список из своей БД и добавит к ответу поле `error = outdated`.

### Статус списка
У списка в базе может быть один из 3х статусов:
- `shared` - список пошарен, доступен по ссылке и на него можно подписаться
- `closed` - список был пошарен, но сейчас закрыт = на него нельзя подписаться, но он доступен для подписчиков
- `deleted` - список был удален пользователем через UI либо по GDPR

Возможные переходы по статусам представлены на картинке:

![Diagram](./diagrams/statuses.png)

### GDPR

#### Какие данные мы используем

- `display_name` из Паспорта. Мы его не храним, каждый раз ходим за ним в паспорт.
- UGC закладок и списков (храним наименования, описания и т.д.)

#### Как мы используем удаленные/скрытые данные

- Если список закрывается (перестает быть публичным), клиенты подписчиков по-прежнему могут получить последнюю сохраненную версию списка
- При удалении закладки из списка клиенты подписчиков удаляют ее при первой синхронизации с сервисом.
- При удалении списка пользователем (через UI) клиент может попросить бэкенд либо закрыть список (если пользователь дал разрешение оставить этот список у подписчиков), либо полностью удалить его. В первом случае клиенты подписчиков по-прежнему могут получить последнюю сохраненную версию списка, во втором - клиенты уже не смогут синхронизировать последнюю версию с бэкенда, а также будут обязаны удалить этот список из локального кэша (если они его поддерживают).
- При удалении списка по GDPR (из Паспорта) происходит то же самое, что и при удалении через UI.

См. также ответы юристов
* https://st.yandex-team.ru/MAPSBACKLOG-1260#5fc8a578b3f2b96d5300de4d
* https://st.yandex-team.ru/LEGAL-43922

#### Как мы делаем GDPR выгрузку данных

- Поддерживаем интеграцию с паспортом с помощью следующих **синхронных** ручек:
    - [`POST /takeout`](https://wiki.yandex-team.ru/passport/takeout/integration/#sinxronnyjjmexanizmvygruzkidannyx). Возвращает ссылки на хранящиеся в сервисе списки (`file_links`) и подписки (`data.subscriptions.json`)
    - [`GET /takeout/status`](https://wiki.yandex-team.ru/users/yakushevsky/takeoutrequirements/#polucheniedannyx)
    - [`POST /takeout/delete`](https://wiki.yandex-team.ru/users/yakushevsky/takeoutrequirements/#udaleniedannyx)
    - `GET /takeout/lists/:id`. Возвращает JSON-файл с данными по конкретному списку
- Регулярным процессом синхронизируем удалённые из паспорта аккаунты с сервисной БД
  > **Примечание:** Удаленные таким образом данные (id и public_id списка, время удаления, uid владельца) будут залогированы в отдельную таблицу в БД, чтобы можно было быстро разобраться, почему перестал отображаться публичный список по его id.

### Спецификация локального кэша

Для того, чтобы работать в офлайне и немного снизить нагрузку на сервис мы рекомендуем клиентам хранить некоторые данные в локальном кэше (клиент может этого и не делать и работать полностью в онлайн режиме):

- Кэш автора - словарь (Map), где ключи - `record_id`, а значения включает в себя:
  - `public_id` - уникальный id списка в рамках `bookmarks-int`, по которому его могут посмотреть другие пользователи. Однозначно соответствует `uid + list.record_id`. Генерируется на бекенде.
  Помимо этого для списков в DataSync необходимо добавить два новых тэга:
    - `maps:shared`
    - `maps:shared:closed`

  Для каждого списка на клиенте может выйти одно из следующих состояний:
    - `tags:[]` - Список никогда не шарился
    - `tags:[maps:shared]` - Список пошарен, загружен на бэк и доступен для скачивания/просмотра
    - `tags:[maps:shared, maps:shared:closed]` - Список был пошарен, но в данный момент его закрыли. Для скачивания доступна только последняя загруженная версия
    - `tags:[maps:shared:closed]` - Список был пошарен, но в данный момент его удалили и он более недоступен для подписки
- Кэш подписчика - массив списков, на которые подписан пользователь. Приходит на клиент из бэкенда. Каждый список хранит в себе:
  - `revision` - ревизия списка, генерируется на стороне DataSync
  - `public_id` - идентично кэшу автора
  - Данные списка: `title`, `children`, последний содержит все внутренние данные заметок: `title`, `description` и т.д.

## Варианты использования

### Роль: Автор закладки/списка

#### Синхронизировать измененные списки

_Описание_: Автор каким-либо образом изменяет свои публичные списки: содает новый, редактирует список или входящую в него закладку, закрывает, переоткрывает, удаляет список. Эти изменения должны быть отображены в `bookmarks-int`, чтобы подписчики смогли получить обновления.

_Предусловия_: Список и все его закладки сохранены в DataSync (исключение - удаление списка), завершены все синхронизации с облаком DataSync (обновлен тэг `shared`)

_Постусловия_: В `bookmarks-int` сохранены последние (согласно ревизии) версии публичных списков, эти же данные возвращены на клиент в теле ответа.

_Дополнительные бизнес-правила_:

- Правила обновления закладок:
  - Если `record_id` передается - закладка будет создана (или переписана, если уже существует).
  - Если `record_id` не передается - закладка будет закрыта.
- Во избежание утечки закрытых данных для _закрываемых_ и _удаляемых_ списков необходимо передавать **только поля** `revision`, `record_id` и `status`.
- Как определить статус удаляемых списков:
  - Если клиент поддерживает удаление списков у подписчиков - необходимо спросить у пользователя разрешение оставить удаляемые списки у подписчиков. Если он даст разрешение - `status` = `closed`, иначе `status` = `deleted`
  - Иначе `status` = `closed`
- Списки пользователя, которые **не были переданы** в запросе на обновление будут **автоматически помечены, как закрытые**

_Псевдокод_
```js
async function syncLists(lists: DataSyncList[]) {
    const body = lists.map(x => {revision, record_id, status, title, bookmarks: [{record_id, title, uri, description}, ...]});
    const result = await http.post('https://bookmarks-int/v1/sync_shared_lists', {headers: {...}, body});

    if (result.canNotGetResponse) {/*Следуя принятой политике ретраев, сделать ретрай*/}
    if (result.statusCode === 200) {
        // Порядок списков в теле ответа != порядку в теле запроса
        // Сохранить ответ в локальный кэш
        for (const listInfo of result.body) {
            if (listInfo.error) {
                /*Обработать конфликт ревизий*/
            } else {
                authorLocalCache.update(listInfo);
            }
        }
    } else {
        /*Следуя принятой политике ретраев, сделать ретрай*/
    }
}
```

_Обработка ошибок_:
Если клиент не получил ответа от сервера - он может, следуя принятой политике ретраев, повторить запрос к серверу. Это не создаст дубликатов в БД (за счет передачи `record_id`). Даже если переданные в запросе данные являются неактуальными (по ревизии) - бэкенд их не примет и вернет то, что уже сохранено в БД сервиса.
Клиент обязан оповестить бэкенд об изменении списка **только после того**, как в DataSync завершилась синхронизация с облаком. В случае, если ретраи были прерваны (приложение надолго закрыли или удалили) - клиент обязан будет позаботатиться об успешном изменении/удалении данных из `bookmarks-int`. Для этого можно запросить текущие публичные списки пользователя через `/get_lists` и синхронизировать содержимое DataSync с ее ответом (источник правды - DataSync).

#### Получить все списки, которыми я поделился

_Описание_: Клиент получает список всех списков, опубликованных пользователем (например, для удаления из списков, отсутствующих в DataSync)

_Предусловия и Постусловия_: Нет

_Псевдокод_
```js
async function getMySharedLists() {
    const body = {only: 'my_shared'};
    const result = await http.post('https://bookmarks-int/v1/get_lists', {headers: {...}, body});

    if (result.canNotGetResponse) {/*Следуя принятой политике ретраев, сделать ретрай*/}

    /*Логика на усмотрение клиента. Например: продолжить попытки удаления*/
}
```

_Обработка ошибок_: Если клиент не получил ответа от сервера - он может, следуя принятой политике ретраев, повторить запрос к серверу. Это не приведет к проблемам с данными.

### Роль: Подписчик списка

#### Подписаться на список

_Описание_: Подписчик получил пермалинк на список закладок и использует его для подписки на него.

_Предусловия_: Нет

_Постусловия_: В `bookmarks-int` сохранена информация о подписке. Клиент может ее закэшировать

_Псевдокод_
```js
async function subscribeList(list_id: string) {
    const body = {add: list_id};
    const result = await http.post('https://bookmarks-int/v1/change_subscription', {headers: {...}, body});

    if (result.canNotGetResponse) {/*Следуя принятой политике ретраев, сделать ретрай*/}

    if (result.statusCode === 410) {notifyUser('Ссылка ведет на список, автор которого удалил его или ограничил к нему доступ');}

    if (result.statusCode === 200) {
        if (!result.body.subscription_changed) {
            notifyUser('Вы уже подписаны на данный список');
            return;
        }
        notifyUser('Успешно');
        /*Сохранить данные в кэш*/
    } else {
        /*Следуя принятой политике ретраев, сделать ретрай*/
    }
}
```

_Обработка ошибок_: Если клиент не получил ответа от сервера - он может, следуя принятой политике ретраев, повторить запрос к серверу. Это не создаст дубликатов в БД

#### Отписаться от списка

_Описание_: Пользователь нажимает кнопку 'Отписаться'. Клиент должен запросить закрытие подписки и удалить связанный кэш (если был)

_Предусловия_: Пользователь подписан на какой-либо список, клиенту известен его id

_Постусловия_: Пользователь больше не увидит список в своих подписках и не получит его обновлений

_Псевдокод_
```js
async function unsubscribeList(lists_id: string) {
    const body = {remove: list_id};
    const result = await http.post('https://bookmarks-int/v1/change_subscription', {headers: {...}, body});

    if (result.canNotGetResponse) {/*Следуя принятой политике ретраев, сделать ретрай*/}

    if (result.statusCode === 200) {
        if (!result.body.subscription_changed) {
            notifyUser('Вы не были подписаны на этот список');
            return;
        }
        notifyUser('Успешно');
        /*Обновить кэш*/
    } else {
        /*Следуя принятой политике ретраев, сделать ретрай*/
    }
}
```

_Обработка ошибок_: Если клиент не получил ответа от сервера - он может, следуя принятой политике ретраев, повторить запрос к серверу. Это не приведет к возвращению ошибочного статус-кода или проблемам с данными.

#### Получить обновление списка

_Описание_: Подписчик хочет автоматически видеть все обновления его подписок при подключении к сети

_Предусловия_: У подписчика есть какие-либо подписки, клиенту известны их (списков) id

_Постусловия_: Клиент получил актуальные состояния своих подписок и может их отобразить [и закешировать]

_Псевдокод_
```js
async function getSubscriptionsUpdates() {
    const result = await http.get('https://bookmarks-int/v1/get_subscriptions_statuses', {headers: {...}});

    if (result.canNotGetResponse || result.statusCode !== 200) {/*Следуя принятой политике ретраев, сделать ретрай*/}

    const body = {/*Собрать все требующие обновления id из result*/};
    const subscriptionResult = await http.post('https://bookmarks-int/v1/get_lists', {headers: {...}, body});

    if (subscriptionResult.canNotGetResponse || subscriptionResult.statusCode !== 200) {/*Следуя принятой политике ретраев, сделать ретрай*/}

    for (const update of subscriptionResult.body) {
        /*Отобразить обновления, сохранить данные в кэш, удалить ненужные данные из кэша*/
    }
}
```

_Обработка ошибок_: Если клиент не получит ответа на какой-либо запрос - его можно безопасно повторить, следуя принятой политике ретраев.

#### Получить все списки, на которые я подписан

_Описание_: Клиенту нужно загрузить детальную информацию по всем подпискам (например, для отображения их списка в UI).

_Предусловия_: Нет

_Постусловия_: Нет

_Псевдокод_
```js
async function getDetailedSubscriptionsList(onlyTitles: bool) {
    const result = await http.post('https://bookmarks-int/v1/get_lists', {headers: {...}, body: {only: 'my_subscriptions'}});

    if (result.canNotGetResponse || result.statusCode !== 200) {/*Следуя принятой политике ретраев, сделать ретрай*/}

    /*Логика на усмотрение клиента. Например: обновить кэш, запросить обновления, отобразить в UI*/
}
```

_Обработка ошибок_: Если клиент не получит ответа на запрос - его можно безопасно повторить, следуя принятой политике ретраев.

### Роль: Незалогиненный пользователь

#### Просмотреть список

_Описание_: Незалогиненный пользователь хочет просмотреть содержимое открытого списка. Клиенту не нужно сохранять его в локальный кэш

_Предусловия_: Клиенту известен id открытого(ых) списка(ов)

_Постусловия_: Нет

_Псевдокод_
```js
async function viewList(list_ids: string[]) {
    const body = {only: list_ids};
    const result = await http.post('https://bookmarks-int/v1/get_lists', {headers: {}, body});

    if (result.canNotGetResponse) {/*Следуя принятой политике ретраев, сделать ретрай*/}

    if (result.statusCode === 400) {notifyUser('Как минимум один public_id некорректен');}

    if (result.statusCode === 200) {
        if (isListsMissed(result.body, list_ids)) {
            /*
            Бэкенд вернул не все списки, что были запрошены. Так бывает, например,
            если список был закрыт и пользователь не был на него подписан.
            Необходимо уведомить об этом пользователя.
            */
        }
        /*Логика на усмотрение клиента. Например: отобразить UI с данными*/
    } else {
        /*Следуя принятой политике ретраев, сделать ретрай*/
    }
}
```

_Обработка ошибок_: Если клиент не получит ответа на запрос - его можно безопасно повторить, следуя принятой политике ретраев.

## API методы

Описание сигнатур API методов находится в файле [swagger.yaml](./swagger/v1/spec.yaml)

# Aвтотесты

Внутри проекта у нас есть два основных типа интеграционных автотестов:

-   пользовательские сценарии (`sets/desktop`, `sets/mobile`);
-   счётчики (`sets/counters`).

Пользовательские сценарии бывают функциональные и скриншотные. Первые проверяют логику работы некого компонента, а вторые проверяют отображение компонента, сравнивая его с эталонным отображением.

-   [Как писать автотесты](#Как-писать-автотесты)
-   [Автозапуск в CI](#Автозапуск-в-ci)
-   [Ручной запуск тестов по стендам](#Ручной-запуск-тестов-по-стендам)
-   [Почему тесты запускаются только по стендам?](#Почему-тесты-запускаются-только-по-стендам)

Что делать, если:

-   [Тест правильный. Ошибка в коде](#Тест-правильный-Ошибка-в-коде)
-   [Скриншотный тест правильный. Но он упал](#Скриншотный-тест-правильный-Но-он-упал)
-   [Код правильный. Ошибка именно в тесте, нужно исправить](#Код-правильный-Ошибка-именно-в-тесте-нужно-исправить)
-   [Код правильный. Теста ещё нет, нужно создать](#Код-правильный-Теста-ещё-нет-нужно-создать)
    -   [Пишем тест к своей (новой) фиче-ветке](#Пишем-тест-к-своей-новой-фиче-ветке)
    -   [Пишем тест к существующей ветке](#Пишем-тест-к-существующей-ветке)
    -   [Запуск тестов по кастомным хостам](#Запуск-тестов-по-кастомным-хостам)
-   [Если в "вашем" PR упали "чужие" тесты](#Если-в-вашем-pr-упали-чужие-тесты)
    -   [Точно упал "чужой" тест?](#Точно-упал-чужой-тест)
    -   [Скипаем "чужой" тест](#Скипаем-чужой-тест)
-   [Нужно создать пользователя для автотестов](#Нужно-создать-пользователя-для-автотестов)

Для разработки автотестов мы используем специальный инструмент — [Hermione](https://github.com/gemini-testing/hermione). Для запуска тестов в разных браузерах используется удалённый [Selenium-грид](https://wiki.yandex-team.ru/selenium/).

В общем случае запускать тесты руками разработчику не нужно, это происходит автоматически после создания
pull-request. Однако существуют случаи, когда ручное вмешательство требуется. Ниже обо всех случаях детально.

## Как писать автотесты

Файлы с тестами называем в зависимости от платформы, для которой написаны тесты:

-   `*.autotest.desktop.ts`;
-   `*.autotest.mobile.ts`.

Тесты, которые должны быть выполнены на обоих платформах должны иметь следующее расширение расширение:

`*.autotest.ts`

Файл с тестами размещаем в одном из двух мест:

-   в директории вьюшки, которую тестируем: `/views/<view-name>/<view-name>.autotest.(desktop|mobile).ts`;
-   в директории высокоуровневого компонента: `/components/<component-name>.autotest.(desktop|mobile).ts`. Здесь размещаем только те тесты, которые проверяют высокоуровневую функциональность отдельных разделов приложения (если её трудно отнести к конкретной вьюшке), либо если проверяем функциональность работы карты.

В файле с тестами пишем один или несколько тестсьютов (`describe`), внутри которых описываем тесткейсы (`it`), которые тестируют соответствующий компонент или раздел приложения.

Для хранения CSS-селекторов используем глобальный модуль `cssSelectors`.

### Асинхронность выполнения команд

Все команды класса `Browser`, как унаследованные от `WebDriverIO`, так и команды `Hermione` и даже кастомные команды, являются асинхронными. Каждый вызов команды возвращает `PromiseLike` сущность, которая, для сохранения последовательности вызовов, может быть использована для вызова следующей команды по цепочке или может быть выполнена с ключевым словом `await`.

При написании тестов принято использовать исключительно `async/await` синтаксис. Синтаксис с использованиеи цепочек вызовов не рекомендуется к использованию и не поддерживается. При использовании такого синтаксиса велика вероятность получить ошибку валидации тесткейсов в прекоммит хуке.

### Ошибки использования `async/await`

Обратите внимание на то, что при использовании синтаксиса `async/await` для ожидания выполнения последовательности команд в тесте, то все вызовы или цепочки вызовов методов класса `Browser` должны быть помечены ключевым словом `await`.

В следующем примере выполнение первой строчки будет проигнорировано:

```ts
this.waitForVisible(selector1);
return this.waitForVisible(selector2);
```

Данную последовательность команд следует переписать следующим образом:

```ts
await this.waitForVisible(selector1);
return this.waitForVisible(selector2);
```

### Переиспользование кода тестов

При написании тестов часто возникает желание вынести куда-то повторяющиеся шаги. Для большинства случаев, достаточно воспользоваться хуками `beforeEach` и `afterEach` или же вынести набор команд в функцию-хелпер и вызывать ее во всех необходимых местах.

Оба этих способа хорошо работают. Но стоит остановиться отдельно на случае, когда функцию-хелпер хочется использовать более чем в одном файле. В таких случаях ни в коем случае **нельзя экспортировать функцию из одного файла в другой**. Данные действия приведут к тому, что в процессе прогона тестов, в одном из файлов будет утерян контекст выполнения. Из-за чего, вся работа гермионы с файловой системой (например, сохранение скриншотов) будет вести себя непредсказуемым образом.

Для того чтобы решить задачу переиспользования логики в тестах следует придерживаться одного из приведенных ниже вариантов.

#### Вынесение последовательность команд в отдельную команду

Данный способ отлично подходит для ситуации, когда выполняются какие-то часто повторяющиеся действия, которые не завязаны на реализацию конкретного блока. Его стоит использовать для проверки текста в инпуте или клик в центр элемента. Этот способ не стоит использовать, например, для перехода в фотогалерею организации из ее карточки — данная команда слишком узкая и не найдет применения в широком наборе кейсов.

#### Вынесение функции-хелпера в /tests/utils

Этот вариант стоит использовать, когда ваш набор команд завязан на реализацию какого-то блока, но при этом достаточно сложен и используется в нескольких файлах. Например, генерация урла для открытия карт с линейкой достаточно нетривиальна и поэтому вынесена в `tests/utils/ruler-utils.ts`.

#### Дублирование последовательности команд

Для большинства остальных случаев лучше всего подходит этот способ работы. Если ваша повторяющаяся последовательность действий состоит из 2-3 команд, то не стоит выносить ее в отдельные хелперы. Простое дублирование команд позволит сохранить читаемость кода на высоком уровне и не будет вызывать проблем при рефакторинге.

### Как писать тесты, которые синхронизируются с Test Palm

Чтобы ускорить тестирование и доставку фич в продакшен, тесты выгружаются в систему Test Palm. Для этого скрипт синхронизации парсит все наши автотесты, расшифровывает их, а затем создает на их основе тесткейсы в системе Test Palm. После этого тестировщики сверяются с этим набором автоматизированных кейсов и не воспроизводят их при ручном регрессионном тестировании. Чтобы скрипт синхронизации работал корректно, необходимо придерживаться нескольких правил.

#### Нельзя использовать `then` в тестах

В большинстве кейсов использование метода `then` излишне. Скорее всего то, что вы хотите сделать, уже реализовано в специализированной hermione-команде.

Например, вместо следующей последовательности действий:

```ts
const text = this.browser.getValue(cssSelectors.search.input);
await this.browser.perform(() => expect(nextTitle).equals(title, 'Доставка еды'), 'Проверить текст в поисковом инпуте');
```

надо использовать готовую команду:

```ts
    .waitAndCheckValue(cssSelectors.search.input, 'Доставка еды');
```

Если же вас случай сложный, и готовой команды для него нет, то для корректной работы скрипта выгрузки необходимо заключить вашу последовательность команд внутрь специальной команды `perform`.

Вместо:

```ts
const elements = await this.browser.$$(cssSelectors.mapControls.ruler.rulerPoint)
const {x, y} = await elements[1].getLocation();
await this.browser.simulateClick({x, y});
await this.browser.pause(50);
await this.browser.simulateClick({x, y});
```

следует написать:

```ts
await this.browser.perform(async () => {
    const elements = await this.browser.$$(cssSelectors.mapControls.ruler.rulerPoint)
    const {x, y} = await elements[1].getLocation();
    await this.browser.simulateClick({x, y, description: ''});
    await this.browser.pause(50);
    await this.browser.simulateClick({x, y, description: ''});
}, 'Сделать двойной клик во вторую точку линейки.');
```

Команда `perform` в качестве второго аргумента принимает текстовое описание, совершаемых ею действий. Именно это описание попадет в выгрузку и будет доступно тестировщикам для анализа содержания вашего кейса.
Если в вашем случае команда perform содержит внутри лишь техническую логику, не представляющую интереса для тестировщиков, то в качестве второго аргумента команде perform следует передать `null`. Такие шаги будут отфильтрованы и в выгрузку не попадут.

#### Функцию `expect` можно использовать только внутри команды `perform`

Так как в процессе выгрузки мы имеем дело не с реальным выполнением команд, а с выполнением их моковых аналогов, никакие проверки с использованием `expect` не будут выполнены. Их падение приведет к падению скрипта парсинга тестов и невозможности выгрузки. Для кейсов содержащих `expect` также необходимо использовать команду `perform`.

Вместо:

```ts
expect(carouselPosition.x).lessThan(0, 'Карусель на стартовой позиции, ожидается обратное.');
```

пишем:

```ts
await browser.perform(() => {
    expect(carouselPosition.x).lessThan(0, 'Карусель на стартовой позиции, ожидается обратное.');
}, 'Проверить, что карусель проскроллена.');
```

#### Используйте правильные команды для кликов

В данный момент у нас имеется несколько способов кликнуть в произвольное место. Это команды: `clickInMap` (ранее `clickInMapCenter`), `simulateClick`, `simulateGeoClick`. Очень важно использовать эти команды правильно. Это позволит проще поддерживать тесты, читать их и выгружать их для ручного прогона тестировщиками или ассессорами.

##### `clickInMap`

Команда `clickInMap` должна быть использована только если нам неважно в какое конкретно место карты будет совершен клик. Это действие удобно, когда нам надо снять фокус с инпута, закрыть попап или вызвать вотсхир. Если вам надо попасть в конкретную точку на карте (линия, улица или остановка), то эта команда не подходит. Используйте `simulateGeoClick`.

Неправильное использование:

```ts
// Клик в остановку на карте
await this.browser.openPage('?ll=30.390662,60.006289&z=17', {mockToday: '2019-02-11 20:00'});
await this.browser.clickInMap();
await this.browser.waitForVisible(cssSelectors.masstransitStop.stop.container);
```

Правильное использование:

```ts
// Клик в карту закрывает балун активной плейсмарки дискавери
await this.browser.waitAndClickInCenter(placemark);
await this.browser.waitForVisible(cssSelectors.discovery.balloon.view);
await this.browser.clickInMap();
await this.browser.waitForHidden(cssSelectors.discovery.balloon.view);
```

##### `simulateGeoClick`

Команда `simulateGeoClick` используется для клика в какую-то определенную точку на карте. Получите координаты точки на карте и передайте их в команду. Команда требует наличия текстового описания того, куда вы хотите кликнуть (поле `description` в опциях команды станет обязательным параметром [задаче](https://st.yandex-team.ru/MAPSUI-17429)).

Неправильное использование команды `clickInMap` в прошлом примере следует переписать с использованием команды `simulateGeoClick` таким образом:

```ts
// Клик в остановку на карте
await this.browser.openPage('?ll=30.390662,60.006289&z=17', {mockToday: '2019-02-11 20:00'});
await this.browser.simulateGeoClick({
    point: [30.390662, 60.006289],
    description: 'Кликнуть в пои остановки.'
});
await this.browser.waitForVisible(cssSelectors.masstransitStop.stop.container);
```

##### `simulateClick`

Команда `simulateClick` должна использоваться только для кликов в произвольные точки интерфейса карт. Это может быть как сама карта, так и другие компоненты (например, галерея фото). Но использоваться эта команда должна только тогда, когда невозможно совершить клик используя селектор элемента (тогда используется `waitAndClick`) или когда нам не надо попасть в конкретную точку на карте (правильная команда в этом случае - `simulateGeoClick`). Команда требует наличия текстового описания того, куда вы хотите кликнуть (поле `description` в опциях команды).

Неправильное использование:

```ts
// Клик в нитку альтернативного маршрута должне осуществляться с использованием команды simulateGeoClick
await this.browser.simulateClick({
    x: 895,
    y: 256,
    description: 'Клик в линию альтернативного маршрута'
});
await this.browser.waitForVisible(cssSelectors.routes.routeList.secondActiveSnippet);
```

Правильное использование:

```ts
// Нам неважно что находится под этими точками на карте. Просто это должны быть две различные точки.
const [x, y] = await this.browser.getMapCenter();
await this.browser.simulateClick({
    x: x - 50,
    y: y - 50,
    description: 'Кликнуть в произвольную точку на карте'
});
await this.browser.waitForVisible(cssSelectors.mapControls.ruler.rulerPoint);
await this.browser.simulateClick({
    x: x + 50,
    y: y + 50,
    description: 'Кликнуть в другую произвольную точку на карте'
});
```

или

```ts
// Кликнуть надо не в селектор, а просто в область галереи с открытым фото.
await openBusinessPhoto(this.browser);
await this.browser.simulateClick({
    x: viewport.width / 2 + 100,
    y: viewport.height / 2,
    description: 'Кликнуть в правую половину открытого плеера фотографий.'
});
await this.browser.waitForHidden(cssSelectors.photo.arrows.backwardDisabled);
```

**Важно**

Если ваши тесткейсы будут содержать последовательность команд, которая приведет к падению скрипта выгрузки, pre-commit hook сообщит вам об этом падением проверки `validate-testcases`. Для локального дебага можно запустить эту проверку с помощью команды `make validate-testcases`.

### Общие тесты

Есть несколько техник, которые облегчают написание общих тестов и положительно сказываются на их читаемости.

#### Платформозависимые селекторы

Часто возникает ситуация, когда одина и та же команда в тесте должна быть применена для разных элементов интерфейса, в зависимости от платформы. В таком случае проще всего использованить тернарное выражение, которые будет выбирать селектор на основании значения поля `this.browser.isPhone`.

```ts
await this.browser.waitForVisible(
    this.browser.isPhone ? cssSelectors.collapsedCardTitle : cssSelectors.search.businessCard.title
);
```

#### Платформозависимые шаги

Другой часто встречающийся случай при написании общих тестов - дополнительные шаги теста, которые необходимо выполнить только для одной из платформ. В таких случаях достаточно поместить данные шаги внуть условия проверяющего значение поля `this.browser.isPhone`.

```ts
if (this.browser.isPhone) {
    await this.browser.swipeShutter('up');
}
```

**Важно**

Поле `this.browser.isPhone` доступно только в теле самих тестов. Использование этого поля при написании кастомных команд приведет к некорректному поведению команды. Для получения информации о текущей платформе в командах следует использоваить хелпер `tests/lib/func/is-mobile-browser.ts`.

## Автозапуск в `CI`

Для поддержки актуальности автотесты запускаются на каждый PR по специально поднятому стенду. Это происходит так:

1. Разрабатываем фичу на разработческом ноутбуке.
2. Делаем PR.
3. Запускается задача в `Sandbox` (это наша `CI`), которая выполняет много разных действий. Среди них и эти два:

-   поднимается стенд в отдельном [Deploy project](https://deploy.yandex-team.ru/projects/maps-front-stands).

    Например, если вы разрабатываете фиче-ветку `sigorilla.poi-feedback`, в кулауде развернётся стенд на домене `https://maps-sigorilla-poi-feedback.stands.maps.yandex.ru`

-   запускаются автотесты

    Тесты запускаются на только что поднятом стенде `https://maps-sigorilla-poi-feedback.stands.maps.yandex.ru`

Результат работы автотестов приходит в виде письма с темой задачи, ссылкой на PR и сообщением:

-   `Pull request #3255 all checks passed successfully 💚` — если тесты прошли
-   `Pull request #3255 failed checks: HERMIONE 💔` —
    если тесты упали

Красное разбитое сердце означает, что тесты не прошли. Причин для этого может быть много разных — мы сломали чужую функциональность в своём PR, либо
сломали сами тесты, либо тесты мигнули, либо что-то ещё.

Чтобы увидеть поломаные тесты переходим по ссылке `HERMIONE`, она ведет на специальную страницу в `Sandbox` с HTML-отчётом о прохождении тестов.

-   если вам кажется, что сломались тесты, которые к вашему PR не имеют отношения, читайте раздел
    [`Если в "вашем" PR упали "чужие" тесты`](#Если-в-вашем-pr-упали-чужие-тесты).
-   если тесты сломались из-за ваших изменений в PR, читайте раздел
    [`Тест правильный. Ошибка в коде`](#Тест-правильный-ошибка-в-коде).

## Ручной запуск тестов по стендам

Если вы сделали PR, и уже поднялся стенд, тогда в командной строке терминала можно выполнить команду, которая прочитает тесты на вашей файловой системе, но запустит их на стенде:

```sh
make hermione
```

Эта команда возьмёт имя вашей текущей локальной git-ветки, сформирует из него имя стенда и запустит на том стенде тесты, которые находятся на вашей локальной файловой системе.

Если вы хотите запустить автотесты с кастомными параметрами запуска, используйте переменную окружения `ARGS`. В неё можно передавать [специальные параметры запуска](https://github.com/gemini-testing/hermione#cli).

Например, с такой настройкой команда запустит все тесты проекта, но только в одном браузере Chrome.

```sh
ARGS="--browser chrome" make hermione
```

А эта запустит все тесты, но только в одном файле:

```sh
ARGS="tests/sets/desktop/poi/index.ts" make hermione
```

А эта запустит лишь один-единственный тест с именем `'POI Организация Содержит все нужные элементы'`:

```sh
ARGS="--grep 'POI Организация Содержит все нужные элементы'" make hermione
```

Команда `make hermione` делает следующее:

1. Читает текущую git-ветку и понимает, какой именно стенд нужно тестировать.
2. На некой удаленной машине в selenium-гриде, на которой запущены все нужные нам браузеры, в каждый браузер по очереди загружается нужный нам стенд Карт.
3. В загруженном в браузере стенде Карт выполняются тесты один за другим. То есть, Hermione читают тесты с локальной файловой системы, а запускает их на удаленной машине.
4. Результат каждого теста выводится построчно в терминал на локальной машине.
5. Если упал скриншотный тест, то скриншоты сохраняются на локальной машине в директорию [reports/hermione/images](../reports/hermione/images)
6. После завершения тестирования сохраняется сводный отчёт о выполнении всех тестов. Сохраняется так же на локальной файловой системе в [reports/hermione](../reports/hermione). Отчет представляет из себя html-страницу.

То есть, результатом выполнения тестов на локальной машине будут

-   сообщения в терминале,
-   пачка скриншотов из тех упавших тестов, которые сравнивают эталонный скриншоты и скриншот из стенда
-   и сводный отчёт в виде html-страницы. Ссылка на него публикуется в терминале после завершения тестирования и выглядит примерно так:

    ```sh
    ...
    ✓ Маршруты Баннер бла-бла-кара [chrome:cc44e7388bfdda934525bcd3ba47360c7f235aef452505485a23e8c4d5ff2367] - 4759ms
    Total: 33 Passed: 33 Failed: 0 Skipped: 0 Retries: 0

    Your HTML report is here: file:///Users/sigorilla/projects/maps/reports/hermione/index.html
    ```

    _Сводный отчёт можно открыть в браузере, как обычную локальную html-страницу._

Когда мы можем захотеть запускать тесты руками? Чаще всего в двух случаях:

1. [Когда тест есть, его нужно исправить](#Тест-правильный-ошибка-в-коде).
2. [Когда теста нет, его нужно написать](#Код-правильный-теста-ещё-нет-нужно-создать).

### Почему тесты запускаются только по стендам

— Зачем запускать тесты через `CI`? Долго ждать!

— Почему бы тестам не проверять работу стенда, поднятого на `localhost` на разработческом ноутбуке? Это же быстрее!

По двум причинам.

Во-первых, для автоматического тестирования локально поднятого стенда у нас не всё технически готово — нужно либо добавлять в проект установку какого-то туннелера до удаленного грида, либо через `selenium-standalone` поднимать грид локально. Возможно, сделаем позже. Пока же разработчику не нужно локально ничего доустанавливать — ни Hermione, ни Selenium-грид — сделал пуш в ветку и подождал 15-20 минут.

А во-вторых, и это самая важная причина, тестирование стенда гарантирует, что мы протестируем приложение в
нужном окружении — с нужной версий nodejs, с правильно установленными из apt-get пакетами, со всеми переменными
окружения, с актуальными секретами — со всем тем, что потом поедет в продакшн. Чтобы не получилось, что тестировали
одно, а в прод поехало другое.

### Стабильность автотестов

Когда вы пишете новый тест или сильно изменяете старый, прогоните его через команду

```
make hermione-stress COUNT=N
```

которая запустит make hermione N раз и сообщит, сколько из этих запусков были успешны.

Сделайте для него `.only()` и запустите хотя бы десяток прогонов, чтобы понять, что тест стабилен и не будет беспокоить вас и других.
Если тест из 10 запусков хотя бы раз свалился (исключая всякие технические сбои, типа сокет таймаутов), то стоит его переделать.

Каждый нестабильный тест съедает кучу времени разработчиков, которые видят ложные срабатывания, занимает время дежурного, который должен погрузиться в контекст вашей фичи и разобраться, что же там происходит.

## Что делать, если?

### Тест правильный. Ошибка в коде

Вы увидели поломанный тест и поняли, что затронули чужую функциональность:

1. Исправляем ошибку, из-за которой падает тест.
2. Коммитим исправления в существующий PR.
3. Ждём, пока переподнимется стенд и пройдут все автоматические проверки.
4. Получаем в PR комментарий от Подрика и статус HERMIONE для коммита.

Если тесты снова упали и снова по нашей вине, возвращаемся к пункту №1.

### Скриншотный тест правильный. Но он упал

Такое случается, когда мы поменяли внешний вид каких-то компонентов. Тогда в `HERMIONE`-отчёте в каждом упавшем тесте мы увидим три скриншота — эталонный, текущий и дифф между ними.

Если эти изменения ожидаемые (мы действительно изменили отображение этого контрола), тогда делаем так:

1. В терминале заходим в фиче-ветку.
2. Скачиваем отчёт, который только что смотрели:

    ```sh
    make hermione-gui
    ```

    Эта команда идёт в Sandbox и выкачивает весь отчёт вместе с картинками. Потом на вашей локальной машине поднимает приложение на `https://localhost:8000` и открывает его в браузере. То есть вы получаете копию отчёта, который смотрели в Sandbox.

3. На https://localhost:8000 находим нужный тест и в нём кликаем на кнопку `Accept`.
4. Возвращаемся в терминал и видим по `arc status`, что появились новые измененные файлы — те самые скриншоты, которые "зааксептили"
5. Коммитим их и пушим PR.
6. После этого переподнимется стенд и перезапустятся тесты.

_Важно понять. Команда `make hermone-gui` не запускает никаких тестов. Она только скачивает готовый отчёт и показывает его на `localhost:8000`. Чтобы эта команда отработала, вы должны перед этим сделать PR, дождаться, пока поднимется стенд и он протестируется._

### Код правильный. Ошибка именно в тесте, нужно исправить

1. Убедитесь, что поднят стенд с рабочим исходным кодом, который этот тест проверяет.
2. Исправьте тест в `test/sets/...`
3. Запустите тест на выполнение. Запускать один конкретный тест в одном браузере — это быстрее и информативнее:
    ```sh
    ARGS="--grep '...' --browser chrome" make hermione
    ```
4. Когда в терминале появится ссылка на html-отчёт, кликните в неё, откройте в браузере и посмотрите глазами на скриншоты (если вы писали тест со скриншотом)

    _Если нужно править скриншотный тест, см. [`Если упали скриншотные тесты`](#Cкриншотный-тест-правильный-но-он-упал)_

### Код правильный. Теста ещё нет, нужно создать

Наши действия будут зависеть от того, где находится исходный код, к которому мы собираемся написать тест. Вариантов
всего три:

1. Мы хотим написать тест к коду, который прямо сейчас разрабатываем в фиче-ветке.
2. Мы хотим написать тест к коду, который давно существует в другой ветке (например, в кулаудном `dev`).

Второй вариант редкий. Чаще всего вы будете исполнять вариант №1.

#### Пишем тест к своей (новой) фиче-ветке

1. У вас уже есть PR из вашей фиче-ветки. Если ещё нет, сделайте.

    Без теста ваш PR можно считать не доделанным до конца, поэтому добавьте в PR специальный label - `WIP` (Work in progress)

2. Дождитесь, пока в PR появится статус того, что стенд поднят.
3. Локально на разработческой машине напишите нужный тест в `tests/sets/...`
4. Запустите тест на выполнение:

    ```sh
    ARGS="--grep '...' --browser chrome" make hermione
    ```

    Если вы написали новый скриншотный тест, он у вас не пройдёт, потому что ещё не существует эталонных скриншотов. В этом случае запускать тестирование нужно с флагом `--update-refs`, и будут созданы все новые скриншоты:

    ```sh
    ARGS="--update-refs" make hermione
    ```

#### Пишем тест к существующей ветке

Бывает, нужно написать тест для функциональности, которая уже давно есть в `dev`-ветке. Можно было бы отвести новую фиче-ветку от `dev`, а дальше выполнить шаги из предыдущего раздела. Но ради одного теста поднимать стенд и занимать лимитированные ресурсы — решение не ок. Придумали другое.

Мы напишем тесты локально, а запустим их на уже давно поднятом стенде.

1. Локально на разработческой машине пишем нужный тест в `tests/sets/...`
2. Запускаем тест на выполнение с флагом `STAND_NAME`

    ```sh
    STAND_NAME=maps-trunk ARGS="--grep '...'" make hermione
    ```

    Hermione запустит указанный тест на разработческом стенде [maps-trunk.stands.maps.yandex.ru](https://deploy.yandex-team.ru/project/maps-front-stands_maps-trunk)

Логика простая — открываете [deploy/front-maps-stands](https://deploy.yandex-team.ru/projects/maps-front-stands) и видите список стендов. Если нужно запустить свои локальные тесты на стенде с именем `maps-sigorilla-united`, значит вызываете Hermione с `STAND_NAME=maps-sigorilla-united`

#### Запуск тестов по кастомным хостам

Это смесь нескольких предыдущих юзкейсов: мы не хотим создавать новый стенд ради того, чтобы проверить какой-то Hermione-тест. Мы лишь хотим проверить тест на стенде, уже поднятом на конкретном хосте. Пока речь идёт только о таких хостах:

-   testing: `https://maps-rc.l7test.yandex.{tld}/maps/`
-   deploy: `https://{stand_name}.stands.maps.yandex.{tld}/maps/`
-   tunneler: `https://{user}-{port}.ldev.yandex.{tld}/maps/`

Например, тестирование на стенде показало нам много-много ошибок в нашем исходном коде. Поправить их все сразу трудно, а править и выкладывать изменения на стенде в таком случае долго — пока Sandbox выполнит все задачи... уходит много времени.

Тогда можно запустить тесты на текущем тестинге. Тестинг живёт на отдельном домене, поэтому запускать надо так:

```sh
HOSTS=testing make hermione
```

В ситуациях, когда хочется протестировать новую функциональность, которая уже есть на trunk стенде, но пока не попала на тестинг, можно легко запустить тесты на trunk стенде. Для этого достаточно выполнить следующую команду:

```sh
make hermione-trunk
```

Важно понимать:

-   `STAND_NAME` — для тестирование разработческих стендов на
    -   `https://${process.env.STAND_NAME}.stands.maps.yandex.{tld}`
-   `HOSTS` — для каких-то стецифических задач на:
    -   `https://maps-rc.l7test.yandex.{tld}/maps/`

##### Запуск тестов через tunneler

Если вы хотите проверить свои изменения кода приложения, **не** выкатывая их на стенд, то можете это сделать используя поднятый туннель. Для этого вам понадобятся две вкладки:

1. `make dev`
1. `make hermione-local`

После этого локальный тесты будут прогонятся по локальной копии с использованием обычного Selenium-грида.

> Данный способ может сильно мигать, поэтому лучше добавлять `.only` для стабильности работы.

## Если в "вашем" PR упали "чужие" тесты

Вы запушили PR — Подрик собрал стенд, запустил Hermione-тесты и показал вам разбитое сердце?
Вы открываете отчёт и видите скриншоты, которые, _как вам кажется_, совершенно не относятся к вашему PR?

Возможно, произошло так называемое "ложное срабатывание". Поскольку наши тесты являются интеграционными, с течением
времени некоторые из них могут ломаться как по зависящим от нас причинам (изменения в проекте, которые
предварительно не были проверены), так и по независящим от нас (обновление бекендов, браузеров...). Бывает.

### Точно упал "чужой" тест?

Нужно посмотреть в `trunk` — если и там поломан этот же тест, скорее всего его сломал не ваш PR.

1. Открыть https://a.yandex-team.ru/arc_vcs/maps/front/services/maps
2. Справа от последнего коммита есть иконка — либо "зеленая галочка", либо "красный крестик".

Если видите `зеленую галочку`:

    - значит в `dev` все тесты прошли успешно
    - а в "вашем" PR тесты упали не из-за `dev` — нужно или искать причину поломки в своих изменениях, или обратиться к [дежурному](https://wiki.yandex-team.ru/maps/dev/ui/products/maps/dev-duty/) за советом.

Если видите `красный крестик`, кликайте в него:

    — всплывёт попап со ссылкой на отчет о Hermione-тестах, кликайте в неё.
    - если в открывшемся отчёте упал тот же тест, что и в "вашем" PR, тогда это настоящее "ложное срабатывание" и его можно скипнуть.

### Скипаем "чужой" тест

Например, отчет показал вам, что с ошибкой упал тест `Каталог. Клик в категорию. ie11`.

1. Создаём таску в очереди [MAPSUI](https://st.yandex-team.ru/MAPSUI) с компонентом
   [dev_duty](<https://st.yandex-team.ru/MAPSUI/filter?components=43761&resolution=empty()>)
2. В таске пишем "мигает такой-то тест". [См.пример](https://st.yandex-team.ru/MAPSUI-6597)
3. Переключаемся на `dev` и освежаем его из `origin dev`.
4. В освежённом `dev`-е находим код мигнувшего теста и дописываем перед ним `skip` со ссылкой на созданую таску в `MAPSUI`. Этим мы его отключаем в нужном браузере.
    ```diff
    +hermione.skip.in('ie11', 'https://st.yandex-team.ru/MAPSUI-6597');
    it('Клик в категорию.', function () {
        ...
    }
    ```
5. Делаем коммит в локальный `dev` с сообщением "Skip test: Клик в категорию"
6. Пушим `dev` ветку в `origin dev`.
7. Возвращаемся в PR и перезапускаем задачу, ссылка на которую хранится в статусе `ci/trendbox [pr]`: [см. видео-инструкцию](https://jing.yandex-team.ru/files/sigorilla/2018-08-09-14-33-57-p1pgb.mp4)
8. Ждём, пока Подрик покажет зелёное сердце.

В результате:

-   в вашем PR все тесты станут зелеными.
-   тест у всех скипнётся — он перестанет краснеть у всех коллег.
-   таска автоматически назначится на [дежурного](https://wiki.yandex-team.ru/maps/dev/ui/products/maps/dev-duty/), он отреагирует на поломаный тест (починит или придёт к разработчику, кто его создавал)

**Почему можно не рибейзить свою фиче-ветку от дева, в котором мы скипнули мигающий тест?**

Потому что тесты в `CI` прогоняются на merge-коммите — перед запуском тестов `Sandbox` мержит нашу фиче-ветку с актуальным `dev`, а потом на полученном коде прогоняет тесты.

### Нужно создать пользователя для автотестов

Обратите внимание, что всегда нужно создавать два пользователя с аналогичными данными: один для [users.ts](./common/users.ts), и второй для [assessors-users.ts](./common/assessors-users.ts).

1. Открываем [форму регистрации](https://passport.yandex.ru/registration)
2. Имя и фамилию указываем любые
3. Логин вида `geo.auto.test.xxx`
4. Пароль `pass-testing`
5. Нажимаем «У меня нет телефона»
6. Задаем вопрос: `Как называется проект в танкере?` (ответ: `loris`)
7. Вводим капчу и жмём «Зарегистрироваться». Игнорируем последующие мольбы загрузить изображение пользователя.

# "Продвинутая" отладка

1. Для каждого запуска автотестов автоматически генерируется лог профайлера, в котором можно посмотреть все команды, которые были вызваны webdriver'ом внутри hermione.
   Этот лог локально можно найти здесь: `reports/hermione-profiler/index.html`. Или среди статусов коммита: `HERMIONE_PROFILER`.

2. Также по sessionId (найти можно в meta в отчете hermione) каждого запуска можно посмотреть полный лог того, что происходило в Selenium по url:
   `https://sw.yandex-team.ru/log/<sessionId>`.

3. При необходимости можно записать видео работы автотеста в Selenium Grid для этого необходимо включить опцию `enableVideo: true` в секции `selenoid:options` в конфиге Hermione. Посмотреть видео можно по ссылке:
   `https://sw.yandex-team.ru/video/<sessionId>`

4. В случае сбоев в работе Selenium Grid (проявляется как массовые поломки автотестов во всех или отдельных браузерах, с разными сетевыми ошибками) необходимо заводить тикет в очередь [QAFW](https://st.yandex-team.ru/QAFW).

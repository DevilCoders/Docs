# Эксперименты

Чтобы завести эксперимент, нужны два человека.

**Разработчик**

-   пишет новую функциональность
-   создает в проекте флаг `isNewFeature`, который отвечает за показ новой функциональности. Больше о типах флага ниже.
-   выкатывает новую функциональность в продакшн

**Менеджер**

-   создаёт новый тикет в специальном сервисе `https://ab.yandex-team.ru` — там "заводятся" все эксперименты.
-   указывает в этом тикете флаг, который создал разработчик (`isNewFeature`)
-   совершает [какие-то нетривиальные действия](https://wiki.yandex-team.ru/maps/dev/ui/experiments/new/)... ура!

После этого часть пользователей БЯК видят новую функциональность, а часть — нет. В этом суть эксперимента.

## Виды экспериментов

Эксперименты в БЯК бывают двух типов — прямые и обратные. Каждый используется для своих ситуаций.

### Прямой

Это когда новая функциональность показывается только маленькому количеству пользователей, например 10%.

Используется, когда мы не уверены, что новая фича стоит того, чтобы оставлять в проекте. Или когда хотим проверить гипотезу, правда ли новая фича, в том виде, что мы её задумали, будет понятна/полезна нашему пользователю.

От результата эксперимента зависит наше решение:

-   то ли докатываем на 100%
-   то ли дорабатываем гипотезу и делаем новый эксперимент
-   то ли отказываемся от фичи, потому что она показала ухудшение взаимодействия между пользователем и UI

**Организация кода:**

1. Заводится флаг эксперимента по схеме: `isNewFeature`. Флаг эксперимента предназначен для того, чтобы **вкл**ючать новую функциональность.
2. Во вьюшке `some-view.tsx` растыкиваем везде где нужно тернарники, которые прячут новую функциональность за флаг

```jsx
// было
{this._renderSomeBlock()}

// стало
{config.experiment.ui.isNewFeature ?
    this._renderSomeNewBlock() :
    this._renderSomeBlock() :
}
```

3. **НЕ пишем** тесты на новую функциональность.

Основная задача такого подхода — сделать эксперимент как можно быстрее. Поэтому код пишем минимально необходимый, который позволит проверить в UI главную идею этой фичи — не пишем "качественный идеальный код". Тесты не пишем по этой же причине (чтобы быстрее выкатить эксперимент) и ещё по одной — не хочется тратить время на разработку тестов, если мы не уверены, что фича полетит.

Когда менеджер и аналитик скажет, что эксперимент годный и "давайте катить на 100%", переходим к пункту №4.

4. Во вьюшке `some-view.tsx` "вычищаем" тернарники
5. Переосмысливаем "быстрые" решения, и пишем "качественный код"
6. А дальше как для любой продакшн-задачи:

-   пишем тесты на новую функциональность
-   отдаём в кодревью
-   в тестирование

### Обратный

Это когда новая функциональность показывается почти всем пользователям. Например, раскатываем новую функциональность на 90%, а 10% видят предыдущий продакшн. Фактически, это выкатка сразу в продакшн, только _почти на всех_.

Используется, когда мы точно знаем, что фичу покатим в прод, но хотим посмотреть, насколько просядут какие-то метрики по сравнению с текущим продовым решением.

Это знание не повлияет на наше решение, мы просто будем знать, как изменится взаимодействие пользователей с сервисом, чтобы знать, как дотюнивать новую фичу.

Когда нужно использовать? Например, когда мы отдаем "технический долг". В картографическом сервисе обязательно должна быть функциональность для построения маршрутов. Если её не было, и мы написали, то её нужно в любом случае выкатывать, как бы там метрики не прокрасились

**Организация кода:**

1. Заводится флаг эксперимента по схеме: `disableNewFeature`. Флаг эксперимента должен **выкл**ючать новую функциональность.
2. Текущий файл `some-view.tsx` переименовываем в `some-view-old.tsx`
3. Текущую вьюшку `SomeView` переименовываем в `SomeViewOld`
4. Создаем новый `some-view.tsx` и в нём пишем новую вьюшку `SomeView`
5. В компоненте, который рендерит эту вьюшку, пишем тернарник или `if`:

```jsx
{config.experiment.ui.disableNewFeature ?
    <SomeViewOld /> :
    <SomeView /> :
}
```

6. Сразу пишем тесты на новую функциональность.

Подход с созданием файлов `some-view.tsx`/`some-view-old.tsx` для обратного эксперимента
удобнее, чем подход с растыкиванием тернарников в `some-view.tsx`.

**Почему именно так — удобно?**

1. На кодревью сразу видно, что `some-view-old.tsx` — это старый файл, его отсматривать не нужно
2. На кодревью в `some-view.tsx` сразу видно что именно изменилось для добавления новой функциональности.
3. Когда после эксперимента поступит распоряжение докатывать эксперимент на все 100%, это делается быстро:

-   удаляется `some-view-old.tsx`,
-   в компоненте удаляется тернарник и остаётся только рендеринг `<SomeView />`
-   не нужно дописывать тесты, они уже готовы.
-   таска отдается в тестирование.

Как правило тестирование не выявляет новых багов и выкатка в прод случается быстро.

## Флаги эксперимента

В большинстве экспериментов флаг `isNewFeature` имеет тип `boolean`. В примерах выше все тернарники основаны на проверке именно такого флага. Однако нередко в этом флаге мы передаём объект, который неким образом конфигурирует параметры эксперимента (см. [`src/server/middlewares/experiments-middleware.ts`](../src/server/middlewares/experiments-middleware.ts))

Имя для флага выбирается произвольно, не обязательно придерживаться схемы `isSomethinfEnabled`/`disableSomething`.

Флаги действующих экспериментов можно увидеть в [`src/types/experiments.ts`](../src/types/experiments.ts)

## Известные проблемы

**И в прямом и в обратном эксперименте мы передаём на клиент больше кода**.
Вариант решения — выносить код эксперимента в отдельный чанк.

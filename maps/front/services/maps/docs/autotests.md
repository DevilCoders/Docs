[Практическое руководство](../tests/README.md)

# Философия тестирования в Картах

Каждая вьюшка должна быть покрыта _нужным_ количеством функциональных тестов и [_минимальным количеством_](#снимаем-минимальное-количество-скриншотов) скриншотных.

**Почему такое соотношение?**

Скриншотные тесты мигают чаще всего.

Мы стараемся писать тесты на замоканных данных, но и это не гарантирует стабильности. Например, скриншот всей карты может упасть, потому что логотип Яндекса над картой не успел подгрузиться.
При небольшом изменении в UI одномоментно может упать сразу много тестов.

Сейчас такие проблемы лечим тем, что исключаем в скриншоте лишние DOM-ноды. Или сужаем зону скриншота, чтобы в снимок не попали лишние элементы. Этих проблем не будет, если не делать лишние скриншотные тесты.

-   [Cкриншотные тесты](#cкриншотные-тесты)
-   [Функциональные тесты](#функциональные-тесты)
-   [Критерии хорошего функционального теста](#критерии-хорошего-функционального-теста)
-   [Как тестировать графику на карте](#как-тестировать-графику-на-карте)
-   [Best practices](#best-practices)
    -   [Снимаем минимальное количество скриншотов](#снимаем-минимальное-количество-скриншотов)
    -   [Скриншотим только необходимое](#скриншотим-только-необходимое)
    -   [Дожидаемся всего нужного перед скриншотом](#дожидаемся-всего-нужного-перед-скриншотом)
    -   [Минимальный "setup"](#минимальный-setup)
    -   [Явно ждём выполнение действия](#явно-ждём-выполнение-действия)
    -   [Явно проверяем выполнение действия](#явно-проверяем-выполнение-действия)
-   [Worst practices](#worst-practices)
    -   [Не костыляем стили](#не-костыляем-стили)
    -   [Не скриншотим лишнее](#не-скриншотим-лишнее)
    -   [Не используем авторизацию, когда она не нужна](#не-используем-авторизацию-когда-она-не-нужна)

## Cкриншотные тесты

Скриншотный тест нужен исключительно для того, чтобы не пропустить момент, когда во время рефакторинга разработчик случайно поломал верстку. Скриншот нужен, чтобы зафиксировать эталонную верстку вьюшки.

Во всех остальных случаях нужно писать функциональные тесты, которые проверяют, что в результате действий пользователя в UI как-то изменилось состояние DOM-дерева (появился или исчез какой-то блок, прокрасилась ссылка, поменялся текст в строке и т.д.). Такие функциональные тесты будут падать только в тех случаях, когда в UI что-то сломалось.

## Функциональные тесты

Чтобы иметь возможность написать адекватные функциональные тесты, мы должны озаботиться, чтобы в DOM-дереве тестируемой вьюшки было достаточно "крючочков", за которые сможет "зацепиться" Webdriver.io. В наших тестах таких "крючочков" есть несколько видов:

-   это CSS-селекторы, которые однозначно матчатся на нужную (одну) ноду.
-   это aria-аттрибуты с текстом, который позволяет найти именно эту ноду в пределах одного родителя.
-   это текстовый узел, уникальный в пределах одного родителя.

При разработке любой UI-фичи разработчику стоит сразу продумывать, какими тест-кейсами он покроет эту функциональность и заранее сверстает так, чтобы потом в тестах можно было без проблем добраться до нужной DOM-ноды.

## Критерии хорошего функционального теста

Прежде чем писать тест, нужно ответить на две группы вопросов: "Так ли тест необходим?" и "Cколько времени это займёт?".

**Так ли тест необходим?**

1. Насколько высока вероятность, что без этого теста что-то сломается в интерфейсе?
2. Что именно сломается, если этого теста не написать?
3. Насколько эта поломка будет критична?

Можно принять за правило: **Если без теста мы пропустим поломку какой-то важной логики, такой тест писать стоит.**

Важной поломкой можно считать ситуацию, когда какой-то компонент перестает выполнять свою задачу: отображать информацию или предоставлять пользователю возможность совершить какое-то действие, ради которого компонент и существует.

_Например, если в маршрутном саджесте сломается функциональность для клика в "Дом"/"Работа" — это важно, тест нужен. А если в саджесте вокруг иконки "Дом"/"Работа" возникнет "padding не по гайдам дизайнера" — это неважно, тест не нужен._

**Сколько времени тест потребует?**

1. Сколько времени нужно потратить, чтобы написать тест?
2. Какая вероятность, что тест будет мигать и ломаться?
3. Сколько времени будут выполняться тесты, и сколько ресурсов на них нужно выделить?

Можно принять за правило: **Если тест пишется быстро, а поддерживать его надо будет редко, такой тест писать стоит.**

В большинстве случаев написание тестов выглядит приятным занятием, потому что состоит из понятных простых инструкций: открой такой-то урл, кликни в такой компонент, проверь, отобразился ли другой компонент. В редких случаях написание какого-то теста начинает занимать неожиданно много времени — это сигнал о том, что, возможно, этот тест не так уж нужен, стоит подумать самому или посоветоваться с коллегами. Нередко написанные тесты мигают — это сигнал о том, что, возможно, тест написан неоптимально, стоит переписать.

### Чего хочется избежать?

Иногда у разработчика возникает желание покрыть супер-подробными тестами каждую строку в `js`- или `css`-коде. С точки зрения покрытия кода тестами это идея хорошая. Но с точки зрения времени на разработку, поддержки и скорости выполнения тестов — идея не очень хорошая.

Хочется избежать ситуации, когда проект окажется на 100% покрыт тестами, но каждый стенд из-за этого поднимается часами, потому что на нем гоняется миллион (минорных?) тестов. Это плохо не только из-за производительности. Чем больше тестов, тем больше среди них будет мигающих тестов, которые нужно регулярно приводить в порядок. Хочется избежать ситуации, когда писать и поддерживать тесты мы будем больше времени, чем разрабатывать саму функциональность.

## Как тестировать графику на карте

**Какая бывает графика на карте?**

1. Подложка карты — это тайлы с дорогами, лесами и всем-всем-всем.
2. Всякая геометрия — маршруты, границы областей.
3. Другие геообъекты — меточки, балуны.

Тестируем эти объекты по-разному.

**Подложку мы никак не тестируем.**

Почему? Отрисовкой подложки занимается программный код АПИ 3.0. На отображение АПИ-тайлов программный код БЯК не влияет, следовательно и тестировать незачем.

**Тесты на отображение "всякой геометрии" должны быть скриншотными.**

Почему? Для отрисовки геометрии мы передаём данные в программный код АПИ 3.0, а он по этим данным рисует объекты на `svg`. Мы не должны хотеть писать тесты, которые проверяют, что "`svg`-элемент с таким-то `css`-селектором есть в `DOM`", потому что АПИ не гарантирует отрисовку геометрии исключительно на `svg`. Условно говоря, внезапно способ рендеринга может измениться на `canvas`, и у нас упадут все тесты, где мы заложились на `svg`-разметку.

Тестируем отображение геометрии как черный ящик. Единственный способ сейчас — делать скриншот геометрии на карте. Скриншоты делаем минимально-необходимыми по размеру и по содержанию. Проявляем смелкалку и делаем так, чтобы на скриншоте была только нужная графика и ничего лишнего.

**Тесты на отображение "всяких меточек" можно писать функциональными**, закладываясь на DOM-структуру объектов.

Почему? Для отрисовки точек мы передаем в АПИ 3.0 готовый `html`-код, который рендерится над картой "как есть". Поэтому в тестах можем спокойно обращаться к нодам по `css`-классам. Если очень нужно, добавляем в верстку вьюшки `css`-классы для удобного поиска нод в тестах.

Если хотим проверять ещё и отображение такой вьюшки, делаем скриншот по тем же правилам — проявляем смекалку и скриншотим только нужный объектик.

## Тёмная тема в скриншотных тестах
Для сохранения скриншота в тёмной теме необходимо перед блоком `it` или `describe` добавить инструкцию ```hermione.also.in(['chrome-dark', 'iphone-dark']);```. Лучше указывать единственный браузер только для десктопных или только мобильных тестов. Например: ```hermione.also.in('chrome-dark');```.

Применяйте данную инструкцию только для скриншотных тестов!

## Best practices

### Снимаем минимальное количество скриншотов

Каждая вьюшка должна иметь минимальное количество скриншотов, покрывающее максимальное количество разных вариаций отображения этой вьюшки.
Например, блок в течение жизни на странице может рендерить в себе одних детей, потом других, схлопываться и расхлопываться.

### Скриншотим только необходимое

Если нужно сделать скриншот сложной вьюшки, в которой есть другие вьюшки, то делаем так — скриншотим только "внешнюю часть" вьюшки в тестах самой вьюшки, а детей скриншотим уже в тестах детей. Это можно сделать, передав в команду `waitAndVerifyScreenshot` параметр `ignoreElements`.

### Дожидаемся всего нужного перед скриншотом

**Проблема №1**
С помощью команды `waitAndVerifyMapScreenshot` создается скриншот ещё до того как на карте отобразятся плейсмарки или маршрут, но тест при этом зеленый за счёт ретраев. Изредка даже ретраи не помогают и тест мигает.

**Проблема №2**
С помощью команды `waitAndVerifyScreenshot` создается скриншот вьюшки, внутри которой что-то асинхронно загружается. Иногда на скриншоте вместо содержимого видим спиннер

**Решение**
Если делаем скриншот, подумать, есть ли в снимаемой области элементы, которые отображаются с запозданием. Если есть — явно указать `waitForVisible` для них перед `waitAndVerifyScreenshot`

### Минимальный setup

В тесте пишем минимальное количество команд, которые позволят "дойти" до тестируемой фичи. Идеальный вариант — одна команда `openPage`, которая сразу откроет в интерфейсе тестируемую вьюшку.

Например, если на тачах нужно протестировать некую вьюшку, которая рендерится в выдвинутой вверх шторке:
**Плохо**

```js
await browser.openPage('?ol=biz&oid=112853648034', {mockToday: '2020-04-15'});
await browser.swipeShutter('up');
await browser.waitForHidden(cssSelectors.sidebar.minicard);
await browser.waitForVisible(cssSelectors.sidebar.panel);
await browser.addStyles(`
    ${cssSelectors.tabs.container} {display: none;}
`);
```

**Хорошо**

```js
await browser.openPage('/org/112853648034', {mockToday: '2020-04-15'});
```

Не на всё бывают прямые ссылки, но искать кратчайший путь надо. Для других похожих кейсов можно использовать параметр `?view-state=expanded`

### Явно ждём выполнение действия

Прежде чем делать следующее действие, важно проверять, что предыдущее закончилось и привело интерфейс в нужное состояние.

Например, некоторые тесты сильно зависят от того, как отрабатывает поиск: нужно "поискать <что-нибудь>, нажать крестик, проверить <что-нибудь>"
**Плохо**

```js
await this.browser.openPage('/213/moscow/catalog/11/');
await this.browser.waitForVisible(groupSelectors.view);
await this.browser.waitAndClick(groupSelectors.firstRubric.view);
// Отображение формы не гарантирует, что пришли данные из поиска
await this.browser.waitForVisible(cssSelectors.search.form.input);
// Когда нажмем эту кнопку, мы на самом деле не фичу протестируем, а получим ложно-положительный реультат
await this.browser.waitAndClick(cssSelectors.backButton);
await this.browser.waitForVisible(groupSelectors.view);
```

**Хорошо**

```js
await this.browser.openPage('/213/moscow/catalog/11/');
await this.browser.waitForVisible(groupSelectors.view);
await this.browser.waitAndClick(groupSelectors.firstRubric.view);
// Проверяем, что реально отобразились данные после успешного поиска
await this.browser.waitForVisible(cssSelectors.search.list.content);
await this.browser.waitAndClick(cssSelectors.backButton);
await this.browser.waitForVisible(groupSelectors.view);
```

### Явно проверяем выполнение действия

Например, нужно "открыть одну организацию, потом перейти в другую организацию и там проверить <что-нибудь>". Нужно убедиться, что тест действительно открыл нужную карточку.
**Плохо**

```js
await this.browser.openPage('?mode=search&oid=1113219372&ol=biz&text=Европейский');
await this.browser.waitAndClick(cssSelectors.placesInside.menu);
await this.browser.waitAndClick(cssSelectors.placesInside.firstPopupItem);
// Тест будет ложно-положительным даже если содержимое карточки не переисовалось
await this.browser.waitForVisible(cssSelectors.placesInside.cardTitle);
```

**Хорошо**

```js
await this.browser.openPage('?mode=search&oid=1113219372&ol=biz&text=Европейский');
await this.browser.waitAndClick(cssSelectors.placesInside.menu);
await this.browser.waitAndClick(cssSelectors.placesInside.firstPopupItem);
// Гарантированно проверяем, что случился переход в другую организацию
await this.browser.waitAndCheckValue(cssSelectors.placesInside.cardTitle, 'Перекресток');
```

Нужно чаще использовать команды `getSelectorByText`, либо `waitAndCheckValue`.

## Worst practices

### Не костыляем стили

Команда `addStyles` позволяет навесить дополнительные стили. Это очень костыльный костыль, который сильно отдаляет нас от тестирования того, что реально видит пользователь. Стремимся к тому, чтобы минимально влезать в поведение и внешний вид интерфейса — хотим тестировать то, что пользователь видит в реальности, а не какую-то захаченную/перехаченную версию

Используем `addStyles` только в крайних случаях, когда без неё вообще никак. При этом хорошо бы самому себе ответить на вопрос, почему без неё нельзя обойтись.

Например, во многих тестах вместо `addStyles` достаточно сделать `scrollIntoView(..., {vertical : 'end'/'center '})`.

### Не скриншотим лишнее

Не делаем скриншотов, на которые попадают посторонние блоки. Плохо, если нужно сделать скриншот карты, а на снимок попадает весь сайдбар.

### Не используем авторизацию, когда она не нужна

Настоящая авторизация нужна для кейсов, в которых мы проверям персональный саджест, подписку на Рассылятор и закладки, потому что они используют настоящий `DataSync`. Для этого используем команду `openPage(url, {userId: 'id '})`, куда передаём один из [реальных логинов](../tests/common/users.ts)

В остальных случах достаточно фейкового логина или вообще тестировать без авторизации:

-   `openPage(url)` — открыть страницу незалогиненным пользователем
-   `openPage(url, {fakeLogin: true })` — открыть страницу "как бы" залогиненным пользователем (без закладок)

# Привязка GPS-сигналов и геометрий к графу на YT

Матчинг GPS-сигналов и геометрий к [графу](/arc/trunk/arcadia/maps/libs/road_graph) на основе библиотеки [graphmatching](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching) на YT.

1. [Использование](#использование)
1. [Многопоточный матчинг GPS-сигналов](#многопоточный-матчинг-GPS-сигналов)
    1. [Описание работы](#описание-работы)
    1. [Статистика операций матчинга](#статистика-операций-матчинга)
1. [Прочее](#прочее)
    1. [Бинарники](#бинарники)
    1. [Скрипты](#скрипты)
    1. [Локальный запуск](#локальный-запуск)

## Использование

Функций две:
* `match_geometry` — привязка геометрии к графу; геометрия должна достаточно хорошо ложиться на граф
* `match_signals` — привязка GPS-сигналов к графу; конфиги можно найти в модуле [`conf`](conf/__init__.py), среди них:
  * `Matcher.ONLINE` — симуляция привязки в сервисе, где нельзя ждать вечно, и за определённое окно нужно определяться, куда же приматчить те сигналы, что уже есть; используется для построения пробочных проездов
  * `Matcher.OFFLINE` — привязка с возможностью накапливать новые сигналы, пока не станет точно ясно, куда привязать предыдущие; матчит точнее, но с большей задержкой; используется для построения асессоров (эталонов)

В модуле [`schema`](lib/schema.py) можно найти описания входных и выходных колонок.

## Многопоточный матчинг GPS-сигналов

Матчер использует достаточно большие по размеру файлы данных (суммарно порядка 8-10Гб, OSM-граф — порядка 30Гб). При запуске в общих пулах memory mapped files обязаны быть добавлены в `memory limit` несмотря на то, что в пределах ноды джобы используют лишь одну копию файла в памяти. Как следствие, у операции крайне высокий `memory limit`, и чтобы удовлетворять желаемому соотношению `memory/CPU` реализована возможность матчить в несколько потоков.<br>
По умолчанию матчер сам определяет необходимое число потоков, выставляет необходимый `cpu_limit`, и дозаказывает `memory limit`, нужный для каждого потока.

**ВАЖНО**: избегайте больших ключей — они враги многопоточного матчера. Если в джобу приходит всего 4 ключа, то в 16 потоков их никак не заматчить, и лишние потоки будут простаивать. Также читатель обрабатывает ключи по очереди, и для запуска 2-го матчера необходимо целиком прочесть ключ для первого.<br>
**РЕШЕНИЕ**: как правило треки можно просто "нарезать", например приписав разные `uuid`ы в разные дни. Более умный способ — переименовывать юзера, если между сигналами произошёл большой разрыв, например в 15-20 минут.

### Описание работы

Многопоточный матчер состоит из:
* читателя — основной поток, который читает вход
* воркеров — потоки, где происходит привязка
* писателя — дополнительный поток, который пишет результирующие строки в таблицы

Между ними данные пересылаются при помощи очередей из [`event_loop`](/arc/trunk/arcadia/maps/analyzer/libs/event_loop).

Читатель вычитывает строки для одного ключа (трека) и отправляет в очередь первому свободному матчеру, т.е. тому, у которого очередь пуста. Если свободного матчера нет — ждёт, пока он появится. Также если совокупный размер очередей воркеров становится слишком велик, читатель тоже подождёт, чтобы избежать `memory limit exceeded`.

**Q**: _Зачем ждать свободный матчер?_<br>
**A**: Матчеры работают на порядок медленнее и в противном случае есть риск переполнить память

**Q**: _Пока мы ждём текущий матчер, разгребающий слишком большую очередь, остальные матчеры могут простаивать?_<br>
**A**: Да, но этот лимит достаточно большой, таких ключей быть вообще не должно, и в логах будет предупреждение на этот счёт. Если не ждать — есть риск упасть по `memory limit exceeded`, что хуже.

### Статистика операций матчинга

Матчер GPS-сигналов пишет пользовательские статистики в YT-операции (секция `custom`):
* `init_time` — время загрузки графа; это время должно быть относительно небольшим по сравнению с `total_time`. Если это не так, возможно, стоит увеличить `data_size_per_job`, чтобы увеличить долю непосредственно матчинга. Слишком большой `data_size_per_job`, однако, повышает риск потери большого кол-ва работы из-за абортов джоб
* `total_time` — общее время работы джобы
* `keys` — общее кол-во обработанных ключей; желательно, чтобы даже минимальное значение превосходило кол-во потоков
* `reading` — секция касательно чтения входных таблиц
  * `time_ms` — общее время чтения; включает в себя ожидание свободных матчеров
  * `wait_time_ms` — время ожидания свободных матчеров; если число большое, это значит, что воркеры матчат медленнее, чем читается вход; в целом это нормально
  * `blocking_time_ms` — время блокирования из-за переполнения очереди текущего матчера; говорит о слишком больших ключах, также об этом будет предупреждение в `stderr`
  * `rows_per_sec` — строки в секунду с учётом ожидания
* `matching` — секция касательно привязки
  * `time_ms` — общее время матчинга
  * `wait_time_ms` — общее (суммарное по потокам) время ожидания писателя воркерами; большое число означает, что писатель не успевает записывать результат и, возможно, имеет смысл снизить кол-во потоков
  * `rows_per_sec` — общая скорость матчинга всеми воркерами с учётом ожидания писателя
* `writing` — секция касательно писателя
  * `time_ms` — общее время работы писателя
  * `rows_per_sec` — строки в секунду

## Прочее

### Бинарники

* [`bin/match_geometry`](bin/match_geometry) — маппер, привязывает геометрии в поле `route_geometry` (или `geometry`/`polyline`, для совместимости с полилиниями [easyview](/arc/trunk/arcadia/maps/tools/easyview)) к графу и выдаёт соотсветствующие сегменты в поле `route_persistent_segments` (`persistent_segments`, если геометрия задана через `geometry`/`polyline`).
* [`bin/match_signals`](bin/match_signals) — редьюсер, привязывает сигналы с графу и выдаёт треки. [Схемы](lib/schema.py):
  * `TRAVEL_TIMES_BASE_TABLE` — проезды по сегментам
  * `TRAVEL_TIMES_TABLE` — проезды по сегментам с добавленной информацией из графа
  * `MATCHED_POINTS_TABLE` — привязанные GPS-сигналы - точки на графе

_TODO: _Добавить входную схему_

### Скрипты

Также есть [`scripts`](scripts) для упрощённого запуска тулз:
  * [`scripts/match_signals.sh`](scripts/match_signals.sh) — привязка сигналов к графу

### Локальный запуск

Можно запустить локально и получить отладочный вывод.<br>
Примеры сигналов можно взять в [тулзе для оценке кач-ва матчера](/arc/trunk/arcadia/maps/tools/matcher_quality/testdata/handmade/signals).<br>
Также на машине должен быть дорожный граф в директории `/usr/share/yandex/maps/graph` (принято делать это симлинкой на конкретную версию в `/var/spool/yandex/maps/graph/<version>`). Граф можно скачать, например, с [YT](https://yt.yandex-team.ru/hahn/navigation?path=//home/maps/graph).<br>

Далее можно заматчить сигналы и вывести результат в [easyview](/arc/trunk/maps/tools/easyview)

```bash
$ cat ~/arcadia/maps/tools/matcher_quality/testdata/handmade/signals/gas_station_1 | ./scripts/match_signals.sh out
Ok
Ok
CONFIG: /maps/analyzer/libs/graphmatching/conf/online
GRAPH_VERSION: 21.10.18-0
OUTPUT: out
$ cat out/ev | ~/arcadia/maps/tools/easyview/bin/easyview
```

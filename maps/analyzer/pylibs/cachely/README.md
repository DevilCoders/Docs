Кэширование промежуточных YT-таблиц
===

Иногда при запуске какого-то скрипта что-то где-то в середине падает, и много времени на вычисления оказывается утрачено.<br>
Данная библиотека позволяет кешировать промежуточные вычисления, т.о. повторный запуск пройдёт значительно быстрее.<br>

ВАЖНО: Сделано "на коленке", поэтому в реальных процессах использовать не стоит. Но для скриптов - ок.

Предоставляются наборы функций (декоратор и обёртка для использования в месте вызова):
* `caches`, `cached`, `cached_if` - кэширование функции. Если результат есть в кэше - создадутся временные таблицы, и кэшированные таблицы будут туда скопированы.
* `hashes`, `hashed`, `hashed_if` - временные таблицы в результатах исходной функции будут помечены, будто они взяты из кэша. Т.е. при повторном позыве вернётся другая временная таблица, но с т.з. кэша они будут "одинаковые". Это нужно, если функция возвращает одни и те же данные при одинаковых аргументах, но сохранять в кэше их смысла нет в силу того, что функция лёгкая, а данных много. Например, `fetch_signals` из тулкита.
* `scopes` - функция будет вызвана с локальным кэшем, см. ниже

Пример
===

См. [example](example)

```python
import maps.analyzer.pylibs.cachely as cachely

def prepare_jams(ytc, begin, end):
    ttimes = cachely.hashed(tk.sources.fetch_jams_sources, ytc, begin, end)
    return cachely.cached(build_realtime_jams, ytc, ttimes)


@cachely.hashes()
def prepare_assessors(ytc, begin, end):
    return tk.sources.fetch_assessors(ytc, begin, end, tk.paths.Assessors.USERS)


def run(ytc):
    jams = prepare_jams(ytc, '2020-02-02', '2020-02-02')
    users = prepare_assessors(ytc, '2020-02-02', '2020-02-02')
    return evaluate_eta_quality_with_jams(ytc, users, jams=jams)
```

Здесь `fetch_jams_sources` и `fetch_assessors` будут вызываться каждый раз, однако при одинаковых `begin` и `end` построение пробок `build_realtime_jams` будет брать результат из кэша несмотря на то, что `ttimes` будут новые.

Библиотека автоматически определяет, что аргумент является таблицей или `YtContext`ом. Но можно ей явно это подсказать. В декораторе можно указать через аргументы:
```python
@cachely.caches(outputs=['tbl'], tables=['sorted_tbl'])
def my_sort(ytc, tbl, sorted_tbl):
    pass
```

При вызове по месту через обёртки:
```python
cachely.cached(my_sort, cachely.ctx(ytc), cachely.table(tbl), cachely.output(sorted_tbl))
```

Также можно указать, использовать ли кэш:
```python
@cachely.caches(enabled=lambda: is_my_cache_enabled)
def foo():
    pass

def run():
    cachely.cached_if(is_my_cache_enabled, bar, arguments)
```

Локальный кэш
===

Полезным может быть наличие возможности кэшировать вызовы функций только, если они считают промежуточные результаты другой функции, и удалять по успешному завершению внешней функции. Для этого есть м.б. использован локальный кэш.

Пример явного создания локального кэша:
```python
def foo(ytc):
    with cachely.Local() as l:
        tbl = t.cached(gen_data, ytc, '2020-02-02')
        tbl2 = t.cached(calc_smth, ytc, tbl)
        return calc_result(ytc, tbl2)
```

То же, но на декораторах:
```python
@cachely.caches(local=True)
def gen_data(ytc, date):
    pass

@cachely.caches(local=True)
def calc_smth(ytc, tbl):
    pass

@cachely.scopes()
def foo(ytc):
    tbl = gen_data(ytc, '2020-02-02')
    tbl2 = calc_smth(ytc, tbl)
    return calc_result(ytc, tbl2)
```

В этом случае, если произойдёт падение где-то внутри `foo`, промежуточные результаты сохранятся, но удалятся, если выполнение завершится успешно.


Ограничения
===

Результат может быть либо таблицей, либо `None`. Другие значения, а также списки/кортежи таблиц не поддерживаются.<br>
Выходной таблицей может быть только аргумент функции. Список выходных таблиц передавать нельзя.

Описание реализации
===

Для набора аргументов при вызове функции делаются следующее:
1. Аргументы типа `YtContext` отбрасываются (так как не влияют на результат)
2. Выходные таблицы также отбрасываются
3. Входные таблицы, имеющие атрибут `@cachely` заменяются на путь до кэша, т.о. разные временные таблицы, взятые из одного кэша, будут считаться одинаковым входом
4. От исходного кода функции (`inspect.getsource`) и обработанных аргументов берётся хэш, т.о. определяется запись в кэше

Кэш для конкретного вызова лежит в `CACHE_ROOT/<полное имя функции>/<хэш из п.4>`:
* в таблице `.result` - результат
* в именованных таблицах - выходные аргументы

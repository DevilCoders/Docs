# EnvKit

Библиотека для упрощения наиболее часто используемого подхода запуска YT-операций: бинарь + python-биндинг к нему. Включает в себя:
1. [config](config.py) — конфиги + определения корня аркадии (см. ниже "Пакетирование")
2. [graph](graph.py) — пути до графовых файлов на YT, выставление версии графа, базовый класс для операций
3. [yt](yt.py) — преднастроенный `YtContext` (см [maps/pylibs/yt](/arc/trunk/arcadia/maps/pylibs/yt))
4. [loggy](loggy.py) — инициализация логгеров с преднастройкой для уменьшения мусора при обычном запуске и в автосборке
5. [env](env.py) — переменные окружения, которые можно использовать в путях, используется в модуле [paths](paths.py)
6. [paths](paths.py) — описание глобального конфига с путями, зависимыми от окружения, подробнее ниже. Пример использования см. [в тулките](/arc/trunk/arcadia/maps/analyzer/toolkit/lib/paths.py)
7. [resource](resource.py) — достать ресурс (в том числе бинарь) в виде временного файла. См. ниже пример, как использовать тулзу в своей библиотеке.

По сути библиотека позволяет единообразно работать в 3-х окружениях:
1. Разработческое — когда программы запускаются прямо из Аркадии
2. Серверное — когда установленная программа запускается на сервере
3. Тестовое — при запуске тестов

Основные функции:
  * `yt.get_context` — получить преднастроенный `YtContext` (см. [maps/pylibs/yt](/arc/trunk/arcadia/maps/pylibs/yt))
      ВАЖНО: По умолчанию в деве операции будут запускаться вне выделенных нод (тэг `yamaps`) и не в пуле (в тестинге/продакшне — умолчание обратное)
      Если используются операции с графом, тэг `yamaps` проставится, а пул — нет. Работать будет, но медленно, так как квота забита.
      Для явного указания тэга по умолчанию есть настройка `config.YAMAPS_TAG` (или переменная окружения `ALZ_API_YAMAPS_TAG`)
      Для использования пулов с гарантией в квоте есть настройка `config.YAMAPS_POOL` (`ALZ_API_YAMAPS_POOL`), однако для запуска в этих пулах нужны права.
      TODO: Научить запускаться операции с графом вне пула с использованием `tmpfs`
  * `config.packaged_path` — для пути относительно корня Аркадии вернёт реальный путь в окружении
  * `config.config_path` — аналогично `config.packaged_path`, но может содержать подстроку `{env}`, которая будет заменена на одно из: `default`, `development`, `testing`, `production`. Как правило используется для указания пути до отличающихся конфигов
  * `config.ConfigPath` — то же, что и `config.config_path`, но "ленивое", т.е. раскрывается в вызов `config.config_path` при преобразовании в строку. Нужно затем, чтобы можно было задать глобальный путь до конфига, но раскрывался бы он в месте использования (так как в момент определения путь до корня Аркадии может быть ещё не определён корректно, например, в тестовом окружении)
  * `graph.param` — `Param`-объект (см. [maps/pylibs/yt](/arc/trunk/arcadia/maps/pylibs/yt)) до графового файла, пригодный для передачи как параметр в `BinaryCmd`/`PythonCmd` (см. [maps/pylibs/yt](/arc/trunk/arcadia/maps/pylibs/yt))
  * `graph.VERSION`, `graph.set_version` — получить/выставить текущую используемую версию графа
  * `graph.graph_version_attribute`, `graph.set_graph_version_attribute` — выставить атрибут с версий графа на таблицу
  * `loggy.init_logging` — инициализация логгирования. По умолчанию зовёт `logging.basicConfig`. Если указать параметр `tests=True`, то добавит к логированию только "интересные" логгеры без лишнего — логов от фикстур и т.п., которые видеть по умолчанию не хочется.
  * `loggy.get_logger` — `logging.getLogger` с занесением логгера в список "интересных". По сути поведение отличаться будет только в тестах.
  * `resource.resource_file` — достать ресурс и сохранить в виде временного файла
  * `resource.resource_tool` — достать бинарь и сохранить в виде временного исполняемого файла

## Пути, зависимые от окружения

Как правило пути до данных зависят от окружения, причём в деве мы обычно хотим читать продакшновые данные (так как девовских нередко и нет), а в тестинге - тестинговые, чтобы убедиться, что ничего не сломалось на границе процессов. При этом писать всегда нужно в то окружение, в котором работаем (т.е. дев пишет в дев).<br>

Чтобы упростить задачу, предоставляется возможность описывать пути с использованием переменных окружения. Для этого надо лишь отнаследовать свой класс от `PathsConfig`, при этом все строки будут заменены на объекты типа `EnvPath`, который лениво раскрывается (т.е. применяет переменные окружения) при доступе к полю `value`.

Пример (см также [тесты](tests/test.py)):
```python
class Paths(PathsConfig):
  SIGNALS = '//home/maps/jams/{env}/data/signals'
  TRAVEL_TIMES = '//home/maps/jams/{env}/data/travel_times'

assert Paths.SIGNALS.value == '//home/maps/jams/production/data/signals'
```

Глобальные переменные окружения лежат в модуле [env](env.py) в переменной `VARS`, среди уже определённых:
* `env` - окружение с данными (`dev`, `testing`, `production`)

**TODO**: добавить `graph_dir`, `graph_version`, `graph_type`

При этом `env` в деве по умолчанию указывает в `production`, т.о. реализуется то, что при запуске процессов в деве, данные будут читаться из продакшна. Однако, если процесс собирается создавать данные, писать их надо в `env`. Для этого есть функция `paths.creates`, которая подменяет локальные переменные окружения в указанных путях:

```python
# собираемся создавать сигналы
creates(
  Paths.SIGNALS
)

assert Paths.SIGNALS.value == '//home/maps/jams/dev/data/signals'

# обновить из словаря, env при этом сохраняется
update(Paths, {'SIGNALS': '//some/other/{env}/path'})

assert Paths.SIGNALS.value == '//some/other/dev/path'
```

Вообще говоря, в каждом `EnvPath` есть локальные переменные окружения. По сути, код `paths.creates` почти аналогичен (см. ниже) подмене переменной `env`:

```python
Paths.SIGNALS.local_env['env'] = 'dev'
assert Paths.SIGNALS.value == '//home/maps/jams/dev/data/signals'
del Paths.SIGNALS.local_env['env']  # use global instead
assert Paths.SIGNALS.value == '//home/maps/jams/production/data/signals'
```

Новые переменные окружения необходимо объявлять с помощью функции `declare`. Это сделано для защиты от опечаток:

```python
# env.VARS.get('foo')  # raises ValueError
env.VARS.declare('foo')
env.VARS.put('foo', 'something')
```

При этом:
- можно указать, а можно и опустить указание начального значения
- в качестве значения можно указать функцию, которая принимает объект с переменными окружения `Vars`; т.о. можно реализовать "ленивую" переменную окружения, которая может зависеть от глобальных переменных или других переменных окружения, собственно, `paths.creates` как раз выставляет в качестве `env` глобальную переменную `config.ENV` для обратной совместимости

## Ресурсы

Чтобы использовать бинарь внутри библиотеки, надо его туда встроить в виде ресурса. Делается это так:
```make
BUNDLE(
  /path/to/tool NAME my_tool
)

RESOURCE(
  my_tool /my_tool
)
```

А далее используем в коде:
```python
def test():
  with envkit.resource_tool('/my_tool') as tool:
    p = subprocess.Popen([tool])
    p.wait()
```

Аналогичная (более общая) функция `resource_file` — по умолчанию не выставляет права на выполнение (параметр `binary=False`).

## Пакетирование

**WARN: DEPRECATED**, используйте BUNDLE + `resource_file`/`resource_tool`, данный подход скоро будет удалён

Определение корня Аркадии делается через "костыль": поиск файла `maps/analyzer/pylibs/envkit/pkg/.envkit.root`, соот-но чтобы установить программу на сервер, необходимо создать цель `PACKAGE`, включающую в себя все нужные конфиги / бинарники + `maps/anayzer/pylibs/envkit/pkg`. Результатом будет срез Аркадии, в котором `envkit` сможет корректно определить корень.<br>
Также эту же цель стоит указывать в тестах.

Если в пакете нужны `geobase`, `coverage`, `calendar` и пр., то нужно прописать соответствующие цели из [`maps/analyzer/data`](/arc/trunk/arcadia/maps/analyzer/data), а также воспользоваться функциями из модуля [`data`](data.py):
 * `init_coverage` — выставить путь по умолчанию до `coverage`, лежащем по притянутому по зависимости пути
 * `init_calendar` — аналогично `calendar`
 * `init_geobase` — аналогично `coverage`, но также распакует `zones_bin`

Пример программы + тестов: [update_models](/arc/trunk/arcadia/maps/analyzer/update_models)

# Gossip protocol

### Протокол для распространения данных в P2P сети http-серверов.

### Использование:

##### Самый простой способ
* Cкопировать папки и файлы ./examples/myYacare/install,
    ./examples/myYacare/Dockerfile, ./examples/myYacare/pkg.json, себе

* Изменить конфиг в install/etc/yandex/maps/analyzer/gossip.conf.json под вашу конфигурацию.

* Если у вас есть группа серверов A и вы хотите передавать что-то из них в группу серверов B.
    Делаете сервера из A distributor-ами, сервера из B consumer-ами. Подселяете этот якр-сервер к
    каждому хосту.

* Когда у сервера A появилось сообщение он дёргает ручку /upload/text?dataset=...&mesId=...

* Сообщение разойдётся по всем серверам из B, которые дёрнут ручку из конфига.

* Готово)

##### Если не хочется создавать якр-сервер:
* Создать экземпляр класса _Config_, Имя текущего хоста можно указать в конфиге _"this_hostname" : hostname_. Если ничего не указано автоматически установится hostname из /etc/hosts.
    Пример конфига можно найти в examples/tets/configs

* Создаём класс Tree_manager - основной класс с точки зрения пользователя. В конструктор передаём
    конфиг.

* При создании/получении сообщения, которое нужно распространить нужно вызвать метод _getAllTargets_,
который вернёт список серверов-получателей. Обязательный параметр - ГПСЧ. Необязаетльный - имя
отправителя, который прислал сообщение текущему серверу. Этот параметр обязателен для _consumer_ и
запрещён для _distributor_. (о них ниже)

* Если сервер-получатель упал во время пересылки, можно вызвать метод _updateTarget_, который вернёт
новую цель вместо упавшей. (Тогда не будет потери данных(естественно сервер, который упал данные не
получит)). После того, как сервер поднялся требуется вызвать метод
_reincarnate(имя_упавшего_хоста)_. После этого госсип будет снова его рассматривать в качестве
получателя.

* Серверы можно делить на группы, тогда пересылка сообщений между группами будет сведена к минимуму.
    Далее либо каждому серверу приписываем группу вручную, либо
    указываем список групп, на которые хотим делить, имена этих должны быть в имени хоста. Пример, группа
    _man_ - хост "stat.man.yandex.net". Если на группы не делить, то все серверы будут принадлжеать одной "дефолтной группе".

* Можно запустить в более безопасном режиме(для каждого сообщения сервер выполнит одну лишнюю
    пересылку), для этого укзываем _"redundant": true_ в конфиге.

* Есть два вида серверов: distributor и consumer. В конфиге должно быть хотя бы по одному каждого
    типа. Пересылка осуществляется следующим образом:
    * Информация появилась у одного из distributor.
    * Он отправляет ёё случайному consumer.
    * Consumer самостоятельно делятся ею друг с другом.

* Пример

```c++
maps::gossip::Config conf = maps::gossip::fromFile(path_to_conf);
maps::gossip::TreeManager tree(conf);
std::default_random_engine rnd(0);

// пересылаем данные, полученные из внешнего мира
maps::gossip::Hostnames targets = tree.getAllTargets(rnd);

// пересылаем данные, полученные от хоста previousHost
maps::gossip::Hostnames targets = tree.getAllTargets(previousHost, rnd);

// если знаем, что хост hostname из системы упал
tree.kill(hostname);

// вернуть упавший хост обратно
tree.reincarnate(hostname);

// если хост hostname упал пока сервер пересылал ему сообщение
// внутри ещё вызовется kill(hostname);
maps::gossip::HostName newTarget = tree.updateTarget(hostname, rnd);

```

* Самый подробный пример можно найти в bin/server/server.cpp

Библиотека привязки
===

Базовая библиотека для привязки точек/сигналов.
Используется в [`maps/analyzer/libs/graphmatching`](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching) для, собственно, привязки точек (геометрии) и сигналов к графу.


Описание алгоритма
===

1. [Термины](#термины)
1. [Добавление сигнала/замера](#добавление-сигналазамера)
    1. [Добавление слоя в граф кандидатов](#добавление-слоя-в-граф-кандидатов)
    1. [Дерево путей](#дерево-путей)
1. [Матчинг](#матчинг)
1. [Пример использования](#пример-использования)

Сама библиотека достаточно абстрактная, и ничего не знает про граф дорог / сигналы и т.п., однако её работу проще будет описать на примере имеющейся конкретной реализации ([graphmatching](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching)) для привязки к [дорожному графу](/arc/trunk/arcadia/maps/libs/road_graph).

Алгоритм решает проблему определения наиболее вероятной истории положений объекта на основе входных данных, таких, как GPS-сигнал.

### Термины

1. Сигнал (`Signal`/`S`) - GPS-сигнал и/или любая другая информация, на основе которой надо определить положение (притянуть в графу).
1. Замер (`Measurement`/`M`) - любая аддитивная информация между сигналами; например, время с предыдущего сигнала, пройденное расстояние согласно одометру и т.п.; при попытке связать кандидаты с пропуском сигналов между ними, соответствующие замеры будут сложены между собой.
1. Кандидат (`Candidate`/`C`) - один из вариантов привязки сигнала - точка на графе, предшествующий путь (если есть), отладочная информация и пр. состояние
1. Переход (`Transition`/`T`) - "путь" между двумя кандидатами; в рассматриваемой реализации - путь по графу, соединяющий точки на графе соответствующих кандидатов
1. Голова (`Head`/`H`) - кандидат со всей его предысторией; назван головой потому, что являет собой голову связного списка; идя в прошлое, пройдёмся по предшествующим кандидатам.
1. Вес (`Weight`/`W`) - некое число, характеризующее предпочтительность кандидата, перехода между кандидатами или головы; вес должен быть отрицательным, но чем он больше - тем кандидат/переход "лучше", при этом
    - обычно под весом кандидата понимается полный вес с учётом его предыстории, т.е. сумма "чистого" веса кандидата, веса перехода, и полного веса предшественника
    - вес перехода - результат `TransitionFunction`, вес перехода между двумя кандидатами
    - чистый вес кандидата - результат `WeighFunction`, вес без учёта перехода и предыстории
1. Слой (`Layer`/`L`) - совокупность голов `H`, соответсвующих кандидатам `C` на основе сигнала `S`, сам сигнал `S` и сумма всех замеров `M` от сигнала этого слоя до самого последнего.
1. Граф кандидатов (`CandidateGraph`/`G`) - совокупность слоёв `L`; чем больше слоёв, тем больше сигналов мы можем потенциально пропустить при матчинге. По сути это может играть роль некоторой фильтрации, когда какой-то сигнал (точнее, порождённые им кандидаты) пропускаются. Максимальное кол-во слоёв задаётся.
1. Матчер (`Matcher`/`M`) - собственно, матчер; хранит как граф кандидатов, так и добавленные в него и ещё не устаревшие сигналы. По мере привязки старые данные удаляются.
1. Поколение (`Generation`) - порядковый номер добавленного в матчер сигнала. Каждый сигнал добавляется, но не обязательно порождает слой (например, если не найдено рядом ни одного кандидата).
1. Генератор кандидатов (`GenCandidatesFunction`) - пользовательская функция, генерирующая кандидаты на основе сигнала и замера; в обсуждаемой реализации эта функция вернёт ближайшие к сигналу точки на графе в некотором радиусе.
1. Взвешивающая функция (`WeighFunction`) - функция, взвешивающая кандидат; в обсуждаемой реализации - чем ближе сигнал в точке на графе - тем лучше (*)
1. Функция перехода (`TransitionFunction`) - функция, оценивающая вес перехода между двумя кандидатами
1. Взвешивание головы (`WeighHeadFunction`) - функция, взвешивающая голову; используется для выбора лучшей головы, а как следствие и той последовательности кандидатов, которые будут выбрраны как результат матчинга. Важный момент: взвешиваются только головы, принадлежащие _разным_ слоям; внутри слоя всегда предпочитается голова с лучшим по весу кандидатом.
1. Лучшая голова (`bestHead`) - ссылка на лучшую голову `H`. Матчер всегда матчит пути, которые лежат на цепочке от лучшей головы до корня.

(*) - описание несколько упрощено, реальные функции лучше смотреть в документации к [graphmatching](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching) и [mapmatching_likelihoods](/arc/trunk/arcadia/maps/analyzer/libs/mapmatching_likelihoods)

По сути, всё API матчера сводится к двум операциям:
 - добавление сигнала - добавление в матчер сигнала и обновление его (матчера) состояния
 - матчинг - выбор лучшей последовательности кандидатов и позыв переданного коллбека поочередно для каждой пары выбранных и соединённых переходом кандидатов, начиная с прошлого; также удаление истории.

### Добавление сигнала/замера

Для каждодго сигнала и замера генерируется набор кандидатов при помощи `GenCandidatesFunction` (в привязке к графу генерируются ближайшие точки на графе).<br>
Затем все они взвешиваются при помощи `WeighFunction` и, опционально, оставляются не более `earlyLimit` лучших.<br>

#### Добавление слоя в граф кандидатов

Чтобы получить из взвешенных кандидатов новый слой, их нужно соединить с предшествующими, и сформировать головы `H`. Таким образом, для каждого кандидата:
 - оценивается вес перехода (с помощью `TransitionFunction`) между этим кандидатом и каждым из кандидатов на имеющихся слоях, при этом в функцию передаётся:
   - потенциальный предшествующий кандидат и текущий кандидат
   - соответствующий предшествующий сигнал и текущий сигнал
   - сумма всех замеров `M` от предшествующего сигнала до текущего<br>
     т.е. например, если замер - это пройденное расстояние, то в функцию передастся суммарное пройденное расстояние с предшествующего сигнала<br>
     где предшествующий сигнал - это потенциально позапрошлый, или поза-позапрошлый сигнал, смотря с кандидатом какого слоя мы связываемся
 - выбирается лучший переход и предыдущий кандидат на основе полного веса (чистый вес кандидата + вес перехода + вес предыдущего)
 - кандидат соединяется выбранным переходом и т.о. становится головой; кроме случая, когда вес получается -∞, такой кандидат не добавляется в слой

Опционально затем оставляется не более `limit` лучших голов и с относительным весом (относительно лучшей головы на добавляемом слое) не менее `threshold`; т.о. лимитируется максимальный размер слоя.<br>
Кол-во кандидатов на слое (как и кол-во слоёв) существенно влияет на производительность, потому добавлять заведомо плохих кандидатов не имеет смысла.

При превышении кол-ва слоёв, наиболее старый из них удаляется.

Наглядно работу добавления сигнала можно увидеть на анимации:

`△` - сигнал, вертиально под ним соответствующий ему слой<br>
`1`, `2`, `3`... - поколения; у 6-го поколения нет слоя (не нашлось кандидатов), но есть сигнал.<br>
`R` - корень (см ниже про [дерево путей](#дерево-путей))<br>
Зелёный кружок - лучшая голова (`bestHead`), чёрные точки - кандидаты, синие линии - переходы.

![add new signal](./docs/img/add_new_layer.gif)

Что происходит:
1. Добавляется новый сигнал и слой с взвешенными кандидатами
2. Каждый кандидат пытается связаться с каждым из кандидатов на всех слоях (максимальное число слоёв можно задать); связь оценивается функцией перехода, и выбирается лучшая.
3. Далее самый старый слой удаляется, некоторые узлы становятся подвешены в воздухе, и отмирают.

#### Дерево путей

Пару слов о хранении истории. Хранить для каждого кандидата копию всей предыстории накладно, потому на деле используется древовидная структура, являющаяся по сути совокупностью связных списков с общими хвостами.<br>
Т.е. это связный список, который наращивается и разветвляется, при этом за владение отвечает голова, т.о. как только мы удаляем голову, всё ответвление отмирает, если на него больше никто не ссылается, что визуально показано на анимации выше при удалении старого слоя.<br>
Соответственно, мы можем создать новую голову, соединить её хоть с серединой имеющегося списка, и таким образом получить новую ветвь.

1. Корень (`Root`/`R`) - корень дерева, любой узел либо связан с другим узлом, либо с корнем
2. Узел (`Node`/`N`) - узел в дереве, хранит состояние кандидата, а также знает своих предков/потомков
3. Голова (`Head`/`H`) - владеет узлом (через `shared_ptr`).
4. Отсоединить (`unlink`) - отсоединить узел от родителя (и автоматом присоединить к корню). Если на родителя больше не останется ссылок, он удалится (и по цепочке все его родители).

### Матчинг

В матчере есть семейство функций для, собственно, матчинга.<br>
Будем называть цепочкой последовательность связанных узлов/кандидатов из прошлого в будущее.<br>
Лучшей цепочкой назовём цепочку, ведущую в лучшую голову. Матчинг всегда матчит лучшую цепочку или её префикс.<br>
Обратите внимание, что от головы мы перемещаемся в прошлое, а по цепочке - наоборот. Это связано с тем, что матчинг зовёт коллбеки, начиная с прошлых кандидатов.<br>
Понятно, почему: с т.з. пользователя библиотеки удобно получать позыв коллбека поочередно для каждой пары выбранных кандидатов в определённом временем порядке.

Коллбек принимает:
1. Сигналы, соответствующие исходному и целевому кандидатам
2. Сами кандидаты
3. Номера соответствующих поколений

Функции матчинга:
1. `match` - заматчить всю лучшую цепочку
2. `matchIf` - заматчить цепочку, оканчивающуюся в узле `N`, удовлетворяющем условию (например, если хочется заматчить старше какого-то времени). При этом поиск с проверкой условия осуществляется с лучшей головы в прошлое. Такое используется в пробках - мы матчим всё, что старше N секунд, чтобы уменьшить лаг в получении результата.
3. `matchUntil` - заматчить всё, старше определённого поколения
4. `matchDefinite` - заматчить общий префикс всех цепочек
5. `matchNode` - заматчить цепочку до конкретной ноды. Это низкоуровневый метод, который используется всеми перечисленными выше, и обычно пользователям библиотеки не нужно его вызывать. Необходим, если вы каким-то образом самостоятельно выбираете ноду для матчинга и она может быть не в цепочке от лучшей головы.

Все функции имеют параметр `unlink` (по умолчанию `true`). Если он `false` - то заматченные узлы (`N`) __не будут__ удалены из дерева и цепочка может быть заматчена повторно.<br>
Например, это используется в сервисе привязки сигналов, который возвращает предысторию, соот-но очистка истории там идёт по кол-ву сигналов, а матчинг используется только для получения истории, но не её очистки.

Визуализация работы `matchDefinite` и `matchUntil`:

![match definite](./docs/img/match_definite.gif)

`matchDefinite`:
1. Идём от корня до первого разветвления
2. Зовём коллбек на 2 пары путей
3. Отсоединяем (unlink) узел, заматченная цепочка отмирает

![match until](./docs/img/match_until.gif)

`matchUntil`:
1. Идём от лучшей головы до узла с поколением, не больше указанного (в первом случае нашли указанное, во втором - 3-е)
2. Зовём коллбек на найденные пары путей
3. Во втором случае (`unlink=true`) отсоединяем найденный узел и всех его соседей с тем же поколением (или больше).

Также тут показано, что если позвать `match`-функцию с `unlink=false`, то после добавления сигнала и повторного матчинга может быть заматчена другая цепочка, так как лучшая голова и соот-но лучшая цепочка могут поменяться.

### Пример использования

Реальные примеры использования в библиотеке [graphmatching](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching):
 - [Привязка геометрии](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching/impl/match_geometry.cpp) - привязка полилинии, которая совпадает или почти совпадает с геометрией рёбер графа.
 - [Привязка сигналов](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching/impl/match_signals.cpp) - привязка GPS-сигналов к графу, используется например в [анализаторе пробок](/arc/trunk/arcadia/maps/analyzer/services/jams_analyzer) и сервисе [привязки сигналов](/arc/trunk/arcadia/maps/analyzer/modules/matcher)

На примере [привязки геометрии](/arc/trunk/arcadia/maps/analyzer/libs/graphmatching/impl/match_geometry.cpp) с некоторыми упрощениями:

```cpp
using namespace maps::analyzer;
using namespace maps::analyzer::mapmatching;
using namespace maps::analyzer::shortest_path;

// Определим состояние кандидата - точка на графе, путь по графу из предыдущего кандидата...
struct Candidate {
    PointOnGraph graphPoint;
    std::optional<Path> pathFromPrevious;
    double distance; // расстояние от вершины полилинии, пригодится для взвешивания
    // ...
};

// Определим конкретный тип матчера, т.е. зафиксируем шаблонные аргументы
using GeometryMatcher = Matcher<
    Candidate,
    geolib3::Point2, // в качестве "сигнала" будем брать просто точку, так как это привязка геометрии/полилинии
    Empty // замер - пустой
>;

// Функция генерации кандидатов на основе сигнала будет просто возвращать ближайшую по нормали точку
std::vector<Candidate> perEdgeCandidates(
    const road_graph::Graph& graph,
    const succinct_rtree::Rtree& rtree,
    const geolib3::Point2& pt,
    double radiusMeters
) {
    std::vector<Candidate> candidates;
    for (const auto& id: rtree.nearestBaseEdges(pt, radiusMeters)) {
        // ...
        // candidates.push_back(...)
    }
    return candidates;
}

// Взвешивающая функция
double weighCandidate(Candidate& c) {
    constexpr double stddev = 0.5;
    return -std::abs(c.distance / stddev);
}

// Взвешивание перехода
// Возвращает копию кандидата с весом и обновленным состоянием с учётом найденного пути
// В данном случае мы выставим путь до предыдущего кандидата
Weighted<Candidate> transitionFunction(
    ShortestPathsFinder& spFinder,
    const geolib3::Point2& startPt,
    const geolib3::Point2& endPt,
    const Candidate& from,
    const Candidate& to
) {
    constexpr double MIN_POINTS_DISTANCE = 30.0;
    const auto pointsDistance = maps::geolib3::fastGeoDistance(startPt, endPt);

    auto c = to;
    // Так как матчим геометрию, то соседние точки должны быть связаны по прямой, потому ограничим макс расстояние между ними
    // NOTE: поиск (find) находит агрегированную информацию о пути между точками на графе;
    // самого пути - последовательности сегментов - там нет
    // чтобы получить сам путь, нужно позвать spFinder.restore, но тут нам эта информация не нужна
    c.pathFromPrevious = spFinder.find(from.graphPoint, to.graphPoint, std::max(MIN_POINTS_DISTANCE, pointsDistance) * 1.5);
    // как-то оцениваем вес пути
    double weight = ...;
    return Weighted{weight, std::move(c)};
}

// Привязка геометрии
std::vector<SegmentPart> matchGeometry(
    const geolib3::Polyline2& pline,
    const road_graph::Graph& graph,
    const succinct_rtree::Rtree& rtree,
    const road_graph::PersistentIndex& persistentIndex,
    double minPart,
    double radiusMeters
) {
    std::vector<SegmentPart> result;

    ShortestPathsFinder spFinder(graph);
    GeometryMatcher matcher{
        1, // максимальное кол-во слоёв, ставим 1, так как пропускать вершины нельзя
        {}, // `{earlyLimit, limit, threshold}`, тут ставим без ограничений
        // generate candidates
        [&](const geolib3::Point2& pt, const Empty&) {
            return perEdgeCandidates(graph, rtree, pt, radiusMeters);
        },
        // weigh candidate
        [&](const geolib3::Point2&, const Empty&, Candidate& c) {
            return weighCandidate(c);
        },
        // transition function
        [&](
            const geolib3::Point2& startPt, const geolib3::Point2& endPt,
            const Empty&,
            const Candidate& from, const Candidate& to
        ) {
            return transitionFunction(spFinder, startPt, endPt, from, to);
        },
        // weigh head function
        // у нас всего один слой, так что головы взешивать не нужно, так как сравниваются только головы на разных слоях
        [&](auto&&...) { return 0.0; },
        // on match
        // коллбек на заматченную пару кандидатов
        [&](
            const geolib3::Point& startPt, const geolib3::Point2& endPt,
            Candidate& from, Candidate& to,
            std::uint64_t genFrom, std::uint64_t genTo
        ) {
            if (to.pathFromPrevious.has_value()) {
                // восстановим полный путь, см NOTE в transitionFunction
                auto& p = spFinder.restore(*to.pathFromPrevious);
                for (
                    auto it = iteratePath(p, graph);
                    it != SegmentPartIterator();
                    ++it
                ) {
                    // получаем куски сегментов, если нужно, склеиваем, кладём в результат
                    // тут для простоты просто кладём всё в результат
                    result.push_back(*it);
                }
            }
        }
    };

    // Матчер создан, добавляем в цикле сигналы - в данном случае точки, и матчим
    for (const auto& pt: pline.points()) {
        if (matcher.add(pt, {})) {
            // если состояние матчера обновилось - добавился новый слой
            // то заматчим определённую часть, чтобы не растить историю
            matcher.matchDefinite();
        }
    }
    // заматчим всё оставшееся
    matcher.match();

    return result;
}
```

TODO
===
Использовать эту библиотеку в [`maps/analyzer/libs/guidance`](/arc/trunk/arcadia/maps/analyzer/libs/guidance), а дублирующий код выкинуть.

# Мотивация:
  * хранение атрибутов фичей занимает 20% объема публикации (cis1 - 12GB / 60GB, например);
  * несмотря на примитивную схему хранения (массив строк c json + индекс по зумам), требуется внешняя либа MMS;
  * загрузка атрибутов жрет CPU при генерации тайлов.

# Результаты:
  * yet another сторадж, без всяких MMS'ов;
  * ключем является sourceId и zoomRange фичи, значением - атрибуты фичи (по сути json);
  * памяти занимает намного меньше, примерно в 20 раз;
  * чтение атрибутов фичи в 2 раза быстрее десериализации с помощью rapidjson::GenericDocument::Parse(const char*);
  * формат не привязан к rapidjson, в будущем можно заменить его в Feature::attributes на что-то менее избыточное.
      
# Устройство стораджа

## Представление ключа

Ключом в страдже является sourceId и zoomRange фичи.
Вариативность атрибутов в зависимости от zoomRange встречается только в слое poi, и даже там маргинальна:

```
количество уникальных атрибутов в пределах одного sourceId : к-во таких sourceId
    1 : 1363889
    2 : 890981
    3 : 324620
    4 : 87761
    5 : 97220
    6 : 10162
    7 : 341
    8 : 128
```

Поэтому основным ключом является sourceId.
В тех случаях, когда нужно хранить разные варианты для разных zoomRange, value представляет собой контейнер из нескольких наборов атрибутов с соответствующими zoom set (битовая маска).
При поиске мы сначала находим нужный блоб по sourceId, потом перебираем все zoomSet, пока не найдем пересекающийся с запрашиваемым zoomRange.

Если по sourceId был только один вариант атрибутов, то zoomSet не сохраняем и запрашиваемый zoomRange не проверяем.
Reader стораджа рассчитывает, что запрашиваться будет только то, что туда положили, полная валидация запроса не производится.

### Оптимизация хранения sourceId

В типовом случае применения стораджа (compiled_map_style2_cis1...) значения sourceId представляют собой почти непрерывный числовой диапазон.
Нет смысла тратить место на возрастающую последовательность чисел, вместо этого в индекс значений можно вставить фейковые позиции, там где sourceId таки не занят.
Если такая оптимизация используется, то мы, опять же, не валидируем полностью запрос.
Если в сторадже запросить по sourceId, который туда не сохраняли, то можно случайно получить значения атрибутов соседней (по sourceId) фичи.
Если диапазон sourceId таки разряжен, сохраняется список валидных значений, по нему производится пересчет sourceId->featureId.
В этом случае корректность запрашиваемого sourceId проверяется, поскольку это не требует хранения дополнительной информации.

### Индекс ключа
Дабы не тратить по 4-8 байт на каждый featureId, индекс представляет собой массив структур такого типа:
```cpp
    template<typename TBase, typename TSize>
    struct Entry {
        TBase base;
        TSize size[4];
    };
```
Обычно TBase - uint32_t, а TSize - uint8_t;
Одна Entry приходится на 5 значений featureId, таким образом на один featureId амортизированные затраты 8/5 байта.
Размер size равный 4 обеспечивает достаточную дешевизну вычисления суммы (2 сложения в среднем).
Для всех типовых сочетаний TBase/TSize сохраняется корректное выравнивание мемберов без паддинга.
В случае TBase = uint64_t значение TSize берется не менее uint16_t.
Если диапазон featureId содержит идентичные атрибуты (случай hydro_a в тестах), с каждой позиции идет ссылка на один и тот же блоб с value,
значения size для промежуточных featureId в диапазоне остаются нулевыми.

## Представление атрибутов

При добавлении фичи в сторадж мы разделяем содержимое json с атрибутами на 2 составляющие: script и valueList.
В script входят размеры контейнеров, имена ключей, тип значений.
Формат скрипта в EBNF:
```
Root        : *Value;
SimpleValue : TYPE SHARED FORMAT
QuotedValue : TYPE SHARED FORMAT
MapValue    : TYPE SIZE (SimplePair | QuotedPair | ArrayPair | MapPair)*
ArrayValue  : TYPE SIZE (SimpleValue | QuotedValue | ArrayValue | MapValue)*
*Pair       : KEY_ID *Value

```
TYPE: терминал "базовый тип":
```
enum ValueType { Simple, Quoted, Array, Map };
```
* Map - список из пар ключ->значение, Object в терминах json;
* Array - список значений без ключей;
* Quoted - строки в кавычках (String в терминах json);
* Simple - любые другие значения: number, true, false, null.

Все строковые значения при заполнении стораджа сразу складываются в таблицы уникальных значений, в промежуточные данные идет id из таблицы.
Есть отдельная таблица для ключей (в скрипт идет число KEY_ID) и отдельная для SimpleValue или QuotedValue.

FORMAT: формат, в котором сохраняется значение.
Каждому появлению терминала FORMAT в скрипте соответствует одно значение в valueList.

ValueList в промежуточным представлении состоит из юнионов, а в файле записывается как байтовый поток.
```
union Value { uint64_t u; int64_t  i; double f;}

enum ValueFormat { // Value:      byteStream:
    String,        // uint64_t    vbe(index)
    StringRaw,     // uint64_t    utf8 zt
    Float4,        // double      float4 LE
    Fixed1,        // double      uint8_t(value*10)
    SIntBig,       // int64_t     vbe(zigzag(value))
    SInt1,         // int64_t     int8_t
    UIntBig,       // uint64_t    vbe(value)
    UInt1,         // uint64_t    uint8_t
};
```
Значение типа QuotedValue также может иметь формат числа, если to_string потом дает точно такую же строку.

Классификация значения по формату происходит при добавлении фичи в сторадж, за исключением выбора между String и StringRaw.
В формате StringRaw сохраняются уникальные (в пределах всех фичей стораджа) строки, их не имеет смысл тянуть в глобальную таблицу.
Чтобы понять, уникальна строка или нет, надо завершить заполнения стораджа и дойти до вызова finalize().
Первоначально все строки определяются как String и попадают в таблицу.

Количество скриптов на весь сторадж исчисляется десятками-сотнями, скрипты хранятся как массив из битовых строк.

### Оптимизация valueList
Во многих случаях valueList содержит одни и те же значения для всех или почти всех фич. Например, слой building:
```
{"ft_type_name":"urban-residential","bld_id":100131119,"cond":"0","height":3,"selection_id":7311618769,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100131455,"cond":"0","height":3,"selection_id":6883558579,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100131823,"cond":"0","height":3,"selection_id":113124465,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100131951,"cond":"0","height":3,"selection_id":6771248195,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100132235,"cond":"0","height":3,"selection_id":113138227,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100132307,"cond":"1","height":3,"selection_id":6771246055,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100134267,"cond":"0","height":15,"selection_id":6771270391,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100134475,"cond":"0","height":3,"selection_id":113120395,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100134559,"cond":"0","height":3,"selection_id":4304744173,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100134811,"cond":"0","height":3,"selection_id":6883596451,"tags":["structure","building"]}
{"ft_type_name":"urban-residential","bld_id":100134839,"cond":"0","height":3,"selection_id":4315530445,"tags":["structure","building"]}
...
```
ValueList для 1'й записи: ["urban-residential", 100131119, "0", 3, 7311618769, "structure", "building"]

Значения ["urban-residential", "structure", "building"] вообще по всему стораджу одинаковые.

Значения ["0", 3] варьируются слабо, в целом они создадут несколько десятков уникальных комбинаций внутри одного стораджа.

Если сгруппировать valueList по скриптам, то у нас получится таблица с однотипными колонкам.
Можно вынести из этой таблицы часть колонок в вспомогательную таблицу таким образом, чтобы rows number в этой вспомогательной таблице было невелико, по сравнению с rows number основной таблицы.
Это устранит избыточность в повторяющихся значениях.
Таким образом, множество значений в valueList разделяется на 2 списка:

 - uniqueValueList (в примере это 100131119, 7311618769);
 - sharedValueList ("urban-residential", "0", 3, "structure", "building")

Мощность множества uniqueValueList равна мощности множества фичей, а вот количество sharedValueList невелико, порядка 10 x к-во скриптов.

Алгоритм выбора колонок для sharedValueList можно найти в функции selectSharedVL, это жадная эвристика с остановкой по размеру вспомогательной таблицы.

При чтении атрибутов мы находим соответствующие script, uniqueValueList, sharedValueList.
Воссоздание атрибутов производится путем выполнения скрипта.
Когда в скрипте встречается терминал FORMAT, мы выбираем значения в одном из valueList.
Выбор между unique или shared определяется терминалом SHARED (это 1 бит), он всегда предшествует терминалу FORMAT.


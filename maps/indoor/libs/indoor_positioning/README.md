# Библиотека indoor-позиционирования

## Термины и определения

**Радио-излучатель** --- излучатель радио-сигнала (точка-доступа WiFi, BLE-маяк,
BEACON-маяк). Радио-излучатель характеризуется следующими параметрами:
 * `latitude`, `longitude` --- географические координаты радио-излучателя;
 * `levelId` --- идентификатор этажа, на котором он расположен;
 * `A`, `B`, `deviation` --- параметры распространения сигнала (см.
 *логарифмическую модель распространения сигнала*).

**Идентификатор радио-излучателя** --- символьная последовательность, однозначно
идентифицирующая радио-излучатель. Для WiFi и BLE излучателей она является
MAC-адресом, для BEACON-маяка --- конкатенацией его uuid, major и minor. Пример
идентификатора BEACON-маяка:

```
 F7826DA6-4FA2-4E98-8024-BC5B71E0893E,48687,10890
```

**NB:** Все идентификаторы излучателей должны указываться в UPPER CASE. Это
позволяет их сравнивать на предмет совпадения как обычные строки.

**Радио-измерения** --- измерения сигналов, регистрируемые на устройстве, от
радио-излучателя. Радио-измерения могут быть представлены в виде мощности
принимаемого сигнала, измеряемой в децибелл-милливаттах. Как правило, значения
мощности сигнала изменяются в диапазоне от -100 dbm до 0 dbm.

**Логарифмическая модель распространения сигнала**. Мощность принимаемого сигнала
убывает при удалении от радио-излучателя. При этом основной моделью
распространения сигнала будем считать модель, согласно которой средняя мощность,
регистрируемая на расстоянии $r$ от излучателя, вычисляется по формуле:
$$rssi(r) = A - B \cdot \ln(r),$$
где:
 * $A$ --- средняя мощность сигнала, регистрируемая на расстоянии 1 м;
 * $B$ --- коэффициент затухания сигнала.

Дисперсия мощности регистрируемого сигнала вычисляется по формуле: $deviation^2,$
где $deviation$ --- среднеквадратическое отклонение мощности сигнала от
модельного значения.

Полезна будет и обратная формула, позволяющая оценить расстояние до
радио-излучателя по измеренной силе сигнала, полученной от него:
$$r(rssi) = \exp\left(\frac{A - rssi}{B}\right).$$

**Инерциальные измерения** --- измерения от трехосных акселерометра, магнитометра
и гироскопа.

**Радиокарта** --- совокупность помещений с этажами, их геометрией и множеством
радио-излучателей, на них расположенных, используемая для позиционирования
устройства. Радиокарта описывается следующим protobuf-файлом:

https://arcanum.yandex-team.ru/arc_vcs/maps/doc/proto/yandex/maps/proto/indoor/indoor_radiomap.proto

**Indoor-позиционирование** --- процесс определения местоположения устройства
внутри схемы помещений по регистрируемым сигналам радио-излучателей и
инерциальным измерениям. Для этого устройство загружает радиокарту местности и
соотносит друг с другом регистрируемую силу сигналов от известных в радиокарте
излучателей. Результатом работы indoor-позиционирования является:
 * универсальный идентификатор этажа, на котором находится устройство;
 * географические координаты устройства (долгота, широта).

Таким образом, для работы indoor-позиционирования необходимо обеспечить 
непрерывный прием сигналов от радио-излучателей, а именно:
 * включить WiFi и bluetooth-приемники;
 * включить геолокацию на устройстве;
 * выдать приложению необходимые разрешения.

## Структура библиотеки позиционирования

Для начала работы с библиотекой позиционирования необходимо создать два объекта:
 * `LevelIndex` --- множество этажей, по которым ведется позиционирование;
 * `IndoorPositioningClient` --- объект, непосредственно выполняющий
позиционирование устройства по радио- и инерциальным измерениям.

### LevelIndex

Представляет собой индексированную коллекцию этажей, по которым ведется
позиционирование. `LevelIndex` является удобным представлением для работы с
радиокартой и позволяет:
 * быстро находить этажи по их идентификаторам;
 * динамически добавлять и удалять этажи, а также вытеснять неиспользуемые этажи
 при превышении максимального размера коллекции (по правилам LRU-кэша).

#### Конструктор

```
    LevelIndex(size_t maxSize);
```

Параметры:
 * `maxSize` --- максимальное количество этажей в коллекции.

Новые добавляемые этажи сверх этого значения будут вытеснять из `LevelIndex`
старые долго неиспользуемые этажи. Таким образом, `LevelIndex` работает как
LRU-кэш для этажей.

#### Метод updateLevel

Метод позволяет добавить или изменить этаж. Его можно вызывать при загрузке
очередного тайла радиокарты не прерывая процесс позиционирования (при изменениях
`LevelIndex` не требуется пересоздавать `IndoorPositioningClient`).

```
    void updateLevel(
        const PlanLevelId& planLevel,
        const LevelTileData& levelData);
```

Параметры:
 * `planLevel` --- идентификатор плана/этажа;
 * `levelData` --- данные об этаже (геометрия помещений и расположение и
 параметры восстановленных радио-излучателей).

#### Метод clear

Метод позволяет очистить коллекцию этажей. Метод полезен в случае изменения
версии радиокарты. В этом случае все этажи должны быть удалены и загружены снова
(с новой версией геометрии и излучателей).

```
    void clear();
```

#### Метод findLevel

Метод позволяет найти и вернуть информацию о конкретном этаже --- геометрию, а
также положение и параметры радио-излучаталей.

```
    const LevelInfo* findLevel(const PlanLevelId& planLevel) const;
```

Параметры:
 * `planLevel` --- идентификатор плана/этажа.

#### Метод touchLevel

Метод позволяет переместить указанный этаж на вершину кэша, избегая для данного
этажа вытеснения из кэша. Метод вызывается для этажа $L$ каждый раз, когда
устройство регистрирует сигнал от некоторого радио-излучателя с этажа $L$.

```
    void touchLevel(const PlanLevelId& planLevel);
```

Параметры:
 * `planLevel` --- идентификатор плана/этажа.

#### Метод traverse

Метод позволяет пройтись по всем этажам коллекции и применить к каждому из них
заданную функцию.

```
    void traverse(const std::function<void(const LevelInfo&)>& func) const;
```

Параметры:
 * `func` --- функция, принимающая на вход этаж коллекции.

### IndoorPositioningClient

Данный класс позволяет определять положение устройства по радиокарте и
принимаемому устройством множеству радио- и инерциальных измерений.

#### Функция createIndoorPositioningClient

Для создания `IndoorPositioningClient` необходимо передать коллекцию этажей и
структуру `DeviceCapabilities` --- описание типа устройства (какие типы сигналов
может получать данное устройство).

```
std::shared_ptr<IndoorPositioningClient> createIndoorPositioningClient(
    const std::shared_ptr<LevelIndex>& levelIndex,
    const DeviceCapabilities& dev);
```

Параметры:
 * `levelIndex` --- коллекция этажей (радиокарта);
 * `dev` --- параметры устройства.

#### Метод position

Метод позволяет вычислить текущую позицию устройства с учетом переданных
измерений.

```
    boost::optional<IndoorPosition> position(
        const TransmitterMeasurements& txMsrs,
        const SensorMeasurements& sensorMsrs,
        const Timestamp& timeNow);
```

Параметры:
 * `txMsrs` --- множество текущих сигналов радио-излучателей;
 * `sensorMsrs` --- множество текущих измерений инерциальных датчиков;
 * `timeNow` --- текущее время.

#### Алгоритм позиционирования

1. Передать измерения в `MeasurementPreprocessor`.

2. Запросить очередное окно позиционирование у `MeasurementPreprocessor`:
    - если есть окно позиционирования, то перейти к шагу 3;
    - иначе перейти к шагу 13.

3. Распределить все радио-измерения текущего окна позиционирования по этажам
(одно и то же радио-измерение может попасть в несколько этажей, если
соответствующий радио-излучатель восстановлен на нескольких этажах).

4. Передать радио-измерения текущего окна позиционирования в `LevelSelector`.
Определить список активных этажей в порядке уменьшения вероятности:
    - если список активных этажей непустой, перейти к шагу 5;
    - иначе сбросить последнюю вычисленную позицию и перейти к шагу 12.

5. Поднять все активные этажи в LRU-кэше `LevelIndex`. Таким образом, мы
препятствуем тому, чтобы активные этажи были вытеснены из кэша в случае его
переполнения.

6. Передать инерциальные измерения в текущем окне позиционирования в
`SensorFusion`. Определить множество шагов пользователя и позиционное измерение
(при его наличии).

7. Для каждого активного этажа:
    - выбрать соответствующий этому этажу `ParticleFilter`;
    - определить возможную позицию устройства на этом этаже, передав в `ParticleFilter` следующие данные:
        - информацию об этаже `LevelInfo`;
        - набор радио-измерений, соответствующих данному этажу;
        - множество сделанных пользователем шагов;
        - корректирующее позиционное измерение.

8. Выбрать первый активный этаж `L`, полученный от `LevelSelector` на шаге 4
(наиболее вероятный этаж нахождения устройства), и взять XY-координаты устройства
на этом этаже (вычисленные соответствующим фильтром частиц на предыдущем шаге).
Преобразовать XY-координаты устройства из локальной метрической системы координат
этажа в абсолютные географические координаты.

9. Уточнить позицию устройства с учетом предыдущей позиции и скорости, передав
текущую абсолютную позицию в `PositionSmoother`.

10. Найти проекцию позиции устройства на текущий выбранный этаж (ближайшую к
найденной позиции точку геометрии этажа).

11. Установить последнюю вычисленную позицию как результат, полученный на
предыдущем шаге.

12. Удалить текущее окно позиционирования путем вызова функции
`MeasurementPreprocessor::eraseMeasurements`. Перейти к шагу 2.

13. Вернуть последнюю вычисленную позицию.

Далее будут описаны компоненты, используемые в алгоритме
`IndoorPositioningClient`.

### DeviceCapabilities

Структура, описывающая возможности устройства. В зависимости от параметров,
передаваемых в `DeviceCapabilities`, может быть выбран тот или иной вариант
алгоритма позиционирования.

Поля структуры:
 * `hasAccelerometer` --- флаг, определяющий есть ли в устройстве датчик акселерометра;
 * `hasMagnetometer` --- флаг, определяющий есть ли в устройстве датчик магнитометра;
 * `hasGyroscope` --- флаг, определяющий есть ли в устройстве датчик гироскопа;
 * `hasBarometer` --- флаг, определяющий есть ли в устройстве датчик барометра (альтиметра);
 * `hasLocation` --- флаг, определяющий, будет ли устройство использовать данные сторонних провайдеров геолокации;
 * `hasBeacons` --- флаг, определяющий, поддерживает ли устройство сканирование BEACON-маяков;
 * `hasWifi` --- флаг, определяющий, поддерживает ли устройство сканирование WiFi-сигналов;
 * `hasBle` --- флаг, определяющий, поддерживает ли устройство сканирование BLE-маяков;
 * `hasWifiThrottling` --- флаг, определяющий, включено ли ограничение
 сканирования WiFi-сигналов на устройстве.

**NB.** С помощью `DeviceCapabilities` можно эмулировать другой тип устройства.
Например, для того, чтобы эмулировать iPhone с помощью Android-смартфона,
необходимо выставить следующие значения флагов (iPhone может принимать только
один тип радио-сигналов --- BEACON-маяки):

```
DeviceCapabilities{
    .hasAccelerometer = true,
    .hasMagnetometer = true,
    .hasGyroscope = true,
    .hasBarometer = true,
    .hasLocation = true,
    .hasBeacons = true,
    .hasWifi = false,
    .hasBle = false,
    .hasWifiThrottling = false};
```

### MeasurementPreprocessor

Класс отвечает за фильтрацию передаваемых радио- и инерциальных измерений и за
разделение непрерывного потока этих измерений на так называемые *окна
позиционирования*.

**Окно позиционирования** характеризуется своим начальным и конечным временем и
представляет собой подмножество всех переданных за время существования
`MeasurementPreprocessor` измерений, для которых выполняется условие:

```
  startTime <= txTime < stopTime,
```

где
 * `startTime`, `stopTime` --- начальное и конечное время окна позиционирования;
 * `txTime` --- время измерения, принадлежащего окну позиционирования.

Различные окна являются непересекающимися, причем конец каждого из них является
началом следующего. Определение местоположения устройства выполняется только при
формировании нового окна позиционирования. Даже при наличии более свежих
сигналов, они не учитываются до тех пор, пока не будет сформировано новое окно
позиционирования. Размер окна позиционирования (то есть разница между `startTime`
и `stopTime`) фиксирован и составляет 1000 мс.

Фильтрация сигналов зависит от:
 * радиокарты (отбрасываются сигналы от излучателей, которых нет в радиокарте);

 * параметров устройства (отбрасываются сигналы, неподдерживаемые устройством,
 например, для iOS отбрасываются WiFi и BLE сигналы);

 * видимого RSSI (отбрасываются сигналы RSSI которых выходит за допустимый
 диапазон [-100, 0]).

#### Конструктор
```
    MeasurementsPreprocessor(const DeviceCapabilities& dev);
```

Параметры:
 * `dev` --- параметры устройства.

#### Метод addMeasurements

Метод позволяет добавить новые измерения в очередь.

```
    void addMeasurements(
        const TransmitterMeasurements& txMeasurements,
        const SensorMeasurements& sensorMeasurements,
        Timestamp timeNow);
```

Параметры:
 * `txMeasurements` --- множество новых радио-измерений;
 * `sensorMeasurements` --- множество новых инерциальных измерений;
 * `timeNow` --- текущее время.

**NB.** Новое окно позиционирования формируется в тот момент, когда переданное
значение `timeNow` становится больше или равно конечному времени текущего окна
позиционирования.

#### Метод availableMeasurements

Метод запрашивает текущее окно позиционирования.

```
    boost::optional<MeasurementsView> availableMeasurements();
```

Возвращаемое значение:
 * множество измерений, попавших в новое окно позиционирования, или
 `boost::none`, если новое окно еще не сформировано.

#### Метод eraseMeasurements

Метод удаляет из очереди измерения, относящиеся к сформированному ранее окну
позиционирования. Фунция должна вызываться каждый раз после получения и обработки
очереденого окна позиционирования (шаги 2--8 алгоритма позиционирования).

```
void eraseMeasurements();
```

#### Метод currentTime

Метод позволяет получить начальное время текущего (еще несформированного) окна
позиционирования.

```
    Timestamp currentTime() const;
```

### LevelSelector

`LevelSelector` отвечает за определение и ранжирование активных этажей радиокарты
по истории видимых сигналов за последние $N$ секунд (текущее значение `30`).

Этаж считается **активным**, если за последние $N$ секунд были зарегистрированы
измерения от радио-излучаталей, расположенных на данном этаже.

**NB:** Поскольку радио-излучатели восстанавливаются на всех этажах независимо,
одно и то же радио-измерение может относиться к нескольким этажам одновременно.

Алгоритм работы `LevelSelector` выглядит следующим образом.

1. Для каждого этажа $L$ радиокарты заводятся три объекта `RetrospectiveValueEstimator`
(см. описание далее) для аккумулирования определенных параметров сигналов, а именно:
    * суммарного количества полученных измерений от радио-излучателей с этажа $L$
    за последние $N$ сек --- `signalCountEstimator`;

    * суммарного rssi полученных измерений от радио-излучателей с этажа $L$ за
    последние $N$ сек --- `rssiEstimator`;

    * суммарного параметра A от радио-излучателей, приславших сигнал с этажа $L$
    за последние $N$ сек --- `aEstimator`.

2. На вход алгоритм в каждый момент времени получает поэтажный список видимых
радио-сигналов в текущем окне позиционирования. Для каждого этажа из списка
добавляются значения в соответствующие `signalCountEstimator`, `rssiEstimator`,
`aEstimator`.

3. Для каждого активного этажа осуществляется вычисление **оценочной функции**,
характеризующей вероятность нахождения устройства на нем (значение оценочной
функции для неактивных этажей неопределено):

    * Предположим, что за последние $N$ секунд для этажа $L$ пришло $n$ измерений
    от радио-излучателей, расположенных на данном этаже. Обозначим эти измерения
    как $\left\{(tx_i, rssi_i), i = 1, 2, \ldots, n\right\}.$ Тут $tx_i$ ---
    радио-излучатель, расположенный на этаже $L$, от которого был зарегистрирован
    сигнал мощностью $rssi_i$. Тогда оценочная функция для этажа $L$ будет иметь
    вид:
    $$E_L = - \frac{n^2}{\sum_{i=1}^n rssi_i} - \frac{n}{\sum_{i=1}^n A_{tx_i}}.$$

    * Тут $A_{tx_i}$ --- параметр $A$ радио-излучателя $tx_i$, восстановленного на
    этаже $L$.

    * Для вычисления значений $n$, $\sum rssi_i$, $\sum A_{tx_i}$ в произвольный
    момент времени используются `signalCountEstimator`, `rssiEstimator`,
    `aEstimator` для соответствующего этажа.

4. Затем осуществляется ранжирование активных этажей в порядке убывания оценочной
функции. На выход алгоритм возвращает полученный упорядоченный список активных
этажей. Первый элемент списка станет в итоге этажом, который будет определен как
текущий этаж расположения устройства.

#### Конструктор
```
    LevelSelector();
```

#### Метод estimatePlanLevel

Метод определяет текущий наиболее вероятный этаж.

```
    std::vector<PlanLevelId> estimatePlanLevels(
        const LevelSignals& levelSignals,
        Timestamp timeNow);
```

Параметры:
 * `levelSignals` --- поэтажный список видимых сигналов в текущем окне
 позиционирования (сигналы группируются по этажам, один и тот же сигнал может
 встречаться несколько раз на разных этажах радиокарты);
 * `timeNow` --- текущее время.

Возвращаемое значение:
 * упорядоченный список текущих активных этажей. Список упорядочен по убыванию
 вероятности нахождения устройства на нем. Пустой список означает, что активных
 этажей нет.

### RetrospectiveValueEstimator

`RetrospectiveValueEstimator` позволяет оценивать среднее значение некоторой
переменной величины в пределах заданного периода времени.

`RetrospectiveValueEstimator` реализован в виде циклического буфера, ячейки
которого аккумулируют значения переменной в течении одной «эпохи» --- короткого
интервала времени.

Каждый раз, когда переменная величина изменяется, ее новое значение должно быть
передано в `RetrospectiveValueEstimator`, который добавляет это значение в ячейку
для текущей эпохи.

Каждый раз, когда требуется узнать среднее значение переменной за период времени,
`RetrospectiveValueEstimator` вычисляет взвешенную сумму значений по всем ячейкам
(исключая слишком старые эпохи). Вес ячеек экспоненциально уменьшается при
удалении от текущей эпохи (с коэффициентом затухания):

```
вес_0 = коэффициент_затухания ^ 0 (текущая эпоха)
вес_1 = коэффициент_затухания ^ 1 (предыдущая эпоха)
вес_2 = коэффициент_затухания ^ 2 (пред-предыдущая эпоха)
...
```

#### Конструктор

```
    RetrospectiveValueEstimator(
        size_t numberOfEpochs = 30,
        int64_t epochLengthMs = 1000,
        double attenuationFactor = 0.999);
```

Параметры:
 * `numberOfEpochs` --- количество отслеживаемых эпох (длина циклического буфера);
 * `epochLengthMs` --- длина одной эпохи в миллисекундах;
 * `attenuationFactor` --- коэффициент затухания.

#### Метод addValue

Метод позволяет добавить новое значение переменной в `RetrospectiveValueEstimator`.

```
    void addValue(double value, Timestamp timestamp);
```

Параметры:
 * `value` --- значение переменной;
 * `timestamp` --- текущее время.

#### Метод getCurrentValue

Метод позволяет вычислить текущее среднее значение переменной за период времени.

```
    double getCurrentValue(Timestamp timestamp) const;
```

Параметры:
 * `timestamp` --- текущее время.

Возвращаемое значение:
 * взвешенная сумма значений переменной по всем ячейкам.

#### Метод reset

Метод позволяет очистить `RetrospectiveValueEstimator` (сбросить все ячейки в
начальное состояние).

```
    void reset();
```

### SensorFusion

Класс `SensorFusion` отвечает за распознавание шагов (длину и направление) по
инерциальным измерениям. Рапознавание шагов позволяет в течении некоторого
времени обновлять положение устройства даже при отсутствии видимых сигналов.

#### Конструктор
```
    SensorFusion(const DeviceCapabilities& dev);
```

Параметры:
 * `dev` --- параметры устройства.

#### Метод getMotionSequence

Метод определяет для данного окна позиционирования количество, длину и
направление сделанных пользователем шагов.

```
    MotionSequence getMotionSequence(
        const MeasurementsPreprocessor::MeasurementsView& msrView,
        Timestamp timeNow);
```

Параметры:
 * `msrView` --- текущее окно позиционирования (содержит множество текущих инерциальных измерений);
 * `timeNow` --- текущее время.

### ParticleFilter

`ParticleFilter` представляет собой основной класс, отвечающий за
позиционирование устройства на определенном этаже.

`ParticleFilter` использует систему **частиц** и их весовых коэффициентов. Каждая
частица представляет собой кортеж $(x, y, w, \alpha)$, где:

 * $x, y$ --- координаты частицы на этаже;
 * $w$ --- вес в диапазоне [0, 1];
 * $\alpha$ --- направление (азимутальный угол).

Частица называется **живой**, если ее вес больше некоторого `EPSILON` (текущее
значение `1e-8`) и **мертвой** в противном случае.

Количество частиц фиксированно и описывается константой `NUM_PARTICLES` (текущее
значение равно 1000). Система частиц изменяется итеративно в соответствии со
следующим алгоритмом.

1. Сэмплировать частицы на этаже, в случае необходимости. Критерий сэмплирования
--- если с момента получения радио-измерения прошло более `RESET_TIMEOUT` секунд
(текущее значение 45), либо если сэмплирование еще не проводилось.

    - Данный шаг заключается в том, что частицы разбрасываются случайным образом
    с условием, чтобы их координаты оставались в рамках геометрии этажа. Угол
    устанавливается случайным образом в диапазоне [-180, 180]. Вес всех частиц
    полагается равным `1.0 / NUM_PARTICLES` (в сумме он должен составлять `1.0`).

2. Переместить частицы с учетом количества, длины и направления детектированных
шагов, а также с учетом позиционного измерения.

    - На данном шаге изменяется только положение частиц и их угол. Если в
    результате какая-то частица выходит за геометрию этажа, то она остается на
    прежнем месте, а ее угол изменяется случайным образом в диапазоне [-180, 180].

    - Позиционное измерение (при его наличии) является центром притяжения частиц.
    Каждая частица сдвигается в направлении позиционного измерения
    порпорционально отношению радиусов indoor-решения и радиуса позиционного
    измерения. Предварительно, позиционное измерение должно быть спроецировано на
    геометрию этажа с тем, чтобы избежать (снизить вероятность) выхода частицы за
    геометрию этажа при подобном смещении.

3. Определить количество живых частиц. Если количество живых частиц снизилось
ниже допустимого ограничения (`NUM_PARTICLES_ALIVE_THRESHOLD`, текущее значение
100), то сэмплировать частицы на этаже заново (см. шаг 1).

4. Аккумулируем сигналы радио-излучателей, выполнив предварительную фильтрацию
«плохих» радио-излучателей. Алгоритм фильтрации:

    - Вычислить для радио-излучателя отношение $deviation/B$, где $deviation$ ---
    средне-квадратическое отклонение силы сигнала от модельного значения, а $B$
    --- коэффициент затухания сигнала для радио-излучателя. Если отношение
    превышает допустимый порог `SIGNAL_QUALITY_THRESHOLD` (текущее значение
    `1.5`), то такой сигнал отбрасывается.

5. Если прошло менее `UPDATE_INTERVAL` миллисекунд (текущее значение 1000) с
момента предыдущего обновления весов частиц, то перейти к шагу 11. В противном
случае, установить время обновления частиц на текущее и перейти к шагу 6.

6. Если количество текущих видимых радио-излучателей недостаточно для проведения
мутации (константа `MIN_TX_NUMBER_FOR_MUTATION`, текущее значение 3), то перейти
к шагу 10.

7. Выполнить мутацию нескольких частиц. Количество частиц для мутации задается
константой `NUM_PARTICLES_FOR_MUTATE` (текущее значение 50). Алгоритм мутации
можно описать следующим псевдо-кодом:

    - Повторять `NUM_PARTICLES_FOR_MUTATE` раз:
        - выбрать случайную частицу;
        - ее координаты и угол инициализируются заново, как при
        сэмплировании (см. шаг 1);
        - вес инициализируется заново значением `1.0 / NUM_PARTICLES`.

8. Определить **центр сэмплирования**. Центром сэмплирования является ближайший к
местоположению радио-излучатель в текущем окне позиционирования (расстояние до
радио-излучателей оценивается по логарифмической формуле распространения
сигнала).

9. Сэмплировать `NUM_PARTICLES_AROUND_CLOSEST_AP` (текущее значение равно 10)
частиц вокруг центра сэмплирования. Алгоритм сэмплирования вокруг центра можно
описать следующим псевдо-кодом:

    - Повторять `NUM_PARTICLES_AROUND_CLOSEST_AP` раз:
        - выбрать случайную частицу;
        - XY-координаты инициализируется случайным образом по гауссовому
        распределению со средним в центре сэмплирования и дисперсией равной
        `DEVIATION_AROUND_CLOSEST_AP` (текущее значение 5.0);
        - угол инициализируются случайным значением в диапазоне [-180, 180].
        - вес инициализируется заново значением `1.0 / NUM_PARTICLES`.

10. Коррекция весов частиц. На данном шаге выполняется переоценка весов частиц с
использованием вектора радио-сигналов из текущего окна позиционирования:
$\overline{s}=\{s_1, ..., s_n\}$, где $s_i$ --- сигнал в dBm от радио-излучателя
$tx_i$. Алгоритм коррекции:
    - Для каждого индекса $i = 1, 2, ..., n$:
        - Вес каждой частицы умножается на **функцию правдоподобия** ---
        вероятность того, что находясь в данной точке устройство будет принимать
        сигнал $s_i$ от излучателя $tx_i$. Она рассчитывается по
        нормальному распределению следующим образом:
        $$p_i = \frac{1}{\sigma_{tx_i}\sqrt{2\pi}}\exp\left(\frac{-(s_i - \hat{s}_i)^2}{2{\sigma_{tx_i}}^2}\right).$$

        - Тут $\hat{s}_i$ --- модельный сигнал от излучателя $tx_i$, получаемый
        по логарифмической формуле распространения сигнала, $\sigma_{tx_i}$ ---
        средне-квадратическое отклонение силы сигнала от модельного значения,
        вычисленное для радио-излучателя $tx_i$.

        - Веса всех частиц нормируются таким образом, чтобы в сумме они
        составляли 1.0.

11. Ресэмплинг. После нескольких шагов процедуры коррекции веса частиц,
соответствующие ошибочным гипотезам, могут стать близкими к нулю. Такие частицы
не вносят вклад в финальную оценку положения устройства. Процедура ресэмплинга
позволяет перераспределить вычислительные ресурсы путем отбрасывания частиц,
имеющих малый вес, и дублирования частиц, имеющих большой вес. Метод состоит
из нескольких шагов.

    - На первом шаге проверяется критерий ресэмплинга. Для этого вычисляется
    сумма квадратов весов всех частиц. Критерий ресэмплинга выполняется, если эта
    сумма больше, чем `1.0 / RESAMPLING_THRESHOLD` (текущее значение 600). Если
    критерий не выполняется, то ресэмплинг частиц на данной итерации не
    производится.

    - В случае, если критерий ресэмплинга выполняется, строится кумулятивная
    функция распределения на основе частиц и их весов. Для каждой частицы
    $k=1,2, ..., N$ вычисляются частичные суммы: $S_k = \sum_{i=1}^k w_i$.
    Таким образом, $0 \le S_1 \le S_2 \le ... \le S_N = 1.$

    - Затем генерируется равномерно распределенная случайная величина:
    $u \sim U(0,1).$

    - На основе значения, которое приняла случайная величина, выбирается
    минимальный индекс $i$, такой что: $S_{i-1} \le u \le S_i.$

    - Частица с индексом $i$ копируется в новый массив частиц. Данная процедура
    повторяется $N$ раз.

    - В ходе применения процедуры ресэмплинга происходит удаление частиц с
    низкими весами и дублирование частиц с более высокими (пропорционально ее
    весу). По этой причине в конце ресэмплинга веса всех частиц выравниваются:
    $w_i = \frac{1}{N}.$

#### Конструктор

```
    ParticleFilter();
```

#### Метод performEstimation

Метод выполняет одну итерацию эволюции частиц.

```
    void performEstimation(
        const LevelInfo& levelInfo,
        const TransmittersSignalStatistics& txMeasurements,
        const MotionSequence& motionSequence,
        const boost::optional<PositionalMeasurement>& posMeas,
        Timestamp time);
```

Параметры:
 * `levelInfo` --- текущий этаж;
 * `txMeasurements` --- измерения радио-сигналов в текущем окне позиционирования;
 * `motionSequence` --- последовательность шагов (длина, направление),
 определенная на шаге 5 алгоритма с помощью `SensorFusion`;
 * `posMeas` --- позиционное измерение, полученное от `SensorFusion`, либо
 `boost::none` в случае отсутствия такового;
 * `time` --- текущее время.

Алгоритм эволюции описан ниже.

#### Метод position

Метод возвращает XY-координаты текущей средневзвешенной частицы.

```
    XYPoint position() const;
```

Возвращаемое значение:
 * локальные XY-координаты точки, соответствующей положению устройства на данном
 этаже.

#### Метод accuracy

Метод возвращает предполагаемую оценку погрешности средневзвешенного решения.

```
    double accuracy() const;
```

Возвращаемое значение:
 * радиус погрешности в метрах.

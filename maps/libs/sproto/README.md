## sproto

![](img/sproto.jpg)

[TOC]

### Что это?

**sproto** (stable protobufs) — это альтернативная реализация libprotobuf от гугла, написанная (в отличие от предшественника) на C++.

Основные отличия от гугловой библиотеки:

* **Максимальная стабильность ABI**. Любые (почти) разрешённые гугловой документацией изменения должны корректно обрабатываться кодом в обе стороны.
* **Нормальный public API**, похожий на стандартные C++-ные контейнеры, с которыми все привыкли работать.
* **Никакой кодогенерации**. С++ предоставляет достаточное количество средств метапрограммирования из коробки, чтобы не требовалось генерировать что-то из каких-то других форматов.

### Fast start

```cpp
#include <yandex/maps/sproto.h>

SPROTO_MESSAGE(MyMessage) {
    SPROTO_FIELD(Required, sproto::Int32,  x,   1);
    SPROTO_FIELD(Repeated, sproto::String, str, 2);
};

void outputMessage(std::ostream& out) {
    MyMessage msg;
    msg.x() = 1;
    msg.str().push_back("hello, world!");
    out << msg;
}

void inputMessage(std::istream& in) {
    MyMessage msg;
    if (in >> msg) {
        assert(msg.x() == 1);
        assert(msg.str()[0] == "hello, world");
    }
}
```

### API

Как видно из вышеприведённого примера, объявления сообщений делаются макросами `SPROTO_MESSAGE(class_name)` и `SPROTO_FIELD(category, type, name, tag)`,
очень похожими на то, что мы привыкли видеть в `.proto`.

В качестве категории может выступать `Required`, `Optional`, `Repeated` или `Packed` (последнее — это аналог `repeated ... [packed=true]` из `.proto`),
в качестве типа — любой стандартный тип:

* `Int32`,
* `Int64`,
* `Uint32`,
* `Uint64`,
* `Sint32`,
* `Sint64`,
* `Fixed32`,
* `Fixed64`,
* `Sfixed32`,
* `Sfixed64`,
* `Bool`,
* `Float`,
* `Double`,
* `String`,
* `Bytes`.

Все типы пишутся с большой буквы и находятся в `namespace sproto`. Также можно использовать определённое ранее сообщение или enum.

{% note info %}

Если не вводить специальных тегов для чисел, то получится неоднозначность.
Например, `int32_t` может быть представлен в протобуфе как `Int32`, `Sint32` или `Sfixed32` — какой выбрать?

{% endnote %}

Определение `SPROTO_FIELD(..., foo, ...)` приносит в класс только один метод — `foo()` (ну, точнее, ещё его константную версию).
Этот метод возвращает (возможно, константную) ссылку на класс, похожий на соответствующий стандартный класс:

* для `Required` арифметического типа или enum-а — `T&`;
* для `Optional` — `boost::optional<T>&`;
* для `Repeated` — `std::vector<T>&`;
* для `Packed` — контейнер, содержащий `T`, но с forward-итераторами.
* для `Required` строк или `Required` вложенных сообщений — возвращается `std::string&` или `NestedMessageType&` ровно (без всяких проксей).

{% note info %}

На самом деле всё это (кроме required string и required embedded message) специальные классы;
пытаться создавать их экземпляры, делать `decltype(myMessage.x())` или принимать их в шаблонные функции по значению не нужно.

{% endnote %}

Работа с расширениями выглядит примерно так:

```cpp

SPROTO_MESSAGE(MyMessage) {
    // ...
    SPROTO_EXTENSION_RANGE(100, std::numeric_limits<size_t>::max());
};

SPROTO_EXTENSION(MyMessage, Repeated, String, newer_strings, 101);

void extendMessage(MyMessage& msg) {
    msg[newer_strings] = { "hello", "world" };
}
```

Extension можно объявить где угодно: в глобальном namespace, во вложенных неймспейсах, внутри класса или его метода.

Кроме аксессоров для сообщений определены такие операции:

* `sproto::isWellFormed(const MyMessage&)` — проверяет, что у сообщения (а также у всех вложенных сообщений на всех уровнях) заполнены все required-поля;
* `sproto::assertWellFormed(const MyMessage&)` — то же самое, но кидает `sproto::IllformedMessage` в случае ошибки;
* `operator<< (std::ostream&, const MyMessage&)` — пишет в поток бинарное представление сообщения;
* `operator>> (std::istream&, MyMessage&)` — читает из потока бинарное представление сообщения (до EOF-а);
* `sproto::textDump(const MyMessage&)` — возвращает класс, который при записи в std::ostream запишет туда текстовое представление сообщения.
* `traverse([const] MyMessage&, F)` — базовый compile-time reflection. Вызывает `F::operator()([const] MyMessage& msg, const char* name, sproto::Field<category, type, fieldIndex> field)` для каждого определённого поля. Значение поля можно получить через `msg[field]`.

Для `isWellFormed()`, `assertWellFormed()` и `textDump()` определены синонимы, позволяющие вызывать их через argument-dependent lookup — это позволяет работать с сообщениями из шаблонного кода, не подключая header-ов от sproto.

```cpp

// подключать <maps/libs/sproto/include/sproto.h> не нужно

namespace sproto { class Message; }

template<class Msg>

typename std::enable_if_t<std::is_base_of_v<sproto::Message, Msg>, yacare::Response&>
operator<< (yacare::Response& out, const Msg& msg) {
    assertWellFormed(msg);

    if (yacare::request().input()["outformat"] == "text") {
        return out << textDump(msg);
    } else {
        return out << msg;
    }
}
```

Операторы сдвига, вызванные для конкретных классов сообщений, проверяют корректность прочитанного/записанного сообщенияi
(`operator<<` зовёт assertWellFormed() вначале; `operator>>` переводит поток в невалидное (failed()) состояние, если isWellFormed() вернул false).
Они же, вызванные для базового класса `sproto::Message`, никаких проверок не делают.

{% note info %}

Все операции определены как свободные функции, чтобы не засорять пространство имен сообщения
(а что, если кто-то захочет определить поле с именем isWellFormed или textDump?)

{% endnote %}

Несколько слов о потокобезопасности: поскольку в момент разбора сериализованного сообщения невозможно отличить bytes от embedded message,
разбор последнего выполняется лениво, в момент первого обращения.
Для максимизации производительности, такой разбор не защищён мьютексом, и таким образом,
первое обращение к `MyMessage::innerMsg() const` будет непотокобезопасным.
Обычно это не является проблемой — isWellFormed(), вызываемый сразу после разбора, рекурсивно пройдётся по всем полям с сообщениями и распарсит их.
Однако isWellFormed() ничего не знает о расширениях, и если ваше сообщение будет использоваться из нескольких thread-ов
и у него есть расширения в виде дополнительных сообщений, его нужно либо защитить внешним мьютексом (в т.ч. на чтение),
либо сразу после разбора взывать явно msg[ext], чтобы выполнить разбор сразу же.

Также о расширениях ничего не знает `textDump()` — точнее, он напечатает только те расширения,
которые были явно установлены в клиентском коде для _данного конкретного экземпляра_ сообщения.
Расширения в распаршенном из стрима сообщении будут проигнорированы при печати.

Сообщение — это обычный класс, понаследованный (косвенно) от `sproto::Message`.
Соответственно, внутри кроме объявления полей можно определять дополнительные методы для удобства работы:

```cpp
SPROTO_MESSAGE(Point) {
    SPROTO_FIELD(Required, double, longitude, 1);
    SPROTO_FIELD(Required, double, latitude, 2);
};

SPROTO_MESSAGE(Rectangle) {
    SPROTO_FIELD(Required, Point, lowerLeft, 1);
    SPROTO_FIELD(Required, Point, upperRight, 2);

    bool isDegenerate() const {
        return lowerLeft().latitude() == upperRight().latitude()
            || lowerLeft().longitude() == upperRight().longitude();
    }

    void assign(double lng1, double lat1, double lng2, double lat2) {
        lowerLeft()  = Point().latitude(std::min(lat1, lat2)).longitude(std::min(lng1, lng2));
        upperRight() = Point().latitude(std::max(lat1, lat2)).longitude(std::max(lng1, lng2));
    }
};
```

Однако не нужно пытаться определять какие-либо поля или виртуальные методы (иначе будет сегфолт).

### Совместимость ABI

Сообщение хранится, грубо говоря, как `map<Tag, vector<Value>>`, спрятанный за pimpl-ом.
Дочерние классы не определяют своих полей, так что все сообщения занимают 8 байт (размер одного указателя) и замечательно reinterpret-cast-ятся друг к другу.
В частности это обозначает, что если одна функция возвращает сообщение (по значению, по ссылке — неважно),
а другая принимает (опять же, неважно как), то такие две функции будут работать вместе, даже если у них разное определение сообщения.

Все поля (то, что возвращает `MyMessage::x()`) — это специальные классы с приватным деструктором, так что не надо их копировать,
а также возвращать или принимать (на самом деле их экземпляров никогда не создаётся,
а то, что возвращает `MyMessage::x()` — это по сути `reinterpret_cast<FieldType*>(this)`.
В свою очередь, методы этих прокси-объектов делают обратный каст и добывают реальное значение из сообщения).
Таким образом, все поля также reinterpret-cast-ятся друг к другу, и даже если кто-то неосторожно примет `Optional<SomeEnum>`, а ему вместо него дадут `Repeated<Int>` — все будет работать.

{% note warn %}

Единственное исключение — это required string и required embedded message.
Чтобы работал синтаксис `msg.x().size()`, `msg.x()` должен возвращать именно `std::string&`, никакие прокси-классы не подойдут.
Так что менять required bytes на required embedded message нельзя — это единственное изменение `.proto`, допустимое у Гугла и недопустимое тут.

{% endnote %}

Срезка сообщений до базового типа sproto::Message тоже допустима и не приводит ни к какой потере данных:

```cpp
auto msg = MyMessage().x(10).y("hello").y("world"); // альтернативный builder-style синтаксис инициализации

sproto::Message base = msg; // срезка

MyMessage& ref = static_cast<MyMessage&>(base);

assert(ref.x() == 10 && ref.y()[0] == "hello");
```

### Прочее

**О дефолтных значениях.**
Значения по умолчанию не поддерживатся — их просто некуда запихать при принятом подходе.
Вообще поле с дефолтным значенем — это такой _optional_
(даже если написано _required_ — гугловый libprotobuf не пишет дефолтные значения полей при сериализации),
так что можно просто явно объявить такое поле optional-ом и воспользоваться `optional<T>::get(const T& defaultValue)`.

**Об удалении/переименовывании полей**.
Как мы помним, удалять однажды объявленную в публичном API функцию нехорошо,
так что однажды объявленное поле в идеале должно оставаться таковым (хотя если от функции никто не брал адрес, она почти наверняка поинлайнилась).
Однако никто не мешает объявить рядом ещё одно поле с тем же тегом.
Старые ненужные поля можно уносить в private-секцию (`private: SPROTO_FIELD(...);`).

**О расширении enum-ов**.
При разборе enum-ов гугловый libprotobuf ведёт себя весьма забавно: все неизвестные данной реализации значения вырезаются и складываются отдельно
(таким образом, required/optional enum считается незаданным, а количество значений в repeated enum уменьшается).
Поскольку в sproto нет ни reflection-а на енумах, ни дефолтных значений, которые можно было бы отдавать, то нет и такой хитрой логики;
приложение получит точно `static_cast<MyEnum>(хранимый_инт)` и должно реализовывать всю логику работы с неизвестными значениями самостоятельно.

### Скорость работы

Разумеется, держать всё за pimpl-ом и каждый раз лазить туда за данными не может не быть медленнее, чем держать данные прямо в сообщении. Сейчас измерения показывают следующее:

|**Действие**|**google lite**|**sproto lite**|**google heavy**|**sproto heavy**|
| --- | --- | --- | --- | --- | --- | --- |
|Заполнение всех полей|45 нс|207 нс|1360 нс|3273 нс|
|Сериализация|1216 нс|780 нс|3734 нс|2660 нс|
|Десериализация|1371 нс|1167 нс|5235 нс|4922 нс|
|Чтение всех полей|10 нс|27 нс|171 нс|374 нс|

Использовалось два типа сообщений: "легкие" и "тяжёлые", отличающиеся от первых бОльшим использованием heap-а.

```
message Lite {
    required int32 x = 1;
    repeated int64 y = 2;
};

/* lite sample data = */ {
    x = 1,
    y = [10, 11]
}

message Heavy {
    repeated int32 x = 1 [packed=true];
    repeated string y = 2;
    repeated Lite z = 3;
};

/* heavy sample data = */ {
    x = [1,2,3,4,5,6,7,8,9,10],
    y = ["hello", "yes", "this", "is", "dog"],
    z = [ { 1, [10,11] },
          { 2, [32,33,34,35] } ]
}
```

# Поддержка Lua в Аркадии

В Яндексе много сервисов, крутящихся поверх *nginx*, и, как следствие, есть немного кода на *Lua* в виде плагинов к нему. Как и любой другой код, этот код тоже хочется тестировать. С точки зрения разработки минимально необходимыми выглядят следующие фичи:
 - организация и переиспользование кода между компонентами на *Lua* - как следствие, возможность *PEERDIR*-иться,
 - тестовый фреймворк для описания тестов и валидации условий,
 - возможность встраивать тесты в сборку и запуск тестов в *CI*.

Официально *Lua* отсутствует в списке поддерживаемых в Аркадии языков, однако макрос *ya make* `SRCS`, тем не менее, умеет их обрабатывать, превращая во встроенный в статическую библиотеку байткод, который потом можно загрузить обычным `require`. Для генерации байткода используется лежащий в Аркадии *luajit*, и, если компонент объявить как `LIBRARY()`, на выходе мы получим статическую библиотеку, которую можно указывать в `PEERDIR(...)` и линковать в исполняемый файл.

## Тестовый фреймворк

В самом по себе тестовом фреймворке для *Lua* нет ничего особенного. Нужна возможность объявлять тест-кейсы, описывать ожидания и выставлять моки/стабы для изоляции тестируемой функциональности. Существуют готовые тестовые фреймворки на *Lua*, активно используемые сообществом: [busted](http://olivinelabs.com/busted/), [lust](https://github.com/bjornbytes/lust). Взяв их за основу, был написан свой простенький фреймворк со следующим *API*:
 - `testing.describe(name, body)` объявляет *test suite*.
 - `testing.it(name, body)` объявляет тест в рамках *test suite*. Должна вызываться только в теле `testing.describe`.
 - `testing.Mock` универсальный *mock*-класс, позволяющий обращаться к любым полям и вызывать себя в качестве функции. Любые поля, которым было присвоенно значение, сохраняются в иерархии.
 - `testing.stub(action)` создаёт класс-заглушку, отслеживающую свои вызовы и сохраняющую списки аргументов, с которыми была вызвана. Списки аргументов могут быть получены с помощью функции `testing.called(stub)`.

Для проверки условий используется встроеная функция `assert`.

Странные на первый взгляд имена `describe` и `it` были выбраны для сходства с вышеперечисленными тестовыми фреймворками.

Таким образом, простейший тест на *Lua* выгядит следующим образом:
```lua
local t = require 'testing'

-- Global setup
p.sometable = t.Mock:new{
  field1 = "hardcoded value"
}

-- Mocking dependencies
package.loaded.some_dependency = t.Mock:new{
  somemethod = function()
    return t.Mock:new()
  end
}

-- Package under test
local p = require 'tested-package'

t.describe("testsuite", function()
  t.it("some simple assert", function()
    local result = p.foo("input")
    assert(result ~= nil)
  end)

  t.it("some stub example", function()
    local mock = t.Mock:new()
    p.somefunction = t.stub(function()
      return mock
    end)

    p.invokesomething()
    -- Assert that stub was called at least once
    assert(#t.called(p.somefunction) >= 1)
  end)
end)
```

## Интеграция с *ya make*

Так как аркадийная *Lua* прекрасно умеет собираться в псевдо-статические библиотеки, почему бы не использовать уже готовую поддержку со стороны других ЯП для написания и запуска тестов? *Lua*, будучи встраиваемым языком, прекрасно интегрируется в код на *С/С\+\+*, а используемый в Аркадии тестовый *С++*-фреймворк *Google Test* достаточно гибок, чтобы позволять регистрировать и запускать тесты на *runtime* с помощью функции `testing::RegisterTest`. 

Разработанный в прошлом разделе тестовый фреймворк был дополнен *callback*-ом в С++, регистрирующим описанные на *Lua* тесты в *Google Test*. Со стороны *Google Test* под каждый тест создаётся фикстура с именем теста, которая в своём `TestBody` вызывает *Lua*-шную функцию `testing.run` с именем конкретного теста. В итоге имеем (почти) нативную поддержку со стороны *ya make*/*CI* и описание тестов на *Lua*.

Одним из недостатков получившегося фреймворка является отсутствие автоматического обнаружения тестов: из исполняемого файла теста невозможно собрать список модулей с описанием тестов из-за особенностей работы *luajit*. При указании *lua*-скрипта в качестве исходника в макросе `SRCS(...)` в *ya.make* генерируется команда сборки, вызывающая *luajit* для генерации объектного файла с *luajit*-байткодом в виде массива байт с префиксом `luaJIT_BC_`. При обработке функции `require` делается попытка найти соответствующий массив в данных программы (платформозависимым способом, под *Linux* это делается через `dlsym`) и подгрузить хранящийся там байткод в текущее окружение. В случае с описаниями тестов, чтобы загрузить и зарегистрировать их, необходимо запустить нашу ya.make магию с помощью `INCLUDE(${ARCADIA_ROOT}/maps/libs/luatesting/ya.make.inc)
`.

Пример объявления теста для *Lua*:

```ya.make
# ya.make
GTEST()

SRCS(my-package-tests.lua)

PEERDIR(
    maps/my/package
)

INCLUDE(${ARCADIA_ROOT}/maps/libs/luatesting/ya.make.inc)

END()
```

## Зависимости на C-библиотеки

Интерпретатор *Lua* поддерживает несколько способов добавления модулей:
 - написанные на *Lua* модули при поддержке байт-компиляции встраиваются в исполняемый файл теста и загружаются стандартным загрузчиком *Lua*,
 - динамические библиотеки - стандартный загрузчик ищет соответствующую имени модуля динамическую библиотеку в *CPATH* и пытается загрузить из неё точку входа `luaopen_<module>`.
 
Второй вариант создаёт трудности при написании тестов: помимо добавления зависимости на библиотеку необходимо добавить путь к ней в *CPATH* при запуске теста. Схема запуска тестов на *Lua* чере движок *GTest* не позволяет это сделать. Альтернативой является статическая линковка библиотеки в исполняемый файл теста и загрузка точки входа в библиотеку непосредственно из исполняемого файла. Стандартные механизмы загрузки модулей *Lua* не поддерживают такую схему, но она реализована в движке *luatesting*. Таким образом, для использования *Lua*-модуля, реализованного в виде динамической библиотеки, необходимо добавить в *ya.make* теста макрос `WHOLE_ARCHIVE` на *статическую версию* библиотеки. Например:

```ya.make
GTEST()

SRCS(tests.lua)

PEERDIR(my/package contrib/libs/lua-cjson)
WHOLE_ARCHIVE(contrib/libs/lua-cjson)

INCLUDE(${ARCADIA_ROOT}/maps/libs/luatesting/ya.make.inc)

END()
```

При обработке вызовов `require "module"` в случае неуспешной загрузки стандартными загрузчиками вызывается расширенный загрузчик для встроенных библиотек и ищет в исполняемом файле теста символ `luaopen_<module>`. В случае, если такой символ есть, он считается функцией загрузки одноимённого модуля и исполняется. Макрос `WHOLE_ARCHIVE` необходим (и именно в финальном *ya.make* теста - транзитивно из зависимостей он не добавляется), так как с точки зрения линковщика символы из библиотеки в исполняемом файле не используются, и линковщик не включает её в итоговый артефакт. 

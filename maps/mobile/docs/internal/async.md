# `maps/mobile/libs/runtime/async`
### Асинки
Асинки - асинхронно выполняющиеся функции/лямбды. Асинки запускаются с помощью диспатчера, при этом диспатчер возвращает `async::Future`/`async::Handle`/`async::MultiFuture`. Диспатчер отвечает за запуск, отмену, смену выполняющихся асинок.
Диспатчер неразрывно связан с соответствующим ему эвентлупом, в частном случае просто тредпулом.
 
### Future, Handle, MultiFuture
* [async::Future](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/future.h?rev=r8419414#L193) - основной примитив, через который можно получить результат асинхронной операции. Она всегда связана с соответвующим [Promise](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/promise.h?rev=r8419414#L107). 
Если запускать асинку через [Dispatcher::async](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/dispatcher.h?rev=r8419414#L96) то `Promise` создается под капотом, а вызов возвращает `async::Future`.
* [async::Handle](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/future.h?rev=r8419414#L271) - просто алиас для Future<void>, получается при вызове [Dispatcher::spawn](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/dispatcher.h?rev=r8419414#L112) с функциями возвращающими void.
* В отличии от stl у нас есть еще [async::MultiFuture](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/future.h?rev=r8419414#L301), связанная с [async::MultiPromise](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/promise.h?rev=r8419414#L142). В `MultiPromise` можно писать много раз, из `MultiFuture` можно будет много раз читать новые значения в той же последовательности, что были записаны в `MultiPromise`. Если позвать [Dispatcher::async](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/dispatcher.h?rev=r8419414#L41) c функцией, которая возвращает void, принимая первым аргументом MultiPromise<T>, то мы получим MultiFuture<T>
 
Так же `Future`/`MultiFuture` можно получить и эксплицитно позвав `future()` у `Promise/MultiPromise`.
 
Основные методы `(Multi)Future`/`Handle`:
* `wait`/`waitUntil`/`waitFor` - ожидание момента, когда из нее можно будет извлечь ранее не прочитанное значение
* `get` - это wait + получить первое ранее не прочитанное значение
* `(Multi)Future::release`/`Handle::detach` - больше не ждать результат, если фьюча получена из диспатчера, соответствующая асинка продолжает выполнение
* `reset` - делает фьючу больше не валидной, если фьюча получена из диспатчера, соответствующая асинка отмененяется.
* `Деструктор` фьючи вызывает под капотом reset

### Исключения внутри асинки
Если не пойманное исключение вылетает из асинки, то произойдет одно из:
* Если асинка была запущена через `async`, то исключение сохранится в `Future`, откуда будет выброшено при вызове `Future:get`
* Если асинка была запущена через `spawn` на `ui` диспатчере, то исключение будет сразу проброшено в `UIEventLoop` в приложение, что приведет к его падению
* Если асинка была запущена через `spawn` на любом другом диспатчере, то исключение будет просто залогировано `MAPS_LOG_EXCEPTION`
 
### Точка отмены (cancellation point)
Внутри асинки могут находиться точки отмены. Это места, где асинка готова подождать чего-то и соответвенно уступить выполнение другой асинке. Например, это: ожидание результата `async::Future`, лок `async::Mutex`, ожидание на `async::ConditionVariable`, вызов `async::yield`, `async::sleepFor`, итд. Запуск другой асинки не является точкой отмены.
 
Диспатчер может быть коррутиным, а может и нет. В случае коррутинного диспатчера, если выполняющияся на нем асинка А дошла до точки отмены, то ее выполнение может быть прервано другой асинкой В, запущенной из этого же диспатчера. При этом контекст асинки А сохраняется, а ему на замену достается контекст асинки B. Позже, когда условие ожидания будет выполнено, асинка А продолжит выполение на каком-то из потоков тредпула диспатчера, и не обязательно на том, на котором была изначально остановлена.
 
Асинка может быть сохранена и заменена другой только в точках отмены, а не просто по истечению какого-то временного кванта. При этом выполнение асинки также может быть приостановлено на время, если поток на котором она сейчас запущена вытесняется с ядра другим потоком.
 
Если диспатчер некоррутинный, то уже запущенная на нем асинка не может быть заменена на другую посреди выполнения и занимает поток пока не дойдет до конца. Понятие точки отмены не применимо к некоррутинным диспатчерам.
 
### Отмена асинки
Асинку можно отменить. Если отмененяемая асинка только находится в очереди диспатчера и еще не начинала выполняться, то она просто будет удалена из очереди: т.е. отмениться не начавшись. Уже запущенная на коррутином диспатчере отмененяемая асинка дойдет до ближайшей точки отмены или отменится на текущей, если уже на ней ждет. На некоррутинном же уже запущенная асинка дойдет до конца функции.
 
Обычно если асинка отменена на коррутином диспатчере, то в точке отмены, вместо ожидания будет выброшено специальное исключение `forced_unwind`, которое приведет к завершению асинки с размоткой стека. Это вполне штатная ситуация.
 
Отмена другой асинки не является точкой отмены. Отмена асинки, выполняющейся на коррутинном диспатчере, является блокирующейся, но обычно быстрой операцией. Вначале произойдет ожидание, пока отменяемая асинка А дойдет до ближайшей точки отмены. Когда отменяемая асинка А уже находится в ожидании на какой-то точке отмены, то текущий контекст будет заменен на контекст асинки А и будет выброшено `forced_unwind`, которое приведет к завершению асинки А с размоткой стека. Т.е. это все произойдет на потоке, откуда асинку отменяли. После контекст будет возвращен в исходное состояние.
 
Некоррутинные диспатчеры делятся еще на 2 типа: с ожиданием при отмене (`NocoroWait`) и нет (`Nocoro`). Отмена асинки уже начавшейся выполняться на `NocoroWait` диспатчере - это блокирующая операция до конца выполения всей асинки. Отмена асинки уже начавшейся выполняться на `Nocoro` - это, наоборот, полностью асинхронный неблокирующийся процесс. Но соответствующая отмененная асинка все равно доработает до самого конца.
 
Существует специальная семейство точек отмены `noThrowOnCancel`. Если коррутина находится в ней, то при отмене она продолжит выполнение дальше, вместо размотки стека через выброс исключения. Не используйте эту конструкцию без сильной необходимости и если вы не знаете, что делаете.
 
### Диспатчеры
Основные коррутинные диспатчеры:
* `background(BackgroundLow|BackgroundNormal|BackgroundHigh)` - семейство диспатчеров общего назначения с соответвующим приоритетом потоков. Количество потоков сравнимо с количеством ядер на телефоне.
* `global` - алиас на background(BackgroundNormal), самый часто используемый по умолчанию.
* `system` - в тредпуле всего 1 поток с realtime приоритетом.
* `filesystem` - 2 потока, операции работы с файловой системой должны быть запущены на этом диспатчере.
 
Из некоррутинных диспатчереров чаще всего встречается:
* `ui` - некоррутинный, без ожидания отмены. При диспатчинге на него вызывается платформенный метод диспатчинга на UI эвентлуп. Соответственно под капотом 1 поток, который и является UI потоком. 
 
Также существуют дополнительные специфичные диспатчеры, созданные в соответвующих модулях.
 
### Вызов платформенного кода
Вызов платформенного кода на коррутином диспатчере приводит к крешу/UB.
Соответственно, вызывать платформенный код можно на ui диспатчере или других некоррутинных диспатчерах.
 
Для вызова на ui можно использовать [runOnUiThread](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/dispatcher.h?rev=r8413730#L281-303). Это обертка, которая вызывает асинку тут же, если вызов уже на ui потоке, а иначе запускает ее через ui-диспатчер. В последнем случае под капотом происходит ожидание на полученной `async::Future`.
 
{% note warning %}
 
И соответвенно есть ньюанс: пусть асинка А была на коррутином диспатчере, из нее с помощью `runOnUiThread` запустили B. Далее кто-то решил отменить А. Если B еще не успела начать исполняться, то ее выполнение отменится. Если же уже успела, то B продолжит выполняться до конца, а А не будет этого ждать. Т.е. если вы передали из А в B какие-то объекты по ссылке, они могут разрушиться в процессе выполнения B.
 
{% endnote %}
 
Аналогично есть обертка [runPlatform<Normal|Realtime>](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/common/include/yandex/maps/runtime/platform_dispatcher.h?rev=r8413737#L142-160). Если вызов происходит из коррутиного контекста, то асинка будет запущена в специальном однопоточном тредпуле c соответвующим приоритетом, а в месте вызова под капотом будет ожидание на полученной `std::future`. Если вызов происходит уже из запущенной асинки на каком-то из этих тредпулов, из асинки на ui-диспатчере или другом некоррутинном диспатчере, то асинка будет вызвана прямо тут же, игнорируя заданный приоритет.
 
{% note warning %}
 
В отличии от `runOnUiThread` в `runPlatform` внутри используется `std::future`. Поэтому, если отменить асинку А, запустившую B через `runPlatform`, то отмена А зависнет, пока B не отработает до конца.
 
{% endnote %}
### Грабли
{% note warning %}
 
* Не должно быть точек отмены в коде защищенным обычным `std::mutex`
* Не должно быть точек отмены в деструкторе
* Нельзя просто ловить все исключения через `catch(...)` в коррутином контексте. Если очень хочется, то вначале нужно поймать `forced_unwind` и перекинуть дальше.
* Не стоит создавать `local static` переменные не POD-объектов. Так как при завершении приложения на IOS диспатчеры будут удалены уже после вызова деструктора `local static`. А значит будут креши, если будет обращение к `local static` из запущенных асинок. Для не POD объекты используете `runtime::singleton`, который под капотом просто хранит вечный сырой указатель на объект.

{% endnote %}
 
### TODO или что еще посмотреть
* [waitany](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/wait_any.h?rev=r8419414)
* [spawnUiTimerUntil/spawnUiTimerFor](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/dispatcher.h?rev=r8419529#L297-316)

[utils](https://a.yandex-team.ru/arc/trunk/arcadia/maps/mobile/libs/runtime/async/include/yandex/maps/runtime/async/utils?rev=r8419414):
* `Publisher`/`MultiPublisher`
* `Retranslator`
* `Snapshot`
 
### Best practices

## Устройство рейтлимитера матричного роутера

### Какие ручки лимитируются?
Все.

### Чем измеряется бюджет?
Запросы в матричном роутере очень сильно отличаются по тяжести: от пары миллисекунд до десятка минут.
Поэтому в качестве бюджетных единиц используются не штуки (запросы), а процессорное время, т.е. миллисекунды CPU.
Таким образом при обработке запроса мы с клиента снимаем количество бюджета, равное времени обработки запроса.

### Как устроен сам процесс?

1. Мы принимаем запрос
2. Пробуем снять со счёта клиента одну бюджетную единицу (по умолчанию все запросы весят 1)
3. Если не получилось (бюджет израсходован), то отвечаем клиенту 429
4. Если получилось снять единицу, то обрабатываем запрос
5. После обработки запроса смотрим, сколько времени занял запрос и снимаем это количество бюджета

Тут важно два момента:
* В пункте 5 мы снимаем бюджет даже если клиент уже ушёл в минус
* Единственный момент, когда клиент может получить 429 в ответ - это пункт 3.

Из этого всего следует, что если пользователь подал нам тяжёлый запрос - то мы это запрос обработаем, но отлимитируем несколько следующих (предположительно лёгких) запросов.

### Почему не снимать бюджет сразу?
В обычных системах принято на каждый запрос выставлять вес и при поступлении запроса (до начала его обработки роутером) проверять: хватает ли бюджета?
В матричном роутере сложно предсказать время обработки запроса, что приводит к очень нечестному расходу бюджета.
Поэтому бюджет снимается в конце обработки запроса - когда уже точно известно, сколько ресурсов мы потратили на данного клиента.

Плюс: всегда снимем честное количество бюджета (в отличие от ситуации с предсказанием веса запроса)
Минус: клиент может прийти с "лишним" запросом, т.к. бюджет снимается после обработки.

В действительности "минус" не является таковым, т.к. у нас уже есть параметр burst, который предназначен как раз для ситуаций, когда клиент хочет прийти с чуть бОльшим числом запросов, чем обычно.
Поэтому можно считать, что мы просто слегка увеличили значение параметра burst.

### Синхронные запросы
С учётом того, что все запросы исполняются относительно быстро и в однопоточном режиме - достаточно измерить время между началом и концом обработки запроса.

### Асинхронные запросы
Здесь можно было бы тоже считать время между началом и концом, но тогда бюджет будет сниматься лишком неравномерно и, что хуже, непредсказуемо.
Поэтому для каждого воркера запускается свой background-thread, который каждую секунду снимает с клиента 1000 бюджетных единиц (и оставшийся "хвостик" снимается в деструкторе).

### Детали
Для того, чтобы снимать бюджет рейтлимитера - поднимается специальная ручка `/spend_ratelimiter_budget`.
На данный момент - это самый простой способ сообщить рейтлимитеру о том, что мы хотим потратить бюджет какого-то клиента.
Вокруг ручки сделана обвязка в виде двух вспомогательных классов: синхронный и асинхронный гарды.

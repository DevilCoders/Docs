# Что такое project_id и как с ним работать

## Что такое project_id

У каждого проекта в компании есть набор IP-сетей, объединённых в макросы firewall (например, `_SEARCHNETS_`). Каждому проекту нужна своя сеть, чтобы огородиться от других проектов firewall-ом, а макрос - чтобы написать с его помощью разрешающие правила на доступ к проекту (то есть, к IP-сетям проекта). Однако, такой способ изоляции плохо масштабируется - каждую сеть нужно вручную заказывать, аллоцировать и настраивать, а сетевое оборудование, если говорить простым языком, может нести на себе ограниченное число IP-сетей.

> Project_id - это другой способ организации адресного пространства, когда все проекты живут в общей IP-сети, а идентификатор проекта закодирован в младшей (хостовой) части IP-адреса.

Очевидное преимущество этой схемы состоит в масштабируемости:
- позволяет создать практически неограниченное количество проектов
- проекты сразу же начинают работать без настройки на сетевом оборудовании
- проект отвязывается от своей IP-сети и правило firewall, проверяющее поле project_id, работает вне зависимости от текущего набора хостов или ДЦ, где живёт проект.

Есть и недостатки:
- Схема работает только с IPv6. В IPv4-адресе нет места, чтобы записать в нём id проекта
- Так как все хосты в локации являются частью одной и той же IP-сети, они должны сами обеспечивать свою изоляцию от хостов других проектов, развёртывая у себя локальный (Host-Based) firewall. Хорошая новость в том, что для этого есть централизованное и поддерживаемое решение (HBF)

Согласно схеме выделения адресов, под project_id выделяется 32 бита в IPv6-адресе (c 64 по 95). Адрес IPv6 состоит из 4 битовых полей:

```
|  prefix  |  geo-часть | PROJECT_ID | host-часть |
|  40 бит  |  24 бита   | 32 бита    | 32 бита    |
```

где:
- prefix - это константа, которая указывает на то, что в IP-адресе есть поле PROJECT_ID
- geo - поле, где записан идентификатор сети (маршрутизаторы находят путь к этой сети по значению `prefix + geo`)
- host-часть - идентификатор хоста внутри пары `сеть + project_id`

Актуальные значения поля prefix можно посмотреть [тут](https://racktables.yandex.net/index.php?andor=and&cft%5B%5D=1242&cfe=&page=ipv6space&tab=default)

Список Project_id можно посмотреть по [ссылке](https://racktables.yandex-team.ru/index.php?page=services&tab=projects)

### Свойства Project ID

#### project_id как замена номеров сетей

- Считаем, что project_id это какая-то отдельная сущность, явно не привязанная ни к каким проектам или сервисам
- Существующие проекты переводим на Project ID по схеме один VRF - один project_id
  - в рамках одного project_id разрешаем любое общение
  - переход получается простым и не требует серьёзных изменений от управляющих систем
- Нельзя просто дать доступ к отдельным сущностям внутри project_id
  - Можно добавить ограничение по портам, но нет никаких гарантий, что другие сущности не будут использовать тот же порт
  - Так же как и в текущей схеме с фаерволом между VRF'ами

#### project_id как идентификатор сущностей в ABC

- присваиваем project_id листьям в дереве ABC
- можно заказывать доступы в формате от одной вершины в ABC к другой
  - в случае доступов к/от поддеревьям доступы можно раскрывать в список доступов между листьями
  - при этом есть риск при доступах к большим поддеревьям получить очень много правил
  - можно попытаться оптимизировать количество правил в случае доступа к/от поддеревьям если зашифровать номера поддеревьев в старших битах и использовать при генерации правил маски на них
    - наложит ограничение на количество сервисов в поддеревьях и их колличество
    - поменять это ограничение будет почти нереально, так это потребует смены ip адресов инстансов
    - перенос сервиса в другое поддерево потребует либо смены project_id либо приведёт к росту количества правил доступа к/от поддереву
  - можно выдавать project_id для поддеревьев блоками, чтобы получалась маска
    - это позволит и оптимизировать количество правил и избежать ограничения на размер поддеревьев
  - возможны случаи, когда доступ нужно будет делать к части сервиса ABC
    - тогда либо прийдётся делать дополнительные project_id для подсервисов
    - либо возвращаться к разделению подпроектов по портам
- при миграции на эту схему потребуется прописать дырки между всеми сервисами, сейчас живущими в одном VRF
  - либо allow все ко всем
  - либо как-то собрать реальную схему доступов
    - в масштабов больших VRF вроде поискового это становится очень непростой задачей
  - задача усложняется тем, что
    - один проект abc может принадлежать нескольким VRF
    - один VRF может принадлежать нескольким проектам abc
  - что не позволит применить оптимизацию с доступом по маскам на диапазоны project_id
- требует прокидывания project_id через все управляторы
  - что довольно дорого и пока не понятно нужно ли кому-либо

#### project_id как идентификатор сервисов на дереве, параллельном ABC

- аналогично варианту с project_id == сервис ABC, только со своим деревом
- дерево можно строить на уже существующей структуре VRF'ов и сервисов с точки зрения системного администрирования
- своё дерево позволяет активно использовать механизм масок project_id при создании доступов вида много к чему-то
- можно сделать привязку вершин дерева project_id к проектам ABC
  - если будет понятно зачем

### Как сейчас

**Openstack**
- projectID это атрибут сети (network), в которую втыкается виртуальная машина.
- на одном ip адресе живёт одна виртуалка
- в одной виртуалке может быть запущено много сервисов на разных портах
- в одной виртуалке может быть несколько ip в одной и той-же сети
- одна и таже виртуалка может быть подключена в несколько сетей (несколькими виртуальными интерфейсами), например BB,FB.

**Qloud**
- projectID это атрибут сети (network), в которую втыкается виртуальная машина.
- на одном IP адресе живёт один сервис в порто контейнере

### Фаервольная запись сетевого префикса с project_id и работа с ним

В `macros-inc.m4` принята следующая форма для записи сетевого префикса для конкретного project_id:

```[project_id]@[CIDR]```

Например, `4130@2a02:6b8:c00::/40`.

Для проверки какого-то адреса на вхождение в эту сеть нужно:
1. в биты 64-95 сетевого префикса записать project_id (в нашем примере - `2a02:6b8:c00:0:[0:4130]::` - тут и далее выделение [] - моё, исключительно для удобства чтения)
2. в битовой маске CIDR'а (в нашем примере - `/40`, `ffff:ffff:ff00::`) выставить в `1` биты 64-95 (`ffff:ffff:ff00:0:[ffff:ffff]::`)
3. На исследуемый адрес наложить получившуюся дырявую маску и результат сравнивнить с эталоном.

В динамическом фаерволе запись ```[project_id]@[CIDR]``` мутируется \[ при помощи опкодов `(src|dst)prjid` \] в вид ```c:c:[project_id]::/64``` для возможности сохранения project_id в таблицы без поддержки wildcard-масок.

## Введение

Все фаерволы под управлением NOC (т.е., не серверы с HBF) иногда нуждаются в ручной настройке. 
Раньше каждое запрошенное правило вносилось в конфиг руками по запросу из e-mail рассылки firewall@, 
потом в RT появился интерфейс для редактирования правил самостоятельно, потом эта функциональность переехала в Панчер.

Но самостоятельно через Панчер можно отредактировать только типовые правила, а если нужно что-то менее казуальное, то 
нужно коммитить в шаблоны конфига фаервола в CVS.

## Работа с CVS

Шаблоны фаервола хранятся в CVS в нескольких местах:
- макросы - в `noc/routers/fw/macros-inc.m4`
- все BSD-фаерволы - в `noc/routers/fw/`
- L3-SLB - в `noc/balancers/iptables/`

Склонировать к себе CVS-рабочую копию можно так:
```bash
export CVSROOT=tree.yandex.ru:/opt/CVSROOT
cvs co -d DEST_DIR noc/routers/fw
```

После внесения необходимых изменений в файлы конфигурации, нужно согласовать изменения. Сохраняем diff для ревью:
```bash
cd DEST_DIR
cvs diff -u > changes.diff
```

Затем оформляем заявку в очереди NOCRFCS по ссылке: https://forms.yandex-team.ru/surveys/21525/

В поле *описание изменения* вставляем содержимое файла `changes.diff`, обрамленное `<{diff \n %%(diff) \n` и `%% \n }>`.
Дожидаемся подтверждения от робота или руководителя (робот имени korxif@ следит за тикетами в очереди NOCRFCS и решает, подтвердить заявку автоматически или призвать живых людей). После подтверждения робот сам созаст событие в infra, URL на который напишет в комментарии к тикету. Этот URL нужно будет упомянуть в CVS commit message, без этого receive hook на стороне CVS не примет коммит. Наличие URL является залогом того, что соблюдена процедура выкладки через NOCRFCS. В экстренной ситуации можно вставить что-то типа `https://infra.yandex-team.ru/event/0`.

После этого коммитим подготовленные изменения в CVS:
```bash
cvs commit
> my commit message.
> https://infra.yandex-team.ru/event/12345
```

## Применение изменений (рестарт)

Закоммиченные в CVS изменения не применятся во всех нужных местах автоматически: хоть в RT и есть очередь на рестарт фаерволов (т.е., на применение свежего репозитория), которая заполняется автоматически на основании анализа diff между ревизиями CVS, но определять по diff, что какой-то фаервол требует рестарта, эта система может только для типовых дырок из Панчера. В случае ручных изменений как правило требуется самому озаботиться их применением. И тут есть несколько способов:
- если список затронутых фаерволов вам известен и он невелик, можно добавить их в очередь рестарта руками:
    - либо через GUI RT: кнопка *дернуть фаервол* на вкладке *Firewall* у соответствующего объекта RT
    - либо через CLI: `fw-restart.php HOSTNAME ...` на master-сервере RT (скрипт уже в `PATH`)
- также через CLI можно поставить все фаерволы в нужной локации по фильтру: `fw-restart.php --text='[работает большой фаервол] and ({Ивантеевка} or {Мытищи})`
- либо же вообще все доступные фаерволы в случае больших глобальных изменений: `fw-restart.php --all`
- если известен макрос, хостнейм или сеть, для которой надо обновить фаервол, то можно вызвать `vlans.php --restart {_MACRO_NAME_,HOST.NAME,IP} ...`, и RT сам найдёт те фаерволы, которые форвардят трафик на эти сети и поставит их на рестарт. Работает также с L3 VS.
- можно делать рестарт не через очередь в RT (т.к. она разбирается в полокационном режиме и ждать можно до 3 часов), а непосредственно на машине, вызывая `sudo -E sh -c 'make update; make restart'` в CVS-копии, которая находится в `/usr/local/routers/fw/` или в `/usr/local/balancers/iptables/`. Такие рестарты самые низкоуровневые и проходят мимо всякой защитной автоматики.
- Наконец, если изменение не нужно срочно катить, можно вообще ничего не делать и когда-нибудь оно везде разъедется само, ведь фаерволы регулярно ставятся на рестарт по другим причинам. В таком случае, правда, нельзя точно сказать, когда всё разъедется. Если нужно сегодня, то лучше поставить явно.

## Назначение файлов и структура папок
- `noc/routers/`
    - `racktables.m4` - содержит слепок некоторых данных из RT в виде M4-define. Эти данные по сути не используются в каких-либо фаервольных конфигах, кроме офисных/VPN/региональных, но по несчастливому стечению обстоятельств файл include-ится отовсюду, заставляя его подвозить, хотя он лежит в папке на уровне выше. `make update` умеет его обновлять.
    - `fw/` - репозиторий с BSD-фаерволом
        - `macros-inc.m4` - база данных макросов фаервола. Оформлена в виде набора M4-define. Правится как руками, так и роботами.
        - `Makefile` - точка входа для скриптов рестарта. Таргеты - `update`, `restart`
        - `router-fw.m4` - "скелет" конфига фаервола. Главный файл, где написаны корневые правила фаервола, с которых начинается обработка пакета. Применим для `core routers` (фаерволы в ДЦ), `TUN64 gateway`, `NAT64 gateway` (старых, на FreeBSD), `RCONCENTRATOR`, `BORDER`, `REFLECTOR`, `DECAP` (старых, на FreeBSD).
        - `rproxy-fw.m4` - корневой файл для машин типа `RPROXY` (что-то про CDN)
        - `regoffice-fw.m4` - корневой файл для роутеров в офисах
        - `vpn-concentrator-fw.m4` - корневой файл для VPN-серверов
        - `puncher_sections/` - сюда Панчер экспортирует дырки из своей БД
        - `sections/` - старое место для проектных правил. Сами правила перемещены в Puncher, а файлы в этой папке остались связующим звеном между `router-fw.m4` и `puncher_sections/`. Иногда здесь можно найти и важные дырки, которые по каким-то причинам не переехали в Панчер. Но в основном все файлы состоят из одного include на `puncher_sections/`. HBF-сервер напрямую смотрит в эту папку для поиска дырок, и до puncher_sections доходит уже через include.
        - `global-inc.inc` - содержит важные служебные define на M4 (не с сетями, а с какой-то логикой), используемые повсюду в фаерволе. Библиотека функций.
        - `router.dnscache.full` - автоматически наполняемый DNS-кеш всех записей, используемых в фаерволе. STALE-записи, которые больше не резолвятся, но используются, сохраняют свои последние IP здесь.
- `noc/balancers/iptables/`
    - `load-iptables.m4` - root-файл (точка входа, шаблон) балансерного фаервола. Сейчас уже legacy, все хосты, которые не входят в список исключений в файле `no-yaml-hosts`, уже используют другой файл - `load-iptables-2.m4`.
    - `load-iptables-2.m4` - новый конфиг фаервола, на который завершается плавный переезд со старого. В отличие от огромного старого, он не хранит список всех VS, и соответственно, не правится роботами. VS и ручные правила к ним хранятся в отдельных файлах `services.yaml` и `rules.inc`. Также по сравнению со старым, базовые правила упрощены и шире используется ipset.
    - `sections/` - папка, куда Панчер складывает свои файлы с правилами
    - `expand-resolve.pl` - центровой скрипт, который транслирует правила в синтаксисе, похожем на ipfw (`{ _MACRO1_ or _MACRO2_}`) в iptables-синтаксис. Используется при `make install`.
    - `Makefile` - точка входа для рестарта. Таргеты - `update`, `install`, `restart`. В отличие от BSD, здесь вся работа происходит в `install`, а `restart` только лишь запускает уже установленный startup-shell-скрипт. А в BSD-фаерволе вообще нет таргета `install`, там оно всё в `restart`.
    - `services.yaml` - список VS-сервисов и их фаервольных опций. По большей части правится роботом l3 manager, но некоторые сервисы и опции не находятся под его управлением и их меняют люди. Робот обучен не перетирать изменения людей.
    - `rules.inc` - важные статические правила до сервисов, которые не приезжают из Панчера, а захардкожены тут. Правится только людьми. В основном там `allow from any` на внешние сервисы.


## Типичные задачи

### Добавить новую L2-сеть и новый vlan
Default router-ом для L2-сетей в основном выступают сами BSD-файрволы. Правила шардированы по файлам секций, а ключом для быстрого поиска нужной секции при обработке пакета является имя интерфейса, через который пакет заходит/выходит. Поэтому когда добавляется новый проект, нужно сделать следующее:

- Создать макрос для сетей проекта, если ещё нет
- Создать файл секции и написать туда некоторые служебные правила (обработку ICMP, fragments, tcp established, etc.)
- Добавить прыжок (skipto) в этот файл из главного конфига `router-fw.m4` по имени интерфейса (т.е., номеру vlan, например, `vlan542`).

Рассмотрим эти шаги на примере реального коммита, проделывающего типичную операцию по настройке новой сети:
- https://tree.yandex.ru/cgi-bin/cvsweb.cgi/noc/routers/fw/sections/CIPTLAVKAMONNETS?rev=1.1&content-type=text/x-cvsweb-markup&f=h
- https://tree.yandex.ru/cgi-bin/cvsweb.cgi/noc/routers/fw/router-fw.m4.diff?r1=1.20457&r2=1.20458&f=h

Макрос (`_CIPTLAVKAMONNETS_`) был создан через RT и ручных коммитов для этого не потребовалось. Делается это так:

#### Создание макроса
На странице https://racktables.yandex-team.ru/index.php?page=services&tab=projects щелкаем на ссылку "Новый проект" и вводим имя макроса, ответственных за него. Родительский оставляем пустым (это тот макрос, в который будет добавлен вновь созданный), галку "Выделить сеть (project id)" снимаем, т.к. project-id не нужен, там будет обычная L2-сеть (CIDR). В результате в БД RT появляется пустой макрос, который мы затем можем наполнить CIDR-сетями опять же в RT.

#### Наполнение макроса
Чтобы наполнить макрос сетями, заходим на страницу каждой такой сети и на вкладке *Properties* в поле *Firewall macro* выбираем из списка вновь
созданный макрос. Через минуту изменения автоматически появляются в macros-inc: https://tree.yandex.ru/cgi-bin/cvsweb.cgi/noc/routers/fw/macros-inc.m4.diff?r1=1.62665&r2=1.62669&f=h (в данном случае они доезжали несколькими коммитами, т.к. человек небыстро тыкал мышкой в каждую из сетей).

#### Файл секции
С файлом `noc/routers/fw/sections/CIPTLAVKAMONNETS` сложнее. Вообще-то он тоже может создаваться автоматически, и RT рапортует об успешном создании секции на этапе создания макроса. Но мы видим, что эта секция создана коммитом человека (alan@), а не робота (racktables@), потому что действует отложенное создание секций при появлении первой дырки в Панчере. Когда `pack-fw.sh` видит, что появился файл `puncher_sections/SECTION_NAME`, а файла `sections/SECTION_NAME` нет, он создаёт его с шаблонным текстом (include и footer). В данном случае файл секции (для прыжка в него из `router-fw.m4`) нам понадобился раньше, чем появилась первая дырка в Панчере, поэтому файл секции нужно было закоммитить в cvs руками. Вот его содержимое:
```bash
# Внимание! Это пилотная секция, переехавшая в Панчер
# Ниже нет никаких работающих правил - это всё некорректные или служебные правила,
# которые нельзя было импортировать в Панчер. Они не работают и ждут, пока их кто-нибудь
# вычистит. Все правила ищите в Панчере (puncher.yandex-team.ru)
```

Это уже не полностью актуальный комментарий, который, однако, копируют из секции в секцию.
```bash
add count ip from any to any
```

Правило не является необходимым, просто подсчитывает количество пакетов, зашедших в секцию. Обычно такие правила начинают секцию.

```bash
add skipto :CURRENT_SECTION`_IN' ip from any to any in
```

Это правило разделяет пакеты по направлению. in-пакеты идут в ``CURRENT_SECTION`_IN'``, а out-пакеты проваливаются дальше.
<[ BTW, в данном примере это правило не обязательно было писать, но перестраховались почему-то. Если в router-fw используется `SKIPTO_PROJECT_INOUT`, а не `SKIP_TO_PROJECT`, пакеты автоматически разделяются на in/out и без этого праивила.  ]> Дело в том, что в ipfw, в отличие от iptables, пакет, который forward-ится через коробку, проходит файрвол дважды - один раз в направлении in, другой - в out. Наши проектные правила работают только на первый пакет в tcp-сессии, и по конвенции они применяются в out-проходе через ближайший файрвол к точке назначения, то есть, перед отправкой (out) на интерфейс `vlan692`. Именно поэтому include правил из Панчера происходит ниже только в out-секции:

```bash
sinclude(`puncher_sections/CIPTLAVKAMONNETS')
```

Ниже идёт типичный out-footer:
```bash
STD_SECTION_FOOTER_OUT({ _CIPTLAVKAMONNETS_ })
add deny log logamount LOGLIMIT all from any to any out
```

Под макросом `STD_SECTION_FOOTER_OUT()` скрываются все служебные правила, которые должны применяться к кажой секции (ICMP, DHCP, IP fragments, etc.). Затем идёт безусловный deny, чтобы out-пакеты не проникли в in-секцию, которая начинается ниже:
```bash
`:'CURRENT_SECTION`_IN'
STD_IN_SECTION({ _CIPTLAVKAMONNETS_ })dnl
```

Здесь задаётся метка для skipto в in-секцию, используя автоматически определяемый макрос `CURRENT_SECTION`, к нему сзади конкатенируются символы `_IN`. Для IN-секций никаких отдельных правил, кроме шаблонных, определенных в `STD_IN_SECTION()`, не требуется.

`STD_SECTION_FOOTER_OUT` и `STD_IN_SECTION` определены в файле `global-inc.m4`.

#### Прыжок в секцию
Наконец, когда макрос и секция готовы, можно настроить прыжок пакета в секцию при совпадении имени интерфейса. Пример такой настройки - в diff https://tree.yandex.ru/cgi-bin/cvsweb.cgi/noc/routers/fw/router-fw.m4.diff?r1=1.20457&r2=1.20458&f=h

В файле `router-fw.m4` есть большой блок идущих подряд вызовов `SKIPTO_PROJECT_INOUT()` и `SKIPTO_TO_PROJECT()`. У этих макросов следующие аргументы:
- `iface_name`
- `label_to_jump`
- `flags` (необязательный)

Как видим, была удалена строчка
```bash
SKIPTO_PROJECT_INOUT(`vlan692',`:PASSPORTCORPNETS')
```
, т.к. она явно неактуальна и осталась с тех времен, когда наш vlan 692 занимал `PASSPORTCORPNETS`. Теперь это `CIPTLAVKAMONNETS`, поэтому добавлена эта строчка:
```bash
SKIPTO_PROJECT_INOUT(`vlan692',`:CIPTLAVKAMONNETS', NO_HBF)
```

Если значение поля flags - `NO_HBF` или `WEIRD`, то skipto работает как ожидается и прыгает по указанному `label_to_jump`. А вот если нет, то применяется performance hack по умолчанию, и независимо от того, какой стоит `label_to_jump`, прыжок осуществляется на общую для всех метку `:HBF`. Это значит, что для обычных vlan (про которые нет причин сомневаться в наличии у них hbf-агента) обычные их правила не применяются, а применяется общее огромное правило из `:HBF`, разрешающее всё внутри `_YANDEXNETS_`, и реально фильтруются только входящие соединения из Интернета до таких хостов. Это помогает разгрузить BSD-файрвол и сделать его более статичным, поэтому надо стараться помещать все новые проекты в уже существующие vlan (например, 333) и требовать, где это возможно, наличие hbf-агента, что позволяет запускать их вообще не перенастраивая BSD-файрвол.

В данном случае было заранее известно, что hbf-агент на хосты в `CIPTLAVKAMONNETS` поставить нельзя, поэтому им потребовались отдельные сети, отдельный vlan, секция и прыжок туда с флагом `NO_HBF`.

Если флага нет и пыжок фактически осуществляется в `:HBF`, то секцию и `EXTERNAL_SECTION()`, как в примере ниже, вообще не нужно прописывать в `router-fw.m4`, она не будет использоваться. Как можно видеть, сейчас все секции, у которых в SKIPTO нет флага `NO_HBF`, закомментированы. Однако, файл в `sections/` всё равно должен быть, иначе hbf не увидит правила. Если на него нет `EXTERNAL_SECTION()`, его можно и не создавать - он появится автоматически когда в Панчере появится первое правило в этой секции.

Кстати, макросы `SKIPTO_PROJECT_INOUT` и `SKIPTO_TO_PROJECT` отличаются друг от друга тем, что в первый уже встроена логика, что in-пакеты попадают не в `:label_to_jump`, а в `:{label_to_jump}_IN`, что помогает сэкономить несолько тактов процессора и не писать отдельные правила для сортировки пакетов на in/out.

Осталось только разобраться, откуда в конфиге файрвола возьмутся метки `:CIPTLAVKAMONNETS` и `:CIPTLAVKAMONNETS_IN`. Смотрим патч ниже и видим такую секцию:
```bash
# VLAN692 CIPTLAVKAMONNETS, FWREQ-4404
#-------------------------------------------------------------------------------
:CIPTLAVKAMONNETS
EXTERNAL_SECTION(`CIPTLAVKAMONNETS')dnl
add deny log logamount LOGLIMIT all from any to any
```

Здесь используется макрос `EXTERNAL_SECTION()`, который просто выставляет `CURRENT_SECTION = "CIPTLAVKAMONNETS"` и делает include файла `sections/CIPTLAVKAMONNETS`, где уже есть в свою очередь include из `puncher_sections/` и метка `:{CURRENT_SECTION}_IN`.

### Создать или изменить ручной макрос

Если макрос нельзя представить набором выделенных сугубо для него project-id, CIDR и дочерних макросов, что позволяет сделать RT в интерфейсе https://racktables.yandex-team.ru/index.php?page=services&tab=projects, то нужно руками писать определение макроса в файл `noc/routers/fw/macros-inc.m4`. Пример такой операции:
https://tree.yandex.ru/cgi-bin/cvsweb.cgi/noc/routers/fw/macros-inc.m4.diff?r1=1.62991&r2=1.62992&f=h

Обычная конвенция такая - каждый элемент макроса пишется на новой строке, разделяются они через `or`, LF экранируется через `dnl` в конце каждой строки. Порядок определения макросов не важен - можно ссылаться на ещё не определенный макрос, если вы оборачиваете значение макроса (второй аргумент `define`) в кавычки. Это значит, что определение будет простой строкой и раскрытие вложенных макросов произойдет потом, в момент раскрытия основного.

Проверить синтаксическую корректность полученного определения можно командой:
```bash
echo _VERTISPROD_ | m4 -DTRYPO_SUPPORT -DTRYPO_RANGE_SUPPORT macros-inc.m4 -
```

Вывод этой команды не должен содержать имена нераскрытых макросов и не должно быть LF (то есть, должен весь находиться на одной строке), иначе при раскрытии макроса в правилах будет синтаксическая ошибка, ведь лексическим разделителем для правил служит новая строка. Параметры `-DTRYPO_SUPPORT -DTRYPO_RANGE_SUPPORT` нужны, чтобы project-id, которые могут встречаться в макросах, использовали наш кастомный синтаксис типа `604@2a02:6b8:c00::/40`. По умолчанию без них всё работает в режиме совместимости и разворачивается просто в `2a02:6b8:c00::/40`.

Ещё надо уделить внимание месту, куда поместить определение макроса. В файле `macros-inc.m4` есть кусочки, которые коммитит робот. Они обрамлены конструкциями `BEGIN_AUTO_SECTION()` и `END_AUTO_SECTION()`. Внутри таких блоков ничего руками писать нельзя - робот это тут же перетрёт.

### Экстренный (ручной) рестарт фаерволов
```bash
# Цитата из моего zshrc (alan)
getrl () {
        vlans $@ | awk '{print $4}'|sort -u|cut -f 1 -d .|grep -v Router|xargs echo
}
fwcmd () {
        command="$1";
        shift;
        case $command in
                verify)
                        ipfw_command="verify";
                        iptables_command="load-iptables.sh";
                ;;
                restart)
                        ipfw_command="restart";
                        iptables_command="install restart"
                ;;
                flushrestart)
                        ipfw_command="restart";
                        iptables_command="flushrestart"
                ;;
                *)
                        echo "Unknown command"; false;
                ;;
        esac
        for item in $@; do
                echo "Restarting ipfw/iptables @ $item";
                ssh -t -A $item "case \$(uname -s) in
                        FreeBSD)
                                echo 'FreeBSD(ipfw) detected';
                                sudo -E make -C /usr/local/router/fw update && \
                                sudo -E make -C /usr/local/router/fw update && \
                                sudo -E make -C /usr/local/router/fw ${ipfw_command};
                        ;;
                        Linux)
                                echo 'Linux(iptables) detected';
                                export LC_ALL=C;
                                sudo -E make -C /usr/local/balancers/iptables update && \
                                sudo -E make -C /usr/local/balancers/iptables update && \
                                sudo -E make -C /usr/local/balancers/iptables ${iptables_command}
                        ;;
                        *)
                                echo 'Unknown OS type!'; false;
                        ;;
                esac;
                " || read
        done
}
alias rrfw='fwcmd restart $@'
alias vlans='vlans.php'
```

Т.о. рестарт нужных для работы `search-temp.edadeal.io` выглядит вот так:
```bash
rrfw `getrl search-temp.edadeal.io`
```
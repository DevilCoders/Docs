## Пояснения к реализации
### Как определена сущность Model?
В эру одночиповых коробок, почти всегда подбор софта зависит от модели устройства и желаемого конфига.
К сожалению, понимания абстракции модели у вендоров - разное. 

**RT HW-Type**: 
Значения, взятые из бота конвертируются и обобщаются. Чаще всего добыть эту информацию при общении с устройством - нельзя.

**Inventory.json**
Карты и шасси перепутаны

**Наливка ruby**
Очень близко к желаемому. Нигде не храним, лишние обобщения.

**RT HW Model** - наш выбор
Новый атрибут в RT
Если ПО может быть установлено на устройство с неким HW Model, то это ПО может быть установлено на все устройства с таким же HW Model. Значение данного атрибута может измениться из-за набора установленных в устройств компонентов(модулей)
https://racktables.yandex-team.ru/index.php?page=chapter&chapter_no=10017


### Почему такой состав Matchers?
* Теги и выражения из тегов, без альтернатив, усложняют юзкейсы.  
* Выражения скатываются до предикатов, с известными проблемами
* Regexp позволяет захватить новые ревизии похожего оборудования
* Были варианты с троичной логикой, когда отдаётся несколько ПО, а не только FirstMatch
* Вероятно, появятся новые атрибуты матчинга, например модули устройств.
* Более явное разделение между "типом оборудования, поддерживающего ПО" и "ролью устройства, требующего определённого ПО"

### Почему необходимо генерировать код из yaml?
* Проще заполнять yaml-файлы вместо go-структур​(не требует знания языка)
* Чтение файлов и проверки унесены из старта сервера на этап сборки

### Почему структура Soft и признаватор опираются на список файлов, а не базовую версию пакета ПО
* Не ясно как контролировать наличие исправлений, если требуется больше одного патча
* У файла может быть больше атрибутов для опознания, например размер и контрольная сумма
* При сравнении версии придётся создавать две стадии матчеров(стандартные и версия+модель). Данный подход себя не оправдал, даже на малой выборке - это решение сложно эксплуатировать
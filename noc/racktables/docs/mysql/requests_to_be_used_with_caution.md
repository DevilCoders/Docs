# Использование "абсолютных" имён таблиц в MySQL
Зачастую считается, что
```
use [db_name];
insert/update/alter ... [table_name] ...
```
можно заменить на
```
insert/update/alter ... [db_name].[table_name] ...
```
Однако, в некоторых случаях при работе с MySQL это не верно. Для полного погружения в тему стоит ознакомится с [этим багом](https://bugs.mysql.com/bug.php?id=93393), его резолюцией и документацией MySQL по приведённым ссылкам.

Если опустить подробности, то данные конструкции могут быть по разному обработаны в случае репликации с включенными фильтрами по конкретным БД. В частности, запросы вида ```[db_name].[table_name]``` могут быть отфильтрованы опциями binlog-do-db и replicate-do-db несмотря на попадение `[db_name]` в разрешающие фильтры, что приведёт к не выполнению запросов на репликах и повлечёт потерю консистентности между мастером и репликой. При этом GTID_EXECUTED_SET между мастером и репликами будет совпадать.

TODO: привести несколько примеров

Для RT принято решение отказаться от использования фильтров с реппликациями - NOCDEV-6369. Однако, при разработке стоит учитывать эти нюансы, чтобы в случае необходимости включения фильтров не возникло проблем с консистентностью.

# Рекомендации по составлению SQL-запросов при работе с MySQL
Независимо от существующих настроек репликации при составлении SQL-запросов для MySQL стоит придерживаться следующих правил:
* Всегда выбирать текущую активную БД
* Избегать запросов производящих модификацию структуры или содержимого таблиц при помощи конструкций [db_name].[table_name]
* При необходимости внесения изменений в таблицу находящейся в неактивной БД - переключиться на БД содержащую таблицу, выполнить запрос, переключиться в исходную БД
* По возможности произвести проверку корректной репликации запросов на тестовом MySQL-кластере - %nocdev-test-mysql

# Процедура выполнения ALTER TABLE на БД RT
Для минимизации рисков при модификации структуры БД RT стоит придерживаться следующей процедуры:
1. Набор запросов на модификацию обязательно должен начинаться с выбора базы
2. Проверить соответствие глобальных переменных MySQL-сервера тестового кластера с продуктовым 
3. Проверить реплицируемость планируемых модификаций на тестовом кластере
4. По возможности произвести нагрузочное тестирование типовыми операциями над изменёнными таблицами


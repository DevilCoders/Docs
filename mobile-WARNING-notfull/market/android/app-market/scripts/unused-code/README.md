# Скрипт для генерации отчёта о неиспользуемых коде в проекте

## Как использовать?

1. Собрать проект версии baseRelease или qaRelease (где есть `minifyEnabled = true`) с помощью
   Android Studio или при помощи команды (`./gradlew assembleBaseRelease` или `./gradlew assembleQaRelease`.
   В результате буду сгенерированы файлы usage.txt (в нас пока называется unused.txt) и mapping.txt.
2. Запустить из корневой папки проекта команду `./unused-code.sh`.

После успешного завершения работы в корневой папке проекта будет сгенерирован файл `unused.xml`.
Его следует открыть в программе **Android Studio** при помощи опции **Analyze / View Offline Inspection Results**

## Зачем нужен?

Отдельная проверка в Android Studio отрабатывает крайне долго,
при этом не умеет адеватно работать с кодогенерацией (всё считает неиспользуемым).
Хочется находить и удалять неиспользуемым код делать это быстрее и точнее,
при этом иметь похожий на обычные проверки интерфейс.

## Как работает?

Идею честно взял из статей с Medium)

Proguard во время своей работы проводит различного рода оптимизации,
удаляя из финальный сборки мертвый (или неиспользуемый код). При этом он же проводит обфускацию,
то есть заменяет адекватные названия в коде на случайные символы, и сохраняет информацию об этом в файле **mapping**
Суммарно информацию о всём коде, с которым так или иначе работал Proguard, можно найти в файле **usage**.
Таким образом, сопоставил информацию из ранее перечисленных источников, можно узнать, с каким кодом он работал, но не
обфусцировал, иначе говоря, ~~удалил~~ прооптимизировал, что нам и нужно)

## Что умеет делать?

Генерирует отчёт в xml-формате о неиспользуемом коде в проекте.

### На данный момент умеет следующее:
- Искать неиспользуемый код на Java c непосредственнйо ссылкой на него
- Искать неспользуемый код на Kotlin с явным указанием на файл и дополнительным комментарием о том, что в нём не так
- Умеет искать как по написанному нами коду, так и по сгенерированному, позволяет выпиливать код с аннотациями, не опасаясь возможных проблем
- По возможности не включает в отчёт код, который генерирует сам Kotlin при переходе в Java (например, методы `copy`, `component` и т.д.). Если вдруг какие-то методы прорастают, пишите, поправим :)

### Что хотелось бы улучшить:
- Из-за того, что Proguard работает не с кодом на Kotlin, а с его Java-версией, нельзя точно узнать язык исходного файла, поэтому приходится генерировать на каждый элемент две версии (для Java и Kotlin)
- Текущий формат проверок для Kotlin не позволяет вести напрямую к неиспользуемому коду, а только к файлу с ним (та же проблема и в обычных проверках, запускаемых через Android Studio)

Приходить с вопросами или предложениями можно в [Telegram](https://telegram.me/yuranous)

Описание системы тарифов
========================

Система тарифов архитектурно разделена на 2 части
  * уровень хранения информации и тарифах и зонах
  * уровень для клиентского представления
  
За первую часть отвечают коллекции `tariffs` и `geoareas`,
вторая покрывается данными из коллекции `tariff_settings`.

Tariffs
-------
Каждый документ из коллекции `tariffs` имеет 3 основных
характеристики: время действия, домашняя зона и описание
подтарифов (категорий).

Поэтому для того, чтобы достать нужный для расчета документ,
нужно как минимум две вещи: точка А и время.

```(python)
# taxi/internal/dbh/tariffs.py

class Doc(...):

    @staticmethod
    @async.inline_callbacks
    def find_active(home_zone_name, due=None):
```

Так же к тарифу привязан список зон (related_zones), 
которые нужны (на которые будут ссылки) при использовании
этого тарифа.

При этом тариф покрывает все возможные варианты: и класс,
и время, все это внутри него. Для генерации описания тарифа
на сайте используется именно tariffs, так как он описывает
все потенциально возможные для пользователя способы.

Каждый конкретный вариант (Эконом-Утро, например) описывается
категорией. Тариф содержит в себе целый список категорий.

TariffCategory
--------------
Идея такая — это максимально простой объект чтобы описать
любой тариф, который может быть в системе (то есть максимально
редуцированный tariffs31).

TariffCategory приводится к tariffs31 (нужен для калькулятора
и еще в ряде случаев) очень просто.

```(python)
# taxi/internal/tariffs_manager.py

def to_tariffs_31(category):
```

Из основных вещей, которые есть внутри категории:
  * настройки постоянно включенных счетчиков;
  * настройки счетчиков, активирующихся при езде по зоне Х;
  * настройки трансферов;
  * настройки платного ожидания и доп. услуг.
  
Счетчик описывается как набор интервалов, например "С 3-й по 10-ю минуту
стоимость 2 рубля в минуту, далее по 1.5". Интервалы могут быть как по
времени, так и по расстоянию.

В Таксометр при синхронизации передается именно документ категории,
для того чтобы снять с аппарата ответственность за выбор правильной
категории из тарифа.

Категории тоже имеют ограничения по времени работы. Но если для
тарифа это даты (с 1 января 2016), то у категорий можно выставлять
ограничения только на время (с 8:00 до 15:00) и по булеву флагу
выходной/будний. Для того, чтобы получить тариф и список категорий,
которые актуальны (отсеять ночной тариф и тарифы выходного дня)
есть метод

```
# Этот метод активно использует кэширование.
@async.inline_callbacks
def tariffs_with_available_categories_only(home_zone, due, city_doc):
```

Информация для клиентов
-----------------------
Для того, чтобы не усложнять формат тарифа, информацию,
нужную клиентам мы храним в отдельной коллекции.

**Давать ответы на вопрос про категорию** (сколько минут включено,
какая цена посадки, диапозон цен отсюда) используйте
`taxi.internal.tariffs_manager.CategoryInfo`.

**Какие тарифы доступны в городе** (вместе с их сугубо клиентскими
настройками, например, `is_default`, `service_level`, локализованное
название и многое другое) используйте
`taxi.internal.renderers.client_tariff_description.CategorySettingsView`.

**Показать полные настройки тарифа** (как на сайте)
`taxi.internal.renderers.full_tariff_description`.

Планы на будущее
================
**Гибкость**, которую нам дало разделение тарифам по зонам,
пока **не испльзуется клиентами**. Нужно постараться прийти
к этому по-скорее, при этом по возможности не разломав
старых клиентов. Я думаю, что для них нужно будет сделать
какой-то mapping меджу `city -> nearest_zone`.

Отдельный вопрос про **лицензии** и tlbr. Пока его можно решить
привязывая все парки к нужному city, а там уж вся логика
проверки лицензий сохранится. Но в будущем это не прокатит:
что если какая-то машина имеет лицензии для работы и в Москве,
и в Санкт-Петербурге. По идее надо привязывать лицензии к
геообластям и все это как-то хранить.

**Классификатор** нужно уметь ослаблять-усиливать не в
зависимости от city, а от nearest_zone.

**Шаблоны тарифов** это старая идея, которая была призвана
уменьшить количество boilerplate действий при заведении
нового города. Типа "тариф в Пензе такой же, как в Перми,
только геообласть поменяй".

*Шось я не пойму! Ти будеш платить ілі як?*

Surge pricing
=============

[Продуктовое описание](https://wiki.yandex-team.ru/taxi/mobile/fspec3revc/surge/)

Реализация будет выполняться поэтапно:
 - согласование протоколов
 - проверки разных формул
 - соединение всего вместе

Протоколы
=========

С клиентами
-----------

Сообщаем клиентам о том, что действует surge-pricing через тот же механизм,
что и upsale, то есть в ручке taxisearch, но в поле /surge.

Почему не использовать поле /reorder?
Во-первых, потому что клиенты не отслеживают изменения в поле /reorder,
то есть не получится преложить surgeprice через 10 секунд и comfort_plus
через 20.
Во-вторых reorder и surge это отдельные сущности. С разным набором полей
и разным UI.

```(javascript)
"properties": {
  "surge": {
    "info": "Включить тариф ×2,0, чтобы увеличить количество доступных водителей?",
    "title": "Из-за дождя спрос на такси вырос",
    "small_icon_label": "Ускорить поиск",
    "decision_id": "5988aea9b30541da81bdc9e83c354c8a",
    "button_label": "Ускорить поиск"
  },
}
```

Как и в случае с /reorder, если пользователь захотел поднять цену,
то мы дергаем "/reorder", передавая ему указанный decision_id.

Зачем нужен decision_id? Потому что вдруг у нас surge обновляется очень быстро.
Кажется, что было бы правильно чтобы мультипликатор был именно той версии,
которую увидел клиент.

С парками
---------

При создании заказа (запросы requestcar, setcar) передаем, что он будет по
повышенной цене. В дальнейшем с помощью атрибутов можно будет генерировать
даже какие-то сетки коэффициентов. Почему SoftRequirements находится внутри
Car? Потому что по идее для водителей из разных классов могут быть разные
коэффициенты.

```(XML)
<Request>
    <Cars>
        <Car>
            <SoftRequirements>
                <PriceCorrections>
                    <Multiply item="price_per_km" value="1.9" />
                    <Multiply item="price_per_minute" value="1.9" />
                </PriceCorrections>
            </SoftRequirements>
        </Car>
    </Cars>
</Request>
```

Что означает написанное выше:

**SoftRequirements** — это список пожеланий к заказу, которые водитель может
принять либо отказать. Например, готовность клиента заплатить больше.
Водитель может повезти как по старой, так и по новой цене. Или если клиент
хотел бы, чтобы такси приехало с мороженным, но если нет, то он не будет против.

**PriceCorrections** — наличие этого узла означает готовность клиента
заплатить за заказ больше. Дети этого узла уточняют пункты, которые пользователь
готов оплачивать дополнительно.

**Multiply** — это пока единственный тип узла-наследника **PriceCorrections**.
Обязательный атрибут *item*, указывает на название одного из коэффициентов формулы,
к которому клиент готов применить умножающий коэффициент. Во втором обязательном
атрибуте *value* находится коэффициент, который пользователь готов заплатить.
Возможные значения атрибута *item*: *price_per_minute* - цена за минуту;
*price_per_km* - цена за километр; *minimal_price* - цена подачи.

В ответе carack мы должны видеть, приняло ли устройство водителя эти коэффициенты,
будет ли их применять. Это нужно для того, чтобы мы могли положить эти данные
в заказ и применять их для SOX-аудита, а в дальнейшем и для таксометра-на-клиенте.
В том случае, когда устройство водителя не смогло ПОЛНОСТЬЮ разобрать запрос,
оно НЕ имеет права применять только те коэффициенты,
которые оно смогло разобрать. Оно обязано считать, что оно не способно удовлетровить
предложенный PriceCorrections.

```
GET /1.x/carack?
    clid=1632340&
    apikey=*************************&
    uuid=7561950&orderid=0fe1ff53fa02488dba2d10dcbb5f8a79&
    status_change_time=2015-11-19T11%3A12%3A28%2B0300&
    longitude=37.5831779876357&
    latitude=55.7539879019526&
    direction=180&
    avg_speed=11&
    time=2015-11-19T11%3A25%3A50%2B0300&
    SoftRequirements=PriceCorrections
```

Кишочки
=======

Сейчас surgepriceinfo хранится для простоты там же, где и reorder.
Кладется он из триггера, чтобы быть однообразным с другими частями reorder-а
и еще чтобы делать работу по обновлению коэффициента в фоне.

Навязчивые мысли мои говорят о том, что можно было дергать surge-price прямо
из taxi-on-the-way, было бы куда проще. В своё оправдание могу сказать только,
что мой подход позволяет немного снизить тайминги ручек и наргузку на surge-
сервер, по сути проксируя все типа как с ключом cache max-age: 60.
К сожалению, это единственный смысл моего overengineering.

Еще меня волновал вопрос, не вызовется ли нотификация при добавлении нового
reorder-suggestion-а с помощью метода `add_reorder_suggestion`.
Соль в следующем, этот метод обновляет список order_proc.Doc._new_reorder_suggestions,
который потом используется для рассылки пушей, если он не пустой.
Но я выяснил, что пуши рассылаются только когда _new_reorder_suggestions не пустой
в методе _build_reorder_suggestions. А я все творю в триггере, так что
на сурж нотификаций не придет.

![А ведь все из-за псов](http://www.picshare.ru/uploads/120926/T09Q0ZaU4F.jpg)

Тарифы 3.0
==========

Структура тарифа
----------------

В формате JSON:

    {
        "id": "...",
        "name": "...",
        "currency": "RUB",
        "class": "...",
        "interval_choice": "...",
        "intervals": [
            {
                "schedule": {...},
                "taximeter": {
                    "services": [...],
                    "comment": "..."
                },
                "transfers": [
                    {
                        "directions": [...],
                        "services": [...],
                        "comment": "..."
                    },
                    ...
                ]
            },
            ...
        ]
    }


Выбор тарифа
------------

У каждого тарифа - дневного, ночного, и т.д. - есть расписание. Выбор
тарифа определяется полем `interval_choice`:

*   `start` - на момент начала поездки (подачи машины)
*   `end` - по окончанию поездки


Трансферы
---------

Трансферы могут отсутствовать. Если поле `transfers` присутствует, то
состоит из нескольких блоков. Так, могут быть разные условия при
трансферах аэропорт-город и аэропорт-аэропорт.

Трансфер состоит из базовой цены и наценок, которые считаются также, как
и в тарификации по счётчику.

Базовая цена (своего рода минималка) определяется парой трансферных зон
"откуда-куда". В JSON пары представлены объектами, являющимися членами
списка `directions`. Поля объекта:

*   `source` - идентификатор трансферной зоны, "откуда"
*   `destination` - идентификатор трансферной зоны, "куда"
*   `price` - цена

Например, "Шереметьево-ЦАО, 1300":

    {"source": "svo", "destination": "cao", "price": 1300}

В случаях, когда одной из трансферных зон (только одной: источником ИЛИ
назначением) является область, цена может быть не указана. В этом случае
в обязательном порядке в списке услуг `services` конкретного
трансферного блока должна присутствовавть услуга `delivery_to_transfer`.


Услуги
------

Платная подача с минимальной (или единовременной, но не с тем и другим)
ценой и возможными наценками за километраж (или время, что реже). То
есть, поля `min_price`, `once_price`, `prices` опциональны, но должно
присутствовавть хотя бы одно из них, причём `min_price` и `once_price`
не могут присутствовавть одновременно. Например, услуга "подача в
область - 10 руб/км, но не меньше 100 руб" в JSON выглядит так:

    {
        "service": "paid_dispatch",
        "source": "suburb",
        "min_price": 100,
        "prices": [{
            "type": "L",
            "areas": ["suburb"],
            "per": 1000,
            "price": 10
        }]
    }

Платная доставка до трансфера. **Присутствует только в тарификации по
счётчику**. Может присутствовавть в случае, когда одна из трансферных
зон - область. Обычно услугу преподносят текстом навроде "трансферы
действуют до МКАД, дальше рассчитываются по городскому тарифу". При этом
цену для трансфера опрпеделяют по ближайшей от точки в областе
трансферной зоне, а вот доставку до трансфера - по наценкам на основе
маршрута от точки подачи до какой-то ближайшей трансферной зоны.
В JSON выглядит так:

    {
        "service": "delivery_to_transfer",
        "nearest": ["wao", "eao", ...],
        "prices": [{
            "type": "L",
            "areas": ["suburb"],
            "per": 1000,
            "price": 10
        }]
    }

Одним из условий сотрудничества с Яндекс.Такси является предоставление
клиентам бесплатного времени ожидания (не менее 5 минут). В JSON:

    {
        "service": "waiting",
        "free_time": 300
    }

Платные услуги из требований к заказу. Например, могут быть платными
перевозка животных, кузов-универсал, детское кресло и (sic!) даже
кондиционер, что в JSON может выглядеть как:

    ...
    {
        "service": "animaltransport",
        "price": 100
    },
    {
        "service": "universal",
        "price": 200
    },
    {
        "service": "childchair",
        "price": 100
    },
    {
        "service": "conditioner",
        "price": 50
    }
    ...

Прочие услуги (кроме описанных выше и счётчиков), которые мы или не в
состоянии предугадать, или же это очень сложно, задаются следующим
образом:

    {
        "service": "other",
        "name": {"ru": "Встреча с цветами", "en": "Meet with flowers"},
        "price": 500
    }


Счётчики
--------

Тоже представлены в виде услуг, но их существует несколько видов, так
что их стоит рассмотреть подробнее. Ещё нужно посмотреть раздел "Tx, Lx,
другие параметры формул".

__Тарификация по времени__

Это основной способ тарификации. Есть какое-то время, которое включено
в поездку, по истечению которых идёт дополнительная оплата. Километраж
по области/МКАДу оплачивается отдельно.

Описание у партнёра может выглядеть так:

> Минималка 400, включено 30 минут, дальше 13/мин. Выезд за пределы
> МКАД - плюс 15/км к тарификации по времени. Проезд по МКАД - плюс 5/км
> к тарификации по времени.

В формате JSON представлено в виде:

    {
        "service": "taximeter",
        "type": "sum",
        "once_price": "400",
        "prices": [
            {
                "type": "T",
                "prepaid": 1800,
                "per": 60,
                "price": 13
            },
            {
                "type": "L",
                "areas": ["mkad"],
                "per": 1000,
                "price": 5
            },
            {
                "type": "L",
                "areas": ["suburb"],
                "per": 1000,
                "price": 15
            }
        ]
    }

Итоговая цена `ServicePrice` расчитывается по формуле:

    ServicePrice = OncePrice + max(MinPrice, sum([PriceBlock, ...]))
    PriceBlock = ceil(max(0, Total - Prepaid) / Per) * Price


__Расчёт по времени или расстоянию, что больше__

Когда скорость падает ниже определённой, аккумулируется время. Когда
выше - расстояние. В итоге оплата идёт за расстояние и за время.

Описание у партнёра (причём дословно):

> Посадка в авто - 150 руб, цены 20руб/км по городу, 26руб/км по
> области, плюс 10руб/за каждую минуту простоя. Если автомобиль
> движется со скоростью менее 8 км/ч в течение 40 секунд, то с 41-й
> секунды начинается простой. С момента начала простоя до его окончания,
> оплата за пройденное расстояние не взимается. Таким образом, таксометр
> считает стоимость поездки либо по километражу, либо по времени.

В формате JSON:

    {
        "service": "taximeter",
        "type": "sum",
        "once_price": "150",
        "stop_speed": 2.222222,
        "stop_speed_after": {"time": 40},
        "prices": [
            {
                "type": "L1",
                "areas": ["city"],
                "per": 1000,
                "price": 20
            },
            {
                "type": "L1",
                "areas": ["suburb"],
                "per": 1000,
                "price": 26
            },
            {
                "type": "T1",
                "per": 60,
                "price": 10
            }
        ]
    }

Итоговая цена `ServicePrice` расчитывается по формуле:

    ServicePrice = OncePrice + max(MinPrice, sum([PriceBlock, ...]))
    PriceBlock = ceil(max(0, Total - Prepaid) / Per) * Price


__Расчёт по километрам, доплата за простой__

Простоем считается время в пробках, на светофорах, и прочее,  когда
скорость падает ниже некоторого заданного значения. Отличие от
предыдущего случая - пробег аккумулируется при любой скорости (в
приведённом выше примере будут фигурировать не `L1`, а просто `L`).


__Расчёт по времени или километрам__

Таксометр вплоть до конца поездки параллельно ведёт два счёта - один по
пройденным километрам, другой - по проведённому в пути времени. Клиенту
выставляют бОльший счёт.

С сайта Сити-Мобил:

> Оплата поездки по городу расчитывается по минутами или по времени, что
> будет больше: 290 руб. за 20 минут + 12 руб./мин. ИЛИ 25 руб./км.
> Допольнительно оплачивается проезд по МКАД - 7 руб./км, и проезд по
> области - 15 руб./км.

Это взрывает мозг обывателя, но мы умеем это учитывать и рассчитывать. А
в JSON подобный вынос мозга выглядит так:

    {
        "service": "taximeter",
        "type": "max_of_sums",
        "max_of": [
            {
                "once_price": 290,
                "prices": [
                    {
                        "type": "T",
                        "areas": ["city"],
                        "prepaid": 1200,
                        "per": 60,
                        "price": 12
                    }
                ]
            },
            {
                "once_price": 290,
                "prices": [
                    {
                        "type": "L",
                        "areas": ["city"],
                        "per": 1000,
                        "price": 25
                    }
                ]
            }
        ]
    },
    {
        "service": "taximeter",
        "type": "sum",
        "prices": [
            {
                "type": "L",
                "areas": ["mkad"],
                "per": 1000,
                "price": 7
            },
            {
                "type": "L",
                "areas": ["suburb"],
                "per": 1000,
                "price": 15
            }
        ]
    }


Итоговая цена `ServicePrice` типа `max_of_sums` расчитывается по
формуле:

    ServicePrice = max([PricesBlockSum, ...])
    PricesBlockSum = OncePrice + max(MinPrice, sum([PriceBlock, ...]))
    PriceBlock = ceil(max(0, Total - Prepaid) / Per) * Price


Tx, Lx, другие параметры формул
-------------------------------

По итогам поездки из A в B заполянется таблица:

            |   L   |   T   |   L1  |   T1  |   L2  |   T2
    --------+-------+-------+-------+-------+-------+--------
     city   |       |       |       |       |       |
    --------+-------+-------+-------+-------+-------+--------
     suburb |       |       |       |       |       |
    --------+-------+-------+-------+-------+-------+--------
     mkad   |       |       |       |       |       |
    --------+-------+-------+-------+-------+-------+--------
     ...    |       |       |       |       |       |
    --------+-------+-------+-------+-------+-------+--------
     total  |       |       |       |       |       |

    L - общее пройденное расстояние
    T - общее время в пути

    L1 - расстояние от L, пройденное со скоростью выше 5 км/ч
    T1 - время от T, когда скорость была ниже 5 км/ч

    L2 - сумма отрезков пути, на которых средняя скорость была выше 5 км/ч
    T2 - время тех отрезков пути, где средняя скорость была ниже 5 км/ч

      0                                     L2       L1        L
    A +--------------------------------------------------------+ B
      0                                 T1      T2             T

Получение какого-либо из описанных значений для заданных территорий:

    total(type_, areas=None) -> value

    # Общее время поездки
    total('T', None)

    # Расстояние, пройденное по области и МКАДу
    total('L', ['suburb', 'mkad'])

    # Время остановок по городу
    total('T1', ['city'])

МКАД входит в город, city и suburb покрывают всё. Это захардкожено:

    total(*, ['city', 'suburb', ...]) == total(*, ['city']) + total(*, ['suburb'])
    total(*, ['city', 'mkad']) == total(*, ['city'])
    total(*, ['suburb', 'mkad']) == total(*, ['suburb', 'mkad'])


Что вообще за CamelCaseParams? Если `service` - это конкретная услуга
типа `taximeter`, `prices = service.get('prices', [])`, а `i` - индекс
конкретного блока из `prices`, тогда:

*   `OncePrice = service.get('once_price', 0)`
*   `MinPrice = service.get('min_price', 0)`
*   `Total = total(prices[i]['type'], prices[i].get('areas'))`
*   `Prepaid = prices[i].get('prepaid', 0)`
*   `Per = prices[i]['per']`
*   `Price = prices[i]['price']`

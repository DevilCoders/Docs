# queries
Этот модуль предназначен для взаимодействия с YT (YQL): запуск запросов на расчет ограниченного набора запросов + чтение и минимальная предобработка данных.

Этот модуль написан так, чтобы для создания нового запроса, вам нужно было просто добавить YQL-скрипт и его параметры в конфиге, а все остальное автоматически соберется и запустится. Поэтому если вы хотите что-то поменять в самом коде, то **убедитесь 100500 раз**, что вам действительно нужно лезть в код.

Основные составляющие модуля:
  - `queries_config` - основной объект, взаимодействующий с конфигом настроек (собирает пути и параметры запросов)
  - `queries_config.json` - конфиг с настройками запросов
  - `runner` - запускает кастомизированные запросы на YQL
  - `reader` - считывает данные из YQL и предобрабатывает их (например, приводит все даты к datetime и восстанавливает пропуски в данных)
  - `yql_src` - содержит исходники всех запросов

Что можно узнать подробнее:
- [Структура конфига `queries_config.json`](#Структура-конфига-queries_configjson)
  * [Внешний уровень](#Внешний-уровень)
  * [Уровень `queries_common`](#Уровень-queries_common)
  * [Уровень `queries`](#Уровень-queries)
  * [Параметры запросов](#Параметры-запросов)
- [Идеология `Runner`](Идеология-Runner)
- [Идеология `Reader`](Идеология-Reader)
- [Как что-то добавить?](#Как-что-то-добавить)
  * [Как добавить запрос на YT?](#Как-добавить-запрос-на-YT)
  * [Как добавить запрос на GP?](#Как-добавить-запрос-на-GP)
  * [Как добавить новую группу запросов?](#Как-добавить-новую-группу-запросов)
  
# Как работает эта магия?
## Структура конфига `queries_config.json`
Конфиг представляет из себя иерархическую структуру.

### Внешний уровень
- `prefix` (dict) - это префикс пути к таблицам в YT/GP. В конфиге указано дефолтное значение, которое можно изменить с помощью метода `set_yt_path` (например, указать свою папку). Для каждой базы данных (ключ) указан свой префикс (значение)
- `queries_common` - параметры, которые будут пробрасываться во все запросы (для каждой базы данных указываются свои)
- `queries` - здесь как раз хранится вся информация о доступных для выполнения запросах. В эту ветку дальше много вложено
- `mutable_parameters` - список параметров, которые можно изменять не меняя дефолтный путь к таблицам. По-умолчанию все параметры защищены от изменения извне (чтобы никто не мог затереть продакшеноовую таблицу)

### Уровень `queries_common`
Ключи в `queries_common` - это названия баз данных, соответствующих `prefix`. Должны соответствовать ключам в `prefix`, часть из них может отсутствовать.

В значениях указываются общие для всех запросов пути к таблицам и параметры (имеет смысл указывать те, которые используются в соответстсвующем start_file). Значения ключей соответствуют виду, описанному в `queries`

### Уровень `queries`
Здесь каждй уровень представляет из себя отдельный тип запросов, которые можно объединить логически. Все тексты этих запросов хранятся в соответствующей структуре в папке `yql_src`. Описания происходящего в запросах можно найти в `README.md` в папках с текстами запросов.

С точки зрения путей, результаты всех этих запросов будут складываться в одну папку в БД: `prefix + query_name` (чтобы было понятнее, можно заглянуть [сюда](https://yt.yandex-team.ru/hahn/navigation?path=//home/taxi-analytics/business_models)). Также все запросы внутри одной группы будут выполняться в одной и той же БД. Больше их может ничего не объединять

Какие сейчас есть запросы (перечислены в порядке их появления):
- `cohorts` - группа запросов для построения когорт
- `planning` - группа запросов, которые группируют данные из различных источников и складывают, чтобы потом по ним можно было строить отчеты
- `metrics` - группа не связанных между собой запросов, которые считают различные метрики (например, часовые данные по поездкам или миграции пользователей)
- `simple_cohorts` - два запроса, которые по-разному вычисляют когорты по любым входным данным
- `tests` - группа тестов над таблицами из business_models, возвращают список ошибок
- `tools` - запросы, которые не создают новые таблицы, а производят операции над существующими
- `reader` - группа запросов для Reader
- `reader_gp` - группа запроосов к GP для Reader
- `metrics_gp` - аналогично `metrics`, но эти метрики рассчитываются на GP

### Параметры запросов
Перед выполнением текста запроса он будет форматироваться через format, и в конфиге можно собственно указать передаваемые туда параметры. Также конфиг позволяет легко управлять названиями путей к создаваемым таблицам. 

Все параметры имеют вид словарей, ключи которых используются в запросах и/или коде, а значения подставляются во время сборки и запуска запроса. Установленные значения в конфиге используются по-умолчанию, при запуске запросов их можно поменять (возможно придется для этого сменить `prefix` через `queries_config.set_prefix()` или передать параметр `sub_path` в вызов запроса).

Теперь про параметры. Все они делятся на несколько групп в зависимости от назначения и любой из них может отсутствовать, кроме `scripts`. 

Есть группа параметров отвечающих за формирование путей к таблицам. Это словари с вида `{table_name: path}`. Название таблицы можно использовать в качестве параметра или значения параметра.
- `full_paths` - полные пути к таблицам, которые никак не предобрабатываются при запуске запроса (например, `{"dm_order": "home/taxi-dwh/summary/dm_order"}`) 
- `related_paths` - пути, зависящие от места в конфиге. Полный путь будет выглядеть так: для YT - `prefix/query_name/sub_path/scale/path`, для GP - `prefix_query_name_sub_path_scale_path`. Причем, 'sub_path' подставляется только если он был явно передан в качестве аргумента в метод генерации пути
- `scale_free_paths` - пути аналогичные `related_paths`, но не зависящие от значения scale: `prefix/query_name/sub_path/path` и `prefix_query_name_sub_path_path`
- `config_paths` - все таблицы, которые есть где-то в другом месте конфига. Вместо `path` для них указывается `table_name` любой таблицы из конфига. Гарантируется, что все пути при этом соберутся правильно. Единственное, что может вызвать неопределенное поведение - это одинаковые названия (ключи) таблиц в разных скриптах или параметрах 

Другая группа параметров отвечает за пути к скриптам и настройки выполнения запросов:
- `database` - база данных в которой, выполняется запрос. Название должно соответствовать доступным в `prefix`. По-умолчанию используется `yt`
- `scales` - список поддерживаемых конфигом скейлов: hour, day, week, month (нужно для формирования полного списка таблиц, генерируемых конфигом)
- `scripts` - `{script_name: script_path}` - здесь перечисляются все пути к yql-запросам, которые нужно запускать. Поиск запросов будет происходить по пути: `yql_src/query_name/script_path`.
- `scripts_order` - список названий скриптов в порядке, в котором нужно их выполнять. Можно не указывать, если порядок не важен
- `scale_free_scripts` - список скриптов (`script_name`), результат выполнения которых не зависит от указанного скейла. Такие скрипты можно не пересчитывать, если передать в `runner` параметр `with_scale_free=False`
- `is_mutable` - bool - если False, то отключает ограничение на изменение параметров

Последняя группа - это параметры, которые будут передаваться в `str.format()` при форматировании запроса. Независимо от указанных здесь параметров в любой запрос будут передаваться: `scale`, `prefix`, `sub_path` и все таблицы, которые находятся в `queries_common` или в параметрах, отвечающих за формирование путей. Общий вид параметров - это словарь вида: `{parameter_name: default_value}`.  При этом в качетсве `default_value` можно использовать значения вида `@table_name`. Символ `@` говорит о том, что нужно сюда подставить путь для таблицы `table_name` (это название таблицы должно быть среди передаваемых скрипту).
- `scales` - список скейлов, доступных для расчета. Например, когорты не могут быть расчитаны по часам. Если не указан, то будет использоваться глобальный параметр `scales` 
- `parameters` - общие параметры для всех скриптов в группе запросов
- `script_parameters` - `{script_name: parameters}` - параметры конкретного скрипта, значения в словаре аналогичны ключу `parameters`  

Кроме стандартных параметров поддерживаются дополнительные ключевые слова. Они могут быть включены в `parameters` на любом уровне вложенности.
- `list_parameters` - `list(parameter_name)` - список параметров, которые перед вставкой в запрос будут склеены через ','. Передача пустого списка повлечет замену значение `parameter_name` на '--'
- `list_str_parameters` - аналогично `list_parameters`, но все значения еще будут обернуты в кавычки
- `formatting_parameters` - `list(parameter_name)` - список параметров, к которым перед вставкой в запрос будет применен `format()` от всех остальных параметров (это происходит до склеивания `list_parameters`) 
- `value_dependent_parameters` - `{parameter_name: {value: parameters}}` - параметры, которые зависят от значений других параметров. Например, в группе запросов planning название таблицы, из которой тянутся данные зависит от названия загружаемой метрики. Блок `parameters` аналогичен общему, но также можно указывать значения параметров для разных скейлов (например, если `trips` нужно тянуть из `hourly_trips` для часовых точек, а во всех остальных случаях из `info`, то можно передать `{'table': {'hour': '@hourly_trips', 'week': '@info'}}`).

## Идеология `Runner`
Функции этого класса предназначены для того, чтобы обработать запуски скриптов со специфическими параметрами или загрузки таблиц в БД

Есть несколько важных вещей в работе его методов:
1. Чтобы мы всегда были уверены, что по основному пути лежат именно те таблицы, которые мы используем в работе, в `runner` есть предохранитель. Он не даст вам запустить расчет с измененными (по сравнению с конфигом) параметрами.
1. Чтобы все-таки обойти это ограничение, можно сменить префикс всех относительных путей для таблиц из конфига с помощью метода `set_yt_path`. Так, например, можно посчитать все когорты в свою собственную папку на YT.
1. Другой вариант обхода ограничения пункта 1 - это указание `sub_path`. В этом случае в середину относительного пути к таблице будет вставляться указанный `sub_path`. Это удобно, например, если вы в одном месте хотите держать сразу несколько разных когорт.
1. Нередка ситуация, когда вы расчитываете когорты сразу по нескольким скейлам. Однако таблицы, не зависящие от скейла, для недельного и месячного расчета будут одинаковыми, а значит нет смысла их пересчитывать. Так вот чтобы этого не делать, можно передать параметр `with_scale_free = False`.
1. Функциями вида `recount_all` можно расчитать только часть запросов с помощью параметров `script_prefix` и `script_contains`. Первый говорит оставить только те скрипты, названия (ключи) которых имеют переданный префикс, второй - просто проверяет наличие соответствующей подстроки. (Возможно однажды будет добавлен вариант с исключающей подстрокой, но это не точно)
1. Если вдруг вы захотите посчитать когорты только по пользователям, то передача параметра `script_contains="user"` отбросит все скрипты, не зависящие от скейла, без которых однако расчет может оказаться невозможным. Чтобы этого не произошло существует параметр `force_scale_free`, по-умолчанию равный `True`. Если он передан и `with_scale_free = True`, то независимо от остальных параметров в расчет попадут скрипты не зависящие от скейла.
1. Помимо скриптов, указанных в конфиге, в `yql_src` есть еще `start_part.yql`, он содержит всякие полезные функции, которые можно использовать в разных запросах, но сам по себе ничего не считает. Его передачу можно отключить при указании `has_start = False`, также вы можете передать свой стартовый файл.

## Идеология `Reader`

Функции этого класса предназначены для того, чтобы вы не думали о том как собирать пути, ну и еще они могут предобработать данные для удобного использования.

Есть только две вещи, которые хочется отдельно отметить. Первая касается функции `read_parameter`. Ее параметр `filter` позволяет предварительно (еще в YQL) отфильтровать данные из таблиц `planning`, чтобы, например, прочитать план только по одному городу.

Вторая полезная вещь - это кэширование. При чтении любых таблиц и параметров вызывается метод `read_raw_table`, а у него есть два параметра: `cache` и `hard_cache`. 

Первый кэш сохраняет данные в оперативку (в отдельный словарь) и вам гарантируется, что при повторном вызове уже не будет никаких обращений к YT, а данные вернутся из оперативки. Этот вид кэша может быть полезен, если вы работаете в Jupyter Notebook и в процессе работы изменяете прочитанный датафрейм или переопределяете переменную.

Второй кэш (hard) записывает данные из YT на диск, и при повторном чтении обращается не в YT, а к локальному хранилищу. Этот метод кэширования может быть полезен если вы запускаете скрипты или вам нужно перезагружать ядро в Jupyter. Но нужно понимать, что если таблица на YT слишком большая, то сильного выигрыша во времени от кэширования вы не получите.

Оба этих кэша можно почистить (а hard-кэш даже обязательно чистить, чтобы вы случайно не читали устаревшие данные). Для проверки состояния кэша и его очистки есть три метода: `get_caches`, `clear_cache` и `clear_hard_cache`.

# Как что-то добавить?
Лучше всего предварительно ознакомиться со структурой конфига, чтобы добавлять скрипты не совсем бездумно.

## Как добавить запрос на YT?
1. Напишите YQL-запрос, который работает (если вам нужен start_part, то можно писать запрос сразу внутри файла)
1. Прочитайте [список существующих групп запросов](#Уровень-queries) и выберите группу по смыслу (скорее всего это будет `metrics`, `tools` или `tests`. Если ни одна группа не подошла, то [добавьте новую](#Как-добавить-новую-группу-запросов).
1. Далее считаем, что вы выбрали условную группу запросов: `<some_group>`. Вместо `<some_group>` везде подставляете выбранную группу запросов
1. Положите в папку `queries/yql_src/<some_group>` файл с текстом запроса
1. Экранируйте все фигурные скобки в запросе: вместо `{<text>}` пишем `{{<text>}}`
1. Выделите все параметры запроса: названия  всех входных/выходных таблиц, числовые/строковые аргументы и проч. Придумайте им названия и замените конкретные значения на выражения вида `{parameter_name}`
1. Откройте файл `queries/queries_config.json` и найдите раздел по пути `queries/<some_group>`
1. Сначала добавим путь к скрипту: в раздел `scripts` добавляем строку вида: `"script_name": "filename"`. По имени `script_name` можно будет работать со скриптом из кода, а `filename` - это полное название файла (не путь!) со скриптом  
1. Если этот скрипт не зависит от того, какой указан scale, то добавьте его название в список `scale_free_scripts`
1. Если в группе запросов важен порядок выполнения скриптов (есть ключ `scripts_order`), то добавьте название скрипта в этот список
1. Теперь добавим все пути к таблицам. Путь добавляется в словарь как `"table_name": "path"`. По названию `table_name` вы сможете обращаться к таблице внутри своего запроса. А `table_name` будет использоваться как путь или для формирования пути на YT.
1. Добавляем полные пути (например, к таблицам DWH). Поищите в конфиге этот путь, если он есть по ключу `table`, то добавьте таблизу в раздел `config_paths` (вместо пути нужно указать `table`). Если нет, то добавьте ее в раздел `full_paths` вместо пути, укажите полный путь
1. Пути к другим таблицам из папки `business_models` добавляем в раздел `config_paths` аналогично полным путям
1. Добавляем пути выходных таблиц (в которые вы делаете inset into). Если результат запроса зависит от того, какой указан scale, то таблицу добавляем в раздел `related_paths`, иначе в `scale_free_paths`.
1. Добавляем остальные параметры: посмотрите на раздел `parameters` - там лежат параметры, которые в любом случае будут пробрасываться в ваш запрос (если есть какие-то ненужные, то это не страшно). Также в ваш скрипт будут проброшены параметры `scale`, `sub_path`, `prefix`.
1. Чтобы добавить параметры только для своего запроса, нужно сложить их в раздел `script_parameters/<some_group>` в виде `{"parameter_name": parameter_value}`
1. Если ваша группа защищена от изменения параметров (ключ `"is_mutable": false` или отсутствует), то изменяемые без необходимости смены sub_path или prefix параметры нужно добавить в список `mutable_parameters` на верхнем уровне конфига 
1. Теперь можно тестировать запуск запроса, в соответствии с методом из `runner`, который его запускает или через `queries_config.run_script`
1. Не забудьте добавить тесты!

## Как добавить запрос на GP?
1. Напишите SQL-запрос, который работает
1. Прочитайте [список существующих групп запросов](#Уровень-queries) и выберите группу по смыслу (скорее всего это будет `metrics_gp`, `tools_gp` или `tests_gp`. Если ни одна группа не подошла, то [добавьте новую](#Как-добавить-новую-группу-запросов).
1. Далее считаем, что вы выбрали условную группу запросов: `<some_group>`. Вместо `<some_group>` везде подставляете выбранную группу запросов
1. Положите в папку `queries/yql_src/<some_group>` файл с текстом запроса
1. Экранируйте все фигурные скобки и проценты в запросе: вместо `{<text>}` пишем `{{<text>}}`, а вместо `%` пишем `%%`
1. Выделите все параметры запроса: названия  всех входных/выходных таблиц, числовые/строковые аргументы и проч. Придумайте им названия и замените конкретные значения на выражения вида `{parameter_name}`
1. Откройте файл `queries/queries_config.json` и найдите раздел по пути `queries/<some_group>`
1. Сначала добавим путь к скрипту: в раздел `scripts` добавляем строку вида: `"script_name": "filename"`. По имени `script_name` можно будет работать со скриптом из кода, а `filename` - это полное название файла (не путь!) со скриптом  
1. Если этот скрипт не зависит от того, какой указан scale, то добавьте его название в список `scale_free_scripts`
1. Если в группе запросов важен порядок выполнения скриптов (есть ключ `scripts_order`), то добавьте название скрипта в этот список
1. Теперь добавим все пути к таблицам. Путь добавляется в словарь как `"table_name": "path"`. По названию `table_name` вы сможете обращаться к таблице внутри своего запроса. А `table_name` будет использоваться как путь или для формирования пути на GP.
1. Добавляем полные пути (например, к таблицам DWH). Поищите в конфиге этот путь, если он есть по ключу `table`, то добавьте таблизу в раздел `config_paths` (вместо пути нужно указать `table`). Если нет, то добавьте ее в раздел `full_paths` вместо пути, укажите полный путь
1. Пути к другим таблицам из папки `business_models` добавляем в раздел `config_paths` аналогично полным путям
1. Добавляем пути выходных таблиц (в которые вы делаете inset into). Если результат запроса зависит от того, какой указан scale, то таблицу добавляем в раздел `related_paths`, иначе в `scale_free_paths`.
1. Добавляем остальные параметры: посмотрите на раздел `parameters` - там лежат параметры, которые в любом случае будут пробрасываться в ваш запрос (если есть какие-то ненужные, то это не страшно). Также в ваш скрипт будут проброшены параметры `scale`, `sub_path`, `prefix`.
1. Чтобы добавить параметры только для своего запроса, нужно сложить их в раздел `script_parameters/<some_group>` в виде `{"parameter_name": parameter_value}`
1. Если ваша группа защищена от изменения параметров (ключ `"is_mutable": false` или отсутствует), то изменяемые без необходимости смены sub_path или prefix параметры нужно добавить в список `mutable_parameters` на верхнем уровне конфига 
1. Теперь можно тестировать запуск запроса, в соответствии с методом из `runner`, который его запускает или через `queries_config.run_script`. Чтобы посмотреть на генерируемый текст запроса можно использовать `queries_config.read_script`
1. Не забудьте добавить тесты!

## Как добавить новую группу запросов?
1. Придумайте название группы запросов (отражающее их суть). Если эти запросы ходят на GP, добавьте к названию суффикс `_gp`
1. Далее считаем, что вы выбрали условное название: `<some_group>`. Вместо `<some_group>` везде подставляете свою группу запросов
1. Создайте папку по пути `queries/yql_src/<some_group>`
1. Откройте файл `queries/queries_config.json` и добавьте в раздел `queries` новый ключ `<some_group>`
1. Добавьте в внутрь раздела `<some_group>` ключ `"scripts": {}`
1. Если ваши запросы будут ходить на GP, то добавьте внутрь раздела `<some_group>` добавьте `"database": "greenplum"`
1. Если вам не нужна защита от изменения дефолтных значений параметров, добавьте `"is_mutable": true`
1. Если в вашей группе запросов важен порядок выполнения скриптов, то добавьте ключ `"scripts_order": []`
1. Добавьте один или несколько запросов в новую группу
1. Добавьте в `Runner` метод, который будет работать с этой группой запросов
1. Не забудьте добавить тесты!
  
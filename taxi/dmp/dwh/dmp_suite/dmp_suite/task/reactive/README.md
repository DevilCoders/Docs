# Реактивный запуск тасок

Реактивность — запуск тасок по событиям изменения данных хранилища.


## Общий принцип работы

Реактивность основана на изменении CTL параметров объектов хранилища.
Изменения состояния объектов (например, доезд нового периода данных или
обновление справочника) должны отражаться в CTL параметрах данного объекта.
Поэтому естественно подвязываться на CTL для реактивного запуска тасок.

Для описания событий, при которых нужно запускать таску, добавили новый
тип шедулера — триггер. Триггер на основе текущего времени, текущих значений
CTL параметров, значений CTL параметров которые таска видела в предыдущий
регулярный запуск и их преобразований вычисляет, произошло ли нужное событие.
Если да, то таска отправляется на выполнение, иначе ждет нужных событий.
При успешном выполнении, текущие значения CTL параметров, которые 
использовались в проверке триггера запоминаются в CTL как предыдущие значения 
и снова начинается ожидание выполнения триггера.


## Типы триггеров

Есть два основных типов триггеров:

- CTL триггеры: на основе CTL проверяют выполнение одного события
- агрегирующие триггеры: комбинируют CTL триггеры

Теоретически, можно сделать триггер, проверяющий произвольную
функцию-предикат. Но так делать не стоит. Это сильно усложнит отладку.
А также, при непредсказуемом времени работы функции, может сломать 
реактивный запуск в целом. Триггеры должны полагаться только на
информацию из CTL и работать за маленькое константное время.

### CTL триггеры

*Замечание:* 
для краткости параметром далее
будем называть пару `(entity, ctl_parameter)`.

Сводная табличка типов триггеров по CTL параметрам:

| Основные типы    | Delta      | Delay      | RefDelay      |
| ---------------- | ---------- | ---------- | ------------- |
| точное сравнение |      Delta |      Delay |      RefDelay |
| chunk сравнение  | ChunkDelta | ChunkDelay | ChunkRefDelay |

CTL триггеры можно разбить на три типа:

- **Delta-триггер**:
    - событие: приход нового инкремента
    - параметр: `min_delta` — минимальная разница/инкремент
    - условие запуска: `current_ctl_state - last_ctl_state >= min_delta`
        - current_ctl_state — текущее состояние параметра
        - last_ctl_state — состояние параметра на предыдущий регулярный запуск
    - надежный триггер:
        - между запусками со временем дельта всегда будет увеличиваться
        - следовательно, когда-нибудь триггер точно сработает

- **Delay-триггер**:
    - событие: отставание от текущего времени меньше заданного
    - параметр: `max_delay` — максимальное отставание от текущего времени
    - условие запуска: `current_time - current_ctl_state <= max_delay`
        - current_time — текущее время
        - current_ctl_state — текущее состояние параметра
    - ненадежный триггер:
        - оба времени идут вперед
        - их разница может меняться в обе стороны
        - запуск не гарантирован, нужен мониторинг

- **RefDelay-триггер**:
    - событие: отставание от другого параметра меньше заданного
    - параметр: `max_delay` — максимальное отставание от reference параметра
    - условие запуска: `current_reference_ctl_state - current_ctl_state <= max_delay`
        - current_reference_ctl_state — текущее состояние reference параметра
        - current_ctl_state — текущее состояние основного параметра
    - ненадежный триггер:
        - оба времени идут вперед
        - их разница может меняться в обе стороны
        - запуск не гарантирован, нужен мониторинг

Каждый вышеописанный тип триггера присутствует в двух версиях:

- версия с обычным сравнением:
    - сравниваем точную разницу с заданной timedelta
    - timedelta может быть произвольной

- версия с chunk-сравнением:
    - добавляется новый параметр `scale` — размер чанка
    - чанк — временной интервал определенной длины (например, 30мин)
    - сравниваем разницу округленных значений с дельтой
    - время округляем до начала чанков (например, для 30мин: `01:42:13` -> `01:30:00`)
    - дельта — целое количество чанков

Смысловая разница между этими типами сравнения следующая:
для примера возьмем `Delta(e, p, '2d')` и `ChunkDelta(e, p, 'day', 2)`;
триггер `Delta` сработает, когда разница между текущим и прошлым
значениями параметра будет больше или равна двух суток;
триггер `ChunkDelta` сработает, когда разница между датами текущего
и прошлого значения параметра будет больше или равна двух, 
разница по времени при этом может быть меньше двух суток,
например `last='2021-04-23 03:51:16'` и `current='2021-04-25 03:27:33'`.

Также, для чанк-версий можно не задавать параметр `min_delta` или `max_delay`.
Особенно это полезно для чанков, у которых нету фиксированной дельты (например, месяц и год).
В этом случае для каждого типа триггеров логика будет следующая:

- **Delta-триггер**:
    - текущее значение параметра 
      относительно предыдущего находится в новом чанке
- **Delay-триггер** и **RefDelay-триггер**:
    - текущее значение параметра находится в том же чанке, 
      что и текущее время или reference параметр

*Замечание:*
есть предположение, что реально нужны только chunk-версии;
обычные версии пока нигде в DSL не используются;
но испытание временем покажет.

### Агрегирующие триггеры

Агрегирующие триггеры просто комбинируют другие триггеры.

Есть два условия агрегации:

- all: выполняются все триггеры
- any: выполняется хотя бы один триггер

На данный момент агрегирующие триггеры были искусственно ограничены:
можно агрегировать только CTL триггеры, нельзя вкладывать агрегирующие
триггеры внутрь агрегирующих триггеров. Это сделано чтобы избежать
сложных в отладке триггеров. Если такая необходимость возникла
и нельзя придумать более простой триггер, нужно пойти в вопросом
в команду платформы. Может можно сделать третий вид агрегирующих
триггеров. Или ослабить ограничение на вложенность; например, можно
допускать один слой вложенности и допускать внутри any-триггера
только all-триггеры и наоборот. Но ограничение в каком-то виде
точно должно быть.

### DSL для триггеров

Сами классы триггеров — это скорее низкоуровневые представления
описания событий. Для использования в тасках лучше делать функции-обертки
с более понятными названиями, возвращающие инстансы классов триггеров.

### Советы по применению типов триггеров

Таск, использующий триггеры, которые не полагаются на состояние CTL
при предыдущем запуске, могут запускаться постоянно как только будет
заканчиваться предыдущий запуск.

Если такое поведение не нужно, то в каждом из вариантов активации
триггера таска должен активироваться какой-то триггер, полагающийся
на состояние CTL при предыдущем запуске. Например:

- одиночный CTL триггер: использовать только Delta-триггер 
- all-триггер: хотя бы один из дочерних триггеров должен быть Delta-триггер
- any-триггер: все дочерние триггеры должны быть Delta-триггерами


## Запуск тасок

Отдельный процесс собирает все реактивные таски сервиса,
проверяет триггеры и ставит таск на выполнение если нужно.

### Текущая картина

Сейчас это сделано в виде таска, который запускается раз в n минут,
в цикле проверяет выполнение триггера каждой таски и, если триггер сработал,
запускает её в отсоединенном процессе на том же хосте.

При успешном завершении таска в CTL базе запоминается
состояние параметров, использованное при проверке триггера.
Пока это не произошло, триггер остается неотработавшим,
и таска-шедулер продолжает её запускать; при этом:

- если таска всё ещё работает, то новый запуск упирается в лок.
- если таска упала ранее, то она запустится заново.

Это быстрый MVP, но у него есть ряд ограничений:

- отсутствие ограничения на одновременный запуск:
  если за один обход сразу много триггеров выполнится
  (например, за n минут приехало несколько табличек,
  на которые полагаются много других тасок), то разово
  запустится большое количество тасок, надо это ограничивать.

- с момента запуска таски и до момента завершения выполнения,
  так как предыдущие виденные таской значения CTL параметров не меняются
  и триггер продолжит срабатывать, таска-шедулер будет пытаться запускать
  процессы, постоянно упирающиеся в лок уже запущенного процесса;
  это не критично, но и не хорошо.

- всегда проверяются триггеры всех тасок, хотя нужно проверять только те,
  на которые могли бы повлиять изменения параметров с последней проверки;
  это будет создавать дополнительную нагрузку при большом числе 
  реактивных тасок

### Целевая картина

Сервис-шедулер работает постоянно и слушает поток изменений из CTL.
При приходе изменения он смотрит по хеш-таблице какие таски могло затронуть
это изменение и проверяет их триггеры. Таски, которые готовы к исполнению
становятся в очередь с каким-то приоритетом. Пока таска находится в очереди 
или исполняется, шедулер не проверяет триггер таски и не пытается её запустить.
Если шедулер ожидает завершение таски, которая довезет данные для другой
высокоприоритетной таски, то очередь перестает разбираться в ожидании 
более важной таски.


## Поведение реактивности

### Первый релиз таска

Так как раньше таска не запускалась реактивно,
то в CTL базе будут отсутствовать параметры при предыдущем запуске.

Если триггер полагается только на текущие значения параметров,
то он будет вычислен как обычно.

Если триггеру нужно предыдущее значение, то, при условии наличия 
текущего значения параметра, триггер будет активирован тут же.

### Изменение триггера таска в последующих релизах

Аналогично первому релизу, если триггер полагается только 
на текущие значения параметров, то он будет вычислен как обычно.

Если триггеру нужно предыдущее значение и он использует параметр,
ранее использовавшийся в триггере таска (то есть присутствующий 
в запомненном состоянии параметров при предыдущем запуске), 
то он тоже вычисляется как обычно.

Если триггеру нужно предыдущее значение и он использует новый параметр,
которого, следовательно, нет в запомненном на момент предыдущего запуска
состоянии, то, аналогично первому релизу, при наличии текущего значения 
параметра, триггер будет тут же активирован.

### Изменение CTL параметров

Изменение CTL параметров в будущее означает 
приезд новых данных и ничего не ломает в реактивности.

Изменение CTL параметров в прошлое ломает реактивный запуск
и требует ручных действий для тасок, полагающихся на объект,
параметры которого меняли:

- при использовании Delay-триггера:
  ручной запуск с записью состояния параметров

- при использовании Delta-триггера:
  передвижение в прошлое или удаление состояния на предыдущий запуск

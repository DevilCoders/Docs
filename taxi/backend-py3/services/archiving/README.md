# Архивация (чистка) баз данных
## Для чего нужен этот сервис?
Это готовый и проверенный инструмент, позволяющий с заданной периодичностью
удалять документы по TTL (и опционально проверять их доставку в YT за счет интеграции
с сервисом репликации).

## Полезные ссылки
Чат поддержки: [ссылка](https://wiki.yandex-team.ru/taxi/backend/datastorage/#chatpodderzhki)

Ccылки на админку:
1. [production](https://tariff-editor.taxi.yandex-team.ru/archiving)
2. [testing](https://tariff-editor.taxi.tst.yandex-team.ru/archiving)

Графики архивации со всеми правилами:
1. [production](https://grafana.yandex-team.ru/dashboard/db/taxi_archiving_stat)
2. [testing](https://grafana.yandex-team.ru/dashboard/db/taxi_archiving_stat_testing)

## Поддерживаемые СУБД и ограничения
- **Postgres**. Архивация по шардам запускается разными процессами, количество
шардов определяется по секрету в секдисте.
Поддерживается только архивация по полям типа `TIMESTAMP` или `TIMESTAMPTZ`.
- **Mongo**. Поддерживаются как шардированные, так и нешардированные базы. yaml-описание БД
должно лежать в репозитории schemas/mongo и в [backend-py3](../../schemas/mongo). Поддерживается только архивация по полю
 c монговским типом `Date` (питонячий `datetime.datetime`).

Если база до этого не использовалась в сервисе архивации, нужно дать
к ней RW доступы к базе.  Для этого нужно создать ПР в
 [strongbox](https://tariff-editor.taxi.yandex-team.ru/services/38/edit/355830/secrets?service_name=archiving)
 и попросить админов его проверить.
## Общая информация
Сервис архивации представляет собой запуск крон-тасок, которые
чистят базы данных, пользуясь
информацией из т.н. "правил", которые позволяют описывать параметры архивации (например, периодичность запусков)
с помощью YAML-файла. Сервис интегрирован с сервисом репликации и позволяет
удалять как с учетом отреплицированных документов, так и с помощью простого TTL.

Описание по уровню взаимодействия с [репликацией](https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/replication-docs/replication-service/):
1. Чистка баз без взаимодействия с репликацией: для чистки используется информация из раздела ttl_info в
YAML-файлике (в скором времени параметры архивации можно будет настраивать через админку). Не проверяется,
был ли отреплицирован документ в YT.
2. Чистка баз с запросами в сервис репликации: при удалении всегда будет учитываться,
был ли документ прореплицирован в YT и после репликации он не будет
удален как минимум некоторое фиксированное время (на данный момент час).
Для Mongo также поддержан специальный режим, который позволяет заливать данные
напрямую в очередь репликации (об этом будет рассказано ниже, в разделе описания структуры YAML-правил).
Для работы этого режима необходимо работающее правило репликации, в противном случае крон-таска
падает.

## Заведение правила архивации
Для того, чтобы архивация заработала, нужно создать поддиректорию в специальной [директории](archiving/rules)
и создать там YAML-правило архивации (структура описана в следующей секции). Валидность правила проверяется
с помощью тестов. После проверки работы таски в тестинге нужно
 в чате поддержки (см. раздел [полезные ссылки](#полезные-ссылки)) попросить окнуть выкатку сервиса `archiving` и включить нужное правило
 в [админке](https://tariff-editor.taxi.yandex-team.ru/archiving) архивации (в других окружениях правило
можно включить самостоятельно).

Эти же люди могут выставлять новые значения
TTL правила, периодичности запуска и слипов при балковом удалении. **Параметры архивации, выставленные в админке, имеют приоритет над значениями в yaml-правиле.**
При нажатии на правило на экран выводятся ссылки, которые могут быть полезны при диагностике проблем.

## Описание структуры yaml-правила
- **name** `required` — название правила. Должно совпадать с именем файла.
  Рекомендуем в названии правила в качестве префикса указывать имя директории.
- **source_type** `required` — тип источника. На данный момент разрешены только `mongo` и `postgres`
- **source_settings** `required` — описание параметров архивации, специфичных для СУБД.
    - Для **postgres** указываются следующие параметры:
        - **connection** `required` — название БД в секдисте. Нужно только имя, полный путь в секдисте
        указывать не нужно
        - **table** `required` — название таблицы
        - **iteration_field_type** — тип поля, по которому удаляет архивация.
        Доступные значения: `timestamp` или `timestamptz`. Дефолт - `timestamptz`.
        - **primary_key** — первичный ключ, указывается списком для поддержки композитных ключей. При отсутствии поля limit
        не используется.
        - **isolation_level** — какой использовать уровень изоляции транзакций. Разрешены уровни, поддержанные postgresql
        (`read_committed`, `serializable`, `repeatable_read`).
        По умолчанию используется `read_committed`.
        - **limit** — для почанкового удаления документов из базы, целое число.
        Обычно выставляют 10000, чтобы удаление не шло слишком медленно.
        Таймаут между чанками задаётся в админке, по умолчанию он 5 секунд.
        Также, указывайте **primary_key** при выставлении **limit**.
        - **custom_conditions** — укажите дополнительные условия архивации. Например: `"terminated_at IS NOT NULL"`,
        где `terminated_at` - это поле вашей таблицы. Учитывайте, что итоговый запрос должен работать по индексу,
        полные итоговые запросы можно посмотреть в тестинге, и сделать их EXPLAIN в production окружении.
        - **by_table_prefix** — укажите `true`, если удалять нужно не только из таблицы **table**,
        но и всех, для которых **table** является префиксом имени таблицы.
        - **timeout_between_tables** — только для режима **by_table_prefix**,
        укажите дополнительный таймаут между удалениями из разных таблиц.
        - **prepared_statement_disabled** - выставьте true,
        если prepared statements не поддерживаются настройками pg bouncer.
    - Для **монги** указываются следующие параметры:
        - **collection_alias** `required` — алиас коллекции из schemas/mongo
        - **base_query** — опциональный объект (словарь). Запрос сервиса архивации будет строиться на основе этого запроса.
        - **projection** — опциональный объект (словарь). Передается в параметр projection запросов к монге.
        - Размер одного балка при удалении — 1000. Настраивается только в конфиге, обращайтесь в чат поддержки.
- **cleaner_delta** — какой по продолжительности интервал времени надо архивировать (сколько отступать от полученной правой границы,
чтобы получить левую границу timestamp документов, которые надо удалить).
- **period** `required` — периодичность запуска тасок архивации (в секундах).
- **ttl_info** `required` — информация о TTL документов
  - **duration_default** `required` - дефолтный TTL документов (в секундах). **Его менять нельзя**, все изменения нужно делать только через админку.
  - **field** `required` — поле, по которому считается TTL
  - **savepoint_type** — тип TTL: `now` — отсчитывается от настоящего времени, `last_updated` — от времени
  последнего зареплицированного в YT документа базы (поддержано только для правил, интегрированных с репликацией).
  По умолчанию используется `now`.
- **replication** — метаинформация о правиле репликации, необходимо в случае интеграции с сервисом репликации.
    - **rule_name** `required` — название правила репликации
    - **usage_level** `required` — степень интеграции с репликацией:
        * `stamp_sync` — удаление документов с учетом даты последнего отреплицированного документа. Документы с более
        свежей датой репликации удалены не будут.
        * `data_sync_api` — удаление с заливкой данных в очередь репликации
        (поддержано только для Mongo для критичных для функционирования такси коллекций,
        операция синка довольно тяжелая). Перед использованием
        такого режима лучше проконсультироваться с
        [ответственными](https://staff.yandex-team.ru/departments/yandex_distproducts_browserdev_mobile_taxi_9720_3279_dep42758/).
    - **target_names** - если указать конкретные таргеты, то валидации даты будет проходить только по ним
    - **dependent_rule_names** — если при удалении из базы также будут происходить удаления
    из зависимых таблиц, реплицируемых отдельными правилами репликации, то нужно указать и их.
    Если хотя бы одно из этих правил отстанет или будет выключено, архивация остановится на этой отметке.
- **preparing** (deprecated) — использование пользовательского кода для фильтрации
  документов.  Поддерживается только для Mongo. Список из объектов со следующей схемой:
    - **type** `required` — тип фильтрующей функции (`aggregation` — принимает на вход чанк документов и
    должна возвращать отфильтрованный чанк. `filtering` — принимает на вход один документ и возвращает
    булево значение, сигнализирующее о том, можно ли удалять документ)
    - **name** `required` — ключ в словаре FILTERING_CLASSES или AGGREGATION_CLASSES к классу,
    реализующему необходимый для фильтрующих функций интерфейс. Подробнее можно посмотреть
    по коду в модуле [data_preparing.py](archiving/data_preparing.py)

## Запуск локальных тестов
Для запуска локальных тестов, необходимо выполнить:

    cd backend-py3
    make test-archiving

## Тестирование postgresql правил
Есть возможность протестировать свои правила в **postgres**-песочнице.
Вы произвольно инициализируете базу своими таблицами и указываете состояние базы до архивации и после.
Архивация в тестах будет запускаться и сверять состояние после архивации с файлом, который вы ей подложили как ожидаемое состояние.
На примере:
* Правило расположено по пути (scope — ваша группа правил):
    * **archiving/rules/{scope}/{rule}.yaml**
    * [Пример](https://a.yandex-team.ru/arc/trunk/arcadia/taxi/backend-py3/services/archiving/archiving/rules/cargo_c2c/cargo_c2c_clients_orders.yaml)
* Общий путь к тестам группы правил: **archiving/rules/{scope}/pg-tests**.
* Инициализация базы:
    * Сейчас это 1 общий файл для группы. Сюда можно заносить не всю схему, а только базовые колонки и триггеры.
    * **archiving/rules/{scope}/pg-tests/schemas/init_db.sql**
    * [Пример](https://a.yandex-team.ru/arc/trunk/arcadia/taxi/backend-py3/services/archiving/archiving/rules/cargo_c2c/pg-tests/schemas/init_db.sql).
* Сами тесты:
    * **archiving/rules/{scope}/pg-tests/{rule}/testcases/test-N.before.sql** - состояние базы **до** архивации.
    * **archiving/rules/{scope}/pg-tests/{rule}/testcases/test-N.after.sql** - ожидаемое состояние базы **после** архивации.
    * Для первого теста положить N=0, для дополнительных N=1 и т.д.
    * [Пример](https://a.yandex-team.ru/arc/trunk/arcadia/taxi/backend-py3/services/archiving/archiving/rules/cargo_c2c/pg-tests/cargo_c2c_clients_orders/testcases)
* Параметризация тестов:
    * **archiving/rules/{scope}/pg-tests/{rule}/metainfo.yaml**
    * [Пример](https://a.yandex-team.ru/arc/trunk/arcadia/taxi/backend-py3/services/archiving/archiving/rules/cargo_c2c/pg-tests/cargo_c2c_clients_orders/metainfo.yaml)
    * Формат:
        * `freeze_now` — на какое время нужно замокать сервис. Пример: вы мокаете `now` на 20 января,
        ваши тесткейсы имеют 10 января, а TTL стоит 5 дней. Тогда вы ожидаете, что все будет удалено.
        Учтите, что триггеры **postgres** будут игнорировать мок времени.
        * `tables_involved` — список включенных в архивацию таблиц, кроме основной таблицы правила.
        Это может быть каскадное удаление, или удаление с помощью триггеров. На эти таблицы тоже можно написать тесты.
        Состояния остальных таблиц не будут учитываться в тестах.

## Тестирование в тестинге
После того как прошли успешно все локальные тесты,
нужно проверить работу правила в тестовом окружении.
Для этого:
1. В PR добавить плашку `taxi/deploy:testing`
2. Выкатить архивацию в testing - [Custom (testing)](https://teamcity.taxi.yandex-team.ru/viewType.html?buildTypeId=YandexTaxiProjects_TaxiBackendPy3_Customs_CustomTesting&branch_YandexTaxiProjects_TaxiBackendPy3_Customs=archiving&tab=buildTypeStatusDiv), бранч `archiving`
3. Дождаться когда правила появятся в [тестовой админке архивации](https://tariff-editor.taxi.tst.yandex-team.ru/archiving)
4. Изменить на `Статус: Включено` и одобрить драфт

## Возможные проблемы
* Если после того, как новые правила архивации были запущены в тестинге,
  и кроны отработали, но информации о документах не появляется на графиках,
  то одна из возможных причин — что не были добавлены секреты для архивации.
  Чтобы диагностировать проблему, необходимо открыть логи кибаны и поискать
  сообщения содержащие в себе: `database not found in secdist`.

## Удаление неактуальных правил
* Нужно удалить yaml'ы с правилами и выкатить сервис `archiving` в тестинг/прод.
* После выкатки вызвать скрипт для ваших правил, примеры:
[тестинг](https://tariff-editor.taxi.tst.yandex-team.ru/dev/scripts/b1cc2d34f001424586ff1aba0a8768c0),
[прод](https://tariff-editor.taxi.yandex-team.ru/dev/scripts/974cbc06494448f098a3585293fab61b).
Если скрипт во время выполнения упал с ошибкой `ValidateRuleToDropError`,
  то необходимо выполнить первый пункт по удалению неактуальных правил.

## FAQ
### Как полностью перегрузить историю таблицы? {#reinit}
- Используя первоистоник данных (таргет с записью в очередь - **queue_mongo**):
  - Частичная перегрузка с даты: **change_state** -> [init](drafts.md#init) с датой инициализации (местное время) для одного таргета из источника в **queue_mongo** (staging_*). Остальные таргеты подтянут историю из очереди сами - чтение из очереди происходит исходя из времени попадания документа в очередь.
  - Перезагрузка 100% истории:
    - **change_state** -> [remove](drafts.md#remove), выбрав все таргеты что есть у правила
    - **change_state** -> [init](drafts.md#init), выбрав все таргеты что есть у правила, которые вы хотите включить
- Для конкретных YT таблиц-таргетов (их нужно накликать) используя **RAW/BSON** YT слой (данные уже должны в нем быть):
  - **yt_ctl** -> [build_struct](drafts.md#build_struct) - полное перестроение
  - **yt_ctl** -> [initialize_columns](drafts.md#initialize_columns) - инициализация части колонок

### Как выборочно отреплицировать конкретные записи?
Руками обновить поле репликации на источнике у этих записей, если поле предполагается мьютабельным.
Иначе, придется [перегружать](faq#reinit) весь источник с нужной отметки.

### Как делать массовые изменения? {#massive_changes}
Иногда бывает, необходимо сделать массовые изменения в базе. Тут рекомендация такая:
- Для <~3.000.000 записей, можно сделать это одним запросом, тогда прогрузка этого места будет почти аналогично снапшоту.
Есть риск, что долгая транзация выставит поле репликации на начало транзакции,
тут стоит озаботиться и заранее настроить базу, чтобы ставилось на конец транзакции,
либо откатить репликацию немного назад, после миграции.
- Если записей больше, лучше сразу заложиться на то, чтобы проставить поле репликации с какими-то диапазонами,
например в 5 минут, выбрав чанки для изменений не более 100.000


### Как поменять тип колонки в YT?
- Если можно удалить таблицу - удалите и используйте перегрузку истории [выше](#reinit)
- Можно сразу использовать [build_struct](drafts.md#build_struct)
- Если можно удалить колонку - удалите ее [alter_table](scripts.md#yt-alter_table) скриптом с --del-columns.
  Далее ее можно создать драфтом [add_columns](drafts.md#add_columns).
  Для восполнения истории можно:
  - перегрузить историю как описано [выше](#reinit)
  - использовать метод перестроения одной колонки в YT: [initialize_columns](drafts.md#initialize_columns)
- Если удалять колонку нельзя, а build_struct не подходит - лучше выкатить версию с новым именем колонки, перегрузить ее историю любым способом выше, а потом удалить старую

### Что значит **mixed** состояние **YT** таргета?
- Это значит, что части одного таргета находятся в разных состояниях, например, на **hahn** правило включено, а на **arnold** выключено
- Как чинить читайте ниже (пункты 2-3)

### Как включить уже работающее правило, но на другом наборе **YT** кластеров?
Если, например, на **hahn** правило включено, а на **arnold** выключено:
  1) В **yaml** правиле нужно добавить нужные кластерные группы (**cluster_groups** или **client_names**) и выкатить релиз
  2) Включаем новый таргет **change_state** -> [init](drafts.md#init), в **target_unit_ids** указываем только нужные кластера явно
  3) Выполняем драфт **yt_ctl** -> [sync_table](drafts.md#sync_table), чтобы сихнронизировать новые кластера со старым, включенным.
     Если партиций в таргете слишком много, то на данный момент такой синк нужно выполнять без этого драфта - средствами YT (например, написать свой скрипт)

### Что такое **ext** таргет? Как его включать?
- Это "читатель" сырой очереди репликации. Сейчас используется **dwh** для построения **ODS** YT таблиц в реалтайме
- Перед включением нужно убедиться, что походы в read_queue уже включены (в проде это верно по умолчанию)
- Если источник с большим объёмом данных (то есть и очередь), например таблица **заказов такси**, то стоит ограничить очередь датой инициализации
- Если такие таргеты вовремя не удалить (**remove**) в случае проблем, то очередь будет **переполняться** и придут алерты

### Как полностью удалить правило?
- Вместе с источником и очередью: [инструкция](delete-rule.md)
- Только yt таблицы, сохранив правило: [yt_remove](drafts.md#yt_remove)

### Как очистить очередь репликации?
**change_state** -> [remove](drafts.md#remove) с выбором **drop_queue**, выбрав все таргеты что есть (главное чтобы бы таргет-очередь staging_*).
Вместе с этим вам нужно удалить и все остальные таргеты.

### Как сделать миграцию очереди на новый кластер? {#queue_migration}
**Пожалуйста, ознакомьтесь с инструкцией полностью, прежде чем начать миграцию!**
- Удалите состояния всех таргетов (в том числе очереди) **change_state** -> [remove](drafts.md#remove) с выбором **drop_queue**
- Выкатите ПР с указанием нового кластера. Для этого в `queue_data` укажите новый `db_cluster`. Если поток данных превышает 1 Mb/s, то рекомендуем увеличить количество шардов очереди. Число шардов определяется из расчёта не более 1 Mb/s потока данных на шард. Число шардов указывается также в `queue_data` в поле `shards_num`.
  Однако оно не должно превышать 16 - максимального числа шардов.
  Пример того, что должно получиться:
  - [обычная очередь](https://a.yandex-team.ru/arc_vcs/taxi/dmp/dwh/replication_rules/replication_rules/accepted_eulas/accepted_eulas.yaml#L16)
  - [шардированная очередь](https://a.yandex-team.ru/arc_vcs/taxi/dmp/dwh/replication_rules/replication_rules/processing/events.yaml#L107)
- Включите все таргеты **change_state** -> [init](drafts.md#init). Укажите **initial ts**, если не хотите прогружать историю с самого начала. Рассчитайте его следующим образом:
  - перед началом миграции запомните дату последней репликации
  - вычтите из этой даты 3 часа
  - укажите полученное значение в поле **initial ts**

### Как изменить количество шардов очереди? {#queue_sharding}
- Аналогично [инструкции](#queue_migration) по миграции очереди на новый кластер, исключая изменения, связанные с указанием нового кластера в ПРе

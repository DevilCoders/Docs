# Обзор

Сервис предоставляет декларативный способ описания потоков данных:
Источник [Source] (БД или внешнее API) -> Очередь Сырых Событий [RAW Queue] -> Потребители [Target].

## Общая схема { #architecture }

![Архитектура](_images/architecture.png "Архитектура")

## Источник { #source }
**Источник [Source]**
  - [База данных](../../sources/sources.md): MongoDB, PostgreSQL, MySQL, Oracle и т.д.
    Пользователь выдает репликации доступ к секретам, описывает свои правила в формате yaml,
    после чего репликация самостоятельно сможет читать данные из БД и записывать в очередь
  - Любой внешний источник - когда конкретный сервис из внутреннего контура Яндекса
    отправляет данные напрямую в API репликации, чтобы те были доставлены до очереди.
    Например, для интеграции с salesforce

### Репликация инкрементом { #replicate_by }
[Подробнее](../../sources/sources.md#table), для каких источников какие типы поддержаны.
В правиле указывается как `replication_type: queue`.
Режим подходит, если на источнике происходят постоянные обновления (большой поток изменений)
и база будет неограниченно расти в размерах.

{% note info %}

Репликация инкрементом на данный момент не подразумевает фиксирование **удалений** в конечных таблицах. Если это нужно, можно предварительно помечать удаления отдельным флагом на истонике, либо хранить их в отдельной таблице. Или можно перейти на репликацию **снапшотом** для маленьких таблиц.

{% endnote %}

#### Репликация по дате
Необходимо наличие на источнике поля для репликации. По нему сервис будет выбирать новые записи.
- Поле монотонно возрастает и должно обновляться при любом апдейте на источнике, иначе записи могут быть частично потеряны
- Поле должно быть датой со временем в `UTC`, запросы в базу вида `where updated_at > last_known_updated_at`. Если поле с таймзоной,
то все будет хорошо автоматически. Если без - в правиле нужно явно указать таймазону.
Если это не указать - графики будут показывать ложное оставание репликации от настоящего момента, например, минус 3 часа, если источник хранил время в MSK.
- Типичное имя для поля updated_at (если записи на источнике изменяемые) или created_at (если неизменяемые)
- Если данных на источнике много (десятки или сотни гигабайт) желатально иметь поле created_at. Это нужно в основном для партиционирования [YT RAW](#raw).


{% note info %}

По полю репликации необходимо иметь **индекс**, про это смотри [ниже](#requirements)

{% endnote %}


#### Репликация по целому integer
Особенности:
- Поле должно быть целым числом (`integer`), запросы в базу идут вида `where id > last_known_id`


### Требования к источнику { #requirements }
#### Индекс по полю репликации
- По полю необходимо иметь **индекс**, для скорости и чтобы не нагружался источник при чтении в силу запросов в базу
- Требования к индексу:
  - поле репликации updated_at должно быть не **nullable**, иначе запрос может работать не оптимально, пробуя при первом включении выгрузить всю базу
  - пример для постгреса `CREATE INDEX ON my_table (name) WHERE name IS NOT NULL`
  - индекс нужен по timestamp, а не по округлению updated_at по дате
  - для `VIEW` часто индексы нижележащих таблиц не работают, возможно стоит переписать запрос view и перед включением проверить как это будет работать
- Если в качестве репликации выступает не просто таблица, а какой-то SQL запрос
(см. `raw_select` для некоторых источников - см. описание источников, это способ написать кастомный запрос в базу)
или вьюха (`VIEW`), нужно также убедиться, что
при обновлении любой части этого запроса будет триггериться обновление поля репликации. Для `postrgresl` можно, например, написать триггер
- Также известна проблема долгих транзакций на источнике: обновление поля репликации должно иметь значение NOW именно на конец транзакции для получения максимальных гарантий

#### Ключевые колонки { #primary_key }
Необходимы для дедубликации. Обычно указаны как primary_key в виде списка строк в yaml-правиле.
Если на источнике их по какой-то причине нет, есть 2 варианта:
- Завести их на источнике
- Выбрать искусственно, учитывая, что 2 записи с одним primary key схлопнутся в очереди репликации в одну

{% note warning %}

Ключевые колонки также необходимы и для режима снапшот.

{% endnote %}

### Снапшот {#shapshot}
В правиле указывается как `replication_type: queue_snapshot`.
Режим подходит, если на источнике не происходит неограниченного роста числа записей, то есть
рост чем-то физически ограничен. Например, он зависит от числа стран.
Также не рекомендуется использовать режим для баз `>5MB`, так как в этом случае репликация
будет работать очень медленно. Для таких баз рекомендуется все же добавить поле репликации.


## Очередь { #queue }
**Очередь Сырых Событий [RAW Queue]** - это буфер данных в виде as is из источника, или,
иначе говоря **RAW** данные.

* В **RAW** автоматически попадают все новые колонки на источнике.
* Репликация, на данный момент предоставляет 2 типа реализации RAW хранилища:
  - Временный буфер - очередь для стриминга. В текущей реализации - это **MongoDB** инсталляции MDB с доступом через API репликации на запись и чтение.
    Используется для поставки данных другим **потребителям**
  - Постоянный: холодное хранение данных/бекап/RAW слой. Стандартная имплементация:
    **YT RAW** в виде 1 таблицы или партицированной по годам/месяцам/дням.
    Используется как технический слой для построения других таблиц, либо как архив или бекап

### YT RAW { #raw }
- [**YT RAW**](generated-targets.md)
- [**YT RAW History**](yt_raw_history.md)


## Потребители { #target }
**Потребители [Target]**: YT, YDB, Logbroker, любой другой сервис.
Вычитывается очередь сырых событий, выполняются трансформации (маппинг данных),
результат записывается в целевую БД (или любую другую сущность).

- [**YT Struct**](yt_target.md)
- [**YDB**](../../targets/ydb/ydb.md)
- [**EXT**](ext_targets.md) - произвольный читатель

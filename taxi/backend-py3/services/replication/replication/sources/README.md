# Документация для разработчиков по добавлению новых источников

Если документация не соответствует действительности, пожалуйста,
обратитесь в чатик поддержки репликации,
либо к мейнтенерам сервиса [репликации](https://wiki.yandex-team.ru/taxi/backend/datastorage/#chatpodderzhki).

## Расположение кода
* Конкретные реализации источников находится [здесь](https://a.yandex-team.ru/arc/trunk/arcadia/taxi/backend-py3/services/replication/replication/sources).
Сюда же нужно писать код новых источников.
* Тесты находятся [здесь](https://a.yandex-team.ru/arc/trunk/arcadia/taxi/backend-py3/services/replication/test_replication/sources).
Сюда же нужно писать тесты на новые источники.
* Базовые классы находятся [здесь](https://a.yandex-team.ru/arc/trunk/arcadia/taxi/backend-py3/services/replication/replication/foundation/sources/base.py).
При создании нового источника от них нужно наследоваться. На данный момент, самый актуальный способ заведения источника - отнаследовать его от **BaseSourceReader**.

## Добавление нового источника
Далее вместо **{type}** следует вставить имя вашего источника.
1. Структура заведения источника:
    * Завести новую папку **replication/replication/sources/{type}**
    * Создать там файл **definitions.py** - здесь будет основной код источника.
    * Создать **pytest_plugin.py** - плагин для pytest.
    * Создать **{type}.yaml**:
        * **schema** - тут описывается кастомная схема, которая проверяет
        значения в поле **source** у правила, а также это значение приходит
        как **raw_meta** в коде.
        * **pytest_fixtures_depends** [optional] - список автоподключаемых фикстур
        из **pytest_plugin.py**.
    * Создать файл **_docs/docs.md** (обязательно с нижнего подчеркивания, иначе он не подключится) и
      явно подключить его в файле **replication/replication/sources/sources.md**. Это будет
      автоматически прорастать в документацию сервиса.
    * Завести новую папку для тестов **replication/test_replication/sources/{type}**.
      В ней создать файл **static/replication.yaml**
      с описанием где локально расположены правила, а также положить сами правила рядом.
      Будущие тесты источника будут находиться здесь.
2. Для регистрации источника достаточно в **definitions.py** объявить следующий хук:
    ```
    @pluggy_manager.hookimpl
    def replication_source_register(source_collector):
        source = source_builder.SourceDefinition(
            {type},
            source_info_getter=_source_info_getter,
        )
        source_collector.register(source)
    ```
    **source_info_getter** - это итератор,
    который будет порождать конкретные источники, его нужно объявить самостоятельно.
    Первый аргумент **source_info_getter** - тот самый **raw_meta**, который вы разрешили
    задавать в схеме для конкретного источника. А также, ряд опциональных аргументов,
    но о них подробнее написано ниже.
    Функция должна итерировать через **yield** объекты **source_builder.IndividualSource**.
    Первый аргумент **IndividualSource** - класс-будущий источник.
    Второй - произвольный объект, созданный на основе **raw_meta**.
    Этот объект станет доступен как **self.meta** в вашем источнике.
    Функция должна вернуть более одного объекта,
    только если это разные шарды одного источника
    (в этом случае их репликация будет запускаться параллельно,
    но писать в одну очередь).
    Если шардов у источника не может быть более одного, то нужно вернуть 1 объект,
    если же источник может быть шардирован, каждый шард должен иметь уникальное имя,
    которое нужно обозначить в **IndividualSource.source_unit_name**.
    Хороший пример имен: **shard0**, **shard1**, ...
    Порядок здесь важен, так что нужно возвращать шарды, начиная с первого.
    Далее этот параметр попадет в **source.base_meta.unit_name**.
3. Доступные параметры **source_info_getter** (без необходимости их не нужно указывать):
    * **raw_meta** - входной документ из yaml правила поля source.
      Без базовых полей, но они доступны с помощью параметра **base_source_meta**.
    * **base_source_meta** - тут будет базовый класс **replication.foundation.declarations.BaseSourceMeta**.
    * **secdist** - секреты сервиса, тут нужно парсить коннекты.
    * **imitate_secrets** - bool параметр, принимающий True только в тестах правил.
      Нужен, чтобы переопределить **secdist** для реальных правил.
4. Как писать код **BaseSourceReader**
    * В коде есть полезные комментарии по использованию классов-конструкторов.
    * Вам нужно определить только то,
    что источник делает при получении левой и правой границ (которые могут быть опциональными,
    например, если источник только что был инициализирован).
    * Чтобы завести источник вида **BaseSourceReader**, вам нужно сделать некоторое действие,
    по переопределению **base_source_meta**. Выглядеть будет как-то так:
        ```
        def _base_meta_override(base_source_meta, raw_meta):
            return [
                declarations.BaseMetaParam(
                    name='iteration_type', value=consts.IterationType.INTERNAL,
                ),
            ]
        ```
        Далее нужно отдать функцию в `SourceDefinition(..., base_meta_override=_base_meta_override)`.
        Это также равносильно тому, что в вашем правиле будет явно указано:
        ```
        source:
            iteration_type: internal
        ```
    * Наилучший пример сейчас: **mysql/../MultipleDatesMysql**
    * Метод **get_reader** - это итератор, возвращающий **replication.foundation.sources.cursor.Cursor**.
5. Другие важные детали:
    * В **self.meta** вашего класса источника будет доступна вся информация,
    которую вы положите в IndividualSource вторым параметром.
    Это нужно, чтобы кастомизировать источник по полям в yaml-правиле.
    * Метод **normalize_stamp** нужно обязательно переопределять в источнике,
    если источник работает не только с наивными UTC датами (datetime.datetime).
    Он принимает дату как есть из источника из поля replicate_by.
    Вернуть он должен наивную UTC дату.
    Если репликация не по дате, этот метод трогать не нужно.
    * **Все принимаемые и возвращаемые источником даты**
    (кроме дат в самих документах)
    **должны быть наивными UTC датами** (datetime.datetime).

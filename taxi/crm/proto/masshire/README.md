# Модуль поиска

Предполагаем, что на начальном этапе рекрутер через модуль поиска может:

* залогиниться на работные сайты
* поискать подходящих кандидатов с корректной поддержкой ранжирования, пагинации и объединения резюме с разных сайтов
* открыть контакты для резюме, причём для объединённых резюме можно выбрать, с какого именно сайта открывать контакты
* взять кандидата "в работу" в рамках одной из поддерживаемых внешних подсистем

## Аутентификация

* Аутентификация между фронтендом и бэкендом – TVM service ticket, который лежит в метаданных каждого запроса по ключу `X-Ya-Service-Ticket`.
* Аутентификация рекрутера – TVM user ticket, который лежит в метаданных каждого запроса по ключу `X-Ya-User-Ticket`.

## Логин на работные сайты

Рекрутер в UI может подключить работные сайты.
Для каждого сайта есть кнопка для подключения.
По нажатию на кнопку или показывается всплывающее окно или открывается новая вкладка.
В этом окне можно дать права доступа для нашего приложения
(предполагаем, что у нас есть свои приложения в терминах OAuth для каждого поддерживаемого сайта).
После этого происходит редирект на какой-то наш сайт.
В идеале, после этого мы должны показать "Спасибо, доступ получен" и закрыть окно.
Для этого:
* (фронт) забираем auth code из URL
* (бэк) размениваем его на токены
* (бэк) сохраняем в соответствующую таблицу рядом с логином рекрутера

## Поиск

При каждом первичном поиске идём параллельно на все работные сайты.

### Ранжирование

Для ранжирования по времени обновления или ожидаемому доходу мы можем сделать сквозное ранжирование между разными работными сайтами, поэтому проблем быть не должно.

Для ранжирования по "релевантности" нужно смотреть.
Сквозную релевантность мы придумаем вряд ли.
Можно показывать разные работные сайты по очереди.

Можно в рамках страницы переупорядочивать по наличию открытых контактов, потом по стоимости открытия. Если упорядочивать по стоимости открытия, то SuperJob в рамках каждой страницы будет выше HH.

### Пагинация

Считаем, что все "лишние" результаты от первичного поиска мы складываем в курсор.
Тогда при запросе очередной страницы мы распаковываем сохранённые результаты, при необходимости делаем дозапросы на работные сайты, и формируем ответ.

### Объединение результатов

Результаты от разных работных сайтов объединяются в рамках одной страницы выдачи.
Объединение на уровне БД никак не сохраняется.
Пока считаем, что для объединения достаточно сравнить карточки из СЕРПа.
В дальнейшем, возможно, для разрешения неоднозначностей понадобятся дополнительные запросы за полными карточками.
Например, дата рождения у SJ есть прямо в карточке СЕРПа, а у HH только в полной карточке.

## Открытие контактов

К каждому резюме приписан идентификатор, который позволяет совершать с ним дальнейшие операции.
Пока считаем, что это будет URN, где разные `<NID>` соответствуют разным работным сайтам – `urn:hh:...`, `urn:sj:...` и так далее.
Этот идентификатор используется для получения полного резюме, для открытия контактов для данного резюме и чтобы взять резюме в работу.
Таким образом, рекрутер всегда взаимодействует с резюме с конкретного работного сайта.
При открытии контактов в БД сохраняется маппинг из идентификатора в открытые контакты + резюме в виде BLOB-а.

## "Взять в работу"

Интеграция для "взять в работу" пока должна делаться для каждого клиента по отдельности.
При нажатии на "взять в работу" рекрутер выбирает в какую подсистему и с какими параметрами он хочет взять кандидата в работу.
После этого в выбранной подсистеме создаётся "претендентство" для кандидата в терминах подсистемы.
Это может быть "сделка" в терминах amoCRM или новый тикет в определённой очереди Трекера.
Внутри БД сохраняется связь между идентификатором резюме и созданным претендентством, а также его статус.
В фоне при этом должен работать процесс, который по таймеру проверяет статус претендентств и обновляет статус в БД.
Текущий известный статус претендентства возвращается для каждого резюме, чтобы рекрутеры не брали в работу кандидата одновременно.

В принципе, если подсистема устроена достаточно просто, то можно рассмотреть вариант с тем, чтобы забирать статусы даже тех претендентств, которые не были созданы через модуль поиска.

## Что и как хранится в БД

### Что хранится

* маппинг из идентификатора в контакты + краткое/полное резюме
* тройки (идентификатор, претендентство, статус)
* токены для рекрутеров

<details><summary>Пример (не-Enum классы соответствуют таблицам):</summary>
<p>

```python
class Resume:
  urn: str
  contacts: bytes
  resume: bytes
  created_at: datetime
  updated_at: datetime

class ApplicationSubsystem(Enum):
  AMO_CRM = 1
  CROWD = 2

class ApplicationStatus(Enum):
  OPEN = 1
  CLOSED = 2

class Application:
  resume_urn: str
  application_subsystem: ApplicationSubsystem
  application_id: str
  application_status: ApplicationStatus
  created_at: datetime
  updated_at: datetime

class JobSite(Enum):
  HEAD_HUNTER = 1
  SUPER_JOB = 2

class Token:
  recruiter_login: str
  job_site: JobSite
  valid_until: datetime
  access_token: str
  refresh_token: str
```

</p>
</details>

### Откуда берётся

* при **каждом поиске** в БД сохраняются все результаты из СЕРПа с открытыми контактами
* при **открытии контактов** в БД сохраняются открытые контакты + полное резюме
* при **"взять в работу"** в БД сохраняется факт претендентства для контакта
* (**в фоне**) статус претендентства для контактов обновляется
* (**в фоне**) подтягиваются открытые контакты из доступных подсистем (amoCRM, Крауд)

## Обработка ошибочных ситуаций

В общем случае для обработки возникающих ошибочных ситуаций используется стандартный механизм через gRPC статус + сообщение об ошибке. То есть, если с точки зрения сервиса, при вызове возникла ошибка, то вернётся [код ошибки][errors1] + какое-то вспомогательное сообщение.

Для ручки поиска нужен специальный подход, потому что мы хотим возвращать ответ с части работных сайтов, даже если на других возникли ошибки. Поэтому для ручки поиска (и только для ручки поиска) заведены вспомогательные сообщения с ошибками от отдельных работных сайтов.

Для всех других ручек (получение полной информации, открытие контактов, etc.) используется стандартный механизм gRPC.

Для некоторых ручек это может создавать неоднозначность. Например, для ручки открытия контактов код `PERMISSION_DENIED` может означать как отсутствие доступа к модулю поиска, так и недостаточные права для открытия контактов на работном сайте. На первом этапе эту неоднозначность предлагается игнорировать и сформулировать какое-то общее собщение об ошибке вида "Ошибка доступа. Убедитесь, что у вас разрешён доступ к работному сайту %JOB_SITE% на вкладке с доступами".

Если в дальнейшем возникнет необходимость снять эту неоднозначность, то можно будет поддержать [расширенную модель][errors2] обработки ошибок и передавать дополнительные детали в специальном заголовке.

[errors1]: https://grpc.io/docs/guides/error/#error-status-codes
[errors2]: https://www.grpc.io/docs/guides/error/#richer-error-model

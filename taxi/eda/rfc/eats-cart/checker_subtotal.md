# Чекер проверки максимальной стоимости

## Текущая организация чекера Subtotal
В настоящий момент в чекере `ShopThresholdCartChecker` осуществляется проверка на то что `subtotal` корзины не превосходит значений, указанных в конфиге `EDA_CORE_CART_TOTAL_LIMITS` в поле `shop` в зависимости от валюты, используемой в стране.

Данный чекер выполняется если выполнены следующие условия:
- `place != NULL` - плейс был найден
- `brand != NULL` - у плейса указан бренд (необхрдимо так как в нем лежит информация о `business_type`)
- `business_type == shop` - это магазин
- Далее выполнено одно из следующих условий:
    - `pickup_type == not_specified` - тип сборки не указан
    - `pickup_type == our_pickup` - наша сборка и `payment_type == checkout || payment_type == checkout_dedicated`
    - `pickup_type == shop_pickup` - сборка магазина и `payment_type == bank`


### Расшифровка способов сборки:
- `not_specified::not_specified`: Не указано
- `our_pickup::checkout`: Наш пикап, оплата на кассе: мастер покупок
- `our_pickup::checkout_dedicated`: Наш пикап, оплата на кассе: выделенный сборщик
- `our_pickup::bank`: Наш пикап, оплата через банк
- `shop_pickup::checkout`: Пикап магазина, оплата на кассе
- `shop_pickup::bank`: Пикап точки, оплата через банк


## Текущая организация проверки оплаты наличными
Проверка оплаты наличными сейчас выполняется в 3-х местах:
1. При выполнении `PlaceChecker` 
    - проверяется, что есть указатель на `place`
    - проверяется, что `place` сейчас доступен
    - получается `DecimalTotalWithoutPromo` из которого вычитаются купоны, если они имеются
    - проверяется метод оплаты: если оплата наличными, то в конфиге `EDA_CORE_CART_TOTAL_LIMITS` в поле `cash` в зависимости от валюты, используемой в стране, берется максимальное значение, которое может быть оплачено и сравнивается с `DecimalTotalWithoutPromo`

2. При построение ответа коры related_data.

    В классе `CartRelatedDataBuilder` при выполнении метода `build` запрашивается информация о `place`, при построение информации о котором, проверяется доступность оплаты наличными, где в случае возможности оптатить наличными, максимальная суммы оплаты берется из конфига `EDA_CORE_CART_TOTAL_LIMITS` из поля `cash` в зависимости от валюты.

3. При запуске `CashAmountConstraintValidator`.

    При выполнении данного валидатора вызывается объект класса `CashSettingsChecker`, в котором проверяется превышен ли лимит оплаты наличными или нет. Значения для лимита берутся из `EDA_CORE_CART_TOTAL_LIMITS` из поля `cash` в зависимости от валюты.

## Реализация чекера в новой корзине
Необходимо определить суловия применения чекера, для этого сделаем завпрос в базу `shop_operational_settings` и посмотрим существующие комбинации `pickup_type` и `payment_type` и их количество.
```
SELECT pickup_type, payment_type, COUNT(*)
FROM hahn.`home/eda-dwh/ods/bigfood/shop_operational_settings/shop_operational_settings`
GROUP BY pickup_type, payment_type;
```
Получаем результат выполнения `SELECT` и видим, что в базе содержатся только записи, которые всегда удовлетворяют одному из условий выполнения чекера `Subtotal`.

number | pickup_type | payment_type | sum 
------ | ----------- | ------------ | ----
1 | "not_specified" | "not_specified" | 11646 
2 | "our_pickup" | "checkout" | 1202 
3 | "our_pickup" | "checkout_dedicated" | 1496 
4 | "shop_pickup" | "bank" | 4798 


Сделаем предположение о пренебрежении необходимостью проверки на тип сборки и информацию о сборщике, так как в таблице нет записей, на которых чекер не был бы применен.

Логически в исходном чекере проверяется `subtotal` без учета скидок. По результатм проблем, обнаруженных в ходе дежурства, было принято решение применять чекеры к сумме айтемов с учетом скидки.

Общий алгоритм проверки чекера будет иметь вид:
```
total_limit = GetCartTotalLimit("EATS_CART_TOTAL_LIMITS", business_type, country_code);
if (cart_promo_subtotal > total_limit) {
    throw exception;
}
```
Код будет вызаваться не только при запросе `lock_cart`, но и в слое `restrictions`, который не будет давать возможность добавить айтемы, если лимит корзины превышен.

Вместо текущего конфига `EDA_CORE_CART_TOTAL_LIMITS` объединить все дефолтные значения о проверке лимитов стоимости в один конфиг `EATS_CART_TOTAL_LIMITS`, о проверки числа айтемов в другой конфиг `EATS_CART_ITEMS_LIMITS`.

## Изменения в коде коры
Так как чекер проверки максимальной стоимости корзины для магазинов теперь будет реализован в `eats-cart`, то из коры он будет удален.

После обсуждения с командой ОПГ выяснили, что проверка доступности оплаты наличными для `place` в чекере `PlaceChecker` сейчас не вызывается, так как она применялась только для старого чекаута. На новом чекауте, появились проверки перед переходом на go-checkout и теперь до чекера `PlaceChecker` доходит уже актуальная информация. так же судя по логам з доступное время, исключений со сработанным чекером проверки оплаты наличными нет. Следственно проверку на `cash` можно удалить из чекера `PlaceChecker`.

Для построения объекта коры `related_data` требуется информация о возможности оплать в этом `place` заказ с текущей корзиной. Эту проверку предлагаю перенсти в `eats-payments` и выполнить в рамках задачи https://st.yandex-team.ru/EDAORDERS-7798 

Валидатора `CashAmountConstraintValidator` используется в момент изменения заказа после его создания. Останется работать без изменений.

Удалить из конфига `EDA_CORE_CART_TOTAL_LIMITS` информацию о `shop`, так как эта проверка будет теперь в корзине.

# Взаимодействие между корзиной и чек-аутом

## Pre-Checkout
До чек-аута все запросы обрабатываются хендлерами `/api/v1/cart`.

Пользователь собирает корзину, далее нажимает кнопку "Оплатить".

## Checkout
Вообще говоря, все запросы, приходящие из чек-аута коры на корзину, обрабатываются internal ручками.
Планируются следующие ручки:
* `POST /api/v1/lock_cart` -- отдать корзину на текущий момент, заблокировать корзину для последующих изменений.
* `POST /api/v1/set_order` -- присвоить корзине номер заказа `order_nr`; с этого момента пользователь будет собирать новую корзину.
* `POST /api/v1/cancel_order` -- разблокировать корзину для изменений в случае отмены заказа; содержимое корзины не изменяется.

### Последовательность действий после нажатия "Оплатить":
1. Происходит переход пользователя на чек-аут, из коры вызывается хендлер `POST /api/v1/lock_cart`. 
2. В этот момент корзина для данного `eats_user_id` блокируется для последующих изменений в пределах интервала, заданного в конфиге `eats_cart_timeouts.checked_out`.
При этом `GET /api/v1/cart` отдает 200 вместе с содержимым корзины на момент заказа. Хендлеры `/api/v1/cart`, изменяющие состояние, отдают 400 до истечения таймаута или снятия блокировки.
3. В коре вызываются валидаторы для проверки содержимого корзины.
4. Далее возможны варианты:
    1. Проверки пройдены успешно
        * В коре создается заказ
        * Вызвается  `POST /api/v1/set_order`, в теле передается `cart_id, order_nr`.
        * В eats-cart корзине присваивается `order_nr`, отображение `eats_user_id -> cart_id` удаляется.
    2. Проверки завершились неудачей
        * Заказ не создается
        * Вызвается  `POST /api/v1/cancel_order`, в теле передается `cart_id`
        * Корзина в eats-cart стает доступна для модифицифрующих ручек `/api/v1/cart`.
    3. Ни одна из ручек `set_order` или `cancel_order` не была вызвана, и время `eats_cart_timeouts.checked_out` истекло. 
    При следующем модифицирующем запросе, корзина автоматически разблокируется. Репортится сообщение о том, что таймаут был превышен.

### Edge Cases:
* `/api/v1/lock_cart` вызывается повторно в пределах таймаута с момента первого вызова -- 200
Наличие одного заказа по корзине гарантируется уникальным индексом по полю cart_id в таблице `orders` в коре. Корзина в данный момент заблокирована, содержимое отдается такое же, как и при первом вызове. Время начала отсчета не изменяется.
* `/api/v1/lock_cart` вызывается повторно, но таймаут вышел -- 200
Если мы поняли, что таймаут вышел, значит блокировка не была снята модифицирующим запросом. Содержимое по сравнению с первоначальным вызовом не изменилось. Репортится сообщение о превышении таймаута, время начала отсчета обновляется, лок берется заново на время `eats_cart_timeouts.checked_out`.
* Если таймаут вышел, далее произошло какое-то изменение, далее вызывается `/api/v1/lock_cart`, то для ручки `lock_cart` это останется незамеченным.
* `/api/v1/set_order` вызывается после истечения таймаута, но до этого вызовов `set_order` не было -- 200
Независимо от того, были ли изменения между окончанием таймаута и вызовом `set_order`, корзине присваивается `order_nr`, связь `eats_user_id`-`cart_id` удаляется.
* `set_order` вызывается повторно для того же `cart_id` -- 400
Вернется ошибка независимо от того, пришел ли повторный запрос с тем же `order_nr`, что и в первый раз, или с другим.
* `cancel_order` вызывается несколько раз/после окончания таймаута -- 200
Если корзина залочена, она будет разблокирована. Если не залочена, ничего не призойдет.
* Сначала вызывается `set_order`, после нее вызывается `cancel_order` -- 200, `cancel_order` игнорируется. 
Считаем, что `set_order` переводит корзину в терминальное состояние без возможности отмены.
* Сначала вызывается `cancel_order`, после этого вызыввается `set_order` -- 200
Происходит все то же, что и в штатной ситуации -- в независимости от наличия изменений между `cancel_order` и `set_order` 
корзине присваивается `order_nr`, связь `eats_user_id`-`cart_id` удаляется.


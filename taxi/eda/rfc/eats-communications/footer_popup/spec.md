## Задача
Локальная задача: предупреждать юзера о скором окончании работы магазина, чтобы
он успел оформить заказ

Более глобальная задача: давать возможность коммуницировать всплывающими
сообщениями с юзером в футере.

Еще более глобальная задача: давать возможность отправлять на клиенты любые
сообщения

PRD: https://wiki.yandex-team.ru/users/apykhtinn/closing-notice/

## Out of scope
- при неожиданной отмене ASAP-доставки мы не будем отправлять сообщение об этом
  - мотивация такая, что сейчас на партнерской сборке таких проблем нет (ASAP
  доступен всегда)
- пока делаем коммуникацию только по определенному времени, других триггеров
  пока не планируется (нет понимания, что нужно)
- тут никак не учитываются слоты, потому что юзер в Ритейле выбирает их на этапе
  чекаута, и при сборке корзины мы про них ничего не знаем.
- для десктопа нет дизайна, поэтому не описываем

Изначально хотелось использовать client-events, но полноценно его затаскивать
сложно (долго), поэтому на первом этапе хочется поддержать его только на
клиентах, а на беке сделать эмуляцию в `eats-catalog`.

## Решение (эмуляция client-events)
Идея: в `eats-catalog` сделать ручку `v1/place_events`, которая будет работать
максимально приближенно к `v1/pull`
(https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/Uservices/client-events/api/pull/).
Клиенты будут ходить в эту ручку через `api-proxy`. И при необходимости,
добавить события от `client-events` в эту ручку можно будет относительно просто.

#### Логика бекэнда
- клиент идет в `eats/v1/pull` в апи-прокси:
```json
{
    "service": "eda_client",
    "channels": ["place_slug:lenta_hmcoe"],
    "events": [  // уже увиденные клиентом события
        {
            "event": "footer_warning",
            "event_id": "lenta_hmcoe:30_min_warning",
            "version": "1654700698"
        }
    ]
}
```
- клиент асинхронно вызывает ручку `v1/pull` при заходе на слаг, чтобы сразу
  показывать попап о закрытии, если он есть. И начинает ее поллить (см. ниже)
- клиент сейчас поллит эту ручку только на экранах, где может показаться футер.
  Интервал поллинга берется из поля "polling_delay" в ответе. В дальнейшем
  предполагается, что на клиентах будет несложно добавить поллинг этой ручки и
  для других экранах, где нужны будут события.
- эта прокси-ручка идет в `eats-catalog` в `v1/place_events`, которая:
    - вычисляет время закрытия магазина
    - на Х часов в прошлое отдает прошедшие сообщения о закрытии, за некоторые
      интервалы до закрытия (интервалы берутся из конфига 3.0, условно 30/15/5
      минут)
    - отдает ответ в формате `client-events` (см. ниже)
    - если клиент знает событие (передал его на вход), то это событие не
      отдается в поле `updated` (так же должен работать и `client-events`).
      Событие определяем по (`event`, `event_id`, `version`). Version учитываем
      на случай, если время работы магазина изменится, и будет новое событие с
      тем же `event_id`. Сейчас бек в `version` будет присылать таймстемп
      закрытия магазина, поэтому при изменении времени закрытия - бек отдаст
      новое событие.
    - если знакомое клиенту событие истекло (т.е. наступило более позднее
      событие, или магазин закрылся), отдает его в поле `expired` (так же должен
      работать и `client-events`)
    - источником данных для времени работы магазина будет сам `eats-catalog`
    - закрытый магазин не учитываем (если магазин закрылся раньше времени своего
      расписания)
    - если магазин круглосуточный (критерий: работает до 24 и начинает работать
      с 0) - плашку показывать не нужно никакую, соответственно события не надо
      генерировать.
    - если запрошено количество `place_slug`ов больше, чем лимит (конфиг,
      допустим 10), то обрезаем до лимита (чтобы нельзя было получить стейт всех
      ресторанов сразу)
    - поля `show_for_sec` и `show_for_sec_without_cart` берутся из эксперимента,
      но ограничиваются периодом наступления следующего события (или окончания
      работы магазина). То есть, если до следующего события остается 5 секунд,
      то `show_for_sec` вернется 5 секунд, и `show_for_sec_without_cart` - тоже
      5 секунд.
    - если до окончания показа попапа осталось бы меньше чем `min_show_for_sec`
      (из эксперимента), то не возвращаем попап. В следующий раз клиент увидит
      уже следующий попап, и не покажет старый (ожидаемое поведение)
    - на клиент надо отдавать только самое последнее событие (то есть, если
      клиент зашел за минуту до закрытия, отдавать надо только один попап про 5
      минут, а не два 5 и 15)

Запрос из прокси-ручки `eats/v1/pull` в `eats-catalog` в `v1/place_events`:
```json
{
    "service": "eda_client",
    "channels": ["place_slug:lenta_hmcoe"],
    "events": [
        {
            "event": "footer_warning",
            "event_id": "lenta_hmcoe:30_min_warning",
            "version": "1654700698"
        }
    ]
}
```

Ответ от `v1/place_events` (он же сейчас и будет прокидываться клиенту):
```json
{
    "polling_delay": 30,
    "events": {
        "updated": [
            {
                "event": "footer_warning",    // Будет приходить один ивент этого типа за раз
                "event_id": "lenta_hmcoe:15_min_warning",
                "version": "1654700698",      // Таймстемп закрытия магазина
                "channel": "place_slug:lenta_hmcoe",
                "payload": {
                    "deduplication_key": "15_min_warning",
                    "show_for_sec": 6,
                    "show_for_sec_without_cart": 600,  // Сколько показывать в случае если нет корзины
                    "content": {
                        "type": "themed_footer_popup_text",
                        "text": "Магазин закроется в 20-00",
                        "color": {
                            "light": "#FF00FF",
                            "dark": "#FF00FF"
                        },
                        "background_color": {
                            "light": "#FF00FF",
                            "dark": "#FF00FF"
                        }
                    }
                }
            }
        ],
        "expired": [
            {
                "event": "footer_warning",
                "event_id": "lenta_hmcoe:30_min_warning"
            }
        ]
    }
}
```

#### Логика клиента
- клиент дедублицирует полученные события по составному ключу (`event`,
  `event_id`, `version`, `payload.deduplication_key`), чтобы не показать
  повторно одни и те же события. `payload` берется из последнего пришедшего
  сообщения с таким ключом.
    - [справочно] Дедупликация нужна для того, что если бек будет пушать в
      `client-events` лишние сообщения, то они не показывались несколько раз на
      клиентах. Сейчас такого быть не может, но может в будущем - лучше сразу
      заложить это. В `client-events` такой логики нет, поэтому ее правильнее
      всего сделать на клиентах.
- клиент показывает сообщение сразу. Подразумевается, что оно придет одно в
  ответе бека. Если придет больше чем одно - показываем последнее.
- если во время показа прошлого сообщения пришло новое - старое закрываем,
  показываем новое.
- клиент держит сообщение показанным не дольше "show_for_sec" секунд.
- если пришло поле `show_for_sec_without_cart`, то, в случае отсутствия
  набранной корзины, показываем попап на это время (сделано, чтобы можно было
  держать этот попап "вечно", как в PRD). Если корзина появилась - переключаемся
  на время показа из `show_for_sec`
- если в `show_for_sec` или `show_for_sec_without_cart` пришло `0`, то не
  показываем попап, но запоминаем что он был.
- клиент удаляет у себя события из поля "expired", и забывает про них (также не
  показывает их в будущем)

### Важные замечания по реализации на клиенте
- Клиент хранит полученные события типа "footer_warning", пока юзер находится на
  экране магазина (главная магазина, меню магазина, корзина, карточка товара,
  открытые сториз и другие экраны во флоу магазина). Как только юзер уходит -
  ивенты забываются (то есть не передаются на вход в ручку `pull`), и при
  следующем заходе на магазин клиент получит новые ивенты, как будто зашел
  заново. Зачем это сделано - чтобы юзер увидел релевантные сообщения о закрытии
  при заходе в магазин, но вместе с тем чтобы его не спамить при переходах между
  экранами магазина/корзины.
- Клиент запоминает время окончания показа сообщения, и если приложение
  сворачивается/разворачивается, то время окончания показа не должно меняться.

В целом, клиент должен работать, как будто он работает с ручкой
https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/Uservices/client-events/api/pull/
, чтобы можно было перейти на `client-events` без доработок.

### Возможности расширения
- [на будущее] Когда появится мультикорзина, можно будет сделать небольшую
  доработку на фронте, и запрашивать не текущий плейс, а все плейсы из
  мультикорзины, тем самым получая уведомления о закрытии всех плейсов. Каждый
  плейс надо будет делать отдельным каналом: "channels":
  ["place_slug:lenta_hmcoe", "place_slug:vkusvill_solnechnogorskaya_4s6"]
- [на будущее] если на прокси-ручке потребуется дополнить какие-то данные,
  например `eater_id`, это можно сделать через добавление нового канала
  `eater_id:123` в список запрашиваемых каналов

# Поддержка "экранов" и DivKit в eats-layout-constructor

## Задача

Решение задачи
["Поддержать виджет дивкита в LC"](https://st.yandex-team.ru/EDAJAM-420) и
схожего класса задач с добавлением новых "экранов" (шторки, страница ресторана
и т.п.) и добавлением виджетов DivKit в существующие/новые layout'ы.

## Краткое описание предложения

Предлагается внести два изменения в `eats-layout-constructor`:

- Добавить новую сущность - `screen` (Экран). Позволит добавлять в Layout
  Constructor другие экраны приложения (сейчас есть только Главный экран и
  "списки ресторанов").
- Добавить новый виджета - `DivKit` (Базовый виджет/класс). Позволит
  создавать новые виджеты на базе рендера `eats-divkit-render`. Это именно
  базовый класс/виджет, а не "самостоятельный" виджет, причины описаны ниже.

Два данных изменения стоит рассматривать вместе (комплексно), т.к. нацелены они
на решение общего класса задач. При этом их реализация планируется
параллельной, т.е. оба изменения не блокируют друг друга и могут
разрабатываться и запускаться независимо.

## Подробное описание предложения

### Добавление сущности screen

В текущей реализации `eats-layout-constructor` существуют только следующие
основные сущности:

- `layout` - определяет состав и порядок виджетов (`widget`) относительно друг
  друга на экране приложения. По-сути это "коробка" в которой виджеты идут
  вертикально один за другим.
- `widget` - отдельный виджет на экране приложения. Может быть: списком
  ресторанов, баннером, заголовком и т.п. Является "макрообъектом" и описывает
  именно тип виджета на экране, но не контент. Сам контент (рестораны, картинка
  баннера и т.п.) получается из третьего сервиса, например, `eats-catalog`. В
  терминах Layout Constructor такие "третьи сервисы" называются `source`.
- `meta widget` - дополнительная информация в отдельных виджетах (как правило
  только на карточках ресторанов). Является дополнительной информацией
  относящейся к конкретному элементу (ресторану, баннеру, т.д.) в конкретном
  виджете. В случае списка ресторанов, это может быть: рейтинг, ценовая категория
  (РРР), скидки, кнопки акция и т.п.

При этом все лейауты (`layout`) заточены и были изначально разработаны, в
основном, только для главного экрана. Т.е. они содержат набор виджетов который
логичен именно для главной (списки ресторанов, баннеры, фильтры), но при этом
могут быть не применимы на других экранах.

Для этого вводится новая сущность - `screen`.

`screen` - описывает отдельный экран приложения: главная, страница ресторана,
поисковая выдача, шторка (второй скрин ниже), и т.п. `screen` - родительский
элемент для `layout`'ов.

Главные отличие `screen` от `layout` в том, что он накладывает ограничения на
допустимые виджеты на данном экране, а также позволяет делать "дополнительные"
/ "субэкраны" (например шторки) в отдельных частях приложения.

При этом сам экран, который хочет получить клиентское приложение, определяет
сам клиент, вызывая соответствующий эндпоинт в `eats-layout-constructor`.

Т.е. при открытии главного экрана, приложение сделает запрос к
`/eats/v1/layout-constructor/v1/layout`, а открывая шторку к
`/eats/v1/layout-constructor/v1/bottom-sheet` (формат может измениться).

> Запрос на лейаут шторки (субэкранов) должен приходить именно в момент
> открытия шторки, а не "предзагружаться" для всех возможных шторок на старте
> приложения / открытии основного экрана.

> Если будет передан несуществующий тип `screen`, `eats-layout-constructor`
> вернет 404 с соответствующей ошибкой.

Сам формат клиентского ответа от Layout Constructor не изменится. `screen` не
будет фигурировать в ответе (или менять его структуру).

![Schema](./layout_constructor_divkit_screens.drawio.png)

Таким образом в Layout Constructor появится возможность заводить и описывать
любой экран и субэкран клиентского приложения.

> В будущем так-же предлагается ввести экрано-специфичные виджеты и специальные
> слоты (`socket`) для них. Это нужно для виджетов которые имеют строгую
> позицию на экране и не могут (и не имеют смысла) быть в общем списке
> виджетов. Например: главная картинка ресторана на странице ресторана, кнопки
> сверху экрана и т.п.
>
> Во многом это будет развитием идеи `static_widget`'ов, но с привязкой к
> конкретному `screen`'у.

В текущей реализации предлагается заводить `screen`'ы на уровне кода / yaml
конфигов, а не в адменке. Кол-во экранов в приложении лимитировано и заранее
известно, а также это позволит добавлять экрано-специфичные сокеты и виджеты в
будущем (когда приступим к их разработке).

В адменке Layout Constructor'а также появится сущность экрана, а каждый лейаут
будет явно связан с одним типом экрана (все текущие лейауты станут - `main`).

Будет добавлено поле "поддерживаемые экраны" во все виджеты. Чтобы сделать
"защиту от дурака" и не позволить вставить на экран (например "шторки
доставки") виджеты которые заведомо требуют контекста (параметров) с главного
экрана или не имеют смысла на другом экране.

При добавлении виджетов в лейаут, админка будет позволять добавить виджет
только подходящий для данного типа `screen`'а.

Данную защиту предлагается сделать именно на уровне кода (yaml деклараций
виджетов) или технических конфигов, а не в админке LC, чтобы предотвратить
возможность ошибочного изменения конфига менеджером.

```yaml
widget: places_collection

# ...

available_screens:
  - main
```

или

```yaml
widget: plus_banner

# ...

available_screens:
  - main
  - slug
  - bottom_sheet
```

В случае если всё же был ошибочно добавлен "неподходящий" виджет на экран,
после его отключения в конфиге, LC должен начать игнорировать его в layoyt'е и
просто пропускать (записывая в лог warn).

## Добавление виджета DivKit

В Еде появился
[сервис для рендера DivKit'ов - `eats-divkit-render`](https://a.yandex-team.ru/review/2331303/files/1).
Данный сервис позволяет рендерить виджеты с произвольной
([DivKit, технология Яндекса](https://wiki.yandex-team.ru/divkit/)) версткой и
отправлять их на клиент.

Для поддержки их в Еде, будет добавлен базовый виджет/класс в
`eats-layout-constructor`.

DivKit это именно рендер "общего назначения", он ничего не знает про контент
который будет рендерить. Из этого следует, что новый виджет не может (и не
должен) быть самостоятельным виджетом. Т.е. это будет именно базовый класс от
которого будут уже наследоваться новые виджеты, которые хотят использовать
отображение через DivKit.

Схема работы данного базового DivKit-виджета будет схожа с текущими виджетами:
нужно будет явно получить данные из `source` (или завести новый, при
необходимости) и передать эти данные в "рендер".

В момент вызова рендера, будет происходить сетевой запрос в сервис
`eats-divkit-render` со всеми необходимыми параметрами (полученными из `source`
или любого другого источника), а ответ от DivKit render'а будет возвращен "как
есть" на клиент (из поля `divjson`, пример ниже).

Клиентское приложение уже будет иметь на своей стороне "рендер" для `divjson` и
самостоятельно его разберет.

Предполагается что `eats-layout-constructor` осмысленно не будет ничего знать
про содержание и структуру поля `divjson` (из ответа `eats-divkit-render`),
оставляя этот домен во владении `eats-divkit-render`.

> В текущей реализации `eats-divkit-render` - отдельный от Layout Constructor
> сервис. Но в будущем, он может стать sidecar'ом или вовсе модулем LC.

> Было решено отказаться от идеи каждый раз заново реализовывать DivKit-base
> виджеты, т.к. сервис "общего назначения" и везде функционал взаимодействия с
> ним будет одинаковым, и удобнее его раз оформить в переиспользуемый класс.

Пример запроса и ответа в `eats-divkit-render`
(и [его API спецификация](https://a.yandex-team.ru/review/2337593/files/6)):

```http
## Request
POST http://divkit-render.eda.yandex.net/api/v1/render-widgets
Content-Type: application/json
{
  "theme": "dark",
  "widgets": {
    "cart_progressbar": [
      {
        "id": "foo-bar-12345",
        "titles": [
          {
            "text": "title",
            "color": "#fff"
          }
        ],
        "subtitles": [
          {
            "text": "subtitle",
            "color": "#fff"
          }
        ],
        "rewards": [
          {
            "title": {
              "text": "hello",
              "color": "#fff"
            },
            "progress": 0,
            "is_reached": false
          }
        ]
      }
    ]
  }
}
## Response
{
  "widgets": {
    "cart_progressbar": [
      {
        "id": "foo-bar-12345",
        "divjson": { /* ... */ }
      }
    ]
  }
}
```

Пример как может выглядеть базовый класс DivKit виджета:

```cpp
class DivKitWidget : LayoutWidget {
 protected:
  void RenderDivKit(formats::json::ValueBuilder& layout,
                    std::string&& type,
                    const divkit::Params& params);
}
```

Сервис `eats-divkit-render` уже поддерживает балковые запросы. Предполагается,
что Layout Constructor изначально будет собирать все обращения к нему (из
текущего лейаута), а затем высылать балковый запрос в сервис.

#### Альтернативные реализации

Были рассмотрены альтернативные варианты реализации DivKit-виджетов, но от
которых отказались.

##### Proxy-рендер

**Proxy-рендер** - отдельный сервис перед LC, который полностью получает
весь ответ LC и сам "выбирает" и рендерит нужные виджеты, заменяя их в выдаче.

**Плюсы**:

- Отдельный сервис, который может иметь сразу весь контекст выдачи.
- Можно сделать частью API-proxy (но весьма трудно выбирать нужные куски
  выдачи).

**Минусы**:

- Еще одна точка отказа перед клиентом.
- Через сервис будет проксироваться вся выдача, большая часть из которой ему
  не нужна.
- Трудно реализовать фолбек виджеты, которые могли бы заменить собой DivKit
  виджеты в случае отказа `eats-divkit-render`.
- Некоторым виджетам будет недостаточно контекста только из "клиентской" выдачи.
  Нужно будет дополнительно придумывать контекст только для render.

##### DivKit-сервис который сам знает про контент

По-сути это отказ от идеи прокидывать данные из source'ов LC в
`eats-divkit-render`. Т.е. сам сервис `eats-divkit-render` должен знать откуда
получить данные для виджетов и сделать сетевой поход.

**Плюсы**:

- Не нужно писать код виджета в два разных сервиса. `eats-divkit-render` может
  инкапсулировать всю логику виджетов в себе.

**Минусы**:

- Дополнительные / дублирующие сетевые походы за данными из `eats-divkit-render`.
- Отсутствующая готовая логика ретраев и сетевого взаимодействия в Node.js.
- `eats-divkit-render` перестает быть универсальным микросервисом и
  реализовывать ещё и бизнес логику.
- Трудно реализовать фолбек виджеты (но проще чем с proxy рендером). В этом
  случае придется ещё раз делать сетевой поход за данными для фолбека, которые
  уже могли бы быть на стороне LC.

## Изменение нагрузки

Изменение нагрузки на сервис Layout Constructor пропорционально добавлению
новых скринов в него. В текущей реализации - это только открытие шторок. Т.к.
загрузка лейаута шторки будет происходить только при нажатии на кнопку,
предположительно будут десятки RPS, но легкие т.к. будут содержать только
"простые" виджеты.

Нагрузка на `eats-divkit-render` будет пропорциональна кол-ву лейаутов
содержащих в себе хоть один DivKit-based виджет

## Фолбеки

### Screen

- Если будет передан несуществующий тип `screen`, `eats-layout-constructor`
  вернет 404 с соответствующей ошибкой.

- По аналогии с главным экраном, в будущем будут заведены дефолтные лейауты для
  каждого из `screen'ов`.

- Фолбек на клиентской стороне на "старые" / "захаржкоженные" скрины, в случае
  ошибки от новых `screen'ов`.

### DivKit

- В случае ошибки (падения, неответ, т.п.) `eats-divkit-render` - виджет
  исключается из выдачи `eats-layout-constructor` (по уже существующему
  механизму).

- В случае если один из рендеров DivKit вернет ошибку, Layout Constructor
  проигнорирует пропустит виждет для которого не удалось получить `divjson` (и
  запишет в лог).

- В будущем возможно сделать "фолбечные" виджеты для каждого из DivKit виджетов.
  Они будет представлять из себя упрощенные статические виджеты.

## Точки отказа

- `eats-divkit-render` - сетевой запрос; новый сервис.
- Несуществующий `screen` или неверно сконфигурированные виджеты
  (`available_screens`). Будет обработано на уровне кода.
- Большой ответ в `divjson`, который не регулируется со стороны Layout
  Constructor. Возможно можно обработать на стороне LC клиента и отбрасывать
  ответы которые превышают лимит.
- Потенциально битые ответы в `divjson`. Тут нужно контролировать на стороне
  `eats-divkit-render`, т.к. LC не будет ничего знать про формат `divjson`.

## Запуск нового функционала

1. Уже существующим механизмом экспериментов (раскатки) лейаутов.
2. Новые скрины будут запускаться через AB на клиентской стороне.

## Метрики

- uServer метрики нового клиента до `eats-divkit-render`.
- Разбиение текущих метрик Layout Constructor по screen'ам.

## Ссылки

- https://st.yandex-team.ru/EDAJAM-420
- https://a.yandex-team.ru/review/2337593/details
- https://a.yandex-team.ru/review/2331303/details

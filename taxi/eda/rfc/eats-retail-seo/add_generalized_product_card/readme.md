# Карточка товара для поисковых роботов

## Проблема

В ритейле есть yaml-фиды по каждому бренду, в которых выгружаются различные данные по товару (название, картинка, страна производства, цена и т.д.), включая ссылку на товар вида `https://eda.yandex.ru/retail/{brand_slug}/product/{product_nomenclature_id}` (пример https://eda.yandex.ru/retail/azbuka_vkusa/product/4b7a8cdc-314c-4ded-83d9-a6aaf8bb6227). Эту ссылку получают и поисковые роботы, и пользователи в поисковике и рекламных карточках.

Поисковые роботы, пользуясь этой ссылкой, парсят данные с карточки товара и сравнивают их с данными товара из фида, и если они не совпадают, то выдается ошибка и товар не появляется в поиске/рекламных карточках.

Проблема в том, что по этой ссылке робот получает данные по товару в конкретном магазине (точнее говоря, в каком-то дефолтном магазине бренда в дефолтном регионе), а в фиде данные выгружаются в общем для всех магазинов бренда виде (например, цена товара берется как минимальная среди всех магазинов бренда), то эти данные могут не совпадать.

Также есть проблема с тем, что в поисковиках ссылки на товары могут жить дольше, чем товар есть на витрине. В этом случае мы тоже хотим отдавать и роботу, и пользователям отдавать какие-то обобщенные данные из фида без возможности купить товар, но с выводом блока апсейла.

## Возможные варианты решения

1. Выгружать фиды не побрендово, а поплейсово. Тогда данные по товарам там будут по конкретным плейсам, и ссылку можно было бы сделать вида `https://eda.yandex.ru/retail/{brand_slug}/product/{product_id}?placeSlug={place_slug}`, а фронт бы по ней получал данные по конкретному плейсу.
   * Плюсы:
       * Данные, которые есть в фиде, точно соответствуют данным с карточки товара.
       * Робот будет видеть все товары всех магазинов бренда, а не только дефолтного магазина.
   * Минусы:
       * Вариант нельзя использовать, т.к. рекламная система Маркета не будет понимать, какой оффер надо подсовывать пользователю.

2. Выгружать в фидах данные по дефолтному плейсу (получая его таким же образом, каким сейчас фронт получает его из каталога).
   * Плюсы:
       * Данные в фиде будут соответствовать данным с карточки товара, которую видит поисковый робот.
   * Минусы:
       * Способ не очень надежный, т.к. придется эмулировать для этого поведение фронта, т.е. ходить в ручку каталога с захардкоженным regionId=1 и считать, что полученный плейс и есть дефолтный плейс бренда.
       * Помимо этого, в захардкоженном регионе может не быть магазинов бренда.
       * И самое главное, мы потеряем таким образом товары, которые доступны в других магазинах бренда, но отсутствуют в этом.

## Предлагаемый вариант решения

Добавить возможность получать обобщенную карточку товара, которая будет выдавать общие для бренда данные по той же логике, по которой их выдают фиды (т.е. например, цена будет минимальной среди всех магазинов бренда).

Фронт будет получать такую карточку в двух случаях:
* если запрос идет от поискового робота или пользователя без адреса
* если товар не найден в ассортименте магазина, то будет фоллбэк на эту обобщенную карточку

Плюсы:
* Независимость от определения дефолтного магазина бренда: поисковый робот всегда будет получать одни и те же данные по товару в бренде.
* Данные в фиде будут соответствовать данным, которые получает поисковый робот в карточке.
* Робот будет видеть все товары всех магазинов бренда, а не только дефолтного магазина.
* В случае, если товара уже нет в ассортименте магазина, пользователь все равно его сможет его увидеть по прямой ссылке (будет фоллбэк на обобщенную ручку), купить не сможет, но будет блок апсейла.

Минусы:
* Обобщенную карточку сможет увидеть и обычный пользователь, если он еще не задавал адрес в Еде, поэтому придется добавить на фронте предупреждение, что цена и доступность товара может зависеть от выбранного адреса.

Подробнее по предлагаемому варианту:
1. В eats-retail-seo добавляется ручка `/v1/product/generalized-info`, которая выдает по nomenclature_id товара его обобщенные данные по всем магазинам бренда в формате, аналогичном ответу ручек `/v1/products/info` и `/v1/place/products/info`, но при этом:
    * Цена берется как минимальная среди магазинов бренда.
    * Поля vat и old_price берутся из того магазина, где у товара минимальная цена.
    * Категории берутся по той же логике, как в фиде (т.е. это будут категории товара в мастер-дереве).
    * Доступность в этой ручке не выдается (аналогично фидам).
    * Остальные необязательные поля (in_stock, vendor_code, location) не отдаются.
2. В eats-products в ручке `/api/v2/menu/product` нужны следующие изменения:
    * Добавляется опциональный параметр brand_slug, при этом параметр place_slug становится необязательным (так можно сделать, т.к. ручка не используется в кодгене других сервисов, только на фронте).
    * При этом place_slug является приоритетнее brand_slug (т.е. если приходят оба параметра, смотрим на плейс).
    * Далее, обобщенная ручка `/v1/product/generalized-info` вызывается в двух случаях:
        * Если в ручку приходит только brand_slug, но не приходит place_slug (т.е. запрос от робота или пользователя без адреса). В этом случае надо вызвать обобщенную ручку и отдать `available: true` по товару (т.е. товар можно купить, но сначала надо выбрать адрес).
        * Если ручки `/v1/products/info` и/или `/v1/place/products/info` не отдали товар, то теперь вместо 404 ошибки надо сначала сфолбэчнуться на обобщенную ручку. В этом случае надо отдавать `available: false` по товару (т.е. товар купить точно нельзя, но показать его пользователю надо).
        * При этом в обоих случаях не применяем discount-applicator.
    * Во всех остальных случаях берем данные из `/v1/products/info` и `/v1/place/products/info` по обычной логике.
3. Фронт:
    * Если видит, что запрос идет от робота (либо если не задан адрес), вызывает ручку `/api/v2/menu/product` не с параметром place_slug, а с параметром brand_slug.
    * Также в этом случае фронт должен выводить плашку с предупреждением, что цена и наличие товара может зависеть от выбранного адреса.
    * Доступность кнопки В корзину управляется флагом `available` из ответа ручки, как обычно.

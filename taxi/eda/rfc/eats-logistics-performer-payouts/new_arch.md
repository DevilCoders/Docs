# 1. Цели
Сервис eats-logistics-performer-payouts занимается расчётом выплат курьерам и отправкой курьерам отчётов в телеграм.
Текущая реализация обладает несколькими недостатками:
- сервис слишком объёмный
- сервис плохо написан
- при изменении формулы расчёта выплат невозможно сразу проверить результаты вычислений по новой формуле - сервис не умеет пересчитывать уже обработанные заказы/смены
# 2. Предлагаемое решение
Предлагается разбить сервис на 3 отдельных:
- сервис, занимающийся сбором необходимых для вычисления данных и генерирующий набор событий о готовности данных к вычислению
- сервис, получающий события и выполняющий вычисления
- сервис, получающий результаты вычислений и отправляющий уведомления курьерам и в другие сервисы

## 2.1. Схема взаимодействия сервисов
![Взаимодействие сервисов](images/elpp_new_arch.png)
# 3. Детали реализации
## 3.1. eats-payouts-events
### 3.1.1. Получение данных
В сравнении с текущим сервисом:
- добавляем подписку на изменения маршрутного листа (TODO, процессинг такси) - это позволит получать информацию о заказах в батче до их завершения
- линковку заказов к смене и исполнителю делаем при назначении курьера, а не при завершении заказа; при переназначении курьера делаем перелинковку

В остальном данные получаем по текущей логике
### 3.1.2. Хранение данных
Схема хранения данных будет отличаться - вместо хранения всех данных в общих таблицах субъектов, факторов и связей между субъектами каждая сущность будет храниться в отдельной таблице.

Набор хранимых данных при этом не меняется.

У courier_services и performers добавляется поле revision - после завершения смены курьер может, например, поменять тип транспорта, но при пересчёте смены мы хотим использовать старый тип транспорта. При обновлении важных для расчёта полей (TODO определить эти поля) создаётся новая ревизия записи. При обновлении неважных для расчёта полей (например, имя) они обновляются в последней сохранённой ревизии.

Соответственно, все таблицы, связанные с courier_services и performers, теперь должны быть связаны с конкретной ревизией.

### 3.1.3. Генерация событий

Сервис будет генерировать следующие события:
- старт/завершение смены - содержит идентификатор смены и исполнителя
- создание заказа - содержит идентификатор заказа
- назначение/изменение исполнителя на заказе - содержит идентификатор заказа, смены, исполнителя
- завершение заказа - содержит идентификаторы заказа, смены, исполнителя
- изменения в данных кс/исполнителя - содержит идентификатор смены/исполнителя и номер ревизии
- события фрода - содержат идентификатор записи и driver_uuid
- корректировки - содержит идентификатор записи и исполнителя
- события, форсирующие вычисление выплат за смену - содержат идентификатор смены и исполнителя

Генерироваться события, форсирующие вычисление смены, будут через некоторое время после завершения смены - зависшие заказы в расчёте не учитываются.

Для получения данных сервис будет предоставлять следующие ручки:

- ручка журнала событий по курсору и опционально идентификатору исполнителя
- ручка получения данных о заказе по идентификатору
- ручка получения данных о смене по идентификатору
- ручка получения данных об исполнителе по идентификатору и ревизии; включает также данные по кс

## 3.2. eats-payouts-calculations
### 3.2.1. Обработка событий
При получении события создания заказа сразу вычисляется и сохраняется в базу коэффициент спроса.
При получении события назначения курьера на заказ сохраняем/обновляем в базе связь заказа со сменой.
При получении события завершения заказа сохраняем в базу время его завершения и запускаем вычисление выплат по заказу.
Вычисление выплат по смене запускается:
- после завершения смены, если все заказы, относящиеся к смене, уже завершены
- иначе после завершения всех заказов, относящихся к смене
- если событие, форсирующее вычисление, получено до завершения части заказов - эти заказы не участвуют в вычислении.

### 3.2.2. Получение данных
Для вычисления коэффициента спроса получаем информацию о заказе по идентификатору из события создания заказа.
Для вычислений по заказу получаем информацию о заказе и исполнителе по идентификаторам из события завершения заказа.
Для вычислений по смене:
- получаем информацию о смене по идентификатору из события
- получаем информацию об исполнителе по идентификатору из события
- получаем список завершённых и незавершённых на момент события заказов смены из базы

### 3.2.3. Вычисления
Вычисления проводятся аналогично существующим, но вместо передачи факторов и дочерних субъектов массивами передаём их в отдельных полях.
Для возможности отладки сохраняем в базу detailed_output пайплайна (TODO проверить влияние на размер базы, если сильно вырастет - писать detailed_output в логи или таблицу в yt)

### 3.2.5. Пересчёт
При получении событий вычисления запоминаем курсор, с которого будем продолжать чтение событий.
Для возможности тестового пересчёта без влияния на отображение в Про/админке выполняем следующие действия:
- в таблицу с курсором добавляем поле, указывающее тип вычисления.
  Возможные значения:
  - debug - результаты сохраняются в таблицу, но нигде больше не отображаются
  - use - результаты сохраняются в таблицу, отображаются в админке, используются для отправки уведомлений
- в таблицу с результатами вычислений добавляем флаг о необходимости отправки нотификации по вычислению, а также версию и тип вычисления 
- при пересчёте добавляем новую запись в таблицу с увеличенной версией
  
### 3.2.4. Отображение вычислений в админке
В админке показываем для исполнителя относящиеся к нему вычисления.
Добавляем следующие ручки для взаимодействия с админкой:
- ручка для включения/выключения отправки уведомлений по конкретному вычислению (выставляет в базе соответствующий флаг)
- ручка для включения/выключения отправки уведомлений по вычислениям, выполненным в заданный период, опционально принимающая набор идентификаторов исполнителей
- ручка, выполняющая пересчёт интервала между парой курсоров с заданным типом вычисления, опционально принимающая набор идентификаторов исполнителей.
  Пересчёт выполняется отдельной stq, на основной процесс вычислений не влияет
- ручка, устанавливающая текущий курсор и тип вычисления для основного процесса вычисления

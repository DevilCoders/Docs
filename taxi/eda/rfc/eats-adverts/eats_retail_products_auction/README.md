# Аукцион для товаров ритейла Я.Еды

Продуктовый тикет: [https://st.yandex-team.ru/EDACAT-1786](https://st.yandex-team.ru/EDACAT-1786)

## ToC

1. [Чего хочет продукт и коммерция](#brief)
2. [Возможные варианты](#how-to-achieve)
    1. [eats-products запршивает у eats-adverts коммерческие товары](#eats-products-requests-adverts)
    2. [eats-products запрашивает у eats-adverts аукцион среди товаров](#eats-products-requests-auction)
    3. [Встраиваемая библиотека lib-eats-adverts](#lib-eats-averts)


<a id="brief"></a>

## Чего хочет продукт и коммерция

[@artem-murzin](https://staff.yandex-team.ru/artem-murzin) хочет продавать
FMCG-партнерам "поднятие" товаров в категориях. Т.е. есть условный кошачий корм
"пурина", и они хотят подниматься в категории товары для животных выше, чем они
встали бы органически.

Рекламу хотят показывать только тогда, когда пользователь **не** выбрал
сортировку (т.е. используется сортировка по-умолчанию).

Сама рекламная сортировка должны быть такой (более подробно в
[комментарии](https://a.yandex-team.ru/arc_vcs/taxi/uservices/services/eats-catalog/src/adverts/auction.hpp?rev=799c43ab7dc08d84d525ed918157036bf39cf68d#L43) к
сортировки ресторанов в каталоге):

1. На нужные рекламные позиции расставляем рекламные товары.
2. Если органически товар выше или на той же позиции, что и в рекламе, то
   оставляем его как "нерекламный" и переходим к следующей позиции.
3. Т.к. "докидывания" товаров не будет (мы показываем только релевантные
   данной категории товары), то у нас не может возникнуть ситуации, когда
   товар задублируется или вставится куда-то.
4. Если по какой-то причине рекламная позиция дальше размера списка товаров,
   то такой товар вставляется в конец. Это невозможная ситуация, т.к. она
   разрешается в пунтке 2 (товар останется на месте как органический).

<a id="how-to-achieve"></a>

## Возможные варианты

<a id="eats-products-requests-adverts"></a>

### eats-products запршивает у eats-adverts коммерческие товары

Спека описана в [eats_products_adverts.yaml](eats_products_adverts.yaml)

eats-products запрашивает у eats-adverts рекламные товары для
одной или нескольких категорий, которые собирается вернуть клиенту.
eats-adverts возвращает для запрошенных категорий рекламные товары, с индексом,
на которые они должны встать в итоге.
eats-products на своей стороне отфильтровывает недоступные товары и размещает
рекламные на нужных позицияих.
Или же, размещает рекламные товары на позициях, на которых хочет сам, но
сохраняет относительный порядок между рекламными.

**Pros:**

- это внешний сервис и его можно менять "на ходу", не дожидаясь релизов
  eats-products
- можно добавлять сетевые зависимости, не боясь того, что это повлияет
  на сам eats-products (при гарантиях на время ответа со стороны нашего сервиса)
- изоляция: сервис eats-adverts отвечает только за то, чтобы отдать рекламные
  товары

**Cons:**

- внешний сервис ничего не знает о доступности рекламных товаров, которые он
  вернет, т.е. мы будем считать, что товар А релевантнее товара Б с точки зрения
  рекламы, но его нет по факту в магазине; продадим А вместо Б, А не будет
  показан, Б не продали, хотя могли заработать
- при отвале нашего сервиса (или сетевых проблем просто), деградация будет
  выключать рекламу


<a id="eats-products-requests-auction"></a>

### eats-products запрашивает у eats-adverts аукцион среди товаров

Спека описана в [eats_products_auction.yaml](eats_products_auction.yaml)

eats-products собирает товары для категории, оставляет только доступные (на самом
деле я имею в виду, что оставляет только те товары, которые собирается отдать
клиенту). Со списком этих товаров идет в eats-advers за одним из двух:

- либо провести аукцион из всех товаров, и получить только рекламные, которые
  отсортированы относительно друг-друга
- либо отдать список этих товаров на сортировку сервису eats-adverts (но этого
  не хочется)

**Pros:**

- это внешний сервис и его можно менять "на ходу", не дожидаясь релизов
  eats-products
- можно добавлять сетевые зависимости, не боясь того, что это повлияет
  на сам eats-products (при гарантиях на время ответа со стороны нашего сервиса)
- мы точно знаем, что если среди отправленных товаров есть рекламный товар, то
  в этом запросе мы его скорее всего покажем

**Cons:**

- оверхед на сеть: будут отправляться **все** доступные в категории товары даже
  в том случае, когда рекламу показывать не нужно
- не хочется заниматься сортировкой товаров вне сервиса eats-products, а если
  этим и нужно заниматься отдельно, то точно не в рекламном сервисе
- при отвале нашего сервиса (или сетевых проблем просто), деградация будет
  выключать рекламу

<a id="lib-eats-averts"></a>

### Встраиваемая библиотека lib-eats-adverts

В сервис eats-products затягивается библиотека lib-eats-adverts со следующим
интерфейсом:

```cpp
namespace eats_adverts::models {

/**
 * @brief Идентификатор ресторана.
 */
using PlaceId = StrongTypedef<class PlaceIdTag, int64_t>;

/**
 * @brief Идентификатор бренда.
 */
using BrandId = StrongTypedef<class BrandIdTag, int64_t>;

/**
 * @brief Идентификатор товара.
 */
using ProductId = StrongTypedef<class ProductIdTag, std::string>;

/**
 * @brief Идентификатор категории.
 */
using CategoryId = StrongTypedef<class ProductIdTag, std::string>;

/**
 * @brief Магазин, для товаров которого проводится аукцион,
 */
struct Place {
  PlaceId place_id{};
  BrandId brand_id{};
};


/**
 * @brief Товар, который будет участвовать в аукционе.
 */
struct Product {
  ProductId product_id{};
  std::vector<CategoryId> categories{};
};

/**
 * @brief Проведенный рекламный аукцион.
 */
class Auction {
public:
  /**
   * @brief Сортирует товары таким образом, чтобы расставить рекламные
   *        товары на предоплаченные позиции, не нарушая порядок в остальном
   *        списке.
   */
  std::vector<ProductId> Sort(std::vector<Product>&& products) &&;
};

} // namespace eats_adverts::models

namespace eats_adverts::components {

/**
 * @brief Класс, который возвращает аукцион.
 */
class Auctioneer final {
public:
  /**
   * @brief Возвращает аукцион для конкретного ресторана и пользователя.
   */
  Auction GetAuction(
      const eats_authproxy_backend::AuthContext& eats_auth_context,
      const models::Place& place) const;

  /**
   * @brief Возвращает анонимный аукцион для конкретного ресторана
   */
  Auction GetAuction(const models::Place& place) const;
};

} // namespace eats_adverts::components
```

Библиотека должна загружать состояние также, как сейчас работает реклама в
сервисе eats-upsell, т.е.:

- внутри содержится кэш YT-вых таблиц с промо-товарами для ритейла
- периодически происходит опрос YT и обновление таблиц, если они изменились

Из-за этого возникают требования к сервису:

- добавить секдист с YT-токеном робота, имеющим доступ к таблицам рекламы
- потребуется "лишняя" память на кэш рекламных товаров (меньше 100мб и то
  это очень завышенная оценка)

**Pros:**

- нет оверхеда на сеть, как в запросе сортировки у внешнего сервиса
- вся логика живет в сервисе, не (не должно) появляется никаких рантайм-походов
- оставляем лучшее от двух подхозов выше: выбираем рекламу из той, что есть в
  акутальных/доступных товарах и при том, логику сортировки оставляем за сервисом

**Cons:**

- это зависимость eats-products, соответственно все наши изменения в логике
  привязаны к релизам eats-products
- если у нас будет корка/ub/etc, то мы приложим не отдельно-стоящий сервис, а
  eats-products
- мы не имеем отдельной квоты на ресурсы под рекламные задачи, а живем в
  eats-products (кажется, минорно)


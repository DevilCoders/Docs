# Динамические катгории в restaurant-menu

## Проблема

Сейчас логика вычисления динамических категорий для меню
ресторана лежит полностью в коре. Хотим вынести эту логику
в сервис eats-restaurant-menu, чтобы избавиться от зависимости
меню от коры.

## Как это работает

По очереди код пытается сформировать категории

- Акции
- Вы заказывали
- Популярное

Если какую-то из них удалось сформировать, категория добавляется в начало меню, остальные динамические
категории опускаются

## Категория Акции

### Как было
В коре категория акции формируется в заивисимости от наличия акций на айтемах.
[Код в коре](https://bb.yandex-team.ru/projects/EDA/repos/backend_service_core/browse/src/ApiBundle/Response/Catalog/Factory/PromoCategoriesFactory.php#49)
Категория формируется только если акционных товаров меньше 15.

Для лавки ограничения нет, также для лавки добавляется картинка категории.
Но в рамках данного переезда кажется это можно опустить.

### Предлагаемое решение
Логика довольно простая, для определения акционности товаров предлагается использовать
библиотеку eats-discounts, которая уже используется в сервисе.

##  Категория Вы заказывали

### Как было
Категория формируется по такому алгоритму:
[Код в коре](https://bb.yandex-team.ru/projects/EDA/repos/backend_service_core/browse/src/ApiBundle/Response/Catalog/Factory/PersonalCategoriesFactory.php#46)
1) Выбираются доставленные заказы
2) Без фидбека (order_feedbacks)
без оценки или с оценкой 4 или 5 и без предефаненного коммента не понравилась еда
ИЛИ
с каким-то другим комментом кроме не понравилась еда
3) Учитываются только заказы за последние полгода
4) Максимум 50 заказов
5) Из ревизии по этим заказам достаются айтемы
6) Считается общее количество заказов каждого айтема (среди всех заказов).
7) Берутся только 10 самых частых айтемов
8) Среди них отфильтровываются недоступные по расписанию категории и стоп-листам
9) Среди оставшихся айтемов берутся только первые 5

### Предлагаемое решение

Кажется всеми нужными данными для построения категории обладает сервис eats-ordershistory.
Более того eats-restaurant-menu уже делает запрос в eats-ordershistory и имеет LRU кэш поверх сервиса.
Единственная проблема тут - в ordershistory нет predefined_comments.

Чтобы фидбеки появились в ordershistory нужно сделать доработку в сервисах 
eats-ordershistory и eats-feedbacks.
Сервис фидбеков должен в stq задаче для ordershistory добавлять идентификатор комментария,
а ordershistory сохранять его в свою базу и отдавать в ответе.

## Категория Популярное

В коре очень не тривиальный алгоритм формирования категории. Данные
для категории подготавливаются оффлайн на основе истории заказов.

Алгоритм описан тут https://st.yandex-team.ru/EDADEV-497

Основная идея - перенести алгоритм как есть в сервис eats-restaurant-menu.
Историю заказов и их состав так же выбирать из сервиса eats-ordershistory.
Для этого нужно

1) Добавить в eats-restaurant-menu базу, в которую будет сохраняться таблица
популярных блюд, аналогичная по смылсу и сожержанию таблице popular_menu_items
в коре

```
describe popular_menu_items;
+--------------+----------+------+-----+---------+----------------+
| Field        | Type     | Null | Key | Default | Extra          |
+--------------+----------+------+-----+---------+----------------+
| id           | int(11)  | NO   | PRI | NULL    | auto_increment |
| place_id     | int(11)  | NO   | MUL | NULL    |                |
| menu_item_id | int(11)  | NO   | MUL | NULL    |                |
| updated_at   | datetime | YES  |     | NULL    |                |
| created_at   | datetime | NO   |     | NULL    |                |
| sort         | int(11)  | NO   |     | 100     |                |
+--------------+----------+------+-----+---------+----------------+
6 rows in set (0,01 sec)
```

2) Добавить в кэш каталога поле с политикой применения популярных - popularity_algorithm

3) Завести периодик, который будет ставить STQ задачи на обновление популярных
айтемов конкретного заведения. Просто проходом по всем айтивным плейсам из кэша каталога.
(В коре апдейт происходит каждую ночь в 01:00)

3) Завести STQ задачу, которая делает запрос в eats-ordershistory за историей
заказов в конкретном заведении. Предлагается использовать ручку
[/internal/v2/get-orders/list](https://a.yandex-team.ru/arc_vcs/taxi/schemas/schemas/services/eats-ordershistory/api/api.yaml?rev=r9376700#L176) с фильтрацией по place_id, status и period.
4) Реализовать алгоритм расчета популярных айтемов, по описанному в тикете выше алгоритму.
5) Сохранять результат в базу.

## Конфигурация политик хождения в ручки клиентского API

### Summary

Сейчас политики ретраев и таймаутов никак не унифицированы и зашиты в код мобильных приложений. Поэтому, во-первых, их невозможно менять без перевыкатки приложений, а во-вторых, существует некоторая вероятность, что разные клиенты могут ходить в одни и те же ручки по разным правилам, что приводит к непредсказуемому поведению.
В рамках данной задачи предлагается научиться отдавать конфигурацию, которая будет сообщать клиентам конкретные параметры ретраев и таймаутов для походов в конкретные ручки.

### Задачи

* [EDAFRONT-7573](https://st.yandex-team.ru/EDAFRONT-7573)

### Предлагаемая реализация

1. Завести конфиг, аналогичный по формату конфигам QOS для серверных ручек. В конфиге задаются отдельные правила для каждой конкретной ручки, а для всех не указанных берется вариант __default__. Пример: [EATS_PLUS_CLIENT_QOS](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/EATS_PLUS_CLIENT_QOS?name=QOS).
```
{
  "/internal/eats-plus/v1/presentation/cashback/places-list": {
    "attempts": 1,
    "timeout-ms": 350
  },
  "__default__": {
    "attempts": 1,
    "timeout-ms": 300
  }
}
```
2. На старте завести только дефолтную конфигурацию, затем попросить ответственных за разные сервисы бэкенда дополнить его специфичными для своих ручек правилами.
3. При запросе какой-то ручки (какой именно – см. [ниже](#endpoint)) отдавать конфиг клиентам
4. На клиентах (в первую очередь Android и iOS, web – можем обсудить) научиться накатывать этот конфиг в момент получения ответа и кешировать его до следующего перезапроса ручки
5. Для самой ручки, отдающей конфиг, задать отдельные правила, зашить их в клиент. Это нужно, чтобы ошибочный конфиг не мог привести клиентов в зацикленное состояние. Например, секундный таймаут на запрос может привести к невозможности получить новую конфигурацию, из-за чего клиент останется с закешированной конфигурацией до сброса кеша
6. (Опционально) Добавить в CI-пайплайн шаг, на котором конфигурация выкачивается и зашивается в сборку приложения в качестве фоллбэчного варианта. Это может быть полезно, чтобы иметь в новых версиях приложения самый актуальный конфиг для фоллбэков, если из ручки по какой-то причине конфиг не пришел.

### <a name="endpoint"></a>В какую ручку ходить?
После нескольких раундов обсуждений, остановились на том, что в **первой итерации заведем отдельную ручку** (см. пункт 3 ниже), поскольку этот вариант проще всего реализовать в ближайшее воремя. 
Субъективно более правильным видится вариант с заездом в новый лонч (п.1), но у него сейчас туманные перспективы в плане сроков. Для истории полный список вариантов ниже:

#### 1. Ручка /launch/native из [этого RFC](https://a.yandex-team.ru/arc_vcs/taxi/eda/rfc/eats-launch/frontend-experiments/main.md?from_pr=2026837&rev=users%2Fandrey-tsarin%2Fbranch-EDAEATERS-1051-frontend-experiments)
Переезжаем клиентом на т.н. "блокирующий" лонч. Подробное описание в RFC, но если вкратце – гарантируется поход клиентов в ручку /launch/native до того, как пользователь начнет что-то делать с приложением. И в ответ этой ручки помимо экспериментов добавляем описываемый конфиг.

##### Плюсы:
* Соответствует планам по переезду на новую логику работы launch.
* Концептуально правильно получать все глобальные конфиги и эксперименты из одного источника правды
* /launch/native уже реализован, туда нужно будет только пробросить конфиг

##### Минусы:
* Клиентам нужно переехать с текущей логики похода в launch на новую, пока сроки неочевидны

#### 2. Ручка экспериментов
Ходим клиентом напрямую в ручку экспериментов и оттуда получаем конфиг. Т.е. сохраняем текущую логику экспов, просто добавляем туда наш конфиг.

##### Плюсы:
* На бэкенде ничего не нужно делать, логика походов в экспы уже есть
* На фронте чуть меньше работы: логику получения конфига писать не нужно

##### Минусы:
* Противоречит планам по перевозу всех глобальных экспериментов в /launch
* Не факт, что текущая логика кеширования экспериментов на мобилке подходит для описываемых конфигов. Могут потребоваться доработки

#### 3. Отдельная ручка
Заводим новую ручку, которая забирает конфиг и отдает клиентам. Клиенты ходят в эту ручку при запуске приложения и, возможно, при разворачивании из фона.

##### Плюсы:
* Ручка изолирована, поэтому в теории можно сделать любую логику похода в нее. Если доводить до крайности – можно хоть каждые 5 секунд поллить, что даст возможность обновлять конфиги почти в реалтайме

##### Минусы:
* Больше работы на клиенте
* Не очень хорошо вписывается в планы перевозить глобальные настройки приложения в новый launch

#### 4. Текущая ручка launch
В текущей ручке /launch добавляем в ответ вышеупомянутый конфиг. В остальном оставляем логику похода в launch без изменений

##### Плюсы:
* Минимальные доработки на бэкенде
* Чуть меньше работы на фронте: логика похода в launch уже написана

##### Минусы:
* Противоречит планам по переезду в новый launch
* В текущий launch ходят только авторизованные пользователи. Т.е. конфиги будут применяться только к ним


### Стартовый конфиг
Предлагается начинать со следующей конфигурацией, в которую впоследствии ответственные могут вписать правила для своих ручек
```
{
  "__default__": {
    "attempts": 1,
    "timeout-ms": 15000
  },
  "/api/v2/orders/tracking": {
    "attempts": 1,
    "timeout-ms": 2000
  }
}
```
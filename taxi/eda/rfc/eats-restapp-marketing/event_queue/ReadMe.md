# Очередь обработки cpm

В cpm очень много различных источников воздействия и различных статусов, что делает очень сложным организацию синхронизации между статусами, так же хотим оптимизировать походы в директ, базку и feeds-admin

Тикет: [https://st.yandex-team.ru/EDAPARTNERS-1944](https://st.yandex-team.ru/EDAPARTNERS-1944)

## Процессинг

Один из вариантов - использование процессинга, но:
1. Большая часть кодовой базы обработки воздействий уже написана и переносить ее на "нулевой" процессинг будет блолее затратно по времени
2. Мы не заводим stqste машину, потому процессинг не актуален

Другой вариант - логброкер, но у нас нет такой нагрузки, что бы его использовать

## Таблица эвентов

Основная идея: несколько писателей, один читатель

Все источники воздействий пишут в единую табличку, которая будет расти вниз.
Поля:
``` 
task_id - уникальный возрастающий идентификатор задачи
type - тип задачи (создание, задача запуска/остановки, редактировние кампании, редактирование баннера, архивация)
inner_campaign_id - идентификатор кампании, к которой относится воздействие
parameters - сериализованная кампания
processed_at - время когда задача была обработана
```

## Воздействия

1. Создать
2. Запустить/Остановить
4. Обновить баннер
5. Обновить параметры кампании
6. Заархивировать

## Писатели

| Писатель                     | Воздействие               |
|------------------------------|---------------------------|
|Ручка результата модерации    |Создать, Обновить баннер   |
|Ручка редактирования кампании |Обновить параметры кампании|
|Ручка запуска кампании        |Запустить                  |
|Ручка остановки кампании      |Остановить                 |
|Ручка архивации               |Архивировать               |
|Периодика запуска кампаний    |Запустить                  |
|Периодика остановки кампаний  |Остановить                 |
|Процессор                     |Любое, кроме создания      |

## Читатель

Вычитывать из таблицы будет дистлок, который получает все задачи у которых не проставлена метка processed_at
1. Группируем задачи по inner_campaign_id
2. Если кампания с inner_campaign_id стоит в статусе in_creation_process - такие задачи не обрабатываем
3. На каждый уникальный inner_campaign_id, создастся EventProcessor
4. Добавление задач в EventProcessor'ы согласно inner_campaign_id
5. Запуск каждого процессора в асинке и ожидание их выполнения
6. Результатом выполнения работы процессора является наборы завершенных и незавершенных задач

## Процессор

Вся обработка осуществляется в процессоре, котрый является наследником интерфейса IEventProcessor

```C++
struct ProcessResult{
    std::vector<TaskId> processed_tasks;
    std::vector<TaskId> unprocessed_tasks;
}

class IEventProcessor{
    virtual ~IEventProcessor() {}
    virtual ProcessResult Process() = 0;
}
```

В нашей версии процессора будет реализована следующая логика:

1. Оставить по одному, последнему экземпляру каждого события, все отброшенные события помечаются как обработанные
2. Оставить только одно последнее событие старт/стоп
3. Отсортировать по следующим критеириям:
    * Первыми обрабатываются события редактирования
    * Вторыми событие создания
    * Третьим событие старт/стоп
    * Четвертым событие архивации
4. Выполнить все необходимые манипуляции

Специфика обработки некоторых событий:
Событие создание в процессоре только меняет статус и отправляет таску на создание
События редактирования проверяют текущий статус и в зависимости от него либо просто меняются параметры, либо происходит процесс остановки и повторного запуска в feeds-admin

## Доработка ручки Campaigns

Нужно будет доработать campaigns что бы она проверяла наличие событий в очереди и отдавала на фронт последню версию камапнии если такая там будет  
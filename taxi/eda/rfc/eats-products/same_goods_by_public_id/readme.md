## Проблема
Сейчас при переходе из поисковым систем (более 70к переходов в день), пользователь попадает на страницу товара, где товар может быть недоступен, или магазин не доставляет пользователю. Из-за таких кейсов у нас очень маленькая конверсия с этой страницы в покупку (около 0.2%)

## Требуется
Выводить карусель с этим же товаром, но доступным в магазинах других брендов.

## Аргументы для ручки
- publicId товара
- координаты пользователя (чтобы подобрать соответствующие доступные плейсы из каталога)

## Ответ ручки

``` yaml
CrossBrandProductsResponse:
    type: object
    additionalProperties: false
    description: Список товаров, присутствующих в других магазинах
    required:
      - crossbrand_products
    properties:
        crossbrand_products:
            type: array
            description: Список пар магазин-товар, в которых товар доступен
            items:
                $ref: '#/components/schemas/CrossBrandProduct'

CrossBrandProduct:
    type: object
    additionalProperties: false
    description: Пара магазин-товар
    required:
      - place
      - menu_item
    properties:
        place:
            description: Описание плейса в котором есть товар
            $ref: '#/components/schemas/Place'
        menu_item:
            # аналогичен полю menu_item ответа /api/v2/menu/product
            $ref: '#/components/schemas/Product'
            description: Описание товара

Place:
    type: object
    additionalProperties: false
    description: Описание плейса в котором есть товар
    required:
      - brand_slug
      - brand_name
      - place_slug        
      - color_overrides

    properties:
        brand_slug:
            description: slug бренда.
            type: string
        brand_name:
            description: Человекочитаемое название бренда   
            type: string
        place_slug:     
            description: slug плейса.
            type: string
        color_overrides:
            # аналогично полю place_overrides ручки /api/v1/cross-brand-history/places
            type: object
            additionalProperties: false
            required:
              - color
              - logo_url
            properties:
                color:
                    type: array
                    description: Цвета фона. Темы light и dark.
                    maxItems: 2
                    items:
                        $ref: '../definitions.yaml#/components/schemas/ThemedColor'
                logo_url:
                    $ref: "#/components/schemas/LogoUrl"

Product:
    type: object
    additionalProperties: false
    description: Структура товара для отображения на плашке перехода
    required:
      - public_id
      - decimalPrice
      - decimalPromoPrice
    properties:
        public_id:
            type: string
            description: Уникальный id товара внутри бренда
        decimalPrice:
            type: string
            example: "199.90"
        decimalPromoPrice:
            type: string
            nullable: true
            example: "99.90"

LogoUrl:
    type: array
    items:
        type: object
        additionalProperties: false
        required:
          - theme
          - size
          - url
        properties:
            theme:
                $ref: "../definitions.yaml#/components/schemas/Theme"
            size:
                type: string
                enum:
                  - small
                  - medium
                  - large
            url:
                type: string
                description: Ссылка на изображение
```


## Ожидаемая нагрузка 
~ 1-3 rps.

## Решение
### Вариант 1:
![](sequence.png)

	- Обращаться в eats-products с publicId товара и координатами пользователя
        ручка /api/v1/menu/cross-brand-products

	- Получить в eats-products товар из обобщённой ручки eats-retail-seo и извлечь sku_id
        ручка /v1/product/generalized-info

    - Получить из eats-nomenclature информацию в каких брендах есть товар(по sku_id) и выдать массив пар brand_id и public_id
        ручка /v1/product/brand-ids-by-sku-id

    - Получить из eats-catalog все доступные плейсы по координатам среди заданных брендов
        ручка /internal/v1/places

    - Получить из eats-nomenclature информацию dynamic_info о товаре (во всех доступных плейсах) по массиву пар (place_id, public_id)
        ручка /v1/place/products/info

    - Собрать в eats-products ответ вида массив пар (плейс, товар)
        ручка /api/v1/menu/cross-brand-products

#### Доработки:
- доработать в eats-catalog ручку выдачи плейсов, доступных по координатам:
  - включить дедубликацию
  - добавить в ответ информацию нужную для отображения (в PlacesListItem добавить поля name string, logo ThemedPlaceLogo и color ThemedColor)

        NOTE: Допускается в первой реализации использовать ручку /internal/v1/catalog-for-layout(она отдаёт намного больше данных, 
              чем надо, медленнее и предназначена для других целей) в случае проблем с реализацией в /internal/v1/places, а далее перейти на /internal/v1/places

- реализовать в eats-nomenclature ручку поиска брендов в которых есть товар с заданным sku-id
- реализовать в eats-nomenclature ручку получения информации dynamic_info о товаре(аналогично /v1/place/products/info), принимающую массив пар (place_id, public_id)

      NOTE: В первой реализации использовать несколько параллельных запросов к /v1/place/products/info и посмотреть на нагрузку/тайминги.
            Предполагается, что в большинстве случаев искомых товаров будет 0-2 шт., поэтому, вполне вероятно, что эта доработка не понадобится.  
  
- реализовать в eats-products ручку осуществляющую реализацию логики вызова походов и сбора результата.

#### Плюсы:
+ актуальные плейсы

#### Минусы:
- много доработок на стороне бэкенда(много затронутых сервисов)

#### Стоит отметить
Данное решение использует обобщённую ручку для получения sku_id. Поэтому данная ручка может быть использована только для поиска товаров, 
которые отсутствуют в номенклатуре. В противном случае правильным решением является сначала проверка товара в ручке номенклатуры, и получения из неё sku_id 
и, лишь при условии его отсутствия, получение ответа из обобщённой ручки. 


## Альтернативные рассмотренные варианты(признаны неподходящими):

### Вариант 2:
	- Список плейсов, доступных пользователю, получает фронт из eats-layout-constructor(аналогично как сейчас реализовано в закупидоне 
    запросом к главной странице и разбором виджета магазинов)
	- Обращаться в eats-products с publicId товара и списком плейсов, в которых искать
	- Получить в eats-products товар из обобщённой ручки eats-retail-seo и извлекать sku_id 		
	- Получить из eats-nomenclature информацию в каких из заданных плейсов есть товар(по sku_id и массиву place_id) и выдать массив пар (public_id, place_id)
	- Получить из eats-nomenclature информацию static_info и dynamic_info о товаре (во всех доступных плейсах) по (place_id, public_id)
	- Собрать в eats-products ответ вида массив пар (плейс, товар)

#### Доработки:
- добавить в eats-nomenclature ручку поиска товара по sku_id в заданных заведениях (по аналогии с /v1/place/products/id-by-sku-id)
- добавить в eats-products ручку осуществляющую реализацию логики вызова походов и сбора результата.

#### Плюсы:
+ актуальные плейсы
+ решение сильно упрощается на стороне бэкенда

#### Минусы:
- доработки на стороне фронта и бэкенда(размазывание логики)
- "неправильное" использование eats-layout-constructor
- медленная ручка

### Вариант 3:
	- Обращаться в eats-products с publicId товара и координатами пользователя
	- Получить в eats-products товар из обобщённой ручки eats-retail-seo и извлекать sku_id 
	- Использовать библиотеку eats-places для получения заведений по координатам(с дублями)
	- Получить из eats-nomenclature информацию в каких из заданных плейсов есть товар(по sku_id и массиву place_id) и выдать массив пар (public_id, place_id)
	- Получить из eats-nomenclature информацию static_info и dynamic_info о товаре (во всех доступных плейсах) по (place_id, public_id)
    - Дедубликация ответа в eats-products на основе библиотеки eats-places
	- Собрать в eats-products ответ вида массив пар (плейс, товар)

#### Обосенности библиотеки eats-places:
Библиотека выдаёт эквивалентный набор брендов, что и eats-catalog. Если у бренда только один плейс, то результаты будут эквивалентны.
Если у бренда несколько плейсов, то ранжирование их будет отличаться. 

Библиотека имеет производительность выше, чем обращение в eats-catalog за счёт упрощения алгоритма ранжирования. 
Данные берутся из eats-catalog-storage и сортируются(в первую очередь по доступности и по eta)

#### Доработки:
- добавить в eats-nomenclature ручку поиска товара по sku_id в заданных заведениях (по аналогии с /v1/place/products/id-by-sku-id)
- добавить в eats-products ручку осуществляющую реализацию логики вызова походов и сбора результата.

#### Плюсы:
+ решение упрощается на стороне бэкенда
+ быстрая ручка

#### Минусы:
- не всегда актуальные плейсы(библиотека не использует umlaas-eats и даёт не всегда самые подходящие плейсы)

### Вариант 4:
	- Обращаться в eats-products с publicId товара и координатами пользователя
	- Получить в eats-products товар из обобщённой ручки eats-retail-seo и извлекать sku_id 
	- Использовать библиотеку eats-places для получения заведений по координатам
	- Получить из eats-nomenclature информацию в каких из заданных плейсов есть товар(по sku_id и массиву place_id) и выдать массив пар (public_id, place_id)
	- Получить из eats-nomenclature информацию static_info и dynamic_info о товаре (во всех доступных плейсах) по (place_id, public_id)
	- Собрать в eats-products ответ вида массив пар (бренд, товар)
	- Фронты по пользовательскому клику по плашке соответственного бренда будут вычислять оптимальный плейс и переходить на карточку товара
        - Для перехода на карточку товара требуется плейс и public id
        - Фронты используют ручку получения оптимального плейса по бренду из eats-catalog 
        (Если для бренда будет найдено несколько плейсов, не гарантируется что плейс из eats-catalog тот же, в котором eats-nomenclature нашла товар) 

#### Доработки:
- добавить в eats-nomenclature ручку поиска товара по sku_id в заданных заведениях (по аналогии с /v1/place/products/id-by-sku-id)
- добавить в eats-products ручку осуществляющую реализацию логики вызова походов и сбора результата.

#### Плюсы:
+ решение упрощается на стороне бэкенда
+ быстрая ручка

#### Минусы:
- если в разных плейсах разная цена(например, скидка), то цена на виджете перехода может отличаться от цены на самой карточке товара(т.к. dynamic_info может быть получен по одному плейсу, а фронт посчитает оптимальным другой плейс)
- есть вероятность, что в одном плейсе в зоне доставки есть товар, а в оптимальном с точки зрения доставки его нет

## Стоит отметить:
Для ускорения работы ручки можно добавить в ответы eats-products sku_id и, соответственно, фронт будет ходить уже с sku_id для получения аналогичных товаров. 
Однако, фронты движутся в сторону того, чтобы иметь только один универсальный id, поэтому эти варианты не рассматривались.

## Выводы:
- 1й вариант даёт оптимальные результаты, однако, требует бОльших доработок, а также ручка может оказаться достаточно медленной. Если добавить фильтрацию по бренду, ожидается существенное ускорение.
- 2й вариант даёт оптимальные плейсы. Однако, является временным решением с неудобной поддержкой. Данный подход будет достаточно медленным.
- 3й вариант даёт не оптимальные плейсы(библиотека не всегда выдаёт оптимальный плейс), однако максимизирует покрытие товаров. Данный вариант позволит реализовать более быструю ручку.
- 4й вариант даёт оптимальные плейсы, однако по переходу по ссылке данные могут отличаться от того, что написано на плашке. Данный подход будет достаточно быстрым, но немного медленнее предыдущего.

3й вариант приводят к неоптимальным плейсам, которые нам не подходят т.к. это приведёт к большому количеству корнер кейсов, сценариев, ошибок и увеличению цены доставки.

4й вариант нам не подходит т.к. может показыавть плашку, по которой мы перейдём к товару, которого нет в плейсе.

2й вариант имеет плохую расширяемость, поддержку и имеет низкую производительность.

1й вариант из недостатков имеет только большое количество доработок.

## Предлагается:
На основе плюсов и минусов 1-е решение выглядит более подходящим для реализации.


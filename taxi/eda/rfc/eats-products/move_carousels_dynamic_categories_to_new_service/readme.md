# Сервис eats-retail-categories

## Цели:
Вынос из минимонолита eats-products логики, отвечающей за наполнение динамических категорий, каруселей и кросс-брендовой истории покупок

## Для архревью

### Какую продуктовую проблему решает сервис:
Формирование динамических категорий с товарами, каруселей товаров и кросс-брендовой истории покупок пользователя в ритейле

### Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?
Реализация этой логики в сервисе eats-products приведет к еще большему разрастанию сервиса и превращению его в микромонолит

### Как именно сервис будет решать поставленные перед ним задачи?
Сервис будет хранить:
- данные о товарах, которые попадают в динамические категории, по каждому магазину
- данные о товарах, которые попадают в карусели товаров категорий верхнего уровня, по каждому магазину
- данные о товарах, купленных пользователем в привязке к бренду и кросс-брендовые

Все данные о товарах будут обновляться асинхронно через stq на основе событий из logbroker.
Дополнительно, при отстутсвии данных о товарах из истории заказов пользователя, они будут обновляться при их запросе.

Сервис будет отдавать наружу id товаров, которые принадлежат запрошенным категориям

### Разрабатывается один сервис или система?
Один сервис

### С кем взаимодействует сервис?

#### Сервисы, которые будут использоваться:
1. eats-ordershistory. Получение истории заказов пользователя
2. eats-nomenclature. Получение товаров для наполнения БД (скидки, популярное, карусели)
3. eats-products. Получение маппинга id товаров
4. eats-discounts. Получение скидочных и товаров с кешбэком из сервиса скидок
5. eda_core. Обновление списка брендов и магазинов

#### Клиенты сервиса:
1. eats-products. Получение динамических категорий, каруселей и кросс-брендовой истории покупок
2. eats-upsell. Получение товаров из кросс-брендовой истории покупок


### Какие базы использует?
Cервис будет хранить в postgres:
1. Список брендов ритейла
2. Список магазинов в этих брендах
3. Список public_id скидочных товарах по магазинам
4. public_id товаров, которые составляют динамические категории магазинов: популярное, вы заказывали
5. public_id товаров, которые составляют карусели магазинов
6. sku_id товаров, которые составляют кросс-брендовую историю заказов пользователя
7. Скоринги товаров из yt (Эти же скоринги будут храниться и в eats-products, в том же виде, что и сейчас, так как потребуются для дальнейшей сортировки)
8. Топы товаров по динамическим категориям и категориям верхнего уровня

### Какие периодические процессы?
периодики:
- периодик чтения скорингов товаров из yt
- периодик чтения ивентов из логброкера по событию new_assortment
- периодик чтения ивентов из логброкера по событию new_prices
- периодик чтения ивентов из логброкера по событию orders_client
- периодик обновления брендов
- периодик обновления магазинов

stq:
- обновление товаров из истории покупок пользователя
- обновление скидочных товаров
- обновление популярных товаров

### Схема инфраструктуры
![Схема](schema.png)

### Какие данные и по какой схеме сервис будет хранить в базе?
таблицы postgresql:
- brands хранение идентификаторов брендов, столбцы id, slug, updated_at;
- places хранение идентификаторов магазинов, столбцы id, slug, brand_id, is_enabled, updated_at;
- discount_products хранение данных о скидочных товарах, столбцы public_id, place_id, updated_at;
- products_scores Хранение public_id всех товаров бренда и соответствующим им скорингов из соответствующей таблицы в yt, столбцы yt_table, brand_id, public_id, score, updated_at;
- top_products Хранение public_id наиболее популярных товаров и соответствующим им скорингов из соответствующей таблицы в yt по категориям в магазине, столбцы yt_table, place_id, category_id, public_id, score, update_at;
- cross_brand_ordered_products Хранение всех кросс-брендовых товаров в виде sku_id (идентификатор мастер-карточки товара) и соответствующего количества заказов с этим товаром, столбцы eater_id, sku_id, orders_count, updated_at;
- ordered_products Хранение public_id всех товаров, купленных в магазинах этого бренда, и соответствующего количества заказов с этим товаром, столбцы eater_id, brand_id, public_id, orders_count, updated_at;
- user_orders Хранение факта наличия товаров из истории заказов пользователя в БД. Нужен для избежания лишнего запроса в eats-ordershistory в случае, если у пользователя нет заказов в ритейле. Столбцы: eater_id, updated_at

### Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?
99 брендов

7216 магазинов

в среднем 1500 скидочных товаров в 1 магазине

место занимаемое одной ячейкой:
- slug - 40 байт (максимум);
- eater_id, yt_table - 16 байт (максимум);
- id, place_id, brand_id, category_id, orders_count - 4 байта;
- updated_at, score - 8 байт;
- public_id, sku_id - 36 байт
- is_enabled - 1 байт
  
место, занимаемое одной строкой в таблице brands:
4 + 40 + 8 = 56 байт

место, занимаемое одной строкой в таблице places:
4 + 40 + 4 + 1 + 8 = 57 байт

место, занимаемое одной строкой в таблице discount_products:
36 + 4 + 8 = 48 байт

место, занимаемое таблицей brands:
56 * 99 = 5544 байт

место, занимаемое таблицей places:
7216 * 57 = 411312 байт = 402 КБ

место, занимаемое таблицей discount_products:
1500 * 7216 * 48 = 519552000 байт = 507375 КБ = 496 МБ

место, занимаемое одной строкой в таблице places:
4 + 40 + 4 + 1 + 8 = 57 байт

место, занимаемое одной строкой в таблице products_scores:
16 + 4 + 36 + 8 + 8 = 72 байт
  
место, занимаемое одной строкой в таблице top_products:
16 + 4 + 4 + 36 + 8 + 8 = 76 байт
  
место, занимаемое одной строкой в таблице cross_brand_ordered_products:
16 + 36 + 4 + 8 = 64 байт
  
место, занимаемое одной строкой в таблице ordered_products:
16 + 4 + 36 + 4 + 8 = 68 байт
  
место, занимаемое одной строкой в таблице ordered_products:
16 + 8 = 24 байт

Так как в остальные таблицах будут данные, которые в данный момент находятся в redis сервиса eats-products (2.5 Гб), то можно примерно оценить объем данных:
2.5Гб / (10+8) = 150000000 товаров. 150000000 * 76 = 11400000000 = 10.6 Гб

Всего занимаемое место:
5544 + 411312 + 519552000 + 11400000000 = 11.1 ГБ

Всего с учетом роста 20% в год через 5 лет:
27,7 ГБ

### Какие операции над данными заложены?
с точки зрения технических данных, то все действия с ними выполняются через бд, там - CRUD.

с точки зрения бизнес логики:
- чтение из БД и преобразование прочитанных данных к формату ответа;
- получение истории заказов пользователя и сохранение id товаров из заказа в БД
- обмен origin_id+place_id на public_id в сервисе eats-products (как часть предыдущего действия).

### Есть ли какой-то стейт в памяти, как он обновляется и валидируется?
Нет

### Какая нагрузка ожидается?
Обновление ассортимента большинства магазинов осуществляется 1 раз в день (событие new_assortment), в этом случае будет вызываться stq и обновлять данные в БД
Обновление цен в большинстве магазинов осуществляется 1 раз в несколько дней, в этом случае будет вызываться stq и обновлять данные в БД
Обновление товаров из истории заказов пользователя осуществляется каждый раз, когда пользователь завершил заказ, в этом случае будет вызываться stq и обновлять данные в БД
Обновление брендов и магазинов в БД будет осуществляться каждые 5 минут

Ожидаемые rps:
- 40 rps на ручку получения товаров в динамических категориях
- 6 rps на ручку получения каруселей товаров
- 15 rps на ручку получения товаров из кросс-брендовой истории заказов пользователя

С учетом роста количества пользователей +20% в год через 5 лет:
- 100 rps на ручку получения товаров в динамических категориях
- 15 rps на ручку получения каруселей товаров
- 40 rps на ручку получения товаров из кросс-брендовой истории заказов пользователя

Нагрузка на БД:

Чтение:

100 * 4 rps + 15*4 rps + 45 rps = 505 rps

Запись:
на запись наиболее популярных товаров в категориях:
150*3 rps (в пиках до 300*3 rps) = 450-900 rps


### Какие фолбеки предусмотрены на сам этот сервис?
Фолбек отстуствует, в случае отказа пользователи не смогут увидеть динамические категорий и карусели товаров

### Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?
В случае отказа коры(монолита) при обновлении таблиц place и brand: сервис продолжит работать с текущим списком магазинов.

В случае отказа eats-nomenclature при обновлении бд с товарами: обновления товаров не произойдет, будут отдаваться данные из бд

В случае отказа eats-ordershistory при обновлении товаров из истории заказов пользователя: будут отдаваться данные из бд

В случае отказа eats-discounts при получении скидок на товары: будут учитываться только скидочные товары из бд

В случае отказа eats-products при получении маппинга id товаров: скоринги товаров в бд не будут обновлены

Сервис хранит у себя в БД все данные, необходимые для ответов, поэтому он считается автономным.
При невозможности взаимодействия с другими сервисами он будет продолжать отдавать данные с актуальностью на момент последнего взаимодействия.

### Какие возможности масштабируемости закладываются?
С учетом роста количества пользователей ритейла на ближайшие 5 лет, возможно, горизонтального в виде увеличения количества тачек.

### Какие точки отказа есть в сервисе?
- отказ базы postgres;
- отказ работы периодиков;
- отказ работы stq;
- проблемы с сетью/железом/электричеством.

### Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить
- Количество ответов с каруселями товаров
- Количество ответов с динамическими категориями

### Укажите технические метрики
- Параметры выполнения stq обновляющих списки брендов и плейсов
- Параметры выполнения stq обновления данных о товарах
- Время выполнения действий с postgres
- Количество данных в postgres
- Время ответов за запросы

### Какая функциональность ожидается в сервисе в будущем?
В данный момент не планируется

### Какое изменение нагрузки планируется?
Пропорционально росту числа пользователей ритейла Еды

### Активно ли будет изменяться сервис?
Скорее периодично в зависимости от появления новых продуктовых фич

## Схема взаимодействия с севрисом:
https://miro.com/app/board/o9J_lgi6ntM=/

## Сервис отвечает за:
1. Товары, которые находятся в динамических категориях
2. Товары, которые находятся в каруселях
3. Товары из кросс-брендовой истории покупок пользователя

## Выбор базы данных для хранения данных

### Postgres
Плюсы:
- Можно добавить допонительные поля для хранения (Например, флаг доступности)
- Можно получить данные по списку категорий одним сетевым запросом
- Старые данные не будут удалены при долгом отсутствии обновлений

Минусы:
- Более сложные запросы
- Займет больше места из-за необходимости дублировать place_id, category_id, updated_at для каждого товара (Примерно на 10%)
- Нужно реализовывать ручкой механизм обновления и удаления старых записей

### Redis
Плюсы:
- По одному ключу можно за раз получить список нужных товаров
- Не нужно следить за временем жизни объектов
- Проще логика обновления данных (не нужно удалять старые, обновлять измененные, добавлять новые)

Минусы:
- Есть необходимость следить за тем, чтобы при добавлении нового ключа не пересечься с уже существующми
- В некоторых случаях может оказаться, что данные протухли (долго не было обновления ассортимента в магазине)
- Менее надеждный, меньше гарантий (https://wiki.yandex-team.ru/taxi/backend/userver/redis/)
- На каждый запрос по 1 сетевом походу (кроме случаев пайплайнинга, но он усложняет реализацию)
- Не очень удобно хранить свои структуры данных

**Так как большого смысла иметь 2 вида БД нет, если в одной из них будет совсем мало данных,
то Postgres является более удобной БД для хранения всех данных сервиса**

## Процесс перехода:
### Фаза 1 - Перенос хранение истории заказов пользователя

Текущие сценарии использования товаров из истории заказов пользователя:
1. История заказов в конкретном бренде: товары, которые пользователь покупал только в этом бренде
2. Кросс брендовая история заказов в конктретном магазине: товары, которые пользователь покупал в разных брендах, которые есть в наличии в этом магазине
3. Кросс брендовая история заказов в конктретном магазине, с замешанной историей заказов в бренде: 2-ой кейс с учетом товаров, которые он покупал в текущем бренде.
   Так как у товара может отстутствовать связь с мастер-карточкой (sku_id) и такие товары не будут учтены
4. Кросс брендовая история заказов в конктретном магазине и отдельно брендовая история (комбинация кейсов 1 и 2):
   оба списка товаров (текущего бренда и всех брендов) для корректного формирования их пересечений (кросс-брендовая динамическая категория "Мои покупки", "Закупидон")

#### Варианты хранения истории пользователя

##### Вариант 1 - Хранение всех public_id кросс-брендовых товаров
По составному ключу eater_id+place_id+public_id хранить массив [public_id -> count], где count - количество заказов с этим товаром
Чтение из БД:
- ходим в бд со списком [public_id] и place_id, чтобы отсеять те public_id, которые принадлежат запрошенному place_id
  Но так как в этом сервисе нет подходящей таблицы (как place_products в eats-products), то данный подход не может быть реализован. А ходить в eats-products для этого не имеет смысла, лучше уж тогда в eats-nomenclature сходить

При записи в БД нужна новая ручка номенклатуры, которая по [sku_id] вернет вообще все public_id во всех брендах для каждого sku_id
Плюсы:
- при чтении из БД нет необходимости делать запросы в номенклатуру

Минусы:
- нужна новая ручка в номенклатуре, предположительно она будет явно тяжелее текущей
- в БД будет значительно больше данных, чем в текущий момент. В том числе данные для магазинов, в которые пользователь вообще не заходит
- в текущем виде не может быть реализован

##### Вариант 2 - Хранение sku_id кросс-брендовых товаров
Повторение текущей реализации в eats-products только с переносом хранилища в postgres

По составному ключу eater_id+sku_id хранить count,
sku_id - идентификатор мастер карточки товара
count - количество заказов с этим товаром

При записи:
- получение истории заказов из eats-ordershistory
- получение [public_id] по [origin_id] в eats-products
- получение [sku_id] по [public_id] в eats-nomenclature

При чтении:
- получение [sku_id] из БД
- обмен [sku_id] на [public_id] в place_id в eats-nomenclature

**Так как вариант 1 не подходит, то реализован будет 2-ой вариант**


#### Что потребуется реализовать: [13d]
1. Ручка получения [public_id -> count] истории заказов по eater_id+brand_id [3d]
2. Ручка получения [public_id, sku_id, count] кросс-брендовой истории заказов по eater_id+place_id [3d]
   В списке товаров будут в том числе те, которые были куплены в этом бренде, но у них нет sku_id
3. STQ обновления истории [1d]
4. Чтение из логброкера ивентов коры [1d]
5. Таблица с брендами + кэш [2d]
6. Таблица с магазинами + кэш [2d]
7. Добавить правила архивации старых записей в таблицах: user_orders, ordered_products, cross_brand_ordered_products [1d]


### Фаза 2 - Перенос динамических категорий

#### Что потребуется реализовать
1. Подписка на сообщения из логброкера из номенклатуры (new_assortment, new_prices)

   Переходит полностью в том же виде, что и сейчас

2. Stq обновления популярных товаров в БД по событию new_assortment

   В stq обновления топов дополнительно сохранять топ товаров в магазине. Логика аналочна текущей, только вместо redis, сохранять в postgres

3. Stq обновления скидочных товаров в таблице со скидочными товарами

   Делается запрос в номенклатуру, получаются все категории и товары в этих категориях, отсеиваются скидочные товары,
   сохраняются public_id товаров в таблицу pg (возможно, есть смысл цену тоже сохранять для последующей сортировки)

4. Ручка динамических категорий для поиска.
   Переносится полностью в том же виде, как сейчас в реализована ее 2-ая версия в eats-products.
   На вход: id категории. На выход: 404, если категория не динамическая, иначе список public_id товаров

5. Ручка получения товаров в динамической категории. На вход: id динамической категории, на выход: список категорий с товарами

   Ручка по большей части реализует логику текущих динамических категорий. Разница только в том, что на выход будут отдаваться только id товаров и их sort_order
```
{
  "categories": [
    {
      "id": string,
      "name": string,
      "products": [
        {
          "id": string,
          "sort_order": optional int
        }
      ],
      parent_id: optional string
    }
  ]
}
```

Массив категорий в данном случае нужен, так как в случае категори "Мои покупки" возможна вложенность подкатегорий

6. Добавить правила архивации старых записей в таблицах: top_products

### Фаза 3 - Перенос каруселей товаров

#### Что потребуется реализовать:
1. Периодик чтения из скорингов из yt

   Большая часть кода в том же виде, что и сейчас. Меняется только часть отвечающая за сохранение.
   В данный момент скоринги сохраняются по origin_id товаров, но их можно перевести на public_id, иначе
   нужно будет ходить за маппингом origin_id -> public_id в eats-products. И вместо redis, сохранять в postgres
2. Подписка на сообщения из логброкера из номенклатуры (new_assortment, new_prices)

   Переходит полностью в том же виде, что и сейчас
3. Stq обновления топов товаров в top-level категориях в БД по событию new_assortment

   Делается запрос в номенклатуру, получаются все категории и товары в этих категориях,
   получаются скоринги товаров, сохраняются public_id товаров с соответствующими скорингами, 
   только вместо redis, сохранять в postgres
4. Stq обновления топов скидочных товаров по событию new_prices

   Делается запрос в номенклатуру, получаются все категории и товары в этих категориях, отсеиваются скидочные товары,
   получаются скоринги товаров, сохраняются public_id товаров с соответствующими скорингами, 
   только вместо redis, сохранять в postgres
5. Сохранение популярных товаров в БД

   В stq обновления топов дополнительно сохранять топ товаров в магазине. Логика аналочна текущей
6. Ручка получения public_id товаров по списку категорий. Вход: [category_id]. Выход: [category_id : [public_id, sort_order]]

   Логика отличается от текущей только тем, что отдаются все товары в категориях (обрезание уже будет на стороне eats-products),
   sort_order формируется на основе персонализации и скорингов
```
{
  "categories": [
    {
      "id": string,
      "products": [
        {
          "id": string,
          "sort_order": optional int
        }
      ]
    }
  ]
}
```

7. Добавить правила архивации старых записей в таблицах: products_scores

# Ваши покупки

В качестве MVP требуется переделать категори "Вы заказывали" следующим образом. Данная категория должна быть во всех магазинах, где есть товары, которые пользователь уже заказывал (даже если в этом магазине он эти товары еще не покупал). Категория будет состоять из двух подкатегорий:
1. Вы заказывали в этом магазине: товары, которые пользователь уже покупал в магазине этого бренда
2. Вы заказывали в другом магазине: товары, которые пользователь не покупал в магазинах этого бренда, но зато покупал в магазинах других брендов

## Разработка

Расширить эксперимент eats_products_repeat_category дополнительными полями:
- version: v1, v2. Где v1 - это старый вид категории "Вы заказывали". v2 - это "Ваши покупки" с кроссбрендовыми товарами
- enabled: флаг включена ли категория

В случае version == v2 добавляются поля:
- category_name_override: строка с названием категории. Нужно для того, чтобы для v1 и v2 показывать разные названия ("Вы заказывали" и "Ваши покупки")
- here_category: подкатегория, обозначающей набор товаров, которые пользователь покупал уже в этом бренде
   {
      - name: строка с названием
      - id: числовой идентификатор
   }
- elsewhere_category: подкатегория, обозначающая набор товаров, которые пользователь не покупал здесь, но покупал в других брендах
   {
      - name: строка с названием
      - id: числовой идентификатор
   }

### Обновление истории пользователя [2d]:

Для того, чтобы при каждом запросе меню или каруселей не получать sku_id товаров из номенклатуры, их необходимо хранить внутри сервиса в привязке к пользователю.

В данный момент в сервисе уже есть хранение данных о истории покупок пользователя в редисе.
Обновление данных в редисе присходит в двух случаях:
1. по событию о завершении заказа пользователя
2. Если пользователь в меню запросил категорию "Вы заказывали", но его данных в редисе нет

Сохранение новых данных будет регулироваться флагом в конфиге EATS_PRODUCTS_SETTINGS.
В случае, если флаг отключен, но пользователь попал в v2 версию в эксперименте eats_products_repeat_category, то будет происходить фолбек на v1 версию категории "Вы заказывали"

#### Хранение:
Есть 2 варианта хранения:
1. [sku_id] товаров, которые пользователь покупал.  44 байта на товар, 50 товаров во всех брендах, 350к человек ~ 730 Мб
   
   Плюсы: занимает меньше места
   
   Минусы: при формировании ответа для пользователя придется дополнительно ходить в ручку ```/v1/place/products/id-by-sku-id```
   
2. [public_id] товаров в каждом бренде, которые пользователь покупал. заказы в 10 брендах, 44 байта на товар, 15 товаров в одном бренде, 350к человек ~ 2Гб
   
   Плюсы: при формировании товаров не нужно по [sku_id] получать [public_id] товаров
   
   Минусы: займет очень много места, особенно, если учитывать увеличение количества пользователей и количества брендов

Первый вариант предпочтительней, так как во втором случае слишком много данных придется хранить в базе данных

#### Алгоритм
После получения ответа от eats-ordershistory дополнительно сохранять sku_id товаров, которые пользователь уже заказывал. (не важно в каком бренде)
Количество хранящихся в редисе sku_id для каждого пользователь будет ограничено новым полем в конфиге EATS_PRODUCTS_SETTINGS

1. Получить ответ истории заказов пользователя.
2. По [core_id] сходить за маппингом в [public_id] в бд.
3. По [public_id] в ручке номенклатуры ```v1/product/info``` получить [sku_id]
4. Сохранить в редис в формате [sku_id => count], где count - количество заказов с этим товаром

Ключи редиса:

```has_history:{eater_id}:cross_brands``` - Флаг наличия кроссбрендовой истории покупок

```{eater_id}:cross_brands``` - Список sku_id => count товаров, которые пользователь уже покупал

### Изменения ручки меню

Изменении касаются только случая v2 версии категории "Вы заказывали". В случае версии v1 логика остается прежней

#### Запрос дерева категорий

Алгоритм:
1. Получить из редиса список sku_id товаров, которые он уже заказывал
2. Получить список public_id товаров в ручке ```/v1/place/products/id-by-sku-id``` по списку sku_id
3. Построить пустую категорию, если public_ids.size() > 0

#### Запрос категории

Алгоритм:
1. Получить из редиса список sku_id товаров, которые он уже заказывал, а так же список origin_id товаров, которые были заказаны в текущем бренде. Преобразовать [origin_id] в [public_id] товаров
2. Получить список public_id товаров в ручке ```/v1/place/products/id-by-sku-id``` по списку sku_id
3. Сходить в ручки информации о товаре, чтобы построить товары для ответа
4. Разбить категорию на 2 подкатегории по принципу. Проходим по списку товаров. Для каждого товара:
   Если среди товаров, которые уже были заказаны в этом бренде, нашелся текущий товар, то определить его в подскатегорию Here, иначе в подкатегорию Elsewhere


### Изменения ручки каруселей

Алгоритм:
1. Получить из редиса список sku_id товаров, которые он уже заказывал
2. Получить список public_id товаров в ручке ```/v1/place/products/id-by-sku-id``` по списку sku_id
3. Сходить в ручки информации о товаре, чтобы построить товары для ответа
4. Построить ответ

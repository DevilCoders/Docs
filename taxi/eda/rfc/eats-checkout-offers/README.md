# Микросервис офферов чекаута Я.Еды
## Что это
Офферы чекаута -- это сущность, которая используется перед созданием заказа. Пользователю предлагается выбрать способ оплаты, доставки, списание/накопление баллов плюса, слот доставки. На каждое такое действие существует отдельно описанный оффер с фиксированной стоимостью. Пользователь, выбирая различные параметры в интерфейсе, фактически выбирает offer_id к которому эти параметры привязаны. После того как оффер выбран, его идентификатор отправляется в ручку создания заказа, чтобы его можно было применить.  

## Как сейчас
[Актуальная схема](https://github.yandex-team.ru/vshept/schemas/blob/da502b46064f195fe92a2cadcde47c5aa21550fe/schemas/services/eda-checkout/api/definitions/go-checkout.yaml)

Офферы чекаута существуют в eda_core (php монолит Еды), фронты делают запрос в ручку коры(api-proxy) `api/v2/cart/go-checkout`, получают все возможные офферы и работают с ними, пока пользователь находится на странице чекуата. Когда пользователь выбрал необходимый оффер происходит запрос в `POST api/v1/orders`, заказ создается на основе перегенерированных офферов (так как они не сохраняеются)

Взаимодействие со слотами релизовано через api-proxy и сервис eats-slots.

Основные параметры, на основе которых мы генерируем офферы:
1. payment_method (карта, applepay, googlepay, наличка)
2. Способ получения заказа (курьер, ровер, самовывоз)
3. Я.Плюс (списание или накопление)
4. Слоты доставки

Как генерируем: перемножением; все доступные способы оплаты на все способы получения x2 на использования/списание плюса. Т.е. если у пользователя 3 карты, apple_pay и доставка курьером или самовывоз и активный плюс, то получаем 3x2x2=12 офферов. Слоты доставки всегда стоят одинаково, поэтому на количество офферов сейчас не влияют.

Примерный ответ API: 
```(json)
{
  "offers": [
    {
        "id": "oid-1",
        "payment_method": "card-123",
        "order_receiving_type": "delivrey",
        "cost_for_customer": "123.00",
        "yandex_plus": {
            "type": "save_up"
        }
    },
    {
        "id": "oid-1",
        "payment_method": "card-123",
        "order_receiving_type": "delivrey",
        "cost_for_customer": "123.00",
        "yandex_plus": {
            "type": "use"
            "amount": "23.00"
        }
    },
    ...
    // 12 офферов на все варианты оплаты/доставки/...
  ]
}
```

Основные известные проблемы:
1. Количество офферов ограничено из-за комбинаторного взрыва (на каждый вариант доставки/оплаты/whatever генерируется отдельный оффер, появились проблемы, когда захотели реализовать слоты на доставку)
2. Офферы живут в рантайме и доступность других сервисов (eats-payments, eats-cart, eats-plus) влияет на создание заказа

## Что хотим
1. Унести логику из монолита в микросервис, для продуктового и технического развития
3. Реализовать новое взаимодействие с фронтами (для решения проблемы 1)
4. Записывать офферы в базу и отдавать (для решения проблемы 2)

## Как будем делать
Хочется отойти от схемы, когда мы генерируем весь набор офферов. Будем это делать только для текущего стейта пользователя, а чтобы уменьшить количество запросов на бек, похожие на текущий оффер будем мержить. Новая реализация предполагает, что на бекенде будет конфиг-ограничитель, который не позволяет генерировать более определенного числа офферов. Таким образом проблема с тем, что фронт получает гигантский ответ, будет решена.

Фронтам говорим явно как перейти в оффер, если параметр в интерфейсе был изменен. В данном случае может быть 3 варианта
1. Текущий оффер не меняется, тогда и делать ничего не нужно
2. Переход будет локальным - это значит, что в списке офферов, который мы отправили и его нужно только найти
3. Оффера нет в списке, но он есть на сервере

Примерный json:
```(json)
{
    "offers": {
        "oid-1": {
            "transtions": {
                "payment_method": {
                    "current": "card-1",
                    "others" {
                        "card-2": {
                            "entity_id": "card-2",
                            "action": "use_current" // значит, что оффер не меняет, переход бесплатный
                        },
                        "card-3": {
                            "entity_id": "card-3",
                            "action": "use_local_offer" // значит, что оффер локальный, нужно его искать в общем списке
                            "offer_id": "oid-2" // используя этот id
                        },
                        "card-4": {
                            "entity_id": "card-4",
                            "action": "request_new2" // значит, что оффера нет в списке, нужно перезапросить на беке
                        }
                    }
                },
                "order_receiving_type": {
                    // все то же самое как для платежей
                }
            }
            "cost": {...}
        },
        ... // много других офферов
    }
}
```
Подробную реализацию смотри в конце документа

Пример 1: 
1. Пользователь открыл экран чекаута
2. Фронты запрашивают данные без передачи необязательных параметров (payment_method, order_receiving_type, ...) 
3. Генерируется оффер только для последнего метода оплаты, способ доставки используем из корзины
4. Если метод оплаты или доставки не отличается по цене от сгенерированного, то отдаем это понимание на фронт

Пример 2: 
1. Пользователь переключил метод оплаты
2. Фронты запрашивают данные с передачей payment_method_id
3. Генерируется оффер только для выбранного метода оплаты, способ доставки используем из корзины
4. Если метод оплаты или доставки не отличается по цене от сгенерированного, то отдаем это понимание на фронт

Общая идея таких переходов изображена на рисунке. В примере `Offer 1` может ссылаться сам на себя, когда изменение способа оплаты или доставки не приводит к изменению цены. В некоторых случая офферы могут не отдаваться на фронт (`Offer 6`), тогда для его получения нужно сделать дополнительный запрос.

![transitions](img/eats-checkout-offers-transitions.jpeg)

## API
[Ссылка на PR](https://github.yandex-team.ru/taxi/schemas/pull/25937/files)
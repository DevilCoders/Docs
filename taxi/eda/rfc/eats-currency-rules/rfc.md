## Сие есть общий и нерушимый свод правил передачи любых цен в API Еды между бекендами и фронтендами.

Предполагается хард-блок, что ни одна новая ручка/изменение в старой ручке не  
пройдет ревью, если там есть цена , а ее формат на соответствует требованиям  
данного документа. Нарушители будут подвергнуты остракизму.

### Применимость
**Данные правила актуальны для**
- клиентского апи (в первую очередь - в пользовательском продукте, но остальных скорее тоже касается)
- только для новых клиентов (для поддержки старых версий пока оставляем старые поля)

**Не обязательно для**
- back2back (воруй-убивай)
- Я.Плюса (там нет значка валюты и локализации, и много специфики выдачи стилей отрисовки баллов)

### Предлагаемый формат
**Основной вариант**

Для подавляющего большинства вариантов дефолтным считаем формат currency. Любая  
ручка, выдающая цены, обязана **в корне ответа** отдать такую структуру:

```json
"currency": {
	"code": "RUB",
	"sign": "₽",
	"template": "$VALUE$ $SIGN$$CURRENCY$",
	"text": "руб."
}
```

- Сама цена при этом выдается в поле price_value, имя которого как бы намекает,  
  что для его парсинга и отображения нужно использовать currency   
  (e.g. `"price_value": "123.00"`). 
- Цена отдается в строковом виде, содержащем целое или вещественное  
  (возможно, отрицательное - для скидок) число и ничего кроме него  
  (что-то типа `^[-].[0-9 .]+([.,].(\d*))?$`). Подразумевается, что клиенты  
  могут трактовать поле как строку и не пытаться парсить.
- Разделитель и количество знаков после разделителя определяется бекендом 
  по правилам локализации.
- Если есть необходимость выдать несколько цен в одном блоке  
  (например, new_price, old_price), то предлагается отдавать их как объекты,  
  в которых есть значение в поле price_value (e.g. `"new_price: {"price_value": "123"}"`).  
  В случае, если выдача парсится каким-то генеричный парсером, то можно  
  ориентироваться на имя поля для выведения типа. Если выдача парсится конкретной  
  моделькой, написанной руками, где точно прописано, что должно быть в том или  
  ином поле, то данный нейминг призван навести больше консистентности и  
  удобства дебага. Обсуждаемо.
- Если есть необходимость на одном экране показать цены в разных валютах  
  (такой пример пока нашли один - история заказов), то структура currency   
  выдается рядом с ценой (для каждой - своя). То есть приоритет - у локального  
  объекта, фолбек на объект в корне. Не уверен, что так (проверку наличия  
  локального приоритетного объекта стоит делать везде, возможно только в  
  истории и подобных ей местах). Пример:
```json
{
  "currency": {
    "code": "RUB",
    "sign": "₽",
    "template": "$VALUE$ $SIGN$$CURRENCY$",
    "text": "руб."
  },
  "history": [
    {
      "order_nr": "1",
      "currency": {
        "code": "USD",
        "sign": "$",
        "template": "$VALUE$ $SIGN$$CURRENCY$",
        "text": "dollars"
      },
      "price_value": "10"
    },
    {
      "order_nr": "2",
      "price_value": "200"
    }
  ]
}
```
- Желательно обеспечить required’ность объекта currency и всех его полей.
- *Фоллбек:* Если в корне выдачи не оказалось currency, а в теле есть price_value,  
  то клиент должен показать цену как строку без валюты и форматирования, как  
  есть, но обязательно залогировать ошибку как критичную - она свидетельствует  
  о серьезной ошибке со стороны бека, которая подлежит немедленному исправлению.  
  *Выяснить:* если есть сведения, что отображение цен без валюты несет юридические  
  риски, то можно рассмотреть вариант падения клиента в фатал (экран/сообщение  
  об ошибке, с логированием и отправкой сигнала в мониторинг, НЕ КРАШ).
- *Фоллбек:* Если в используемом шрифте отсутствует символ валюты из поля sign, 
  происходит фоллбек на сокращенное человекочитаемое название валюты из поля text.
- *На будущее:* можем договориться, что currency приходит не в каждой ручке, а   
  в лонче (или похожем месте, вызываемом 1 раз) и прикапывать в клиенте на время  
  существования сессии. Можно оверрайдить в конкретной ручке. Таким образом, в  
  общем случае приоритет убывает от локального объекта через корневой и до  
  лончевого. Тут важно, чтобы при "переходе" в другую страну лонч вызывался повторно.
- Если цена целая, копейки (.00) не отображаются. Эта логика живет в бкекнде,  
  формирующем price_value.
- *Важно:* за формат price_value отвечает бекенд, включая такие аспекты как   
  разделитель (запятая или точка, зависит от локали, плюс THIN_NO_BREAK_SPACE  
  пробел (u202F)), двойные неразрывные пробелы для разделения тысяч и все такое.  
  Вероятно, это нужно вынести в общую библиотеку.
- *Важно:* про содержимое template. Оно бывает захардкожено, бывает из  
  конфигов/экспериментов. За корректность этого содержимого отвечает либо  
  разработчик, написавший его в коде, либо тот, кто его редактирует через  
  админку. К этому темплейту также есть ряд требований (например, что пробел  
  должен быть неразрывный - `&nbsp`), но они выходят за рамки данного документа.

**Оверрайд**

В редких случаях, когда общие правила форматирования не подходят, допустимо  
использовать локально иной вариант: `"price_formatted": "100.23 $SIGN$$CURRENCY$"`
- Пример использования: для отображения стоимости доставки со специфическим  
  шаблоном ("0₽ - 149₽")
- Для интерпретации такого поля структура currency используется для получения  
  самой валюты, но не шаблона.
- О том, что для интерпретации этого поля работают именно эти правила, можно  
  также понять по имени поля. При нескольких ценах в одном блоке правила  
  аналогичны price_value.
- Содержимое поля может состоять из чисел и переменных подстановки, но в общем  
  случае может содержать что угодно, так что парсить его не рекомендуется.
- *Фоллбек:* Если в корне выдачи не оказалось currency, а в теле есть  
  price_formatted, то значения переменных подстановок предлагаю считать пустыми  
  строками (с той же оговоркой про юр. риски, что и выше). Это также надо  
  логировать и алертить как серьезную ошибку, но все лучше, чем фатал или краш.

### План внедрения
- Новые правила мы в начале вводим только для новых полей и новых версий  
  клиентов. То есть не надо бросаться переписывать все и везде.
- Старые поля продолжают отдаваться и обрататываться как есть.
- Любое новое поле с ценами уже подчиняется новым правилам. Фронты обрабатывают  
  новые поля уже по новым правилам.
- При любых изменениях в выдаче цен ранее существовавших полей к ним добавляется  
  отдача новых полей по новым правилам; на фроны ставится тикет на переход на  
  новые поля в рамках техквоты.
- Так постепенно большая часть цен переходит на новый формат (по мере 
  эпизодических правок старых полей (и введения новых) и перехода фронтов на них).  
  Вероятно, в какой-то момент стоит устроить упражнение по более массовому  
  переходу на новые поля, чтобы сократить время органического отмирания старых полей.
- Старые поля продолжают отдаваться беком до тех пор, пока существует хотя бы  
  2% клиентов, их использующих.
- Когда все ручки уже отдают новые поля, а все клиенты свежих версий читают  
  новые поля, старые еще небольшое время живут для поддержки хвоста устаревших  
  версий клиентов, потом дропаются.

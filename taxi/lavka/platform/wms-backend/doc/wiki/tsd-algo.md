
## История правок

* **22.10.2019**.
    - у ордера может быть несколько исполнителей (`users` в ордере)
    - подсказка `check` - проверка товара на полке
    - глава о приёмке товара
    - размещение и инвентаризация
 * **23.10.2019**.
    - добавил метод, запрашивающий информацию о полке по её ID
    - shelf - означает имя полки (title из её модели), shelf_id - идентификатор
* **28.10.2019**.
    - отправляемые события включают в себя секцию `users` из ордера (таким образом можно будет экономить запросы на фронте)
    - в ответе авторизации появился `fullname` - полное имя юзера (если где-то надо выводить на фронте)

* **30.10.2019**.
    - Все подсказки, связанные с товаром на полке должны показывать срок годности товара по мнению системы
    - Добавил поле `condition` в подсказки. Если поле присутствует, то подсказка выполняется только для товаров  которые соответствуют указанным условиям.
    - Описал процесс контроля сроков годности
* **05.11.2019**.
    - Добавил в модель заказа `external_id` - внешний идентификатор ордера
    - Добавил новые типы ордеров:
        - `writeoff_prepare_day` - перемещение в списание однодневных товаров без контроля даты
        - `check_valid_regular` - контроль сроков годности и списание обычных (многодневных) товаров
        - `check_valid_short` - проверка сроков годности  под краткосрочных товаров
* **11.11.2019**.
    - Исправил все идентификаторы к единообразному виду:
        - `orderid` -> `order_id`
        - `shelfid` -> `shelf_id` (при этом `shelves` остаётся как был)
        - `productid` -> `product_id`
        - `userid` -> `user_id` (при этом `users` остаётся как был)

    - Добавил способ перемещения товара с полки на полку по инициативе работника

* **28.11.2019**.
    - Добавил возможность создавать с ТСД заявки на инвентаризацию

* **02.12.2019**.
    - Описал собственно процесс списания
    - Появился тип ордера - `writeoff`

* **03.12.2019**.
    - Описал процесс раскладывания по полкам

* **05.12.2019**.
    - Добавил tags в товары и полки

* **16.12.2019**.
    - Добавлены статусы закрытия саджестов в `shelf2box`.
    - Добавлена возможность исправить ранее завершенный саджест.

* **18.12.2019**.
    - Добавлена возможность отмены ранее произведённых действий по саджесту (`CANCEL_ACTION`)
    - Описана возможность "слепой" инвентаризации (новый тип саджеста `check_more`)

* **09.01.2020**
    - Добавлена поддержка стелажей (`rack`) в полки

* **10.01.2020**
    - Затронутые заказом полки
    - Добавил в уведомления серверу событий - поле order.type чтобы фронтенд мог фильтровать интересные ему ордера без их загрузки.
* **16.03.2020**
    - Добавил описание саджеста `check_more`.
    - Добавил главу про проверку конкретного товара на конкретной полке.
* **20.03.2020**
    - Расширили секцию problems в модели ордера
    - Описал более внятно поведение закрытия ордера
* **03.04.2020**
    - Добавил описание снижения уровня авторизаии для совместного
     использования устройств ТСД.
    - Добавил в модель ордера поле `number`. Номер или имя ордера.
    - Добавил в перемещение причину перемещения.
* **06.04.2020**
    - Добавил в модель ордера поле `doc_number` и `doc_date`. Номер и дата документа.
    - Удалил из модели ордера поле `number`. Номер или имя ордера.

* **07.05.2020**
    - Добавил признаки товаров семплинга в саджесты.

* **08.07.2020**
    - Описание работы с сигналами

* **27.08.2020**
    - Описание индикаторов в tsd

## Введение

Все запросы выполняются в JSON. Все ответы должны содержать JSON-тело.
В случае внутернних ошибок (например недоступна база данных) сервер должен выдавать ошибку 500:

```http
500 Internal error
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
   "code": "ER_INTERNAL",
   "message": "Can't connect database"
}
```

Коды ошибок (`code` в ответе) могут выбираться любыми, требования к ним:

1. строковый идентификатор
2. только большие английские буквы и символ подчеркивания и цифры
3. не начинается с цифры и подчеркивания

Ошибки 500 от 1C хорошо бы снабжать префиксом: `ER_1C_`, например `ER_1C_DATABASE_ACCESS`.

1. Все ответы сервера не содержащие JSON считаются некорректными
2. `message` в ответах используется только для логгирования (пользователю не показывается)
3. во всех ответах сервер должен устанавливать заголовок `Access-Control-Allow-Origin: *`

## Ордера

Все манипуляции с заказами, инвентаризацией итп производятся при помощи одного и того же документа, описывающего необходимые манипуляции.

Назовём его `order`. Ордер (не обязательно заказ) может быть создан

- внешней системой (заказ клиента)
- администратором склада (например инвентаризация)
- системой автоматически

Ордер характеризуется следующими статусами:

- `request` - создан, но никто не выполняет (ожидается исполнитель)
- `processing` - исполнитель взял в работу
- `failed` -  (завершён) данный ордер исполнить невозможно
- `complete` - (завершён) данный ордер исполнен, товар отправлен/положен на полки итп
- `canceled` - (завершён) ордер отменён по инициативе стороны, его создавшей

Возможны промежуточные статусы. Например между статусами `request` и `processing` возможен статус `ack`, означающий что один или несколько исполнителей выразили желание исполнить ордер.

Граф статусов:

- `request` - `processing` - `complete` - обычно исполненный ордер
- `request` - `canceled` - ордер отмененный еще до выполнения
- `request` - `processing` - `canceled` - ордер отмененный в процессе выполнения
- `request` - `processing` - `failed` - ордер, в процессе выполнения которого выяснилось что выполнить его невозможно

Соответственно в статусах

- `request` - нет исполнителя, привязанного к ордеру
- `processing`, `failed`, `complete` - есть исполнитель привязанный к ордеру
- `canceled` - исполнитель может быть, а может отсутствовать

Ордера бывают разных типов, предварительно такие:

- `order` - заказ
- `order_errors` - заказ с ошибкой (legacy)
- `refund` - возврат недоставленного заказа на полки (будет создаваться автоматически)
- `acceptance` - приёмка товара
- `stowage` - раскладка (размещение) принятого товара на полки
- `check` - инвентаризация
- `writeoff_prepare_day` - перемещение в списание однодневных товаров без контроля даты
- `writeoff` - списание товаров с полки списания
- `check_valid_regular` - контроль сроков годности и списание обычных (многодневных) товаров
- `check_valid_short` - проверка сроков годности  под краткосрочных товаров

В перспективе еще будут типы ордеров связанные с другими складскими операциями.


### Модель ордера

Приблизительная модель ордера (в реальности будет иметь больше полей чем тут зарезервировано)

```yaml
order_id: "19696188-e121-11e9-a884-0050b6972766"
doc_number: "123-27",
doc_date: "2020-04-06",
external_id: "103511ba-ffae-11e9-96b8-df8dab478346"
parent:
 - "b1c49868-e12f-11e9-b2db-0050b6972766"
 - "5fdad9dc-e36d-11e9-b329-0050b6972766"
status: "processing"
created: 1569587362
version: 23
revision: 123
users:
 - "7e7cb0e8-e121-11e9-a88c-0050b6972766"
type: order
required:
 - product_id: "a0585330-e12a-11e9-a7ff-0050b6972766"
   count: 3
 - product_id: "b052e21e-e12a-11e9-8974-0050b6972766"
   count: 1
problems:
 - product_id: "a0585330-e12a-11e9-a7ff-0050b6972766"
   count: 1
box:
 - id: "a0585330-e12a-11e9-a7ff-0050b6972766"
   count: 3
suggests:
  - suggest_id: "befcfd58-e446-11e9-b5bf-0050b6972766"
    type: "box2shelf"
    shelf_id: "1ad5410e-f594-11e9-bd53-0050b6972766"
    product_id: "f52297d4-e122-11e9-8cbc-0050b6972766"
    count: 7
    status: complete
    data:
      foo: bar
shelves:
  - 5d286674-3380-11ea-b1ff-0050b6a4b5a0
  - bff9437c-3380-11ea-8f28-0050b6a4b5a0
```

Где

- `order_id` - идентификатор ордера
- `external_id` - идентификатор ордера во внешней системе (если ордер сгенерирован внешней системой)
- `doc_number` - Номер из накладной, приходного документа итп.
- `doc_date` -  Дата из накладной, приходного документа итп.
- `status` - статус ордера
- `created` - когда заказ был создан в нашей системе
- `version` и `revision` - версия и ревизия (ниже)
- `users` - пользователь или пользователи, занимающиеся исполнением
- `type` - тип ордера (`order` - заказ, `check` - проверка полки, итп). По этому полю будет выбираться сценарий на фронте
- `box` - список товаров отложенных в корзину исполнителя
- `required` - список товаров, требуемых для исполнения данного ордера
- `parent` - Данный ордер создан автоматически для продолжения работ над указанным в этом поле ордере (например ордер возврата товара на полки будет иметь в этом поле ссылку на ордер-заказ). Каждый последующее наследование ордеров приписывает новый id в начало этого списка.
- `suggests` - список подсказок действий по ордеру. Опционален. Если в ордере его нет, гуй может запросить подсказки отдельным запросом ниже.
- `problems` - список товаров которые отсутствуют на складе
- `data`- опциональные произвольные данные в виде объекта. Фронт обязан послать эти данные в запросах `box2shelf`, `shelf2box`.
- `shelves` - список полок, которые требуется обойти при исполнении ордера.
  Этот список можно использовать для того чтобы в списках ордеров показывать исполнителям информацию о том сколько работы примерно им придётся проделать.


#### Обработка секции `problems`

1. Секция `problems` может быть в ордерах любых типов,
   наличие секции problems обрабатывается в зависимости от типа ордера.
2. Работа по саджестам в заказе с problems может производиться если они
   сгенерированы.
4. После закрытия всех саджестов кладовщик на последнем экране перед закрытием
   ордера видит список проблем, которые остались не решёнными.


Примерный механизм работы с проблемами такой:

1. Наличие проблем в ордере с типом "заказ клиента" (`orders`) приводит к
   генерации саджестов "положить всё обратно на полки" и далее исполнитель
   звонит в КЦ с последнего экрана, затем закрывает ордер как `failed`.
2. Наличие проблем в ордере с типом "раскладка на полки" - должно приводить к
   невозможности закрыть ордер вовсе. Проблемы с этим типом ордера обычно
   связаны с неправильной конфигурацией склада (например пришёл товар для
   морозильника, а морозильник не сконфигурирован).


Секция problems представляет собой массив элементов со следующими моделями
(в категориях OpenAPI):

```yaml

type:
    type: string
    required: true
    default: low
    enum:
        - low                   # недостаточно товара
        - shelf_not_found       # полка не найдена
        - product_not_found     # продукт не найден
        - empty_products        # пустая секция products (при созд ордера)
        - empty_shelves         # пустая секция shelves (при созд ордера)

    product_id:
        description: Идентификатор продукта для `low`, `product_not_found`
        type: string
        required: false

    shelf_id:
        description: Идентификатор полки для `low`, `shelf_not_found`
        type: string
        required: false

    count:
        description: Количество продукта для `low`
        type: integer
        required: false
```

#### Версия и ревизия

Версия - `version` - это версия ордера от источника. Инкрементируется, если источник в процессе жизни ордера изменяет его. У большинства ордеров будет всегда 1, редко 2 и очень редко 3.

Ревизия - `revision` - инкрементируется при любом изменении любого поля в ордере (статус ордера изменился, таска помечена как выполненная итп)

При любом изменении ордера отправляются события в сервер событий:

```yaml
- key: ["order", "store", "123"],
  data:
     order_id: "c42b088a-e368-11e9-9413-0050b6972766"
     status: "processing"
     version: 3
     revision: 27
     users:
      - "9e25de80-f95c-11e9-aa9e-fb10567f9882"
     type: "order"
- key: ["order", "user", "9e25de80-f95c-11e9-aa9e-fb10567f9882"],
  data:
     order_id: "c42b088a-e368-11e9-9413-0050b6972766"
     status: "processing"
     version: 3
     revision: 2
     users:
      - "9e25de80-f95c-11e9-aa9e-fb10567f9882 "
     type: "order"
- key: ["order", "device", "567"],
  data:
     order_id: "c42b088a-e368-11e9-9413-0050b6972766"
     status: "processing"
     version: 3
     revision: 27
     users:
      - "9e25de80-f95c-11e9-aa9e-fb10567f9882"
     type: "order"
```

Сообщения отсылаются следующим получателям:

1. склад (`order`, `store`, `123`)
2. исполнитель (`order`, `user`, `234`)
3. ТСД: (`order`, `device`, `567`)

**Примечания**:
1. Если у ордера не назначен исполнитель, то сообщения исполнителю и ТСД не отсылаются
2. При изменении исполнителя у ордера, уведомления отсылаются и старому и новому исполнителю (и их ТСД)
3. **Важно!**: Если у ордера несколько исполнителей, то события по исполнителям и ТСД отправляются всем.

## API

### Авторизация TSD

В карточке управления сотрудниками складов каждому сотруднику выделяется уникальный (в пределах всех складов вообще) штрихкод. Этот штрихкод можно распечатать на бейджике сотрудника.

Авторизация TSD производится при помощи считывания этого штрихкода сотрудником (сотрудник считывает штрихкод со своего бейджика)

при этом TSD вызывает метод:

```http
POST /user/assign-device HTTP/1.0
Content-Type: application/json; charset=UTF-8

{
  "device": "4e83a38a-e115-11e9-808a-0050b6972766",
  "barcode": "123456788897"
}
```

В ответ система может ответить ошибкой, если JSON невалиден или какой-то параметр в нем не передан:

```http
400 Bad Request
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_PARAM_REQUIRED",
  "message": "barcode is not defined"
}
```

Либо кодом ошибки 403, если код невалиден (или пользователь заблокирован)

```http
403 Forbidden
Content-Type: application/json; charset=UTF-8

{
  "code": "ER_ACCESS_DENIED",
  "message": "barcode invalid"
}
```

В случае успеха возвращается токен, который будет использовать устройство для последующих запросов:

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "OK",
  "token": "5fe70dd2-e116-11e9-a8fe-0050b6972766",
  "user": "3b3f1dd4-e44b-11e9-a5dc-0050b6972766",
  "store": "345",
  "fullname": "Василий Пупкин"
}
```


Где

- `token` - токен, который будет использоваться для дальнейших запросов
- `user` - идентификатор пользователя, который авторизовался
- `store` - идентификатор склада пользователя
- `fullname` - имя пользователя

В случае успеха сервер выполняет следующую работу

1. Находит какому пользователю был присоединён этот TSD ранее (идентификатор)
2. Удаляет связь предыдущего пользователя с TSD
3. Прописывает идентификатор TSD в профиль пользователя, определенного штрихкодом
4. Прописывает уровень доступа TSD в профиль пользователя до уровня `low`
5. Отправляет события в сервер событий:

```yaml
- key: [ "device", "store", "123" ]
  data:
    device: "4e83a38a-e115-11e9-808a-0050b6972766"
    user: "789"
    type: "unlink"
- key: [ "device", "store", "345" ]
  data:
    device: "4e83a38a-e115-11e9-808a-0050b6972766"
    user: "567"
    type: "link"
```

В примере устройство отвязалось от пользователя с id `789` на складе `123` и привязалось к пользователю `567` на складе `345`.


Уровни доступа `TSD` определяют что может делать данный пользователь с `TSD`:

* `low` - собирать заказы
* `high` - может делать всё, что разрешено его ролью (требуется двухфакторная авторизация)

Изменить уровень доступа конкретного TSD для конкретного пользователя можно будет дополнительным запросом (пока оставим его за кадром).

Все последующие запросы от TSD выполняются с полученным токеном.

Токен добавляется в заголовок запроса (синтетический пример):

```http
POST /foo/bar HTTP/1.0
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
   "hello": "world"
}
```

#### Снижение авторизации (неполная деавторизация)

Поскольку ТСД используются косвенным образом даже когда они стоят на зарядке:
на их экранах наблюдаются приходящие ордера итп, то после того как сотрудник
завершил действия по ордеру можно понизить авторизацию (но оставить устройство
способным принимать ордера). Для этого предусмотрен описанный ниже метод.

Этот метод фронт должен вызывать при следующих одновременно выполняющихся
условиях:

- Завершена обработка ордера
- У пользователя больше нет назначенных на него ордеров в статусе `processing`


```http
POST /user/free-device HTTP/1.0
Content-Type: application/json; charset=UTF-8

{
  "device": "4e83a38a-e115-11e9-808a-0050b6972766",
}
```

В ответ возвращается новый токен (ответ такой же как у метода `assign-device`,
но в ответе отсутствуют данные о пользователе:

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "OK",
  "token": "848d669a-7586-11ea-832f-17f8300dc6b0",
  "store": "345",
}
```

Фронт должен заменить используемый токен на тот, что пришёл в ответе и
продолжить работу по получению ордеров и событий.

Токен, полученный после этого запроса даёт возможность:

- получать список ордеров склада
- выполнять методы /barcode, /shelves, /products

Если пользователь решит взять какой-то ордер в исполнение, то фронт должен
попросить у него пикнуть на баркод/qr-код сотрудника и выполнить метод
`assign-device`.

### Работа с ордерами

TSD может получить информацию об интересующих его ордерах, передавая фильтры:

```http
POST /orders HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_ids": [
      "e5217e0e-e11d-11e9-bcd0-0050b6972766",
      "f5628592-e11d-11e9-bd60-0050b6972766"
   ],
   "statuses": [ "processing", "request" ]
}
```

Где:

- `statuses` - означает что необходимо выбрать список ордеров в заданных статусах
- `order_ids` - ограничивает список только определёнными `order_id` ордеров

`order_ids` либо `statuses` могут опускаться (но не оба вместе)

Ответ

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": OK,
  "orders": [
     {
       // тело ордера
     }
  ],
  "errors": [
     {
        "order_id": "e5217e0e-e11d-11e9-bcd0-0050b6972766",
        "code": "ER_NOT_EXISTS",
        "message": "Order not found"
     }
  ]
}
```

В списке `orders` - передаются только те ордеры, которые имеет право видеть данный пользователь. Если ордер не найден, либо информация о нём не доступна для данного пользователя, то о каждом таком исключении пополняется массив `errors` в ответе.

В случае ошибки входных данных возвращается 400, по аналогии с вышеописанными методами

Запрашивающий пользователь имеет право получить ордер, если

1. ордер в статусе `request` или `canceled` (исполнитель не назначен) и пришел на тот же склад на котором работает пользователь
2. ордер в ином статусе (или `canceled` с назначенным исполнителем) и у ордера проставлен исполнителем запрашивающий пользователь

в иных случаях про ордер проставляется ошибка `ER_ACCESS` либо `ER_NOT_EXISTS`

**Запрещенные варианты**:

1. Нельзя опускать оба фильтра (`order_ids` и `statuses` вместе)
2. при передаче в `statuses` значений отличных от `request` и `processing` передача `order_ids` обязательна (иначе возвращается Bad Request)

### Операции над ордером

#### Уведомить систему о готовности исполнить ордер

```http
POST /order/ack HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "3ab319ba-e12b-11e9-9a68-0050b6972766"
}
```

В ответ на этот запрос система может назначить заказ на одного
из запросивших это исполнителей и прислать соответствующее событие
(об изменении заказа) через сервер событий.

Коды ответа:

1. 200 - запрос принят, ордер **возможно** будет назначен в ближайшие секунды.
2. 403 - попытка взять ордер принадлежащий другому складу.
3. 410 - ордер уже назначен на кого-то или отменён.

#### Получить подсказки по заказу в работе

Чтобы исполнить ордер, исполнитель должен знать список действий. Действия сводятся к элементарным операциям:

1. Взять с полки  и положить в коробку (`box`) - `shelf2box`
2. Взять из коробки и вернуть на полку - `box2shelf`

**Примечания**:
- Подсказки генерируются в момент обращения (система может хранить а может не хранить их в записи связанной с ордером)
- Подсказки сортируются в соответствии с позицией полки на складе
- Исполнять подсказки пользователь может в произвольном порядке, это его дело.

```http
POST /order/suggests HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "3ab319ba-e12b-11e9-9a68-0050b6972766"
}
```

В ответ в случае успеха возвращается массив подсказок

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "OK",
  "order_id": "3ab319ba-e12b-11e9-9a68-0050b6972766",
  "suggests": [
     {
        "suggest_id": "befcfd58-e446-11e9-b5bf-0050b6972766",
        "type": "box2shelf",
        "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
        "product_id": "5b3d0e96-e448-11e9-89f6-0050b6972766",
        "count": 7,
        "status": "done"
     }
  ]
}
```

#### Модель подсказки

```yaml
suggest_id: "befcfd58-e446-11e9-b5bf-0050b6972766"
type: "box2shelf"
shelf_id: "1b7675ba-f594-11e9-aeb7-0050b6972766"
product_id: "f52297d4-e122-11e9-8cbc-0050b6972766"
count: 7
status: done
valid: 2030-01-01
condition:
  type: and
  valid: 2029-01-01
  tags:
     - sampling
     - packaging
data:
  helo: world
```

где

- `suggest_id` - идентификатор подсказки
- `type` - тип
- `shelf_id` - полка
- `product_id` - идентификатор товара
- `count` - количество
- `status` - состояние подсказки: `done` - выполнена, `request` - не обработана
- `valid` - дата срока годности товара на полке по мнению системы
- `condition` - условие которое должно быть выполнено. Поле присутствует только когда нужно. Вариант - пустой хеш.
   - `valid` - дата срока годности до указанной даты
- `data` - произвольные данные связанные с подсказкой


Типы подсказок

- `box2shelf` - положить на полку
- `shelf2box` - взять с полки
- `check` - проверить на полке
- `check_more` - инвентаризировать на полке



Статусы подсказок

- `request` - подсказка ещё не обработана
- `done` - подсказка выполнена
- `error` - подсказка не выполнена (исполнитель сообщил о невозможности выполнить)

Что означают статусы применительно к товарам:

- `request` - товар не перемещался.
- `done` - товар перемещён или посчитан. Данные при закрытии товара - верные.
- `error` - товар не перемещался (а если перемещался - то перемещения отменены: товар снова находится на полке/в корзине).

Обязательные поля

В подсказках всех типов обязательные поля

- `suggest_id`
- `type`
- `shelf_id`
- `status`

Поле `data` - если бакенд передаёт это поле - фронтенд возвращает это поле в метод закрытия подсказки.

Поля

- `product_id`, `count` - обязательны для всех подсказок кроме `check_more`. Работа с подсказками `check_more` описана в главе об инвентаризации.


##### Особенности подсказки `check_more`

По умолчанию подсказка содержит только номер полки. Идентификатор продукта не содержит.

Трактуется подсказка как вопрос: "укажите какие ещё товары есть на этой полке, кроме тех что Вы проверяли ранее?".


#### Условные подсказки

Если подсказка содержит поле `condition`, то это означает что необходимо совершить манипуляции только с теми товарами что подходят под условия.

Поле `condition` может так же содержать рекомендательные вещи (необязательные для исполнения). На основе этих вещей фронт формирует какие-то вспомогательные управляющие элементы, подсказки итп.

У раздела `condition` есть следующие поля:

- `valid` - срок годности должен быть ниже или равен указанного в этом поле.
- `all` - товаров может быть меньше или больше указанного в подсказке - необходимо собрать все. При этом при закрытии подсказки поле `count` может быть больше указанного в подсказке.
- `editable` (значение по умолчанию - `true`) - информирует фронт о том, что данный саджест можно исправить (редактировать) после закрытия. Есть ряд случаев, когда саджесты нельзя исправлять. Например если заказ собирался, затем пришла омена - и его надо разложить назад на полки. В этом случае саджесты выполненные ранее уже нельзя исправить.
- `error` (значение по умолчанию - `true`) - информирует фронт о том, что данный саджест можно закрывать в статус `error`.
- `need_valid` (значение по умолчанию - `false`) - при завершении саджеста надо указать valid.
- `cancelable` (значение по умолчанию - `false`) - завершённый в `done` саджест может быть возвращён в `request`;
- `max_count` (в сочетании с all) - `true` означает что `count` не может превышать указанное в саджесте;
- `tags` - массив признаков для того чтобы фронт мог понимать что это за саджест:
    - `sampling` - этот товар добавлен в список в рамках семплинга (добавление вилок к салатам например)
    - `packaging` - этот товар добавлен в список в рамках упаковки (добавление пакета в которые положат товары)

Заполнение `condition` используется фронтендом для того чтобы модифицировать поведение, а так же бакендом чтобы проверять переданные фронтом значения.

## Манипуляции с товарами

Брать товар с полки, а так же класть на полку можно двумя способами:

1. закрывая (выполняя) подсказку
В этом случае:
 - проверяется статус подсказки (если она уже `done`, то возвращается ошибка)
 - проверяется соответствие `count` и `shelf_id`

2. принимая самостоятельное решение (поле `suggest_id` не передается)
В этом случае:
 - проверяется соответствие товара и полки (что на данной полке лежит столько или может быть положено столько)

Вторым способом пользователь может набрать товар не с тех полок. Решать пользоваться ли такой фичей будет фронт.

Запросы в случае передачи `suggest_id` являются идемпотентными (повторная передача запроса не приведет к фаталу)


### Положить товар из коробки на полку

```http
POST /order/done/box2shelf HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "8175c06a-f0b1-11e9-b3f5-53f7dcef5769",
  "suggest_id": "81a63944-e449-11e9-bab7-0050b6972766",
  "product_id": "3ab319ba-e12b-11e9-9a68-0050b6972766",
  "count": 21,
  "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
  "data": {"foo": "bar"},

  "status": "error",
  "reason": {
     "code": "SHELF_IS_FULL",
     "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766"
  }
}
```

Где:

- `order_id` - ордер
- `suggest_id` - закрываемая подсказка
- `product_id` - идентификатор продукта
- `count` - количество продукта
- `shelf_id` - идентификатор полки куда кладётся товар

- `status` - (`done` или `error`, если не указано - `done`) - как закрываем подсказку. С ошибкой или обычно.

Если подсказка закрывается с ошибкой, то поля `product_id`, `count` - передавать не нужно.

В случае закрытия подсказки с ошибкой, дополнительно передаётся обязательное поле `reason`:

- `code` - код причины ошибки
    - `SHELF_IS_FULL` - полка полностью заполнена, нет места
    - `LIKE_SHELF` - товар лучше положить на полку, указанную в `reason.shelf_id`
- `shelf_id` - идентификатор полки проблемной или той что предлагается взамен



В ответ получаем

- 200 Ok, если товар успешно перемещен. В заказе уменьшится запись в соответствующем разделе `box`
- 400 Bad Request, если запрос невалидный
- 409 Conflict, если на данную полку данный товар класть нельзя
- 412 Precondition Failed, если данного товара нет в заказе, а пользователь пытается выполнить операцию

**Примечание о коде 412**. Этот код будет зависеть от типа ордера. Для ордеров с типом "заказ" эта проверка выполняется всегда.
А вот для ордеров с типом "инвентаризация" - наоборот - игнорируется.


### Положить товар с полки в коробку

```http
POST /order/done/shelf2box HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "8175c06a-f0b1-11e9-b3f5-53f7dcef5769",
  "suggest_id": "81a63944-e449-11e9-bab7-0050b6972766",
  "product_id": "3ab319ba-e12b-11e9-9a68-0050b6972766",
  "count": 21,
  "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
  "data": {"foo": "bar"},
  "status": "error",
  "reason": {
      "code": "PRODUCT_ABSENT",
      "count": 11
  }
}
```

В ответ получаем

- 200 Ok, если товар успешно перемещен. В заказе увеличится запись в соответствующем разделе `box`
- 400 Bad Request, если запрос невалидный
- 409 Conflict, На данной полке не могло лежать данного товара.
- 412 Precondition Failed, если данного товара нет в заказе, а пользователь пытается выполнить операцию

**Примечание о коде 412**. Этот код будет зависеть от типа ордера. Для ордеров с типом "заказ" эта проверка выполняется всегда.
А вот для ордеров с типом "инвентаризация" - наоборот - игнорируется.


Подсказка `shelf2box` может быть завершена с ошибкой. Это означает, что кладовщик не нашёл нужный товар на этой полке.

При этом кладовщик указывает причину почему он закрывает саджест с ошибкой:

- `PRODUCT_ABSENT` - товара на полке в нужном количестве нет. При этом поле `reason.count` указывает сколько товара на полке не хватает для исполнения ордера.
  В примере запрошено 21 товар, а в ошибке сообщили о недостаче 11 штук. Значит на полке есть 10.


В ответ на закрытие подсказки со статусом ошибки, система может

1. сгенерировать другую подсказку (взять те же товары с других полок)
2. самостоятельно инициировать процесс работы с клиентом по вопросу "у нас нет этого товара в нужном количестве".

### Проверить наличие товара на полке

```http
POST /order/done/check HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "8175c06a-f0b1-11e9-b3f5-53f7dcef5769",
  "suggest_id": "81a63944-e449-11e9-bab7-0050b6972766",
  "product_id": "3ab319ba-e12b-11e9-9a68-0050b6972766",
  "count": 21,
  "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
  "data": {"foo": "bar"},
  "valid": "2029-12-11",

  "status": "done"
}
```

В ответ получаем

- 200 Ok, пометка о проверке успешно сохранена
- 400 Bad Request, если запрос невалидный

В процессе проверки подсказки пользователь может обнаружить товара больше или меньше чем его указано в подсказке.
при этом он сообщает точное количество найденного товара. Таким образом, значение `count` ноль - валидно для данного запроса.

**важно**: При завершении подсказки пользователь может указать срок годности (в перспективе и другие параметры).


### Проверить наличие неучтённого товара на полке

```http
POST /order/done/check_more HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "8175c06a-f0b1-11e9-b3f5-53f7dcef5769",
  "suggest_id": "81a63944-e449-11e9-bab7-0050b6972766",
  "product_id": "3ab319ba-e12b-11e9-9a68-0050b6972766",
  "count": 21,
  "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
  "data": {"foo": "bar"},
  "valid": "2029-12-11",

  "status": "done"
}
```

В ответ получаем

- 200 Ok, пометка о проверке успешно сохранена
- 400 Bad Request, если запрос невалидный

Подсказка `check_more` может закрываться двумя способами:

1. с указанием `product_id`, `count` (и опционально `valid`). Это означает что на полке найден указанный неучтённый товар.
2. без указания `product_id` итп. Это означает что неучтённых товаров нет.

Закрытие подсказки `check_more` с ошибкой пока не предусматривается.


### Завершить выполнение ордера

Когда работник собрал все товары, либо обнаружил проблемы с тем что какого-то товара нет, то в результате его действий вызывается этот метод:

```http
POST /order/change_status HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
   "order_id": "012c743c-e371-11e9-8861-0050b6972766",
   "status": "complete"
}
```

В случае, если пользователь определил что ордер не может быть исполнен, то вызывается тот же метод, с другим статусом:

```http
POST /order/change_status HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
   "order_id": "012c743c-e371-11e9-8861-0050b6972766",
   "status": "failed",
   "reason": "incomplete",
   "comment": "Я не смог найти на полках этот долбанный сырок!"
}
```

В случае закрытия ордера с ошибкой, пользователь выбирает идентификатор причины (`reason`) и может написать коментарий (опциональный)

Возможные значения `reason` (будет пополняться со временем):

- `incomplete` - не нашел товар
- `comment` - другая причина (указана в коментарии): в этом случае заполнение `comment` обязательно

При попытке успешного завершения ордера выполняются проверки:

1. товары в корзине (`box`) соответствуют товарам в секции `required`)
2. нет лишних товаров в `box`
3. `suggests` проверять на закрытость не нужно (будут типы работ где определять что переместить и куда будет решать работник)

***Важно***: Система может не закрывать ордер в ответ на данный запрос.
А только сохраняет пометку о том что пользователь указал как будет завершён
ордер.

В ответ на этот запрос система может

1. закрыть ордер (в TSD придут уведомляющие события)
2. сгенерировать новый набор саджестов (например пользователь пометил какой-то
order как failed, а у него на руках в box есть какие-то товары: система
предложит саджестами разложить их обратно на полки)

Если этот запрос выполнен до завершения всех саджестов, то после завершения
последнего система сама закроет ордер с указанным статусом и пришлёт
соответствущее событие.



### Информация о полках

Зная идентификатор полки можно запросить ее параметры.

```http
POST /shelves HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
    "ids": [
        "1ad5410e-f594-11e9-bd53-0050b6972766",
        "1b7675ba-f594-11e9-aeb7-0050b6972766",
    ]
}
```

В ответ возвращается информация о полках:

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "OK",
  "shelves": [
     {
        "shelf_id": "1ad5410e-f594-11e9-bd53-0050b6972766",
        "title": "Полка 10",
        "barcode": "123456",
        "type": "store",
     }
  ],
  "errors":[
      {
        "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
        "code": "ER_NOT_EXISTS",
        "message": "Product not exists"
      },
  ]
}
```


Модель полки


```yaml
shelf_id: 1b7675ba-f594-11e9-aeb7-0050b6972766
title: Полка у окна
barcode: "112344989892"
type: store
tags:
 - refrigerator
 - freezer
rack: Стелаж 1
```


Типы полок могут быть следующие

- `store` - склад
- `incoming` - приёмка товара
- `out` - отправка товара (выдача курьерам)
- `trash` - полка для списанного товара


Поля:
- `shelf_id` - идентификатор полки
- `title` - название
- `barcode` - штрихкод
- `type` - тип
- `tags` - список дополнительных признаков полки и товара
  (разъяснение в товарах)
- `rack` - стелаж (подмножество которому принадлежит полка)

### Информация о товарах

Зная идентификатор товара можно запросить подробную информацию о нём (или о них)

```http
POST /products HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
    "ids": [
        "d803f1b4-e372-11e9-b578-0050b6972766",
        "d86e31b4-e372-11e9-a3cf-0050b6972766",
        "d8b206aa-e372-11e9-b607-0050b6972766"
    ]
}
```

В ответ получаем `400 Bad request` при несоблюдении формата или список метаинформации о товарах:

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "OK",
  "products": [
     {
        "product_id": "d803f1b4-e372-11e9-b578-0050b6972766",
        "barcode": ["123456", "345678"],
        "title": "Батончик МАРС, 100г",
        "description": "Длинное описание батончика МАРС 100 г.",
        "images": [
             "81449bf2-e373-11e9-b3e2-0050b6972766"
        ],
        "available": [
           {
              "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
              "count": 22,
              "reserved": 11,
           },
           {
              "shelf_id": "1b7675ba-f594-11e9-aeb7-0050b6972766",
              "count": 11,
              "reserved": 0
           },
     }
  ],
  "errors":[
      {
        "product_id": "d86e31b4-e372-11e9-a3cf-0050b6972766",
        "code": "ER_NOT_EXISTS",
        "message": "Product not exists"
      },
      {
        "product_id": "d8b206aa-e372-11e9-b607-0050b6972766",
        "code": "ER_NOT_EXISTS",
        "message": "Product not exists"
      },
  ]
}
```

### Модель товара

```yaml
product_id: "d803f1b4-e372-11e9-b578-0050b6972766"
barcode:
  - "123456"
  - "345678"
title: "Батончик МАРС, 100г"
description: "Длинное описание батончика МАРС 100 г."
images:
   - "81449bf2-e373-11e9-b3e2-0050b6972766"
available:
  - shelf_id: "1b7675ba-f594-11e9-aeb7-0050b6972766",
    count: 22
    reserved: 11
  - shelf_id: "2b7675ba-f594-11e9-aeb7-0050b6972766",
    count: 11
    reserved: 0
tags:
  - refrigerator
```

где

- `product_id` - идентифкатор товара в номенклатуре
- `barcode` - список штрихкодов, идентифицирущих данный товар
- `title` - заголовок/название товара
- `description` - "длинное" описание товара
- `images` - список ссылок на изображения товаров (возможно урлы - надо решить)
- `available` - описывает наличие товара на данном складе (номера полок где лежит и сколько)
   - `shelf_id` - полка
   - `count` - количество
   - `reserved` - сколько зарезервировано для выполнения ордеров
- `tags` - дополнительные признаки товара и полки

#### Дополнительные признаки товара и полки

Используются для визуальных и прочих сопоставлений. Формализуются при
разработке в коде (а не в админках).

На текущем этапе выделяем два признака

* `refrigerator` - холодильник. Такой признак у полки означает, что полка
  является холодильником. Такой признак у товара означает, что товар следует
  хранить в холодильнике
* `freezer` - морозильник.
* `freezer2_2` - холодильник -2+2.
* `freezer24` - морозильник -24.
* `safe` - сейф.
* `domestic` - бытовая химия.

### Распознавание штрихкода

Штрихкодами оснащены:

1. полки
2. корзины доставки
3. бейджики работников склада
4. товары

Данный метод позволяет выяснить на что указывает штрихкод:

```http
POST /barcode HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
    "barcode": "123455"
}
```

В ответ получаем

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "OK",
  "found": [
     {
        "type": "shelf",
        "shelf_id": "511e0948-e375-11e9-96c4-0050b6972766",
        "title": "Полка 123",
        "available": [
            {
                "product_id": "030204dc-e45e-11e9-8978-0050b6972766",
                "count": 10,
                "resevred": 2
            }
        ]
     },
     {
        "type": "user",
        "user_id": "715ebdce-e375-11e9-b6fe-0050b6972766",
        "title": "Вася Пупкин",
     },
     {
        "type": "product",
        "product_id": "8d30e98c-e375-11e9-b7b8-0050b6972766",
        "title": "Баточник Сникерс 100г",
        "available": [
           {
              "shelf_id": "511e0948-e375-11e9-96c4-0050b6972766",
              "count": 22,
              "reserved": 11,
           },
           {
              "shelf_id": "afee0948-e375-11e9-96c4-0050b6972766",
              "count": 11,
              "reserved": 0
           },
    ],
     }
  ]
}
```

Особенности:

- Порядок поиска:
   - поиск товара по коду
   - поиск полки по коду
   - поиск пользователя по коду

- Любой успешный поиск означает что следующий поиск выполняться не будет (то есть если нашли полку, пользователей не ищем): соответственно ответ как в примере невозможен.


### Присоединение/отсоединение исполнителя ордера

```http
POST /order/executer HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
   "order_id": "012c743c-e371-11e9-8861-0050b6972766",
   "link": [
      "ede17264-f0d7-11e9-ae3c-1704dad851bb",
      "f67837d2-f0d7-11e9-8f1e-4bc5021f432c",
   ],
   "unlink": [
       "0d43d41c-f0d8-11e9-b4b1-13dfd6c8bfa0"
    ],
}
```

Где
- в секции  `link` перечислены пользователи которых надо **добавить** в список исполнителей ордера
- в секции `unlink` - перечислены пользователи которых надо **удалить** из исполнителей ордера

При присоединении/отсоединении пользователей можно менять версию ордера.

```http
200 Ok
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "OK",
  "message": "Success"
}
```

Ошибки  (помимо 400) только три:

1. Нельзя удалять всех исполнителей ордера:

```http
410 Conflict
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_EXECUTER_REQUIRED",
  "message": "One executer required at least"
}
```

2. Не найден один из указанных в списке исполнителей


```http
404 Not Found
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_UNKNOWN_USER",
  "message": "User not found",
  "details": {
      "users":  [
         "0d43d41c-f0d8-11e9-b4b1-13dfd6c8bfa0"
      ]
  }
}
```

3. Так же если автор запроса не является исполнителем ордера, либо если ордер уже завершен, то возвращается ошибка доступа 403

```http
403 Forbidden
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_ACCESS",
  "message": "Forbidden",
}
```

### Приёмка товара

Это обычный order с отличным значением типа.

Задачей `order` является проверка наличия товаров на условной полке разгрузки.

Тип ордера - `acceptance`.

Все подсказки идут с типом `check`, номер полки в этом случае указывается как номер полки приёмки. то есть в инфраструктуре склада регистрируется полка приёмки товара.

После того как все подсказки данного ордера будут выполнены (некоторые будут завершены с числами `count`, отличающимися от первоначальных, то данный ордер будет переведён в статус `complete`.

После этого система сгенерирует один или несколько ордеров на размешение на полки с типом `stowage`.

### Размещение на полках

Это тоже обычный `order` с типом `stowage`. Все подсказки данного ордера идут с типом `box2shelf`. Выполнять могут как несколько так и один исполнитель в обычном режиме.

Данный ордер оформляется автоматически после того как будет выполнена приёмка товара.

Особенности работы в том, что пользователи выполняют подсказки `box2shelf`.

При их выполнении, система неизбежно может ошибиться с ёмкостью полки, либо выбрать неудобную полку.

Для разруливания подобных проблем, пользователь может закрыть подсказку `box2shelf` с простановкой
статуса ошибки.

При простановке статуса ошибки, пользователь обязан указать причину, почему данная подсказка не может быть исполнена.

Общая схема такая:

1. Пользователь сообщает: данная подсказка не может быть исполнена, причина - недостаточно места на полке
2. Система генерирует новую подсказку с другим номером полки
3. Пользователь исполняет новую подсказку

Еще вариант

1. Пользователь сообщает: данная подсказка не может быть исполнена, причина - товару лучше храниться не на полке X, а на полке Y
2. Система генерирует новую подсказку с номером полки Y
3. Пользователь исполняет новую подсказку

### Инвентаризация

Это `order` с типом `check`. Все подсказки данного ордера идут с типом `check`.
У подсказок проставлен `condition.all`.

`order` с типом `check` может содержать в себе одну подсказку (для каждой инвентаризируемой полки) с типом `check_more`.

Закрытие этой подсказки в `done` с указанием найденного товара приводит к тому, что
бакенд генерирует новую подсказку `check_more`.

Закрытие этой подсказки в `done` без указания найденного товара указывает что на этой полке нет больше новых товаров.

### Слепая инвентаризация.

Это `order` с типом `check`, содержащий только подсказки `check_more`. Логика работы как описана выше.

### Контроль сроков годности и перекладывание на полку списания

Это `order` с типом:
1. `writeoff_prepare_day` - списание однодневных товаров
2. `check_valid_short`	  - списание краткосрочных товаров
3. `check_valid_regular`  - списание долгосрочных товаров

 Содержит подсказки:

- `shelf2box` с проставленным `condition.valid` и `count`,
  соответствующему количеству товара на полке

- `box2shelf` с проставленным `condition.valid` и `count`,
  соответствующему количеству товара на полке

целью `box2shelf` является полка списания

### Перемещение товара с полки на полку

Пользователь может взять с любой полки товар и положить на другую полку.
Результатом его действий будет `order`, который создастся по его инициативе.

Ордер при этом создаётся сразу в статусе `complete`.

Метод следующий:

```http
POST /order/move HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "e261af28-049e-11ea-ab9b-2b9f4c3ddc85",
  "move": [
    {
       "product_id": "0b660784-049f-11ea-a412-ab99636cd0ba",
       "count": 22,
       "src_shelf_id": "16a19ac8-049f-11ea-acdb-2750fe9b6cf7",
       "dst_shelf_id": "2fde0a3a-049f-11ea-92c1-3f0b5f9e3dea",

       "reason": {
           "code": "DAMAGE",
           "comment": null,
       }
    }
  ]
}
```

Таким запросом пользователь сообщает системе о том что он **уже**
переместил товар `product_id` с полки `src_shelf_id` на полку `dst_shelf_id`
в количестве `count` штук.

Возможные ответы сервера:


Товар на полке не найден (в таком количестве):

```http
410 Conflict
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_PRODUCT_UNEXPECTED",
  "message": "Product is absent on the shelf",

  "details": {
     "problems": [
         {
            "product_id": "0b660784-049f-11ea-a412-ab99636cd0ba",
            "shelf_id": "16a19ac8-049f-11ea-acdb-2750fe9b6cf7",
            "count": 11
         }
     ],
  }
}
```

При этом в секции `details.problems` сервер показывает на какой полке сколько товара
он не нашел.

В данном примере пользователь запросил о перемещении 22 товаров, а на полке по мнению
сервера лежит всего 11.

В этом случае вместо перемещения нужно сперва инициировать инвентаризацию полки и
списать (или найти) недостаток.

И еще ошибка, если передали неизвестный номер полки или номер товара:

```http
400 Bad Request
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_BAD_REQUEST",
  "message": "Unknown src_shelf_id"
}
```

#### Причины перемещения (reason)
Переместить товар с полки на полку можно без указания причины.
Но перемещение на полку списания (`trash`) приведёт к тому, что товар далее
будет списан. Если кто-то выполняет подобную операцию, то он обязан указать
причину (поле `reason`) зачем он это делает.

Причины перемещения определяются кодом (или комментарием при коде `COMMENT`):

- `OPTIMIZE` - оптимизация склада (эта причина не
  подходит для перемещения на полку списания)
- `DAMAGE` - товар/упаковка повреждены
- `TTL` - вышел срок годности
- `DECAYED` - товар пришёл в нетоварный вид (например помидоры протухли)
- `ORDINANCE` - списание по распоряжению. Склад просят списать товар на нужды, или по другой причине.
- `MOL` - разбил/сломал/сьел. То есть списание на МОЛ.
- `ACCIDENT` - поломка оборудования. Отказ холодильника, обвал стеллажа и тд.
- `COMMENT` - другая причина - указана в комментарии


**Важно**: Если фронт передаёт `order_id`, то тогда этот `order_id` используется
как ключ идемпотентности запросов.
Переданное поле `order_id` попадёт в `external_id` созданного заказа.

## Инициация инвентаризации с ТСД

Пользователь может инициировать инвентаризацию (проверку наличия) товаров

Для этого он может отправить запрос:

```http
POST /order/check HTTP/1.1
Authorization : Bearer 5fe70dd2-e116-11e9-a8fe-0050b6972766
Content-Type: application/json; charset=UTF-8

{
  "order_id": "e261af28-049e-11ea-ab9b-2b9f4c3ddc85",
  "check": {
      "shelves": [
          "821eee4e-11c0-11ea-81e8-67f7ea040920",
          "8e4c8a46-11c0-11ea-8a50-0fdc24e127af"
      ],
      "products": [
          "986649a4-11c0-11ea-9ca1-07b7784535bd"
      ]
  },
  "mode": "check"
}
```

В ответ система создаёт ордер инвентаризации, который

- автоматически назначается на пользователя, выполнившего запрос
- цель ордера определяется в зависимости от поля `mode` (если не указано, то `check`)

Цель ордера при `mode="check"` (если mode не передан, это - умолчание):

- Создаётся ордер с типом `check` (инвентаризация).
- Для каждой указанной полки `shelves`, для каждого найденного продукта,
  на ней создается подсказка `check`.
- Для каждой указанной полки `shelves`, создаётся дополнительно подсказка
  `check_more`.
- Для каждого продукта `products` создаётся подсказка `check` для всех полок не
  указанных в секции `shelves`.

То есть число саджестов тут сумма:
 - `check_more` - по количеству указанных полок
 - `check` - по количеству товаров найденных указанных на полках
 - `check` - по количеству товаров из секции `products`, найденных на прочих полках.


Цель ордера при `mode="check_product_on_shelf"`:

- Создаётся ордер с типом `check_product_on_shelf` (инвентаризация одного товара на одной полке).
- В этом случае `shelves` должен содержать одну полку и `products` должен содержать один продукт.
  Иначе запрос считается невалидным.
- Для указанной полки создаётся одна подсказка `check` с указанным продуктом и количеством, найденным
  на этой полке (может быть 0). То есть в этом режиме ордер создаётся с ровно одним саджестом.


Переданный `order_id` попадает в `external_id` поле создаваемого ордера
и является (если передан) ключем идемпотентности.

Ответы:

Что-то передано не корректно. Например обе секции что проверять - отсутствуют. См. описание выше.

```http
400 Bad Request
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_BAD_REQUEST",
  "message": "shelves OR products have to be defined"
}
```


Товар или полка не найдены в БД:

```http
410 Conflict
Content-Type: application/json; charset=UTF-8
Access-Control-Allow-Origin: *

{
  "code": "ER_PRODUCT_UNEXPECTED",
  "message": "Product is absent",

  "details": {
     "problems": [
         {
            "product_id": "0b660784-049f-11ea-a412-ab99636cd0ba",
         }
     ],
  }
}
```


## Процесс списания

После того как товар помещен на полку списания, то можно инициировать собственно
процесс списания товара.

Процесс списания товара как отдельный шаг в бизнеспроцессе задуман для того, чтобы
можно было провести аудит списанного, а так же (возможно) вернуть товары на полки.

Иницируется процесс списания запросом `/order/writeoff`. Семантика запроса полностью
совпадает с семантикой запроса `/order/check`, за исключением того, что `products`
передавать нельзя.

выполняет следующую работу:

1. проверяет валидность запроса:
   - не может быть указана дополнительная другая полка не являющаяся полкой списания
   - не может быть указан никакой товар (в этом отличие от запроса `/order/check`)
2. Создаёт ордер с типом `writeoff` списания в котором в подсказках прописаны все товары
на полке списания с указанным количеством соответствующим количеству на полке списания
3. Пользователь может закрывать check-подсказки, указывая меньшее (не большее) количество
товара
4. По закрытии ордера производится сравнение количеств на полке и количеств указанных для
списания. Списывается именно столько товара, сколько указано при закрытии подсказок.
5. Оставшийся товар может быть возвращён с полки списания на полки - выполнением метода `move`.

## Исправление завершенных подсказок

Иногда пользователь завершил подсказку и при этом ошибся.

Например завершать подсказку ему было не нужно, он указал неверно количество, срок итп.


В этом случае, он может перепослать `done` для той же подсказки заново.

При этом заполнение поля `reason` в некоторых случаях становится обязательным, даже для отправки статуса `done`.

Возможны следующие случаи:

1. подсказка ранее была закрыта в статус `error`.
    - перезакрытие подсказки снова в `error` не предусматривается.
    - можно перезакрыть подсказку в статус `done`. В этом случае `reason` не обязателен.
2. подсказка ранее была закрыта в статус `done`.
    - возможно перезакрытие подсказки в статус `error`, при этом `reason` заполняется как описано выше в протоколе.
    - возможно перезакрытие подсказки в статус `done` (исправление), при этом `reason.code` устанавливается в значение `CHANGE_COUNT` - если исправляется количество, `CHANGE_VALID` - если исправляется срок годности, `CHANGE_COUNT_VALID` - если исправляется и то и другое.
3. Закрытая в done подсказка может быть возвращена в открытое состояние. В этом случае надо перезакрыть её в error с посылкой reason.code `CANCEL_ACTION`.


## Сигналы ордерам

В некоторых случаях фронт может уведомить ордер о каком-то событии послав ордеру сигнал. Для этого используется метод `signal`:

```http
POST /order/signal HTTP/1.0
Content-Type: application/json; charset=UTF-8

{
  "order_id": "3ab319ba-e12b-11e9-9a68-0050b6972766",
  "signal": "acceptance_agree",
  "data": {}
}
```

В настоящее время принимаются следующие сигналы:

- `acceptance_agree` - завершить приёмку доверительно (поле `data` не используется).

Получив этот сигнал ордер `acceptance` будет завершён и создан заказ раскладки. При этом:

1. Закрытые в `done` саджесты говорят о товарах, которые проверены при приёмке. Для таких саджестов будут сгенерированы обычные саджесты раскладки.
2. Незакрытые саджесты говорят о товарах, которые не проверены при приёмке (приняты доверительно). Для таких саджестов будут сгенерированы саджесты раскладки, позволяющие указать иное количество, чем в ордере приёмки.

Указанный сигнал можно послать только ордеру приёмки (`acceptance`).

## Индикаторы в tsd

В приложении имеются следующий индикаторы состояния сетевой активности приложения, индикаторы перечислины по порядку, слева направо:
1. Количество неуспешных сетевых запросов с последнего успешно закрытого ордера, имеет 2 состояния:
    - серый, если нет неуспешных запросов.
    - красный, если неуспешные запросы есть.
2. Индикатор наличия активных сетевых запросов (иконка wi-fi), имеет 2 состояния:
    - серый, если нет активных сетевых запросов.
    - синий, если есть активные сетевые запросы.
3. Количество неуспешных запросов к ивент серверу, имеет 2 состояния:
       - серый, если нет неуспешных запросов.
       - красный, если неуспешные запросы есть.
4. Индикатор наличия соединения с ивент сервером, имеет 2 состояния:
    - синий или зеленый(цвета меняются по очереди после каждого окончания запроса), если связь с ивент сервером установлена
    - красный, если невозможно установить связь с ивент сервером
5. Индикатор скорости получения ответа от api, обновляется раз в секунду и после каждого выполненного запроса,
в первом случае принимает в качестве значения время самого долгого активного запроса,
во втором случае принимает время выполненного запроса, имеет 3 состояния:
    - зеленый, если ответ на запрос был получен быстрее чем за 5 секунд.
    - желтый, если ответ на запрос был получен быстрее чем за 15 секунд.
    - красный, если ответ на запрос был получен более чем за 15 секунд или последний сетевой запрос окончился не успешно.

## Архитектура

cargo-crm использует procaas, postgres и stq.
**TBD** описать как


## API

### Неформализованные договорённости

В ряде случаев предпочитаем неформализованные договорённости в виде описания
поведения комментарием в `description`, например:
- `FailReason.code` - коды ошибок перечислены в комментарии вместо `enum`, т.к.
   любое расширение enum приводит к обратной несовместимости.
- `FailReason.details` - объект с `additionalProperties: true`, схему валидации
  которого надо брать в зависимости от кода ошибки, и эта зависимость описана
  в комментарии в `description`. Вместо этого можно было бы наследовать
  `FailReason` (FIXME может и стоит использовать наследование).
- `NewOperation` содержит либо `token`, либо `disable_reason`. Об этом написано
  в комментарии в description, но не формализовано через `one_of`.
- В поле `forms` заполняются только те данные, которые доступны пользователю,
  хотя в описании перечислено больше возможных полей.


### Автоматическая генерация yaml для клиентов

Её нет. Но если понадобится, надо будет извлекать информацию по ручкам по
префиксу `/flow/b2b`. По ручкам и объектам, имеющим отношение к ручкам.


### Асинхронность, авторизация запросов, avoiding races

Важно:
- Модифицирующие операции выполняются асинхронно, т.е., сначала необходимо
  инициировать выполнение операции, затем дождаться результатов её выполнения.
- На проведение модифицирующей операции необходимо получать токен. Сервер
  использует токен для проверки того, была ли операция авторизована.
- Так же токен используется для проверки того, что при принятии решения о
  модификации пользователь опирался на самые актуальные данные.

Алгоритм клиента:
1. Дёргаем за ручку, оканчивающуюся на `/state`:
   1. Получаем из ручки:
      1. Актуальную информацию о бизнес-процессе.
      2. Информацию о незавершённых операциях, инициированных пользователем.
      3. Авторизационный токен для проведения новой оперции.
   2. Ручка предоставляет всю информацию для восстановления контекста. Так,
      если пользователь закрыл браузер, то при повторном открытии этого (или
      другого) браузера можно продолжить работу с прерванного момента, в том
      числе отследить выполнение асинхронной операции.
2. С полученным в (1.1.3) токеном инициируем проведение нужной операции.
   1. Сервер может ответить 409 с кодом `invalid_token`, в этом случае
      необходимо вернуться к (1), получить новый токен и повторить операцию.
      Но перед проведением операции надо проинформировать пользователя о том,
      что что-то изменилось с момента последнего обращения пользователя, и что
      пользователю необходимо изучить новые данные перед тем как принимать
      решение о выполнении модифицирующей операции.
   2. В случае 200 ОК берём из ответа `operation_id`. Это идентификатор
      операции, за которой необходимо следить. 
3. С полученным из (2.2) `operation_id` необходимо следить за пушами от сервера
   `client-events`.
   1. Как только придёт пуш о завершении операции, можно дёргать за ручку
      `/state`, передавая в запрос поле из пуша `push.event_id`.
   2. Только после получения пуша операция в (1.1.2) будет числиться завершённой,
      и состояние бизнес-процесса изменится (если операция была завершена
      успешно).


### Группы ручек

#### Ручки для участников процесса

Начинаются с префикса `/flow/<participant_kind>/<workflow_name>`. Мотивация:
- Префикс `/flow/<participant_kind>` для авторизации на уровне b2b-authproxy.
- Префикс `/flow` для того, чтобы отличать процессные ручки от служебных и
  общепроцессных ручек: `/procaas`, `/triggers`, `/functions`.

Какие бывают `participant_kind`s:
- `b2b` - для внешних людей; например, сотрудников корп. клиентов.
- `admin` - для имеющих доступ к админке; например, сотрудников телемаркетинга.
- `procaas` - для уведомлений от procaas.
- `stq` - для уведомлений от stq.


#### Общепроцессные ручки

Общепроцессные ручки - те, что шарятся между процессами.

Функции, вызываемые из procaas и из триггеров:
- AA через TVM
- Функция может быть переиспользована в разных процессах
- API выглядит как `/functions/<func_name>`; например:
  - `POST /functions/create-corp-client-id`
  - `POST /functions/create-cargo-corp-client`
  - `POST /functions/create-cargo-corp-employee`


#### Служебные ручки
 
Ручки для сохранения состояния триггеров (триггеры вызываются из stq):
- AA через TVM
- API из двух ручек:
  - `GET /triggers/state?ticket_id=...&trigger_kind=...`
  - `POST /triggers/state/upsert?ticket_id=...&trigger_kind=...&last_known_revision=...`

Кэширующая прокси для получения списка событий из procaas, которую по
хорошему надо унести в procaas (TODO завести задачу на procaas):
- AA через TVM
- См. [ручки /procaas/caching-proxy](./docs/yaml/api/procaas_caching_proxy.yaml)



## Данные

Каждый процесс - как тикет в st - проходит по некоторому workflow.

Разрешаем только один открытый процесс. Т.е., при наличии открытого
тикета продолжаем работу именно в этом тикете. Так проще (по опыту
масснайма).

С какими данными работаем:
- Данные из форм (фио, город, ...).
- История изменений (кто и когда как-то модифицировал данные).
- Служебные данные (состояние триггеров).

Доступ к данным:
- Пользователь должен увидеть только те данные, которые ему доступны.
  Заводящий компанию не должен увидеть комментарии от модераторов,
  саппорты не должны видеть оценку, которую им поставили за решение
  вопроса, и т.д.


## Процессы

**phoenix** - регистрация карточных b2b-клиентов.

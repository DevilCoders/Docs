Заведение новых правил умных субсидий
=====================================

#1 БД
-----

По пути ```schemas/postgresql/billing_subventions_x``` добавляем нужные поля в структуры и создаем новую миграцию.

```migrations/XXXX_tblTASK_ID.sql``` должен содержать все необходимое для раскатки на тестинге\проде.

[Пример](https://a.yandex-team.ru/review/1802578/files/2) первого шага.

#2 Схемы ручек
--------------

Есть несколько мест, где требуется ввести новый тип
1. SmartRuleType - определение типа. Добавляем еще один в enum
2. SmartRule - модель используется в читающих ручках для админки
3. SmartRuleSpec - определение правила для ручек создания
4. MatchingRule - определение ответа ручки матчинга

Создаем для этих типов вложенные типы с определением новых правил (см. определение single_ontop и single_ride в качестве примера).

Прописываем в ```types::RuleType FromSchema(handlers::SmartRuleType rule_type)``` выброс исключения для нового правила и катим в прод.

[Пример](https://a.yandex-team.ru/review/1802290/files/3) второго этапа.

#3 Добавление моделей и читающие ручки
--------------------------------------

Размещаем определение правила в новую директорию.
```services/billing-subventions-x/src/smart_rules/types/<rule_name>```

В качестве примера берем любое существующее правило.

Обязательные элементы
* match.hpp - определение правила, из которого будет строится ответ для ручки match
* rule.hpp - расширение базового правила. Сюда так же попадают поля, которых нет в основной таблице rule в базе.
* rulespec.hpp/cpp - dto и набор функций FromSchema\ToSchema. Для конвертации запроса ручки create во внутреннее представление.

Прописываем определения новых правил в нескольких участках.

1. ```smart_rules/types/base_types.hpp```
   
   прописать в RuleType и kRuleTypes
2. ```smart_rules/types/match.hpp```

   прописать в MatchingRule

3. ```smart_rules/types/rule.hpp```

   прописать в Rule

4. ```smart_rules/types/rule_draft.hpp```

   добавляем неймспейс с черновиком нового правила и прописываем его в SmartRuleDraft

5. ```smart_rules/types/rulespec.hpp```

   добавляем в SmartRuleSpec

6. ```smart_rules/usecases/close_rules.cpp```

   добавляем валидатор возможности закрыть правило

7. ```smart_rules/usecases/match_rules.cpp```

   тут нужно прописать CalcRulePriority. Это либо заглушка, либо код, который ранжирует правила по какому-либо алгоритму.

8. ```smart_rules/validators/draft.cpp```

   добавляем ValidateSpec для своего типа

Если ваше правило содержит новые поля и расширяет стандартную таблицу драфтов, то важно поправить ```BaseRuleDraft``` добавив в него новые поля (опциональные).

Дальше на очереди конвертеры и билдеры правил.

1. ```smart_rules/builders/rule_draft.hpp|cpp```

   RuleDraftBuilder::MakeRuleDraft. Этот метод позволит из спецификации правила составить черновик для вставки в таблицу драфтов

2. ```smart_rules/repositories/postgres/converters/match.cpp```

   Заводим новый метод RUleFromRow в отдельном неймспейсе.
   
   Конвертирует правило из строки бд во внутреннее представление для ручки матчинга.

3. ```smart_rules/repositories/postgres/converters/rule.cpp|hpp```

   Добавляем новый метод RuleFromRow для конвертации строки бд в правило. Этот метод используют читающие ручки админки.

4. ```smart_rules/repositories/postgres/converters/rule_data.cpp```

   Тут можно добавить специфическое поведение для дополнительных полей.

5. ```smart_rules/serializers/<rule_type>```

   Набор определений, который позволит преобразовывать правила из внутрених dto в представление api.
   
   Важнейшие - это ```rule.cpp|hpp```, ```rule_draft.cpp|hpp```, ```rule_spec.cpp|hpp```.

   Последевательно подключаем эти функции в:

   ```smart_rules/serializers/rule.cpp```
   ```smart_rules/serializers/rule_draft.cpp```
   ```smart_rules/serializers/rule_spec.cpp```
   
6. ```smart_rules/serializers/rule_type.cpp```

   Убираем эксепшн первого этапа и прописываем конвертацию типов.

7. ```added_by_draft.sql```
   ```sql/closed_by_draft.sql```
   ```sql/select_rules.sql```
   ```sql/select_rules_by_ids.sql```
   ```sql/select_updated_rules.sql```
   ```sql/select_updated_rules_fixed.sql```
   
   Обновляем запросы и добавляем новые поля (если надо).

Теперь можно писать тесты.

1. Добавляем новую фикстуру ```a_<rule_type>```.
2. Пользуемся ей в тестах для насыщения базы.

Важно отметить, что если вы добавляете новые поля, то они должны быть отражены в запросах ```sql/insert_rules.sql``` и ```sql/create_rules_to_add_draft.sql```. В противном случае фикстуры в тестах работать не будут.

[Пример](https://a.yandex-team.ru/review/1804115/files/5) после выполнения этого шага.

#4 Создание драфтов
-------------------

1. Если ваше правило подразумевает дополнительное поле, которое входит в состав ключа идемпотентности для нового типа, то следует поправить запрос ```sql/select_clashing_rules.sql``` и код, который его использует. Чтобы передавать необходимые поля.
2. Остальное сводится к созданию большого числа тестов, которые покроют создание черновиков в любых условиях. Особое внимание стоит уделить тестам на перекрытие и пересечение правил.

[Пример](https://a.yandex-team.ru/review/1805633/files/4) четвертого шага.

#5 Апрув драфтов
----------------

Этот этап сведен к написанию тестов. Так как все подготовительные шаги уже выполнены.

[Пример](https://a.yandex-team.ru/review/1805633/files/4) пятого этапа.

#6 Матчинг правил (схема)
-------------------------

Нужно доработать ```docs/yaml/api/v2_rules_match.yaml```.

Добавляем ```Matching<Type>Rule```. Это определение, которое будет попадать в ответ ручки match.

[Пример](https://a.yandex-team.ru/review/1820047/files/2) шестого этапа.

#7 Матчинг правил
-----------------

1. ```smart_rules/serializers/matching_rule.cpp```

   Тут должен быть добавлен конвертер ToSchema для преобразования из модели ```MatchingRule``` в схему ручки.

2. ```smart_rules/usecases/match_rules.cpp```

   Тут следует обратить внимание на метод ```GroupByRuleType``` если ваше правило предусматривает, что оно должно быть одно из, а не много.

3. ```sql/select_matching_rules.sql```

   Добавляем новую секцию к существующим union all. Обратите внимание на флаги ```subv_disable_*```. Они должны участвовать в работе.

[Пример](https://a.yandex-team.ru/review/1820655/files/2) этапа.

## ContractorId
Для идентификации контрактора мы используем один токен. Токен - это любая последовательность кроме символов '$' и '\_'.
uuid - обязательный

В процессе перевода Такси мы фиксируем что их токен - это $dbid _ $uuid
(объединение через подчеркивание)

## Пайплайны
Пайплайн - это просто независимый потребитель. Данные одного пайплайна изолированны от всех остальных пайплайнов, никакой обмен данными внутри нашей системы невозможен.
По сути пайплайн - это поток данных и конфиг описывающий как этот поток данных генерируется и обрабатывается.
Имена пайплайнов должны быть уникальны в рамках всей системы FleetTrackingSystem.

Иногда возникает вопрос - что если Такси и Маркет имеют разные пайплайны, а
затем захотят переиспользовать supply друг друга? Это весьма просто:
1. Если они хотят в своих сервисах использовать потоки координат из двух
   пайплайнов, то им ничего не мешает. Мы никак не запрещаем хозяевам пайплайнов
   делать с их данными за пределами наших систем все что угодно.
2. Альтернативно, они могут объединить два пайплайна в один. Аккуратно
   замерджить конфиги, смешать квоты и наслаждаться жизнью.

## Авторизация
Пока начнем с server-to-server API. В нем авторизация происходит на доступ к пайплайну и происходит по TVM. Авторизация контракторов на доступ к системе пока не относится к спектру нашей системы.


## Сигнал и позиция
### Позиция
Начем рассмотрение базовых понятий с понятия позиции. Позиция - это позиция на
глобусе, по сути - lon, lat + опциональные параметры.
Обратите внимание, что timstamp в позиции отсутствует.
Например минимальная позиция, в которой есть только lat и lon выглядит вот так:


{% if has_jsonpath %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.SignalAlternative.examples.minimal_position.value' %}

{% else %}

```yaml
position: [52.569089, 39.60258]
```

{% endif %}

Полноценная позиция со всеми членами вот такая:

{% if has_jsonpath %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.SignalAlternative.examples.full_position.value' %}

{% else %}

```yaml
position: [52.569089, 39.60258]
accuracy: 5
speed: 16.6
direction: 125
```

{% endif %}

{% cut "Схема позиции" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.SignalAlternative' %}

{% endcut %}



Рассмотрим теперь какие случаи возникают у нас в системе.

**Притягивание** - притягивание на каждый входящий сигнал генерирует набор альтернатив - где может находится эта точка. У каждой альтернативы в теории должен быть параметр вероятность, но мы сейчас не умеем их считать честно. Более того, мы сейчас и качетсво альтернатив отслеживать не можем, поэтому пока что, до появления нормальных метрик, у нас всегда один элемент в массиве.
Примечание: эти альтернативы уже используются в Такси и есть еще больше мест где мы планируем их подключить. Это не из воздуха высосанные штуки.

**Предсказание** - Для каждой точки можно сгенерировать набор предсказаний на заранее заданные интервалы. Например предсказание на 10, 15, 45, и 60 секунд. Почему "набор" - так устроен процесс предсказания. Проще один раз сгенерировать на 5 различных интервалов, чем 5 раз по одному смещению. (Довольно очевидно, надо просто сгенерировать предсказание на 60 секунд и все остальные автоматом будут из него).

**Притягивание и предсказание по отслеживанию** - Для отслеживаемых водителей мы можем лучше притягивать и предсказывать т.к. мы знаем маршрут. Наш сервис в этом случае генерирует N точек, 1 из которых это притягивание, N-1 оставшиеся - это предсказания на заранее указанные интервалы.

### Сигнал (входящее представление)

Для входящих сигналов мы используем более простую схему, чем для рабочего
представления.

{% cut "Схема сигнала" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.IncomingSignal' %}

{% endcut %}

### Сигнал (рабочее представление)

Итак, как вы выяснили, большая часть наших алгоритмов из одной точки создает некоторый набор.
Такой набор описывается вот такой схемой:

{% cut "Схема сигнала" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.UniversalSignal' %}

{% endcut %}

Мы вынесли данные, которые относятся ко всем элементарным позициям в наборе наверх, в общую структуру, а сами элементарные позиции записали в массив positions, сгруппировав по time_shift.


!!Конкурирующее представление сигнала
Сейчас у нас явно вынесенны в члены позиции source, transport_type, region.
Вместо этого можно ограничится просто source (он точно нужен отдельно) и полем
sensors. И разрешить просто фильтрацию по произвольным сенсорам.
Пример позиции в таком исполнении

```yaml
timestamp: 1649970983056
source: "Adjusted"
sensors:
  my_super_sensor: "45"
  engine_acceleration: "C6E8 (base-64 encoded double)"
  transport_type : "Scooter"
  region : "spb"
geodata:
  - time_shift: 0
    positions:
      - position: [52.569089, 39.60258]
        accuracy: 5
        speed: 16.6
        direction: 125
```

В этом случае нам нет необходимости как-то определять по чему можно фильтровать,
а по чему нельзя.

Рассмотрим примеры позиций

**Сырая позиция**

{% if has_jsonpath %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.UniversalSignal.examples.raw_simple.value' %}

{% else %}

```yaml
timestamp: 1649970983056
source: "Android"
transport_type: "Scooter"
region: "spb"
geodata:
  - time_shift: 0
    positions:
      - position: [52.569089, 39.60258]
        accuracy: 5
        speed: 16.6
        direction: 125
```

{% endif %}

**Притягивание**
Пример притянутой позиции. Здесь так же показанны пользовательские сенсоры.
{% if has_jsonpath %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.UniversalSignal.examples.adjusted_simple.value' %}

{% else %}

```yaml
timestamp: 1649970983056
source: "Adjusted"
transport_type: "Scooter"
region: "spb"
sensors:
  my_super_sensor: "45"
  engine_acceleration: "C6E8 (base-64 encoded double)"
geodata:
  - time_shift: 0
    positions:
      - position: [52.569089, 39.60258]
        accuracy: 5
        speed: 16.6
        direction: 125
```

{% endif %}

**Предсказание**
Пример предсказаний на несколько времен
{% if has_jsonpath %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.UniversalSignal.examples.adjusted_simple.value' %}

{% else %}

```yaml
timestamp: 1649970983056
source: "Adjusted"
transport_type: "taxi"
region: "moscow"
geodata:
  - time_shift: 0
    positions:
      - position: [52.569089, 39.60258]
        accuracy: 5
        speed: 16.6
        direction: 125
  - time_shift: 10
    positions:
      - position: [52.569090, 39.60259]
        accuracy: 5
        speed: 16.6
        direction: 125
  - time_shift: 20
    positions:
      - position: [52.569095, 39.60263]
        accuracy: 5
        speed: 16.6
        direction: 125
```

{% endif %}

### О свойствах сигнала

**О времени**
Есть две оси времени - одна на сервере, одна на клиенте. Пользователь передает позицию с клиентским временем. В большинстве случаев наши сервисы умеют работать строго в шкале клиентского времени, однако есть часть запросов, где мы вынужденны опираться на серверное.
Из этого также следует, что система будет работать весьма неожиданно для пользователя если эти две шкалы начнут сильно расходится.
В частности, запросы о последней позиции контрактора ориентируются на серверное время для интепретации параметра max_age.
Также архивация сломается для позиций, которые приходят сильно за пределами серверного времени.

**О сенсорах**
Сенсоры - это произвольные пользовательские данные. Мы их никак не
интерпретируем.
Так же мы можем дозаписывать служебные сенсоры, например
backend_receive_unix_time 
TODO: Что делают притягиватели с сенсорами? Копирают дальше в выходной поток?

**О источниках**
Источники все еще в процессе проработки, но пока что идея следующая. Источник - это всго лишь один из сенсоров, с которым мы позволяем пользователю совершать дополнительные манипуляции. В частности, мы позволяем в определенных запросах в систему использовать источники как фильтр ответа. Например "дай мне шорттрек водителя A где источник один из S1..SN.
Эта фича требуется для пользователя Такси, которые с ее помощью определяют близость курьера к нужной точке назначения.
Набор допустимых источников описывается пользователем в конфигурации пайплайнов.

**О типах транспорта**
Еще один прозрачный для нас параметр - это типы транспорта. Мы позволяем разводить по ним потоки данных внутри системы и
в будущем позволим указывать настройки притягивания по-транспортно.

**Входные сигналы**
Мы доказали что такая схема сигнала подходит для описания выходных данных наших сервисов. Однако, чтобы безболезненно можно было бы связывать наши серисы внутри друг друга, мы хотели бы
чтобы для входных сигналов схема была бы точно такой. Посмотрим на примере сервисов как они с такими сигналами взаимодействуют.


**сервис притягивание**
Притягивание будет групировать позиции по time_shift и затем притягивать каждую группу. time_shift внутри группы будет сохраняться. Основной интерес - как притягивать группу. Для этого небольшой экскурс в работу алгоритма под капотом яги.
Сигнал для этого алгоритма - это вообще произвольный класс- параметр шаблона. Первое что делает алгоритм с ним - это преобразует этот объект в множество ребер графа S{}. Затем с помощью внутренней механики он ранжирует это множество и оставляет из него top-X элементов (например top-10) которые и становятся ответом. Для преобразования обычного сигнала (lat,lon) просто используются ближайшие к нему ребра NearestEdges(lon, lat). Из этого автоматом следует как использовать такой UniversalSignal - множество ребер UniversalSignal это просто объединиение NearestEdge(lon_i, lat_i) по всем positions в группе.
Отметим еще раз - элементы в конкретной группе time_shift не притягиваются независимо. Вместо этого они считаются "облаком вероятных позиций" и результат притягивания - это другое облако, уже "облако вероятных притянутых позиций".

Какой сценарий у этой ситуации ? - это притягивание предсказанных сервисом DRW позиций. Сервис DRW отслеживает водителей на маршруте и умеет выдавать поток предсказанных на разные времена позиции - т.е. UniversalSignal где 5 time_shift (0, 10, 20, 50, 100) и в каждой группе один элемент. Потребителям однако часто нужно эти позиции притянуть на граф. Для этого этот поток можно завернуть в сервис притягивания и получится то что надо

**сервис притягивания - предсказание**
Тут начинаются проблемы. Представим что сервис настроен делать предсказания на 10, 20, 40 секунд. Что ему делать если ему на вход пришел UniversalSignal у которого есть time_shift=0, time_shift=7, time_shift=10. Легко заметить, что AdjustPredict(signal={time_shift=0}, time=10} и AdjustPredict(signal={time_shift=10}, time=0) дадут в итоге набор позиций у которых time_shift по логике 10. Но смешивать их нельзя, потому что пользователь их в жизни потом не сможет различить.
Для решения этой проблемы предлагается запретить предсказание если на вход поступает UniversalSignal в котором есть элементы с time_shift != 0. Так себе решение, конечно.
Альтернативно, можно сказать что мы всегда предсказываем только для time_shift=0
Альтернативно, можно отказаться от единого формата входных и выходных позиций

**сервис отслеживания водителей**
Сервис отслеживания водителей на маршруте на вход потребляет произвольный поток координат и по нему понимает где находится водителей. Для него поведение следующее:
1. Он всегда использует минимальный time_shift из пакета и игнорирует все остальные !!TODO: надо поддержать это в DRW!!
2. Полученную группу он по аналогии с ягой использует как единое облако - например среди всех проекций на маршрут берет наиболее вероятное, или средне-взвешенное. 

## Timelefts, маршрутный лист и маршрут

### Timelefts

Timelefts - это необходимая сущность, если внутри fts мы хотим не просто передавать, хранить, притягивать и предсказывать (предсказывать тоже можно по-разному, используя априорную информацию (известное место назначения) или нет) положение исполнителей, но и отслеживать/рекомендовать? маршрут движения исполнителю/контролёру. Эта сущность не отделима от места назначения исполнителя и представляет собой комбинацию текущего положения исполнителя и рассчитаного времени до места назначения.


{% cut "Схема eta" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.Eta' %}

{% endcut %}


{% cut "Схема timelefts" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.Timelefts' %}

{% endcut %}

```yaml
contractor:
  uuid: "uuid1"
  dbid: "dbid1"
position: [43.123422, 54.124752]
etas:
  - destination: [43.128765, 54.124982]
    time_left: 565
    distance_left: 5932
    raw_time_left: 465
    raw_distance_left: 4932
    order_id: "order_id2"
    flow_id: "flow_id1"
    point_id: "moving_point_id2"
  - destination: [43.128765, 54.124982]
    time_left: 865
    distance_left: 5932
    raw_time_left: 765
    raw_distance_left: 4932
    order_id: "order_id2"
    flow_id: "flow_id1"
    point_id: "waiting_point_id2"
route: [[43.123422, 54.124752], ..., [43.123424, 54.124767], ..., [43.128765, 54.124982]]
look_behind_element:
  destination: [43.123424, 54.124767]
  time_left: 10
  distance_left: 100
  raw_time_left: 10
  raw_distance_left: 100
  order_id: "order_id1"
  flow_id: "flow_id1"
  point_id: "moving_point_id1"
```

### FlowId, OrderId, PointId
Если так посмотреть, то это всё просто идентификаторы, которые позволяют группировать и различать точки. Так сложилось исторически, что flow_id - это имя сервиса, по которому ещё косвенно и определялся статус исполнителя, например "processing:driving", "processing:transporting", "reposition-watcher" и "cargo-dispatch". Раньше это требовалось для установления порядка точек, но сейчас я предлагаю к нему относится как к параметру, по которому имеется возможность дополнительно сгруппировать точки, т.к. сейчас мы хотим убрать логику упорядочивания на уровень выше. Аналогичная ситуация с order_id - это просто идентификатор заказа, по которому раньше возвращалось eta до точки (она требовалась одна), сейчас мы хотим отслеживать не только ближайшую точки движения исполнителя, а максимально известный маршрут (для сокращения запросов маршрута, для возможности более точного предсказания будущего положения исполнителя). Внутри этот параметр в наших сервисах не интерпретируется, используется только для группировки точек для возврата eta. На эти два идентификатора мы не накладываем никакие ограничения, кроме того, что это просто строка.
Последний из идентификаторов - это point_id. На данный идентификатор мы накладываем требование уникальности внутри одной сессии для исполнителя. Этот идентификатор требуется, чтобы поддержать возможность указать конкретную точку (произвольный набор точек), по которым будет произведена фильтрация и возвращён результат. Это можно использовать для поддержания статусов (ожидание/движение), т.к. позволяет запрашивать eta до точек разного типа с одной координатой, например.
Опишу чуть подробнее для понимания почему этот параметр требуется и имеет именно такие требавния.
Имеется следующая последовательность точек A(MovingTo [34.575821, 57.972354])->B(WaitingIn[34.575821, 57.972354])->C(MovingTo[35.789231, 58.098236]). Если запрашивается eta до точки A, то мы вернём время сколько исполнителю осталось двигаться до точки A. Если запрашивать eta до точки B, то вернётся eta сколько времени осталось ехать до точки A и ждать в точке A по параметрам точки B. Если запрашивать eta до точки C, то вернётся суммарное eta всех предыдущих этапов + eta по маршруту B->C. Если мы оставим только order_id и flow_id, не накладывая ограничения на эти индентификаторы, то мы теряем гибкость запроса eta до конкретных точек, например eta только движения или eta с ожиданием.

Можно рассмотреть вариант, когда flow_id и order_id - это опциональные поля (или пусты строки по дефолту), но вот point_id - обязательное с предъявленными требованиями, чтобы опиональные поля использовались только тогда, когда они требовались. Можно подумать над ситуацией, чтобы не воодить эти дополнительные идентификаторы, а иметь у точки какой-нибудь произвольный набор сенсоров (по аналогии с сигналом), по которому позволять селектить или фильтровать. Но пока это выглядит излишним усложнением и дополнительной степенью свободы, которая не очень понятно на сколько вообще нужна, но на поддержание потребует ресурсов, как разработки, так и железа.



### Маршрутный лист
Мы хотим ввести понятие маршрутного листа в нашей системы для отслеживания исполнителей через заданные точки. Мы не хотим внутри этой системы решать задачу определения оптимальной маршрутизации, поэтому нам требуется принимать уже сформированный маршрутный лист снаружи. Маршрутный лист представляет собой последовательность позиций, через которые последует исполнитель с некоторой дополнительной информацией, которая будет определять правила отслеживания.

Мы хотим поддержать возможность передавать не только точки, в которые ожидается непрерывное движение исполнителя по наискорейшему маршруту, но и точки в которых исполнитель ожидает. Для этого вводятся точки двух видов Waiting и Moving (можно задавать статус у точек и больше опуиональных полей, а не выделять 2 типа, суть от этого не сильно изменится).

{% cut "Схема Waiting точки маршрутного листа" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.WaitingRouteListPoint' %}

{% endcut %}

{% cut "Схема Moving точки маршрутного листа" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.MovingRouteListPoint' %}

{% endcut %}

{% cut "Схема маршрутного листа" %}

{% code './yaml/common.yaml' lang='yaml' jsonpath='$.definitions.RouteList' %}

{% endcut %}

```yaml
contractor:
  uuid: "uuid1"
  dbid: "dbid1"
region: "moscow"
points:
  - destination: [43.123424, 54.124767]
    flow_id: "flow_id1"
    order_id: "order_id1"
    point_id: "moving_point_id1"
    is_connected: false
    transport_type: "car"
  - destination: [43.128765, 54.124982]
    flow_id: "flow_id1"
    order_id: "order_id2"
    point_id: "moving_point_id2"
    is_connected: false
    transport_type: "scooter"
  - destination: [43.128765, 54.124982]
    flow_id: "flow_id1"
    order_id: "order_id2"
    point_id: "waiting_point_id1"
    wait_time: 300
```

### Маршрут
Отдаваемый маршрут в Timelefts представляет собой массив позиций. Внутреннее представление маршрута - это уже детали реализации.

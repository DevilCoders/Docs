# Потоки данных

!!Важно!! Все это в стадии продумывания и будет на ревью.

Потоки данных - это внутренняя часть системы, с помощью которой наши сервсиы
обмениваются информацией. Пользователь настраивает связи между сервисами в
конфигурации пайплайна и может регулировать какие позиции куда отправляются.

Шина, с помощью которой происходит обмен даных между сервисами и протоколы
которые они используют - это все внутренняя часть системы и асбтрагируется от
пользователя.

### Мотивация

Почему мы хотим заморочиться распределением потоков данных внутри нашей системы, а не скармливать всем потребителям все разом + дать им возможность настраивать компоненты. Т.е. почему бы например не сделать так:
1. Принимаем на вход поток данных - все позиции с кучей источников и прочим
2. Отправляем весь поток в притягиватель. В настройках притягивателя пользователь может указывать какие источники притягивать, какой тип транспорта
3. Пишем в тот же канал из которого считали и отдаем пользователю

Проблем в том что это около 16x трафика от того, который нужен нашим основным потребителям (кандидаты, цепочки) и даже внутри нам такой трафик не нужен. При этом каждой сообщение в шине придется распарсить и отфильтровать оттуда ненужные позиции - и это на каждой принимающей машине. У кандидатов их 70. У нас от одна. Если мы будем делать это у нас, то это будет сильно эффективнее.

### Управление потоками

Внутри системы пользователь может настраивать потоки данных. Описание конфигурации для пользователя мы пока не продумывали, поэтому будем смотреть на конфиг как он выглядит внутри.

Общая идея такая - в любом сервисе который что-то пишет на выход мы позволяем указать набор фильтров, которые регулируют что уходит в канал. в YQL нотации это эквивалентно
```sql

INSERT INTO 'channel_name'
SELECT * FROM $source
WHERE
   -- Набор условий
   transport_type = 'car'
   AND source = 's1'
```

TODO: Проблема с таким подходом в том, получается прям целый язык и фильтры надо применять.

Список полей по которым мы позволяем фильтры фиксирован.
Пример описания в json. В этом варианте у нас элементы поля filters явно зафиксированны т.к.
мы поддерживаем фильтрацию лишь по определенным полям.
```json
{
  "channel": "yagr:pedestrian_positions"
  "filters": {
    'transport_type' : {
       "type" : "include" # exclude if we want to filter out, not filter in
       "values": [ "car", "pedestrian" ]
    },
    'sources' : {
       "type" : "include" # exclude if we want to filter out, not filter in
       "values": [ "Verified", "Adjusted" ]
    },
   }
}
```
Есть другой вариант, где filters = [] это массив фильтров по полям. В этом варианте мы все также фиксируем поля по которым можно фильтровать, но теперь их чуть проще добавлять. С другой стороны, у нас возникают ситуации когда могут быть две записи на одно поле, и надо либо валидировать, либо мерджить.
```json
{
  "channel": "yagr:pedestrian_positions"
  "filters": [
    {
       "field" : 'transport_type'
       "type" : "include" # exclude if we want to filter out, not filter in
       "values": [ "car", "pedestrian" ]
    },
    'sources' : {
       "field" : 'sources'
       "type" : "include" # exclude if we want to filter out, not filter in
       "values": [ "Verified", "Adjusted" ]
    },
   ]
}
```

В обоих случаях наша задача будет скомпилировать конфиг в плюсовый класс который можно применять сверх быстро, т.к. поток данных большой. Например
```cpp
using TransportType = std::string;
using Source = std::string;

class Filter {
  std::unordered_set<TransportType> transport_filter;
  bool transport_filter_type = TFT::Include;
  std::unordered_set<Source> source_filter;
  bool source_filter_type = TFT::Exclude;
};
```

Вообще, не плохо бы подумать что из фильртров можно смело организовывать дерево решений. если научится это делать. Но довольно сложно и точно не на первом этапе.

**Текущие доступные для фильтрации поля**
1. transport_type
2. source
3. region
4. time_shift TODO: понять надо ли? С помощью этого фильтра можно отделять
   предсказания от притягиваний и направить их в трекстори с разными
   источниками, например. С другой стороны, у трекстори и так есть
   функциональность фильтрации ответа, а из потребителей каналов все в целом
   переживут и единый канал.

**Альтернатива**
Можно просто сделать фильтрацию по сенсорам и сделать transport_type, region
обычными сенсорами.

### Примеры и схемы
Для потоков данных мы предоставляем две схемы - для поисания потоков на вход и
для описания потоков на выход. Соответственно, сервисы которые принимают потоки
на вход (например притягиватель и хранилище) и которые создают новые потоки ни
выход используют соответствующие схемы.

Вот примеры описания потоков на вход. Просто один поток:
{% code './yaml/config_internal/data_streams.yaml' lang='yaml' jsonpath='$.definitions.Source.examples.simple_source.value' %}
Два потока:
{% code './yaml/config_internal/data_streams.yaml' lang='yaml' jsonpath='$.definitions.Source.examples.two_channels_source.value' %}

{% cut 'Схема источника' %}

{% code './yaml/config_internal/data_streams.yaml' lang='yaml' jsonpath='$.definitions.Source' %}

{% endcut %}

Вот примеры описания потоков на выход

{% code './yaml/config_internal/data_streams.yaml' lang='yaml' jsonpath='$.definitions.Destination.examples.simple_destination.value' %}
Два потока:
{% code './yaml/config_internal/data_streams.yaml' lang='yaml' jsonpath='$.definitions.Destination.examples.destination_with_filters.value' %}

{% cut 'Схема выхода' %}

{% code './yaml/config_internal/data_streams.yaml' lang='yaml' jsonpath='$.definitions.Destination' %}

{% endcut %}

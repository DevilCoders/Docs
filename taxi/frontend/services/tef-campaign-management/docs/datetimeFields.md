# Нюансы / проблемы, связанные с датами, а также подходы, которых придерживаемся при работе с ними

## Таймзоны / смещение от UTC

При работе с датами / временем учитываем конкретную таймзону (!есть исключения!). 
Для гибкости реализован пикер таймзоны, который записывает выбранное значение в `LocalStorage`, 
чтобы во всем приложении можно было учитывать смещение от UTC, соответствующее той или иной таймзоне.

По дефолту, в начале работы с приложением, проверяется сохраненное значение таймзоны, – 
если его нет, устанавливается локальная таймзона пользователя.

Селектор таймзоны также ориентируется на `LocalStorage` для определения выбранного значения, 
либо устанавливает его исходя из локальной таймзоны пользователя (в качестве фоллбэка).

Для определения таймзоны / смещения от UTC реализован ряд вспомогательных функций:
- `getLSTimezone` / `setLSTimezone` – получение / сохранение таймзоны в LS;
- `getCurrentTimezoneName` – получение названия текущей таймзоны пользователя. Пример: *'America/Chicago'*;
- `getCurrentTimezone` – получение объекта, определяемого из общего списка таймзон, на основании названия (name) таймзоны. 
Для гибкости (поиска конкретной таймзоны) предусмотрен параметр timezoneName. 
Без данного параметра выбирается таймзона с названием, определенным из `getCurrentTimezoneName`.

- `getCurrentUtcOffset` – вытаскивает formattedOffset (строку виду *'+03:00'*) из таймзоны, сохраненной в LS, 
либо значение из конфига в качестве фоллбэка.
- `getCurrentUtcLabelTip` – предназначена для генерации подсказки для полей даты / времени без лейбла.
На выходе отдает значение вида *'Время в UTC +03:00'* или, если указано `fullTip = false`, – *'UTC +10:00'*.
К примеру, кейс использования – есть alert-подсказка "Отправка запланирована в N часов".
В этом случае необходимо дополнить текст информацией о смещении от UTC => *"Отправка запланирована в N часов. Время в UTC +03:00"*
- `wrapLabelWithUtcOffsetTip` – дополняет ("оборачивает") лейбл подсказкой в виде `<sup>`-элемента.
К примеру, кейс использования – есть форма, в которой присутствует поле с датой отправки. 
В этом случает необходимо отобразить подсказку со смещением от UTC около данного лейбла =>
`label={wrapLabelWithUtcOffsetTip('Дата отправки')}`
отдаст
```html
Дата отправки
<sup>
    UTC +03:00
</sup>
```

## Общение с бэкендом / конвертация дат и времени

1. С бэкендом "общаемся" в обе стороны в формате `YYYY-MM-DDTHH:mm:ss.SSSZZ`. 
Пример выглядит так: *2022-02-28T12:04:18.995446+03:00*. 

В кейсе, когда бэк отдаёт дату в каком-то другом формате => проблема на стороне бэкенда => пингуем, что это дело они должны исправить. 
В кейсе, когда фронт отправляет дату в каком-то другом формате => проблема наша => приводим дату к указанному формату общения.

! Есть некоторые исключения !
<br/>
В некоторых местах дата и время передаются в ином формате (без таймзоны).
Пример – "Расписание" в кампании, которое задается cron-выражением. 
Вероятно в дальнейшем реализуем или подключим утилиту, которая сможет распарсить крон и скорректировать смещение.

2. AntD умеет работать **только в локальном времени** пользователя. 
Отсюда правило – в компоненты AntD ВСЕГДА передаём даты с локальной таймзоной. 
Если хотим, чтобы юзер работал с UTC, значит отдаём объект moment с датой / временем UTC, 
но таймзону всё равно указываем локальную для пользователя.

Для правильного "скармливания" даты antd-дейтпикеру реализована функция `prepareDateTimeForAntD`. 
Вторым аргументом функция принимает `offset` (смещение от UTC), в котором хотим получить итоговую дату. 
По дефолту будет конвертить значение в дату со смещением текущей таймзоны (выбранной в селекторе таймзон).

К примеру (предположим, что в пикере выбрана МСК таймзона => смещение +3):
<br/>
1) Есть дата и время в UTC => на выходе получим ту же дату, но в локальной таймзоне +3 

```javascript
let a = moment('2022-03-07T10:00:00.000+0000', 'YYYY-MM-DDTHH:mm:ss.SSSZZ');
prepareDateTimeForAntD(a); // -> 2022-03-07T10:00:00.000+0300
```

2) Для получения на выходе даты с конкретным смещением, необходимо передать ```offset``` вторым аргументом

```javascript
// К примеру, хотим, чтобы юзер вводил дату и время в GMT +10 (Владивосток)
prepareDateTimeForAntD(a, 10); // -> 2022-03-07T17:00:00.000+1000
```

3. Для того чтобы принять дату от antd и как-то адекватно с ней работать в коде 
(валидация, сохранение данных формы и т.д.), необходимо производить обратную конвертацию даты/времени.
Для этого реализована функция `prepareDateTimeFromAntd`, которая принимает дейттайм с любой таймзоной 
и на выходе отдаёт ту же дату / время, но в заданной таймзоне (по дефолту – в текущей таймзоне (выбранной в селекторе таймзон)).

К примеру: *2022-03-07T10:00:00.000+0300* превратит в *2022-03-07T10:00:00.000+0000*.

4. Придерживаемся принципа "даты и время храним (и обмениваемся) в виде строк".
Для этого реализована функция `createFormDateConverters`, которая выдаёт набор пропсов 
для date / time antd-элемента `Form.Item`, обеспечивающие прозрачную работу со строковым представлением 
даты и времени как на входе, так и на выходе. Это позволяет обойти процесс конвертации даты / времени 
в moment для модели формы и обратной конвертации даты / времени из moment при получении данных формы.
Функция на вход принимает формат moment, в котором данные придут в поле формы.

```javascript
const dateTimeFieldConverters = createFormDateConverters('YYYY-MM-DDTHH:mm:ss.SSSZZ');
// ...
<Form.Item
    name="send_at"
    help="Время в UTC"
    {...dateTimeFieldConverters}
/>
// ...
```

За счет `dateTimeFieldConverters` теперь `send_at` В форму antd можно передать в формате `YYYY-MM-DDTHH:mm:ss.SSSZZ`
и в этом же формате получать значение ИЗ формы.
Примечание: функция не решает проблемы, решаемые в пунктах 2 и 3. Возможно имеет смысл интегрировать, но пока это не реализовано.

5. Поля, где фигурирует только время без даты, рассматриваем так, словно эти поля в UTC. 
Все необходимые трансформации производим на стороне фронта.

Исходя из этого, значение времени обрабатываем по следующему алгоритму:
5.1) При отправке на бэк необходимо из строки вида "12:30" получить moment-объект и снабдить его информацией о текущем смещении.
Затем необходимо избавиться от установленного смещения и привести значение к UTC.
Для этого реализована функция `normalizeTimeToUtc`.

```javascript
// К примеру, предположим, что пользователь выбрал мск таймзону (+3).
// Для передачи значения времени бэкенду нормализуем время и приведем его к строковому формату
normalizeTimeToUtc('13:30').format(TIME_FORMAT); // -> отправится 10:30
```

5.2) Время, которое пришло с бэкенда, соответственно, необходимо рассматривать в разрезе UTC =>
необходимо из строки получить moment-объект с нулевым смещением, после чего установить текущую таймзону пользователя.
Для этого реализована функция `normalizeTimeFromUtc`. 

```javascript
// Также предположим, что пользователь выбрал мск таймзону (+3).
// Для отображения времени на фронте также нормализуем время и приведем его к строковому формату 
normalizeTimeFromUtc('10:30').format(TIME_FORMAT); // -> отобразится 13:30
```

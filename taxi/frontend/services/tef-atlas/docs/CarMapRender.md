## Quick start

Компоненту PointLayerDrawCanvas необходимо передать массив объектов, функцию стилей, и указать, как искать ID и геометрию объектов.

```javascript
<PointLayerDrawCanvas 
    objects={[{objId:'1', geom: [53.3213, 34.93487]}]}
    styles={(obj) => ({fillColor:'red', size: 10})}
    idParam="objId"
    geomParam="geom"
/>
```
Этого будет достаточно для работы.  
Обратите внимание на объект стилей, который мы возвращаем из функции `styles`. В этом объекте необходимо вернуть `size`, остальные параметры опциональны и зависят от конкретной реализации функции render-а объектов.

Функцию render-а объектов можно переопределить с помощью props-а `draw`. Функция принимает объект стилей и должна вернуть элемент canvas (или img), с отрисованным объектом.  

Простейшая реализация функции render-а выглядит так:  
```javascript
const draw = styles => {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = style.size * 2
    const ctx = canvas.getContext('2d');

    ctx.beginPath();
    ctx.arc(styles.size, styles.size, styles.size, 0, 2 * Math.PI)
    ctx.fill();

    return canvas;
}
```

## Как это работает?
1. На вход в компонент прилетает большой массив объектов с геопозицией (lat, lon).
2. Индексируем этот массив в [KDBush](https://github.com/mourner/kdbush)
3. Вызываем перерисовку всех видимых на данный момент тайлов (leaflet хранит массив текущих тайлов).
4. Для каждого тайла вычисляем объекты, которые попадают в границы тайла с небольшим буфером.
5. Считаем стили для объекта и генерируем ключ стилей для кеширования.
6. Пытаемся по ключу стилей получить canvas с уже отрисованным объектом. Если такого нет - рисуем и кладём canvas в кеш под ключём стилей.
7. Рисуем объект на тайле

На **2**-ом пункте мы индексируем наши объекты в KDBush. Это библиотека для очень быстрой пространственной индексации 2D точек. 
Такой индекс поможет нам очень быстро определить, какая именно точка находится вблизи курсора мыши, когда мы будем обрабатывать события мыши.  

Для сравнения, если мы будем определять "точку под курсором" в ручном режиме, при 50к объектах, этот процесс займёт в районе 40мс, в то время, как с индексом KDBush мы справимся за 1мс.  
Такая разница очень ощутима при mousemove.  

Также KDBush позволит нам, за дешёвое время, определить точки, которые попадают в границы тайла.

На **4**-ом пункте, для поиска объектов, которые мы будем рисовать на тайле, мы считаем границы тайла с неким буфером. Буфер это кол-во пикселей, которые мы добавляем к каждой стороне тайла.  
Это необходимо для того, чтобы те точки, центр которых находится за границами тайла, но "цепляют" область тайла своим радиусом, тоже были отрисованы на текущем тайле.

На **5**-ом и **6**-ом пунктах, мы кешируем отрисованные объекты на отдельных canvas элементах в памяти. 
Поскольку процесс отрисовки на canvas-е можно считать достаточно дорогим по времени, мы render-им визуально одинаковые объекты один раз и кешируем результат этого render-а. В дальнейшем эти закешированные "фрагменты" используются для быстрой отрисовки визуально одинаковых объектов на карте, с помощью `ctx.drawImage`.

## Как работает анимация?
1. В componentDidUpdate сравниваем предыдущий список объектов с текущим.
2. Создаём индекс changedObjects по ID с ссылкой на старый объект, новый объект и пометкой "удалён", "добавлен", "изменён". _На данный момент, изменённые объекты определяем по разнице в геометрии._
3. Если changedObjects не пустой, запускаем процесс анимации вместо rerender-а тайлов.
4. Рисуем все объекты, которые не попали в changedObjects и сохраняем эти изображения
5. Запускаем анимацию. Считаем стили и позицию объекта для каждого кадра на основе данных из changedObjects.
6. Индексируем объекты, участвующие в анимации в KDBush
7. Рисуем объекты из changedObjects стандартными методами, но поверх сохранённых изображений из п.4
8. После анимации очищаем changedObjects и рисуем финальный кадр по стандартной схеме, чтобы вернуть объектам правильный zindex.

На **4**-ом пункте мы запускаем render объектов, которые не участвуют в анимации. Делаем мы это для того, что-бы получить статичный фон одним изображением, и в каждом кадре анимации рисовать анимированные объекты поверх этого фона.  
К примеру, у нас есть 10к объектов, 3к из них изменили геопозицию. Мы один раз рисуем 7к объектов, которые не менялись, а на каждом кадре анимации рисуем только те 3к объектов, которые изменили свою позицию.

Из-за этой оптимизации у нас есть побочный эффект. На время анимации, те объекты, которые анимируются, визуально всплывают над теми объектами, которые не менялись. Чтобы вернуть этим объектам правилный zIndex, сразу после последнего кадра анимации мы запускаем полноценный полный rerender всех объектов. Мы это можем себе позволить, т.к. в этот момент все фрагменты объектов уже гарантированно закешированы.

## Как работают события мыши?
1. Ищем ближайший объект от курсора с помощью [geokdbush](https://github.com/mourner/geokdbush)
2. Считаем стили для объекта (нужно понять его размеры)
3. Считаем расстояние от курсора до точки
4. Если меньше чем радиус объекта - hover/click по объекту. Иначе это клик по подложке.

## Сравнение с реализацией на SVG
Поскольку мы имеем дело с большим кол-вом объектов (более 30к), реализация на SVG заметно проседала по производительности. Новая реализация основана на использовании тайлового слоя leaflet и рендере машинок с помощью canvas на каждом тайле. Отрисовка на canvas менее подвержена к просадкам производительности при большом кол-ве отображаемых объектов, по сравнению с SVG.

При SVG, браузер "вешался" из-за кол-ва дом узлов и событий с ними связанных.  
![](https://jing.yandex-team.ru/files/csilence/svgdomnodesandeventlisteners.png)

При canvas, браузеру заметно легче работать с DOM.  
![](https://jing.yandex-team.ru/files/csilence/canvasdomnodesandeventlisteners.png)

Поскольку Canvas, это просто bitmap буфер, производительность не критично зависит от отрисовки большого кол-ва объектов. При SVG ситуация обратная, поскольку необходимо обслуживать дополнительные связи к объектам, которые браузер render-ит.  

_Зависимость производительности от кол-ва объектов_  
![](https://jing.yandex-team.ru/files/csilence/varying-number-of-objects.png)

Однако производительность Canvas сильно зависит от размера холста, т.к. при размере холста растёт и буфер данных (кол-во пикселей), которые необходимо обрабатывать. При SVG размер холста практически никак не влияет на производительность.  

_Зависимость производительности от размера холста_  
![](https://jing.yandex-team.ru/files/csilence/varying-drawing-area-height.png)

Это одна из причин, по которой мы используем несколько маленьких canvas элементов (по размеру тайла), вместо одного большого на весь экран.

### Несколько сравнительных замеров
**Canvas первый рендер 30k cars**  
1326ms - от получения данных до кадра с машинками  
110ms - индексация машинок  
850ms - рендер  
366ms - react  
  
**SVG первый рендер 30k cars**  
1600ms - от получения данных до кадра с машинками  
50ms - подготовка SVG контейнера  
990ms - рендер JS (добавляем пути SVG)  
530ms - React (recalculate styles, layout)  
30ms - Paint  
  
**Canvas обновление машинок 30k cars**  
FPS 5  
1100ms от получения данных до кадра с машинками  
  
**SVG обновление машинок 30k cars**  
FPS 2  
1800ms от получения данных до кадра с машинками  
  
**Canvas Zoom +1**  
FPS 30  
1500ms от scrollEvent-а до последнего кадра анимации  
  
**SVG Zoom +1**  
FPS 2  
3000ms от scrollEvent-а до последнего кадра анимации  

При SVG, в момент render-а мы ловим фриз браузера, в этих моментах события mousemove, mouseover, mouseout отрабатывают по 3-4 секунды.  
При Canvas фризы отсутствуют в принципе.  

Видео работы рендера машинок на SVG и Canvas:  
[~30k машинок в статике (SVG)](https://jing.yandex-team.ru/files/csilence/static_svg.webm)  
[~30k машинок в статике (Canvas)](https://jing.yandex-team.ru/files/csilence/static_canvas.webm)  
[Обновляемые данные (SVG)](https://jing.yandex-team.ru/files/csilence/real-data-svg.webm)  
[Обновляемые данные (Canvas)](https://jing.yandex-team.ru/files/csilence/real-data-canvas.webm)  

**Дополнительные плюсы реализации**
* Сколько тайлов когда отображать, сколько держать в кеше, как анимировать (при zoom/pan), нас это не волнует. Со всем этим leaflet справляется просто прекрасно.
* Получаем полную синхронизацию анимации с остальными тайловыми слоями
* Никаких лишних экземпляров классов и объектов. Используем всю мощу движка JS и "бегаем" непосредственно по массивам без лишних дополнительных обработок.
* Небольшое кол-во (десятки) DOM элементов
* Всего один listener на событие мыши
* Если тайлы отрисованы, стоимость обслуживания такого слоя браузером равносильна обслуживанию обычного тайлового слоя (как подложка). Это одна статичная картинка на каждый тайл.
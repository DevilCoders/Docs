Одним из самых распространенных кейсов является необходимость среагировать в UI на начало / окончание какого либо процесса, описанного в сагах, или его шага.

Для этого в Админке существует механизм асинхронных операций. Асинхронность в данном случае не означает что операция обязательно будет асинхронной, а только то, что время ее выполнения и соответственно окончания не известно. (Хотя в перспективе с включением React fibber любое изменение стора, вызывающее ререндер, будет асинхронным)

Каждая операция описывается объектом следующего типа

```typescript
interface AsyncOperation<TRes = any, TArgs = any, TMeta = any, TErr = Error> {
    id?: string | OperationId<TRes>;
    isLoading?: boolean;
    isError?: boolean;
    isBlocked?: boolean;
    error?: TErr;
    args?: TArgs;
    result?: TRes;
    meta?: TMeta;
    promise?: Promise<unknown>;
}
```

У каждой операции есть уникальный `id`, котроый является строкой, но с точки зрения типов существует специальный тип `OperationId<TRes = any, TArgs = any, TMeta = any, TErr = Error>`, который содержит в себе основную информацию о типах испльзуемых в операции, что позволяет напримр автоматически выводить результат операции по ее `id`.

При обявлении айдишников вручную каст к `OperationId` обязателен

Все объекты такого типа хранятся в сторе, общий стейт операций представляет собой обычный хэш вида 
`{[id: string]: AsyncOperation}`, содержащий описание операций доступное по их id. Идентификторы операций создаются либо вручную, либо автоматически, например при использовании `useSaga`.

Таким образом все что нужно сделать в UI - это подписаться на нужную операцию. Это можно сделать через хук `useOperation`, или любым способом подписавшись на нужную часть стора с помощью `react-redux`, но у `useOperation` есть поддержка `React.Suspense`

Для того чтобы отображать контент по готовности операции можно использовать:
- `AsyncContent`
- `AsyncButton`. 
- `Suspense` если подписка была через `useOperation`

### На нижнем уровне
Для создания и удаления операций используется хелпер `operationRunner`.

При создании операции можно укзать стратегию ее обновления `updateStrategy`

По сути стратегия - это обычная функция которая вызывается перед записью операции в стор и мутирует ее некоторым образом, это позволяет кастомизировать операции под процесс, например конкатенировать результаты операции при педжинации

На данный момент существует ряд базовых стратегий доступных через `_sagas/update-strategies/<strategy>`:
- `paginationStrategy` - конкатенирует результаты обернутой функции и хендлит параметры педжинации
- `silentReplaceStrategy` - заменяет результат операции по готовности, тем самым избегая состояния когда операция не содержит никакого результата
- `extendListStrategy` - добавялет результат обернутной функции в массив 
- `removeFromListStrategy` - удаляет результат обернутной функции из массива
- `updateListStrategy` - обновляет значение одного из элементов массива результатом обернутной функции

sagas/my-saga
```typescript
// Идентификатор импортируется в UI
export const TYPES_LOADER_ID = 'TYPES_LOADER_ID' as OperationId<Type[]>;

const typesLoader = operationRunner(TYPES_LOADER_ID, function * () {
    return yield call(apiInstance.requestTypes);
}, silentReplaceStrategy);
```

components/my-component/MyComponent
```typescript
import {TYPES_LOADER_ID} from '../../sagas/my-saga';

...

class MyCopmonent extends PureComponent<Props> {
   public render() {
        return (
            <AsyncContent id={TYPES_LOADER_ID}>
                 <Content/>
            </<AsyncContent>
        )
   }
}
```

Вся информация выше приведена для понимания того, как создаются операци под капотом, но при решении повседневных задач создавать их руками не потребуется.

### На высоком уровне
Оперции создаются через декораторы `@operation` и `@daemon`, которые применяются к методам сервисов. Подробнее об этом будет написано в разделах 5.4 и 5.5
Как правило какие-либо действия пользователя влекут за собой не единичное изменение стейта, а запускают некоторый процесс, который может иметь множество шагов и ветвлений прежде чем достигнет конечного состояния, которое интересует пользователя.

В типичном front-end приложении такие процессы описаны раздроблено, часть логики находится в одном евент-хендлере, который дергает следующий евент, который ловится где-нибудь в другом компоненте и тд. Разбираться, отлаживать и тем более усложнять логику процессов, описанных таким образом довольно сложно. Саги позволяют описать всю последовательность в одном месте, детализируя ее настолько насколько нужно посредством разбиения на более мелкие функции.

sagas/processes
```typescript
function* step1(...args) { ... }
function* step2(...args) { ... }

export function* process(...args) {
  const partialResult = yield call(step1, ...args);
  return yield call(step2, partialResult);
}
```

в свою очередь уже описанные процессы легко делаются частью более сложного процесса или пайплайна

sagas/transactions
```typescript
let openedTransaction = null;
const queue = [];

function* queueProcessor() {
    while (true) {
        const process = queue.pop();
        if (!process) {
            return;
        }

        yield call(process)
    }
}

function* transaction(process) {
    yield call(onTransactionOpened)

    try {
        yield call(process);
        yield call(onTransactionCommit);
    } catch (e) {
        yield call(onTransactionRollback, e)
    }

    openedTransaction = null;
}

export function* transactionRunner(process) {
   queue.unshift(process);

   if (!openedTransaction) {
       openedTransaction = yield fork(() => transaction(queueProcessor));
   }

   return openedTransaction;
}
```

sagas/my-saga
```typescript
import {process} from './processes'
import {transactionRunner} from './transactions'

function* pipeline() {
    // все описанные процессы будут обрабатываться в рамках транзакций
    yield call(transactionRunner(process));
}

...
```

Все сценарии процессов можно разделить на две группы:
* появляется новый UI требующий инициализации
* требуется обновление уже проинициализированного UI

Для первой группы используются функции `onLoad` и `onDispose` описанные [тут](/arcadia/taxi/tariff-editor/docs/5.-sagas-general.md)

Для второй используются так называемые "демоны" (daemon).
Демон - это фоновый процесс, который отслеживает некоторый триггер и запускает по нему дочерний процесс согласно некоторой логике запуска (например следует ли убивать предыдущий незавершенный дочерний процесс). Демон условно не имеет конечного состояния, и живет до тех пор пока его не уничтожит создавший его процесс.

В нашем случае триггерами являются redux-экшены, а дочерними процессами - любые саги, имеющие конечное состояние. Т.е. стоит избегать написания демонов, запускающих демонов, разве что это некоторое инкапсулированное поведение, которое существенно облегчает жизнь и покрыто тестами, поскольку множественная вложенность неблокирующих вызовов процессов имеет повышенную вероятность плавающих багов и утечек памяти.

### На нижнем уровне 
Для создания демонов следует использовать хелпер `daemonRunner`, и избегать написания собственных реализаций.

```typescript
import {process} from './processes'
import {pure as actions} from '../actions'

const createDaemon = daemonRunner(`${actions.myEntityApi.create}`, process);
```

`daemonRunner` может принимать в качестве триггеров те же типы аргументов, что и эффект [take](https://redux-saga.js.org/docs/api/index.html#takepattern)

`daemonRunner` может быть запущен в четырех режимах:
* `SYNC` - это режим по-умолчанию, в нем триггеры игнорируются до тех пор пока не окончен текущий дочерний процесс
* `EVERY` - в этом режиме для каждого триггера будет запущен дочерний процесс, внутри используется [takeEvery](https://redux-saga.js.org/docs/api/index.html#takeeverypattern-saga-args). Обратите внимание что очередность вызовов не гарантируется.
* `LAST` - в этом режиме предыдущий процесс будет закенселен, и будет запущен новый дочерний процесс, внутри вызывает [takeLatest](https://redux-saga.js.org/docs/api/index.html#takelatestpattern-saga-args). Обратите внимание, что предыдущий процесс может быть прерван на произвольном `yield`, в зависимости от того до какого состояния успел добежать генератор.
* `SCHEDULE` - в этом режиме демон будет вызываться раз в указанное количество миллисекунд, ни на какие экшены данный демон не реагирует

Чтобы понять в каком режиме нужно запустить демон необходимо представить, а что будет если подряд прилетит несколько триггеров.

### Пример 1 (Педжинация):
Для того, чтобы подгрузить новую порцию данных, нам нужно бросить триггер незадолго до того, как скролл страницы достигнет нижнего положения. 

Таким образом в обработчике скролла нам хотелось бы написать как можно более простую логику из разряда - если до конца скролла меньше чем столько-то пикселей, то вызвать триггер подгрузки. Таким образом мы имеем, что начиная с некоторой точки, каждый евент скролла будет кидать триггер, и мы получим некоторое неопределенное число вызовов в зависимости от скорости скролла.

Подходит ли для хендла такого триггера режим `LAST`? Очевидно нет, он отменяет предыдущие вызовы, таким образом мы вероятно потеряем кучу страниц и подгрузим непонятно что.

Подходит ли для хендла такого триггера режим `EVERY`? Такой режим подгрузит все страницы, но он не гарантирует порядок, так что тоже не подходит

Таким образом подходит дефолтный режим `SYNC`, он отфильтрует все лишние вызовы, пока грузится новая страница, тем самым обеспечив верный порядок загрузки, а также поможет избежать множественных подгрузок страниц за раз.

### Пример 2 (Фильтрация таблицы):
У нас есть фильтр который применяется неважно как, сразу при изменении, или по отдельной кнопке. При применении фильтра происходит вызов соответствующего триггера и необходимо отфильтровать таблицу, запросив данные по новым параметрам с сервера.

Подходит ли для хендла такого триггера режим `SYNC`? Нет, если первый запрос подвиснет, а юзер успеет применить фильтр еще раз, то второй триггер проигнорируется, в результате получится рассинхрон таблицы и фильтра

Подходит ли для хендла такого триггера режим `EVERY`? Поскольку режим не гарантирует очередность, то рассинхрон также возможен, так что он не подходит.

Таким образом подходит режим `LAST`, он отменит все предыдущие операции, и применит только последнюю

### Пример 3 (Логгер):
Предположим у нас есть триггер, который срабатывает при возникновении ошибок. И мы хотим логгировать все возникшие ошибки в некотором сервисе, что требует отправки запроса.

Подходит ли для хендла такого триггера режим `SYNC`? Нет, если первый запрос подвиснет, то мы можем потерять все ошибки, которые придут в период обработки текущей ошибки

Подходит ли для хендла такого триггера режим `LAST`? Нет, поскольку он может отменить логгирование прошлой ошибки, которая еще не успела отправиться в сервис

Таким образом подходит режим `EVERY`, то что он не соблюдает очередность нам не важно, главное записать ошибку, потом можно будет вывести их по таймстемпу.

### Примечания

На текущий момент не покрыт кейс, когда нам требуется и сохранить очередность и обязательно обработать все триггеры.

Также есть общий набор рекомендаций по использованию демонов:
* Для операций записи безопаснее использовать режим `SYNC` и дизейблить UI на время выполнения процесса, это хороший способ избежать лишних запросов на сервер
* Одному процессу должен соответствовать РОВНО один демон, если у вас один демон вызывает триггер другого демона это грубая ошибка. В таком случае вы теряете атомарность процесса и соответственно управление над ним. В частности возможность консистентной отмены, т.к. вам придется как-то проверять не отменен ли процесс в каждом демоне, что вообще не всегда возможно. А так же вы больше не сможете встроить нормально такой процесс в другой. 

Предположим у вас есть два процесса:
1. Установить текущий выбранный айтем, с какими-то инициализациями форм и еще возможно запросом каких-то деталей
2. Сменить тип айтемов, и выставить текущим первый айтем

Таким образом у вас второй двушаговый процесс содержит первый.

как делать НЕ НАДО
```typescript
const setItemDaemon = daemonRunner(`${actions.ui.setCurrentItem}`, function * (id) {
    const item = yield select(state => state.entities.items.find(item => item.id === id));
    item.details = yield call(api.loadDetails);
    yield put(actions.entities.findSuccess(item));
    yield put(commonActions.form.load(MODEL, item));
});

const loadByTypeDaemon = daemonRunner(`${actions.ui.changeType}`, function * (type) {
    yield call(entityLoader.init, {type});
    const item = yield select(state => state.entities.items[0]);

    // дергаем первый демон
    yield put(actions.ui.setCurrentItem(item.id));
});
```

как НАДО делать
```typescript
const setCurrentItem = function * (id) {
    const item = yield select(state => state.entities.items.find(item => item.id === id));
    item.details = yield call(api.loadDetails);
    yield put(actions.entities.findSuccess(item));
    yield put(commonActions.form.load(MODEL, item));
}

const loadByType = function * (type) {
    yield call(entityLoader.init, {type});
    const item = yield select(state => state.entities.items[0]);

    // вызываем второй шаг синхронно, сохраняя атомарность процесса
    yield call(setCurrentItem, item.id);
}

const setItemDaemon = daemonRunner(`${actions.ui.setCurrentItem}`, setCurrentItem);
const loadByTypeDaemon = daemonRunner(`${actions.ui.changeType}`, loadByType);
```

Вся информация выше приведена для понимания того, как демоны работают под капотом, но при решении повседневных задач создавать их руками не потребуется.

### На верхнем уровне
Для создания демона следует использовать декоратор `@daemon` применяемый на метод сервиса, он инкапсулирует всю низкоуровневую работу, указывая какие методы сервиса должны быть запущены как демоны. Подробнее об этом будет написано в разделах 5.4 и 5.5



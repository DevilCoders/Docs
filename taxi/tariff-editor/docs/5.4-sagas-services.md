Создание демонов требует довольно много типовых действий, таких как
* создать экшены, которые будут тириггерить демон
* обернуть запускаемую в демоне логику в операцию
* обернуть операцию в демона
* запустить демона
* уничтожить демона и операцию

Для саг с большим числом демонов это выливается в портянки из типового кода. Таким образом появилась идея как сделать написание подобной логики менее затратным, и более ясным, которая превратилась в то, что в Админке называется сервисом.

Сервис - это отдельный класс, состоящий только из статических приватных или публичных методов. Методы необходимо объявлять как члены, а не свойства класса (те НЕ через знак равенства), иначе декораторы методов не получат дескриптор метода. Приватными методами могут быть какие-то хелперы, которые не нужны наружу, а публичные методы это те, которые необходимо вызывать в компонентах или других сагах. 

На каждый публичный метод можно повесить следующие декораторы:
* `@operation` - декоратор обеспечивает обертку метода в `operationRunner`. `id` операции генерируется автоматически по шаблону `SERVICE_NAME_METHOD_NAME`, и доступен как свойство метода `MyService.myMethod.id`. Операция будет уничтожена при уничтожении сервиса (см. ниже про `createService`)

```ts
class MyService {
    @operation
    public static *myMethod(object: any) {
        ...
    }
}
```

* `@daemon(mode?: DaemonMode, action?: Pattern)` - декоратор обеспечивает обертку метода в `daemonRunner`. Если `mode`не указан, то используется дефолтный `Sync`. Если не указан `action`, то демон будет ожидать автоматически сгенерированный экшен, сделанный через `createActions`. Внутри вложено вызывается декоратор `operation`, так что для каждого демона существует соответствующая операция. Важно понимать, что наличие декоратора только обеспечивает мета-данные для создания демона, сами демоны генерируются только при вызове `createService`.

```ts
class MyService {
    @daemon(DaemonMode.Last)
    public static *myMethod(object: any) {
        ...
    }
}
```

Ядро приложения предоставляет гораздо больше декораторов, подробнее можно посмотреть в разделе 5.5

Публичные методы сервиса можно использовать в сагах и других сервисах, но чтобы заработали демоны необходимо создать прокси для сервиса через хелпер `createService(ServiceCtr: {new (): any})`. Хелпер возвращает объект вида `{run, destroy, actions}`.

* `run` - запускает демоны для методов помеченных декоратором `daemon`
* `destroy` - уничтожает созданные демоны, а также операции созданные для методов обернутых в декоратор `operation`
* `actions` - создержит экшены автоматически сгененрированные для демонов

bundle/sagas/services/MyService.ts
```ts
import {Service} from 'common/infrastructure';

class MyService {
    ...
}

// тут происходят обертки в daemonRunner нужных методов
// и создание экшенов для них
export const service = createService(MyService, {
    bind: true // привязываем экшены к стору
});

// принудительный каст к типу Service обязателен,
// если наружу требуются id операций,
// поскольку указать изменения, производимые декораторами,
// можно только явным приведением к новому типу 
export default MyService as Service<typeof MyService>;
```

```ts
import Myservice, {service} from '../../sagas/services/Myservice'

function MyComponent() {
    useService(service, [])

   return (
      <>
          <AsyncContent id={Myservice.makeRequest.id}>
              ...
          </AsyncContent>
          <button onClick={service.actions.makeRequest}
      </>
   )
}
```

### Важно
* Не забывать экспортировать класс сервиса как `Service<typeof MyService>` (см. пример выше)
* Сервисы нужно складывать в папку бандла `/sagas/services` либо в папку компонента, если сервис сделан персонально для компонента
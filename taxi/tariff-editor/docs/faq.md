Оставляйте тут свои вопросы, по мере дописывания документации буду добавлять ссылки на ответы

### Какой правильный порядок импортов ?

* Первый блок - все что в `node_modules`
* Второй все что из общих папок `static` (но не внутри `bundles`)
* Третий все что внутри бандла (внутри `/bundles/<твой бандл>`)
* Четвертый стили
* Каждый блок отсортирован линтером
* Между блоками пустая строка

### Что нужно сделать перед тем как отправлять PR на ревью ?

* Убедится что компилятор TypeScript не выдает ошибок (иногда IDE может затупить, лучше прогнать через cli)
* Убедится что линтеры не выдают ошибок (npm run lint)
* Убедится что тесты не выдают ошибок (npm run test)
* Убедится что плагин валидирующий бандлы не выдает ошибок по вашему бандлу
* Просмотреть самостоятельно свой PR перед отправкой, вдруг забыли удалить какой-то лишний код, или сами заметите что что-то не так
* Не запрашивать ревью, если все еще ведете работу над веткой, которая выходит за рамки багфиксов, те у вас еще не готово АПИ на бекенде, или дизайн в разработке и тд
* На момент запроса ревью в PR все изменения должны быть слиты в один коммит

### Как мне оформлять исправления по ревью ?

Если ваш PR не является тривиальным фиксом, затрагивающим пару файлов, то все исправления с момента последнего ревью должны быть оформлены одним коммитом, те число коммитов в PR должно быть равно Первый начальный коммит + число итераций ревью. После успешного прохождения ревью, все коммиты сливаются в один.

### Мне нужно подправить существующий тип, или сделать из него производный тип, как это лучше сделать ?

На проекте есть файл `typings/common/utils.d.ts`, содержащий набор полезных утилит по преобразованию типов, возможно там уже есть то, что вам нужно 

### Как мне правильно настроить перезапрос данных из ручек ?
Принцип однонаправленного потока данных, предложенный в рамках FLUX, неплохо применять не только в рамках фреймворков, но и в целом при написании запросов данных, те нужно по возможности выделить первоисточник, изменение которого генерит необходимость запрашивать данные, и писать код так чтобы у вас всегда была цепочка вида

```
<some code> ---|-----change---> <source> ---trigger---> <data load>
               |
<other code> --|
```

Т.е. к пункту data load должна существовать только одна стрелка, от одного источника

В админке все кейсы можно поделить по большому счета на две категории, когда загрузка данных зависит от вариаций урла раздела, и когда не зависит.

В случае, когда зависит, url поскольку существует еще до загрузки приложения и есть первоисточник данных, а значит необходимым и достаточным условием должно быть изменение урла, потому код ниже НЕВЕРНЫЙ

```typescript
commonActions.router.pushFilter(FILTER_MODEL);
commonActions.entity.initLoad(PartnersPollsApi, undefined, {
    reset: true,
    cancel: true
});
```

Тут url вместо того чтобы быть источником синхронизируется с данными, а значит уже существует минимум две стрелки в графе загрузки данных, одна в коде выше - ручной вызов загрузки, вторая - при открытии страницы, когда надо брать данные из url перед первой загрузкой.

Правильно - это цепочка вида
```
<page opening> --|
                 |
pushFilter ------|-----> <new url> --> bindSaga({ checkReload }) --> onComponentLoad --> <data load>
```

где `checkReload` возвращает `true` при определенных изменениях `location`

### Как мне правильно инициализировать модели форм ?

```typescript
function onLoad * () {
  // const model = ...
  yield put(commonActions.form.reset(MODEL))
  yield put(commonActions.form.load(MODEL, model))
}

function onDispose * () {
  // ничего с формой не делаем
}
```

### Зачем мне напрягаться с дженериками в bindSaga и bindService (deprecated) ?

Потому, что пока не выходит выводить аргументы из саги, передаваемой внутрь `bindSaga` и `bindService`, и матчить их с тем, что возвращается из `mapProps`, тк сага, экспортируемая для компонента инкапсулирует все детали внутри функции без агрументов `main`, и текущая типизация генераторов не дает как-то вытащить нужные типы наружу

```ts
export default function * main() {
    yield fork(() => basicFlow(main, onLoad, onDispose));
}
```

таким образом образуется разрыв в цепочке проверок типов, который надо как-то закрыть, для этого и указываются дженерики, первый принимает контракт компонента в виде пропсов, второй - контракт саги в виде необходимых ей аргументов

по причине того, что в этой связи есть две стороны, то надо указывать два отдельных типа, первый для пропсов компонента, второй для аргументов саги, даже если они пересекаются. Если вы в оба параметра передаете например пропсы, то вы сравниваете контракт компонента с самим собой, те не проверяете ничего по факту.

Потому првильным является подход, когда вы явно экспортируете из файла саги тип аргументов

```ts
// saga.ts
export type LoadArgs = ...

function * onLoad({args}: LoadOptions<LoadArgs>) { ... }
```

```ts
// index.ts
import saga, {LoadArgs} from './saga'
import {OwnProps} from './types'

...

export bindSaga<OwnProps, LoadArgs>(...)(Component)
```

### Если зависла сборка в тимсити ?
1) Зайти по ssh на билдагент
2) делаем ps -eo pid,lstart,cmd
3) Ищем что-то похожее и его пид
```ls -l /home/buildfarm/teamcity/projects/tariff-editor-build-unstable/node_modules/.cache/tests/jest-transform-cache-03cfb770c95a0422a63b98654f83d265-663cd5096d102708621094```
4) Выполняем kill -9 $pid

### Когда что использовать при работе с модалками ?
99% кейсов того, что может именоваться на проекте модалкой, делятся на четыре типа:
1) Модалки Да/Нет - те вы можете либо подтвердить некоторое действие, либо отменить. 

Если подтверждение не требует ввода данных, то можно использовать декоратор `@confirm`, он покажет дефолтную модалку, в которой можно через аргументы поменять подписи.

Если подтверждение подразумевает ввод данных, то надо использовать связку хока `modalConfirm` c декоратором `@modal`, они написаны так, чтобы работать в паре. В компонент из хока придут колбеки `submit` и `close`. Первый вызовет метод обернутый в `@modal`, второй закроет модалку.

```ts
type Args = [...]; // аргументы для открытия
type Props = ModalConfirmProps<Args>;

const MyModal = modalConfirm({
    modalId: MODAL_ID
})(function MyModal({submit, close, args}: Props) { 
  ...
})

...

@a // вызовется сразу при открытии модалки
@modal(MODAL_ID)
@b // вызовется после сабмита
public static * makeAction(...args: Args) {
  ...
}

...

const onClick = (...args: Args) => myService.actions.makeAction(...args);
```

2) Модалки на просмотр данных - не требуют от пользователя ответа, могут быть только закрыты.

Для таких модалок используется хок `modal` (не `modalConfirm`), и экшены `commonActions.modals.open`, `commonActions.modals.close`

3) Сайдбары справа, которые привязаны к урлу - это не модалки, просто компоненты которые рендерятся по некоторому условию, и не надо к ним применять что-то из модалок 

4) Сайдбары справа, которые НЕ привязаны к урлу - если сайдбар имеет одно действие, то можно использовать пункт 1, если больше одного - пункт 2
# Описание протокола

# Оглавление

* <a href="#formatting">Условные обозначения</a>
* <a href="#userid">Идентификаторы пользователей</a>
* <a href="#statuses">Статусы заказов</a>
* <a href="#proxies">Проксируемые запросы</a>
* <a href="#block">Блокировка пользователя</a>
* <a href="#localization">Локализация</a>

<a name="formatting"></a>
## Условные обозначения

Значение каждого ключа JSON может быть описано тремя параметрами:

* `type: допустимые типы данных`
* `format: формат`
* `oneOf: допустимые значения`
* `re: регулярное выражение`

Например:

* `type: string` `format: date-time` строка, содержащая дату и время в формате ISO 8601
* `type: boolean/integer` `oneOf: true/false/1/2/3` либо логическое значение истина/ложь, либо целое число от 1 до 3

Обязательные параметры помечены как `required`.


<a name="userid"></a>
## Идентификаторы пользователей

Идентификатор пользователя - это случайный уникальный идентификатор сессии, который генерируется
сервером при запросе `launch` и позволяет отслеживать все запросы одного и того же пользователя, в
том числе аутентифицировать пользователя для создания заказа.

Клиентское приложение должно передавать идентификатор во всех запросах к серверу, если
идентификатор уже известен (запрос `launch` завершился успешно). Допускается не передавать `id` в
тех случаях, когда он не является обязательным параметром запроса, для ускорения инициализации
приложения и реакции на действия пользователя (например, при первом запуске приложения в запросе
`cities` для определения города).


<a name="statuses"></a>
## Статусы заказов

Каждый заказ в Яндекс.Такси проходит через строго определенную цепочку этапов. Эти этапы
обозначаются особыми ключевыми словами, которые имеют одинаковое значение во всех запросах протокола:

* `scheduling` (только для заказов на точное время)

  Заказ уже предложен партнерам, но на него еще не назначен ни конкретный водитель,
  ни конкретная компания. Заказ может находиться в этом состоянии достаточно долго -
  например, при заказе на завтрашее утро заказ может находиться в этом состоянии всю ночь.

* `scheduled` (только для заказов на точное время)

  Заказ уже закреплен за конкретной компанией и конкретным водителем, но водитель
  еще не выехал к клиенту. Партнер может за много часов взять на себя обязательство
  выполнить заказ, но при этом сервер Яндекс.Такси не будет показывать клиенту
  перемещения водителя по городу все это время. Заказ может находиться в этом состоянии
  достаточно долго, аналогично `scheduling`.

* `search` (только для срочных заказов)

  Заказ уже предложен ближайшим к пользователю водителям, но ни один из них
  еще не согласился его выполнить. Заказ может находиться в этом состоянии не более 15 минут.

* `driving`

  Водитель едет к клиенту.

* `waiting`

  Водитель ожидает клиента возле места подачи.

* `transporting`

  Водитель забрал клиента и выполняет заказ.

* `complete`

  Водитель успешно выполнил заказ.

* `failed`

  Заказ сорван по вине компании-партнера. Заказ может попасть это состояние из любого другого.

* `cancelled`

  Заказ отменен клиентом (независимо от того, сделано это через приложение или через
  диспетчера/водителя). Заказ может попасть в это состояние из любого другого.

* `expired` и `preexpired`

  Если на заказ не найден исполнитель, это состояние означает, что прошло слишком много
  времени, и поиск водителя прекращен. Если на заказ исполнитель найден, это состояние
  означает, что произошел технический сбой и реальное состояние заказа неизвестно
  (партнер не присылал обновления состояния в течение длительного времени).
  В обоих случаях заказ считается завершенным.


<a name="proxies"></a>
## Проксируемые запросы

Часть запросов не обрабатывается непосредственно серверами Яндекс.Такси, а проксируется
во внешние сервисы. Для таких запросов мы не можем предоставить схему, набор параметров
или примеры использования, а только даем ссылку на внешнюю документацию.

*  `geosuggest` http://wiki.yandex-team.ru/SERP/suggest/geo


<a name="block"></a>
## Блокировка пользователя

В ответ на любой запрос клиента, содержащий id пользователя, сервер может сообщить о том,
что этот пользователь заблокирован в системе за нарушения до определенной даты.
Блокировка бывает двух типов - по id клиента и по его номеру телефона - сервер сообщает
тип в параметре `type`. Если клиент заблокирован по id, то он не сможет совершать
попытки авторизации телефона с этим id. При этом клиент может получить новый
незаблокированный id в `launch`. Если клиент заблокирован по номеру телефона,
то на этот номер телефона будет невозможно отправлять заказы. В этом случае
получение нового id не приведет к разблокировке номера телефона.

Формат ответа указан в разделе <a href="#additional_types">Дополнительные типы данных</a>.


<a name="localization"></a>
## Локализация
Клиент может указать, на каком языке он хотел бы получить ответ. Язык указывается
в HTTP-заголовке `Accept-Language`.
Формат заголовка стандартный. Сервер берет из заголовка первый знакомый ему язык и использует его.
На текущий момент поддерживаются языки `ru` и `en`. Если заголовок не передан, используется `ru`.
Если передан, но ни одного из поддерживаемых языков там нет, используется `en`.


<a name="token_authorization"></a>
##Авторизация по токену
Если клиент поддерживает создание аккаунта и авторизацию через аккаунт-менеджер (АК),
то он должен передавать полученный от АК токен во все ручки протокола 3.0 в виде заголовка
`Authorization: Bearer TOKEN_FROM_ACCOUNT_MANAGER`.

Первый запрос с токеном должен осуществляться в ручку `launch`, при этом если к аккаунту
уже привязан и подтвержден номер телефона, то подтверждение номера телефона старым способом
(через `auth`/`authconfirm`) не требуется — ручка `launch` вернет номер телефона по умолчанию,
список привязанных в Паспорте (незаблокированных) телефонов и поле `authorized: True`.

Клиент может изменить номер телефона на другой подтвержденный в Паспорте номер через ручку `auth`.
При этом код подтверждения не высылается, возвращается поле `authorized: True`.

Если клиент, авторизованный по токену, сделает запрос в любую другую ручку без токена, сервер
ответит ошибкой `400 Bad Request` с телом вида:

-

    {
        "error": {
            "code": "MISSING_TOKEN",
            "text": "Некоторый человекочитаемый текст ошибки"
        }
    }

Если клиент, ранее авторизованный по токену, придет без токена в ручку `launch`,
то его авторизация будет снята, и из профиля пользователя будет удалена информация о ранее
сохраненном телефоне и аккаунте Паспорта. После этого данный клиент может приходить в ручки
как обычный старый клиент без токена (предварительно пройдя авторизацию по старой схеме через
`auth`/`authconfirm`).

Если клиент передаст невалидный токен, то сервер ответит ошибкой `401 Unauthorized`,
поле `code` будет содержать строку `INVALID TOKEN`. Такая же ошибка будет возвращаться при запросе
без токена в ручках, обязательно требующих токен
(новые ручки, связанные с оплатой картой: на данный момент только `cards`).

Кроме того, при запросе с токеном сервер может вернуть ошибку `406 Not Acceptable`
такого же формата в следующих случаях (на тип ошибки указывает значение поля `code`):
 
 - UID_DOES_NOT_MATCH - uid, для которого выдан токен, не совпадает с uid,
   сохраненным для данного id клиента;
 - MISSING_UID - у данного id клиент отсутствует сохраненный uid
 - UNKNOWN_PHONE - телефон, ранее привязанный к данному id клиента, не известен Паспорту
   (заблокирован, отвязан и т.п.); проверяется только в некоторых ручках (на данный момент это
   `launch`, `order` и `cards`).

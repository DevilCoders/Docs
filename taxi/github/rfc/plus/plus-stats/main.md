##  Продуктовые требования
Нужно уметь показывать пользователю предрасчитанную статистику использования Плюса.  
Для этого нужен сервис, который предоставляет API для доступа к данным, реплицированным из YT.

## Источник статистики
Статистику будут расчитывать DMP-процессы. Результаты расчёта будут храниться в статических таблицах YT:

|yandex_uid| value | updated_at |
|------------|------| ------------|
| 12456        | 143   | 2021-01-21T21:21:21.212|

После расчёта статистика должна реплицироваться в Postgres нового сервиса статистики `taxi-plus-statistics`

### Репликация YT → Postgres
Я предлагаю не писать собственное решение наподобие passenger-profile, а доработать платформу репликации.  
Для нашей задачи достаточно будет поддержать YT как источник, а postgres как приёмник для репликации.  
Тогда любую новую статистику можно будет добавить через конфиг репликации. В добавок к этому мы почти бесплатно получим админку.

Задача делится на две:
1. Поддержать YT как источник репликации
2. Поддержать Postgres как приёмник репликации

### Хранение статистики в Postgres
Каждая из статистик будет реплицироваться в отдельную таблицу (при необходимости, шардированную по yandex_uid).
Примерная схема таблицы:
```sql
CREATE table stats.plus_points (
	yandex_uid TEXT PRIMARY KEY,
	value      TEXT NOT NULL,
	updated_at TIMESTAMPTZ
)
```

## Сервис статистики
Для доступа к реплицированным данным нужно будет использовать новый сервис `plus-stats`. 

### API plus-stats
Сервис будет предоставлять единственный метод — получение статистик по yandex_uid.

```
POST v1/get-stats?yandex_uid=123456
{
  "names": [
  	"kinopoisk.hours",
	"music.minutes",
	"plus.points"
  ]
}
```

```json
{
  "stats": {
  	"kinopoisk.hours": {
		"value": "111",
	},
	"music.minutes": {
		"value": "100523",
	},
	"plus.points": {
		"value": "1243"
	}
  }
}
```

## Хранение всех статистик в общей таблице VS Отдельная таблица для каждой статистики


### Одна таблица со всеми статистиками:
Пример:

| yandex_uid | stat_name | stat_value (jsonb) | updated_at |
| ---------- | --------- | ------------------ | ---------- |

`UNIQUE INDEX (yandex_uid, stat_name)`

Пример запроса:
```
SELECT stat_name, stat_value 
FROM stats 
WHERE yandex_uid = {{yandex_uid}} AND stat_name IN {{ stat_names }}
```

Или:

| yandex_uid | stats (jsonb) | updated_at |
| ---------- | ------------- | ---------- |

`UNIQUE INDEX (yandex_uid)`

Пример запроса:
```
SELECT stats 
FROM stats 
WHERE yandex_uid = {{yandex_uid}}
```


### Несколько таблиц на каждую статистику:

Stat 1
| yandex_uid | value (int) | updated_at | 
| ---------- | ----------- | ---------- |

`UNIQUE INDEX (yandex_uid)`

Stat 2
| yandex_uid | value (text) | updated_at |
| ---------- | ------------ | ---------- |

`UNIQUE INDEX (yandex_uid)`

Stat 3 
| yandex_uid | value (jsonb) | updated_at |
| ---------- | ------------- | ---------- |

`UNIQUE INDEX (yandex_uid)`

Пример запроса:
```sql
SELECT yandex_uid, stat_1.value, stat_2.value, stat_3.value from 
stat_1 INNER JOIN stat_2 ON (yandex_uid) INNER JOIN stat_3 on (yandex_uid)
WHERE yandex_uid = {{ yandex_uid }}
```


### Плюсы одной таблицы на все метрики:
- Статистику для одного пользователя можно достать одним запросом без JOINов
- Индексы в сумме занимают меньше места, потому что идентификатор пользователя не дублируется для индексов в разных таблицах

### Плюсы таблицы на каждую метрику:
- Чтобы обновить какую-то одну статистику, в зависимости от типа репликации придётся обновлять таблицу целиком, либо делать много UPSERT-операций, которые дороже, чем копия тех же строчек в новую таблицу
- Значения статистик в отдельной таблице можно типизировать, это даст больше гарантий, чем использование одного JSONB-поля.     


## Снапшот-репликация VS Репликация по дате
### Снапшот-репликация
таблица в PG обновляется целиком:
```
CREATE TABLE "stats_new" (...);

COPY stat_new FROM ...;
CREATE UNIQUE INDEX stats_new(yandex_uid);

BEGIN;

ALTER TABLE "stats" rename to "stats_old";
ALTER TABLE "stats_new" rename to "stats";
DROP TABLE "stats_old"

COMMIT;

```

### Репликация по дате
Реплицируем [только изменившиеся строчки](https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/replication-docs/replication-service/#yandextaxi-replication) по updated_at/версии

```
for new_row in yt_rows:
    execute('INSERT INTO stats VALUES (...) ON CONFLICT UPDATE', new_row)
```

#### Плюсы снапшот-репликации:
- Если аналитический объект обновляется целиком, и нет возможности понять дату последнего изменения строчки, то других вариантов нет
- Если за одну репликацию обновляется большая часть строчек (40+%), то COPY будет работать быстрее, чем много миллионов UPSERTов


#### Плюсы репликации по дате
- Можно достичь практически реалтаймового обновления (если аналитические процессы позволяют)
- Если обновляется малая часть строчек, то обновление быстрее, чем копия таблицы целиком 

Можно реализовать оба типа, но нужно выбрать приоритетный для реализации в первую очередь.


## Этапы реализации
### Этап 1. Репликация
1. Поддержать YT как источник репликации
2. Поддержать Postgres как приёмник репликации

### Этап 2. Сервис plus-stats
1. Ручка v1/stats — обёртка над Postgres

# Новые ручки

Предлагается добавить новый флоу - **инициализация PlusSDK**.

Содержание:

- [Определение сервиса от имени которого SDK сделало запрос](#определение-сервиса-от-имени-которого-sdk-сделало-запрос)
- [Информация о состоянии](#информация-о-состоянии)
  - [Баланс](#баланс)
  - [Информация о подписках](#информация-о-подписках)
  - [Подписочные настройки](#подписочные-настройки)
  - [Сервисные настройки](#сервисные-настройки)
  - [Нотификации](#нотификации)
  - [Частиная информация](#частиная-информация)
- [Структура меню](#структура-меню)
  - [Бэджик баланса](#бэджик-баланса)
  - [Сторизы](#сторизы)
  - [Меню](#меню)
  - [Действия над подпиской](#действия-над-подпиской)
- [Предлагаемый протокол](#предлагаемый-протокол)
- [Легковесный запрос](#легковесный-запрос)
- [Матчинг настроек](#матчинг-настроек)
  - [1. Получаем состояние пользователя и структуру меню](#1-получаем-состояние-пользователя-и-структуру-меню)
  - [2. Матчим настройки](#2-матчим-настройки)
  - [3. Отображаем те, что сматчились](#3-отображаем-те-что-сматчились)
  - [4. Изменяем настройку](#4-изменяем-настройку)
- [Самое главное](#самое-главное)


## Определение сервиса от имени которого SDK сделало запрос

Для новой ручки обязательным аргументом будет являться идентификатор клиента, так называемый `client_id`.
Передавать будем через хедер `X-SDK-Client-ID`.

По этому идентификатору мы будем определять доступные в сервисе настройки и структуру меню.
В отличие от User-Agent, этот идентификатор будет достаточно консистентным для всех приложений.


## Информация о состоянии

Это данные, которые должны быть всегда самыми актуальными.

Рассмотрим составные части.

### Баланс

Будем получать из `plus-wallet`.

Сейчас приходит в двух местах: в способах оплаты и в доме Плюса.
С учётом того, что `plus-wallet` сможет держать большую нагрузку, предлагаю так и оставить.
Дублирование информации необходимо, чтобы Плюсовое SDK не зависело от запроса к способам оплаты.

> В `plus-wallet` лежат закешированные балансы, а в `paymentmethods` получаются балансы из траста, которые будут более актуальными.
> Нам ок, потому что мы будем использовать быстрые балансы в основном для отображения.
> Актуальные балансы всегда будут приходить в способах оплаты у потребителя.
> Ожидаем, что в большинстве случаев эти балансы будут консистентны.

```json5
{
    "wallets": [
        {
            // идентификатор кошелька
            "id": "718ea809cbq34qaddsffs7abfdcc6dfe",

            // валюта кошелька, сейчас всегда будет RUB
            "currency": "RUB",

            // текущий баланс кошелька
            "balance": "120"
        }
    ]
}
```

Чтобы поддержать возможность работы с несколькими кошельками, данное поле предлагается сделать **списком**.
На первом месте будет находиться текущий **дефолтный кошелёк** пользователя.
На данный момент предполагается, что кошелёк всегда будет 1, а клиенты будут отображать информацию только о первом кошельке.

### Информация о подписках

Информацией о подписке является:

- текущие подписки пользователя
- возможность покупки подписки
- возможность апгрейда
- подписки доступные для покупки

Эту информацию мы будем получать из Медиабиллинга.
Есть вероятность, что отвечать они будут достаточно долго, поэтому нужно будет потестировать (под экспериментом) и, возможно, поставить перед ними кэш.

За основу используем данные из ответа ручки `/internal/v1/subscriptions/list`, но немного изменив общую схему.

> Сейчас там возвращаются `allowed` подписки (то, что в принципе можем продавать) - это напрямую из МБ данные, а также `promoted` (то, что будем продавать) - из конфига.

Есть вероятность, что в будущем у нас появится мультиподписочность.
В первой версии API мультиподписочность отбрасываем совсем. 
Только после формулирования продуктовых требований к мультиподписке выпускаем новую мажорную версию SDK и делаем новую версию АПИ.
Сейчас работаем только с одной подпиской.

Предлагается следующий протокол:

```json5
{
    "subscription": {
        // идентификатор подписки, который можно использовать 
        // в ручках (например, для покупки)
        "subscription_id": "ya_plus_rus",

        // состояние подписки (required)
        "status": "ACTIVE",  // AVAILABLE, PURCHASING, ACTIVE

        // может ли пользователь осуществить апгрейд текущей Плюсовой
        // подписки. влияет на показ кнопки апгрейда скидочной подписки.
        // поле, специфичное для Плюса
        "need_upgrade": false
    }
}
```

`subscription_id` может отсутствовать, если мы не смогли получить доступные для покупки подписки от МБ.

Состояния пописки:

- `AVAILABLE` - доступна для покупки
- `PURCHASING` - в процессе покупки
- `ACTIVE` - активная подписка

Состояние подписки будет приходить всегда, даже если МБ не ответил.
В таком случае мы будем маппить наличие подписки из хедеров `passenger-authorizer` (`Pass-Flags`).

Пример других состояний подписок:

1. Доступная для покупки подписка

    ```json5
    {
        "subscription": {
            // этот идентификатор нужно будет использовать для покупки
            "subscription_id": "ya_plus_rus_trial",
            "status": "AVAILABLE"
        }
    }
    ```

2. Подписка находится в состоянии покупки

    ```json5
    {
        "subscription": {
            "subscription_id": "ya_plus_rus",
            "status": "PURCHASING",

            // (опциональное) если подписка в состоянии PURCHASING,
            // то в этом поле вернётся ID покупки, по которому можно 
            // будет поллить успех покупки
            "pending_purchase_id": "88888817"
        }
    }
    ```

### Подписочные настройки

Подписочные настройки не зависят от сервиса. Для их изменения нужно будет использовать общую ручку `PUT /4.0/plus/v1/subscriptions/settings` (реализующую частичное обновление настроек).
К таким настройкам сейчас относится только **"Продление подписки за баллы"**.

```json5
{
    "subscription_settings": {
        "settings": [
            {
                // продлевается ли сейчас подписка за баллы
                "id": "renew_subscription_by_plus",

                // тип значения настройки
                "type": "boolean",

                // текущее значение настройки для пользователя. 
                // данное поле является Variant'ом, то есть будет 
                // иметь тот тип, который указан в поле type
                "value": false,

                // доступна ли настройка для изменения (если нет, 
                // то соответствующий пункт меню должен быть 
                // отображён задизейбленным)
                "enabled": true
            } 
        ],

        // Последняя версия настроек, для избежания гонок
        "version": "iamveryhappyversion"
    }
}
```

> С нашей стороны настройка `renew_subscription_by_plus` уже почти поддержана (тикет - [TAXIBACKEND-29615](https://st.yandex-team.ru/TAXIBACKEND-29615)), ожидаем поддержку со стороны Траста где-то в сентябре.

Структура в виде списка с ID'шниками предлагается для удобства последующей передачи настроек в ручку изменения. 
Матчинг значений настроек с пунктами меню будет [описан ниже](#матчинг-настроек).

### Сервисные настройки

Это настройки, которые уникальны для каждого сервиса (Такси, Афиша, Еда, etc).
К таким настройкам на данный момент относится **композитная оплата** ("Оплатить поездку баллами").

На этапе MVP значения сервисных настроек предлагается **хранить на клиентах**.
В будущем, это состояние может храниться на беке.
В таком случае, будет добавлена ручка обновления сервисных настроек (подобно подписочным).

На данный момент мы можем присылать с бека **дефолтные значения**:

```json5
{
    "service_settings": {
        "settings": [
            {
                // продлевается ли сейчас подписка за баллы
                "id": "composite_payment.enabled",

                // тип значения настройки
                "type": "boolean",

                // дефолтное значение настройки. если на клиенте 
                // уже сохранено какое-то состояние, это значение 
                // можно игнорировать
                "default_value": false,

                // доступна ли настройка для изменения (если нет, 
                // то соответствующий пункт меню должен быть 
                // отображён задизейбленным)
                "enabled": true
            } 
        ]

        // здесь может быть версия настроек
    }
}
```

### Нотификации

Будут прорабатываться отдельно, сейчас просто оставим для них место в общем протоколе.

На данный момент поддерживаем псевдонотификацию: если с бека пришло значение `unread_count` с некоторым числом, клиенты должны отобразить красный кружок "нотификации" на виджете Плюса (правый верхний угол на главном экране в Такси).

```json5
{
    "notifications": {
        "unread_count": 1
    }
}
```

В первой версии АПИ поддерживаем старый протокол псевдонотификаций: клиенты кэшируют факт показа нотификации, поле `unread_count` носит **опциональный** характер и в будущих версиях протокола может быть убрано. 
Сейчас мы присылаем его **всегда**.

### Частиная информация

В случае недоступности некоторых источников данных, можно не фейлить весь запрос, а возвращать только доступную информацию.
Подробнее см. [потоки данных](./data-flows.md).

В первой версии АПИ мы это поддерживаем сразу.
При этом клиенты, если они не могут это поддержать в первой итерации, должны не ломаться, если пришла неполная информация - отсутствуют кошельки или нет информации о подписке.
Если бекенд не смог получить какую-то часть информации, то мы присылаем что есть, а также добавляем хедер `Retry-After` - через какое время клиенты должны будут сделать перезапрос.

На текущий момент это относится только к **кошелькам** и **подпискам**.

Если мы не смогли получить балансы от `plus-wallet`, то мы пришлём пустой список `wallets`, а также хедер `Retry-After`.

Если мы не смогли получить доступные для покупки подписки, то мы не вернём `subscription_id` в секции `subscription`, а также добавим хедер `Retry-After`.


## Структура меню

Общая структура домика Плюса будет меняться в зависимости от сервиса.
Частота изменения этих данных намного ниже, чем у состояние (предыдущий раздел).

Предполагается, что структура меню будет обновляться при смене состояния подписки (покупка, апгрейд - по нажатию на кнопку).

| <img src="https://jing.yandex-team.ru/files/erakli00/sdk-design.png" width="700"> |
| :---------------------------------------------: |
|     Дизайн SDK при разных состояниях подписки   |

### Бэджик баланса

Предлагается задавать тексты для бэджика отдельно от кошельков.
Секция будет выглядеть следующим образом:

```json5
{
    "balance_badge": {
        // формируем в зависимости от каких-то правил.
        // при отсутствии не показываем
        // subtitle, потому что так дизайнеры разговаривают
        "subtitle": "ваши баллы на Плюсе",

        // замещающий текст, который будет показан вместо 
        // баланса в зависимости от разных условий: нулевой 
        // баланс, отсутствие информации о балансе
        "placeholder": "плюс",

        // показывать ли глиф (изображение плюса) на беджике
        "show_glyph": true
    },
}
```

Замещающий текст предполагается показывать, например, для новичков, либо когда не пришли кошельки.

### Сторизы

Старые сторизы сейчас deprecated, к тому же они не имеют необходимой нам гибкости. 
Помимо этого они написаны на питоне (`taxi-stories`), а значит они не приспособлены к многократному росту нагрузки в отличие от `inapp-communications`.

По этой причине в `inapp-communications` ручка коммуникаций [будет адаптирована](https://github.yandex-team.ru/taxi/rfc/pull/490) для потребителей в сервисах, отличных от Такси.

SDK должно будет получать сторизы отдельным запросом, мы здесь никак влиять не будем.

> Если клиентам будет удобно, мы можем присылать сторизы как секцию, благодаря чему мы сможем их отключать.

### Меню

Исходя из нового дизайна, у нас должны быть секции меню подобно меню iOS.

<img src="https://jing.yandex-team.ru/files/erakli00/menu-items.png" width="600">

Каждую строчку меню хотелось бы настраивать с бека.
Поэтому мы договорились сделать общий объект "пункта меню" (`MenuItem`) со следующей структурой (описание для строчки **"Потратить на поездку"** - тип `setting`, стиль `switch`):

```json5
{
    // описание левой части (занимает большую площадь элемента).
    // может быть функциональным элементом
    "lead": {
        // стиль элемента (обязательный)
        "type": "default",    // switch, disclosure, default

        // (опциональный) наполнение элемента
        "content": {
            // иконка, которая должна быть отображена в элементе
            "icon_url": "<image url>",

            // основной текст элемента
            "title": "Потратить на поездку",

            // подпись под основным текстом
            "subtitle": "Баланс: 1200 баллов"
        }
    },

    // описание правой части (как правило, функциональный элемент)
    "trail": {
        "type": "switch"
    },

    // действие, которое должно быть выполнено по нажатию на 
    // функциональный элемент
    "action": {
        // тип совершаемого действия
        "type": "setting",  // deeplink, url, setting, plus_sdk_hook
        "content": {
            // настройки будут описаны позднее
            "setting": {
                "id": "renew_subscription_by_plus",
                "type": "SUBSCRIPTION"  // SUBSCRIPTION, SERVICE
            }
        }
    }
}   
```

> Данная структура обусловлена желанием мобильных клиентов настраивать компоненты в терминах дизайнеров.
> Если нам потребуется формировать меню для веб виджета, то для этого будет сделана **отдельная ручка**.

Каждая строка меню определяется тем действием, которое оно выполняет.
Для простоты отображения, стиль компонентов будет задаваться по отдельности.
Консистентность вида функционального элемента и выполняемого действия гарантируется на беке (чтобы по переключению тоггла не открывался deeplink).

#### Элементы строки меню (`lead`, `trail`)

`lead` и `trail` являются левым и правым элементами строки соответственно и имеют одинаковую структуру.
`trail` может отсутствовать, тогда всю строку будет занимать `lead`, являясь при этом **функциональным элементом** (который визуализирует выполняемое действие).

> Судя по дизайну, функциональные элементы могут быть как в `trail`, так и в `lead`.
> Мы будем гарантировать, что функциональный элемент в строке меню будет **всегда один**.

Возможные **стили** (`type`, потому что клиенты хотят делать на языке дизайнеров) для элементов:

- `switch` - переключатель с двумя состояниями
- `disclosure` - элемент со стрелкой (по сути ссылка)
- `default` - простой элемент с текстом

В любом элементе (как в `lead`, так и в `trail`) может быть задано наполнение (`content`):

- `title` - основной текст
- `subtitle` - дополнительный текст, снизу от основного (обычно серый)
- `icon_url` - URL, по которому располагается иконка, подробнее про картинке см. [ниже](#картинки)

Возможные типы действий (`action.type`):

- `deeplink` - открытие диплинка
- `url` - открытие ссылки
- `setting` - установка настройки, подробнее ниже
- `plus_sdk_hook` - кастомное действие, подробнее ниже

Рассмотрим, как должны задаваться строки меню с разными действиями на основе картинки из [начала раздела](#меню).

#### Открытие ссылок (`url`)

Строчка **"Вы в Плюсе"** (тип `url`, стиль `disclosure`):

```json5
{
    "lead": {
        "type": "default",
        "content": {
            "title": "Вы в Плюсе"
        }
    },
    "trail": {
        "type": "disclosure",
        "content": {
            "title": "детали"
        }
    },
    "action": {
        "type": "url",
        "content": {
            "url": "https://plus.yandex.ru"
        }
    }
}   
```

Строчка **"Список кафе"** (тип `url`, стиль `default`):

```json5
{
    "lead": {
        "type": "default",
        "content": {
            "title": "Список кафе"
        }
    },
    "trail": {
        "type": "default",
        "content": {
            "icon_url": "<some url>"
        }
    },
    "action": {
        "type": "url",
        "content": {
            "url": "<some url>"
        }
    }
}   
```

#### Открытие диплинков (`deeplink`)

Строчка **"Отсканировать счёт"** (тип `deeplink`, стиль `default`):

```json5
{
    "lead": {
        "type": "default",
        "content": {
            "title": "Отсканировать счёт"
        }
    },
    "trail": {
        "type": "default",
        "content": {
            "icon_url": "<some url>"
        }
    },
    "action": {
        "type": "deeplink",
        "content": {
            "deeplink": "yandextaxi://<scan QR code>"
        }
    }
}   
```

#### Настройки (`setting`)

Для задания настроек используется отдельный тип.
Пример описания настройки **"Потратить на поездку"** приведён в [начале раздела](#меню).

Рассмотрим подробнее содержимое `action`'а:

```json5
{
    "action": {
        "type": "setting",
        "content": {
            "setting": {
                "id": "renew_subscription_by_plus",  // composite_payment.enabled
                "type": "SUBSCRIPTION"  // SUBSCRIPTION, SERVICE
            }

            // здесь могут быть дополнительные описания
        }
    }
}
```

Как было описано ранее, у нас могут быть разные типы настроек - подписочные и сервисные.
Для того, чтобы SDK понимало, что нужно сделать, при изменении конкретной настройки, предлагается задавать тип данной настройки:

- `SUBSCRIPTION` - подписочная настройка
- `SERVICE` - сервисная настройка

Для каждого типа будет задана отдельная ручка для изменения настроек и сохранения состояния на беке.
На этапе MVP такая ручка будет присутствовать только для `SUBSCRIPTION`; для настроек типа `SERVICE` клиенты должны будут сохранять значение локально.

Подробнее про матчинг настроек будет описано [далее](#матчинг-настроек).

#### Кастомные действия (`plus_sdk_hook`)

Для тех случаев, когда действие явно не может быть задано через SDK, необходимо использовать тип действия `plus_sdk_hook`.
В таком случае, вместо собственной реализации внутри SDK, хостовое приложение должно предоставить хук, который будет вызван при совершении данного действия.

Хуки будут регистрироваться под некоторыми ID'шниками (`hook_id`).
Когда с бека приходит ID'шник, то для выполнения действия ищется соответствующий хук, зарегистрированным хостовым приложением в SDK.
Если хук не удалось найти, то просто ничего не делаем.

Кастомные действия могут пригодится, например, если какое-то приложение не поддерживает диплинки. 
В таком случае пункт меню **"Отсканировать счёт"** может быть задан следующим образом:

```json5
{
    "lead": {
        "type": "default",
        "content": {
            "title": "Отсканировать счёт"
        }
    },
    "trail": {
        "type": "default",
        "content": {
            "icon_url": "<some url>"
        }
    },
    "action": {
        "type": "plus_sdk_hook",
        "content": {
            "hook_id": "custom_action.scan_qr"
        }
    }
}   
```

#### Картинки

Картинки в SDK будут передаваться как URL'ы.
После скачивания картинки кэшируются на клиенте.

#### Секции

Рассмотрим секции на примере уже известной картинки:

<img src="https://jing.yandex-team.ru/files/erakli00/menu-items.png" width="600">

Все элементы меню объединяются в секции (`Section`) в виде упорядоченных списков (отображаются в том порядке, в котором пришли):

```json5
{
    // название секции
    "title": "Кэшбэк в кафе",

    // стиль секции
    "style": "bordered", // none, bordered

    // содержимое секции
    "items": [
        // здесь идёт список MenuItem
    ]
}
```

> На клиентах должен быть реализован фоллбек в случае, если пришёл неизвестный стиль.

Для удобства предлагается задавать **все элементы меню** через секции для единообразия.

### Действия над подпиской

Внизу домика есть кнопка смены состояния подписки.
На текущий момент можно выделить следующие состояния:

- нет подписки
- скидочная подписка
- кэшбечная подписка

Исходя из дизайна, а также судя по текущей реализации клиентов, у самих кнопок может быть несколько состояний, пример:

<img src="https://jing.yandex-team.ru/files/erakli00/action-button-states-example.png" width="700">

Клиентам очень хочется тексты для всех состояний кнопки задавать с бекенда, чтобы иметь консистентность в разных локалях.

Также на новом дизайне также есть вторая строчка текста на кнопке:

<img src="https://jing.yandex-team.ru/files/erakli00/sdk-design.png" width="700">

С учётом данного дизайна, предлагается следующая структура:

```json5
{
    // какой-нибудь сопроводительный текст над кнопкой
    // title, потому что так дизайнеры разговаривают
    "title": "Кэшбек вместо скидки",

    // дополнительное описание, серого цвета
    "subtitle": "10% остаются с вами",

    // какое действие должно быть совершено при нажатии на кнопку
    "action": "PLUS.BUY",  // PLUS.BUY, PLUS.UPGRADE

    // возможные надписи на самой кнопке, как список или объект
    "states": [
        {
            "state": "PENDING",

            // основной текст кнопки, но мне больше нравится название text
            "title": "Активировать баллы",

            // подпись на самой кнопке
            "subtitle": "Попробуй ещё этих вкусных булочек"
        },
        {
            "state": "PROCESSING",
            "title": "Баллы активируются..."
        },
        {
            "state": "SUCCESS",
            "title": "Баллы активированы"
        },
        {
            "state": "ERROR",
            "title": "Произошла ошибка"
        }
    ]
}
```

Действие, которое должно быть совершено при нажатии на кнопку определяется полем `action`, возможные значения:

- `PLUS.BUY` - совершить запрос в ручку покупки подписки (`/plus/v1/subscriptions/purchase`)
- `PLUS.UPGRADE` - совершить запрос в ручку апгрейда скидочной подписки (`/plus/v1/subscriptions/upgrade`)

> Для унификации, поле `action` можно задавать также, как для остального меню.
> Добавляем новый тип `type: subscription_action`, в теле передаём ID действия.

В структуре меню предлагается передавать только основную кнопку для текущего состояния подписки (так называемый footer).

> Когда будет финализирован дизайн мультиподписочности, предлагается дополнить АПИ с дополнительными кнопками и их выбором.

Для кнопок, где нужно будет отображать цену, нужно также будет передать `currency_rules` (см. [финальный протокол](#предлагаемый-протокол)).

Юридическую информацию будем зашивать в текст кнопок через переводы.

## Предлагаемый протокол

Всю описанную информацию предлагается получать из новой ручки.
Для удобства инициализации, предлагается присылать состояние и структуру меню в объединённом ответе (так как клиентам труднее иметь 2 ручки, а затем их мержить).

```
POST /sdk-state
```

Headers:

- X-Yandex-UID
- X-Remote-IP
- X-SDK-Client-ID
- X-YaTaxi-Pass-Flags
- X-Request-Application
- X-Request-Language


Request body:

- `include` - (array) Определяет, список полей, который будет возвращён в ответе ручки. При пустом массиве или отсутствии аргумента будут возвращены все поля. (подробнее [ниже](#легковесный-запрос))

Response (неподписчик):

```json5
{
    // описание структуры меню (компиляция из секций раздела "Структура меню")
    "menu": {
        "balance_badge": {
            // формируем в зависимости от каких-то правил.
            // при отсутствии не показываем
            "subtitle": "ваши баллы на Плюсе",

            // замещающий текст, который будет показан вместо 
            // баланса в зависимости от разных условий, например: нулевой 
            // баланс, отсутствие информации о балансе
            "placeholder": "плюс",

            // показывать ли глиф (изображение плюса) на беджике
            "show_glyph": true
        },

        // не придёт, если действие не требуется
        "button": {
            "title": "90 дней в подарок",
            "subtitle": "потом за 199 $SIGN$$CURRENCY$/мес",
            "action": "PLUS.BUY",  // PLUS.BUY, PLUS.UPGRADE
            "states": [
                {
                    "state": "PENDING",
                    "title": "Попробовать бесплатно"
                },
                {
                    "state": "PROCESSING",
                    "title": "Покупаем..."
                },
                {
                    "state": "SUCCESS",
                    "title": "Всё хорошо"
                },
                {
                    "state": "ERROR",
                    "title": "Произошла ошибка"
                }
            ]
        },

        // для отображения цен, например в button
        "currency_rules": {
            "code": "RUB",
            "sign": "₽",
            "template": "$VALUE$ $SIGN$$CURRENCY$",
            "text": "руб."
        },
        "sections": [
            {
                "style": "none", // none, bordered
                "items": [
                    {
                        "lead": {
                            "type": "default",
                            "content": {
                                "title": "Вы в Плюсе"
                            }
                        },
                        "trail": {
                            "type": "disclosure",
                            "content": {
                                "title": "детали"
                            }
                        },
                        "action": {
                            "type": "url",
                            "content": {
                                "url": "https://plus.yandex.ru"
                            }
                        }
                    },

                    // other menu items go here 
                ]
            }
        ]
    },

    // информация о состоянии (см. раздел "Информация о состоянии")
    "state": {
        "wallets": [
            {
                // идентификатор кошелька
                "id": "718ea809cbq34qaddsffs7abfdcc6dfe",

                // валюта кошелька, сейчас всегда будет RUB
                "currency": "RUB",

                // текущий баланс кошелька
                "balance": "120"
            }
        ],
        "subscription": {
            // идентификатор подписки, который можно использовать 
            // в ручках (например, для покупки)
            "subscription_id": "ya_plus_rus_trial",

            // состояние подписки
            "status": "AVAILABLE"  // AVAILABLE, PURCHASING, ACTIVE
        },
        "subscription_settings": {
            "settings": [
                {
                    // продлевается ли сейчас подписка за баллы
                    "id": "renew_subscription_by_plus",

                    // тип значения настройки
                    "type": "boolean",

                    // текущее значение настройки для пользователя.
                    // данное поле является Variant'ом, то есть будет 
                    // иметь то значение, которое указано в поле type
                    "value": false,

                    // доступна ли настройка для изменения (если нет, 
                    // то соответствующий пункт меню должен быть 
                    // отображён задизейбленным)
                    "enabled": false
                } 
            ],

            // Последняя версия настроек, для избежания гонок
            "version": "iamveryhappyversion"
        },
        "service_settings": {
            "settings": [
                {
                    // продлевается ли сейчас подписка за баллы
                    "id": "composite_payment.enabled",

                    // тип значения настройки
                    "type": "boolean",

                    // дефолтное значение настройки. если на клиенте 
                    // уже сохранено какое-то состояние, это значение 
                    // можно игнорировать
                    "default_value": false,

                    // доступна ли настройка для изменения (если нет, 
                    // то соответствующий пункт меню должен быть 
                    // отображён задизейбленным)
                    "enabled": false
                } 
            ]
        },
        "notifications": {
            "unread_count": 1
        }
    }
}
```

> Если потребуется, можно будет потом добавить фильтрацию возвращаемых возможностей клиентов в целям оптимизации.


## Легковесный запрос

Чтобы не запрашивать всю информацию сразу, когда нет необходимости отрисовывать UI домика Плюса, можно запросить только самое необходимое - баланс, факт наличия подписки, настройки, нотификации - всё то, что нужно для инициализации точек входа (виджет на главном) и можно получить быстро.

Для этого клиенты могут делать запрос только состояния, указав `include: [state]`.

По договорённости с клиентами, в первой итерации будет следующий флоу:

- **на старте** приложения делаем **легковесный запрос** для инициализации точек входа
- **при открытии** домика Плюса, делаем полный запрос (редкий кейс)

Таким образом, чтобы **сильно** не замедлять основной флоу приложения (то есть для всех пользователей), мы добавляем легковесный запрос.
Также это нужно, чтобы без нужды не загружать данные для UI домика Плюса, который открывается достаточно редко (редкий кейс).

Почему на первой итерации мы не делаем *внешнюю инициализацию*, а делаем компромисс с запросом на старте:

1. SDK делается не только под Такси, у других потребителей будут другие флоу для внешней инициализации.
   Придётся поддерживать два варианта инициализации - внутренний и внешний.
2. Для клиентов реализация двух флоу на первой итерации - дорогое занятие. 
   У них сейчас скоуп сильно больше бекендного.

Какие улучшения взамен на **запрос на старте** будут со стороны клиентов:

- на iOS планируется технозадача на вывод второстепенных запросов (в том числе и этого легковесного) на момент после всех блокирующих (ETA - ближайшие полгода)
- на Android это будет сделано сразу
- на iOS закрыли экспериментом запрос в ручку перс целей - теперь он будет осуществляться только для тех пользователей, для которых сматчился эксп (это где-то 100к пользователей в квартал)
- на Android этот запрос будет закрыт экспериментом - https://st.yandex-team.ru/TAXIA-12029 


## Матчинг настроек

Предлагается разделять UI и состояние в целях удобства управления данными и логического разделения.
Это будет удобно как с точки зрения кода, так и с точки зрения потоков данных.

Для того, чтобы это сделать, клиентам необходимо реализовать матчинг настроек в структуре меню (секция `menu`) с состоянием настроек (секция `state`).

Чтобы понять, как это должно произойти, рассмотрим пример.
Опишем алгоритм изменения настройки **"Продлевать подписку за баллы"**:

1. Получаем состояние пользователя и структуру меню
2. Матчим настройки
3. Отображаем те, что сматчились
4. Изменяем настройку

### 1. Получаем состояние пользователя и структуру меню

Делаем запрос к ручке, в ответе которой имеем описание настройки:

```json5
{
    "menu": {
        ...
        "sections": [
            ...
            {  // её отображение
                "lead": {
                    "type": "default",
                    "content": {
                        "title": "Потратить на поездку",
                    }
                },
                "trail": {
                    "type": "switch"
                },
                "action": {
                    "type": "setting",
                    "content": {
                        "setting": {
                            "id": "renew_subscription_by_plus",
                            "type": "SUBSCRIPTION"
                        }
                    }
                }
            },
            ...
        ]
        ...
    },

    "state": {
        ...
        "subscription_settings": {
            "settings": [
                {  // сама настройка
                    "id": "renew_subscription_by_plus",
                    "type": "boolean",
                    "value": false,
                    "enabled": true
                } 
            ],
            "version": "iamveryhappyversion"
        }
        ...
    }
}
```

### 2. Матчим настройки

Теперь, нам необходимо объединить настройку и её отображение.
Для этого:

1. определяем тип действия как `setting` (по пути `menu.sections.[0].action.type`)
2. смотрим на тип настройки (`action.content.setting.type`) - `SUBSCRIPTION`
3. ищем настройку среди подписочных настроек - `state.subscription_settings.settings` (для сервисных будет `state.service_settings`)
4. находим настройку с таким же ID, как в действии (`action.content.setting.id`) - `renew_subscription_by_plus`

Матчинг происходит по соответствию ID'шников:

```
value_of(action.content.setting.id) == value_of(subscription_settings.settings.[].id)
```

### 3. Отображаем те, что сматчились

- если матичнг не удался, то настройка скрывается
- если элемент нашёлся, но у него `enabled: false`, то он отображается задизейбленным

### 4. Изменяем настройку

При нажатии на не-disabled тогл мы должны определить, что необходимо сделать:

1. определяем тип настройки (`action.content.setting.type`)
2. если это `SERVICE` (сервисная настройка), то сохраняем значение на клиенте
3. если это `SUBSCRIPTION` (подписочная настройка), то делаем запрос с новым значением в ручку изменения подписочных настроек c версией из состояния

В последнем случае произойдёт запрос к ручке `PUT /4.0/plus/v1/subscriptions/settings`. 

Request body:
```json5
{
    "settings": {
        "renew_subscription_by_plus": true
    },
    "version": "iamveryhappyversion"  // эту версию берем из state
}
```

В случае успеха, обновляем состояние на клиенте.
При провале, состояние не меняется.

> В случае, если мы будем переносить состояние для сервисных настроек на бек, то протоколы нужно будет согласовывать отдельно.
> Для них также будет производиться запрос в преднастроенную ручку (другую), но с другой логикой провала.


## Самое главное

Спасибо, что дочитали до конца.

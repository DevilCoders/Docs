## Описание переноса эскперимента

Основано на https://github.yandex-team.ru/taxi/rfc/pull/344 и проблеме распухшего https://jing.yandex-team.ru/files/rgnlax/launch%20проблема.pdf

### Частные проблемы в рамках задачи
* Отказываемся от легаси протокола (см. предыдущую версию проработки https://github.yandex-team.ru/taxi/rfc/pull/344);
* Переносим параметры в ручку v1/products, которая дергается на каждый сдвиг пина, как следствие - не хотим отдавать параметры супераппа всегда, хотим описать механизм кеширования.

### Глобальные проблемы
* Эксперименты 3.0 (и конфиги 3.0) предоставляют инструмент удобной и быстрой доработки ответа ручки бэкенда без написания кода со стороны бэкенда, но это приводит к распуханию ответов существующих ручек https://jing.yandex-team.ru/files/rgnlax/launch%20проблема.pdf
У данной проблемы следующие корни:
* * Неправильное использование концепции экспериментов - эксперимент рано или поздно должен заканчиваться, клиентская логика поддерживающая несколько вариантов должна удаляться -> данный вопрос в рамках этой RFC не решается, так как требует изменения процессов связанных с заведением и завершением конфигов (у @ilyasov есть планы на это)
* * Использование экспериментов как 'конфигов' (см launch, например **superapp_parameters**, **safety_center** и другие) - в данном случае иметь возможность менять параметры мы хотим, соответственно отдача данных необходима, но изменения настолько редки, что нет смысла делать это на каждый запрос
* * * пример изменения эксперимента (конфига) **safety_center**: https://tariff-editor.taxi.yandex-team.ru/audit?date_from=2019-07-29&date_from_time=18%3A50%3A00&date_till_time=23%3A33%3A33&date_till=2020-04-13&actions=change_experiment&object_id=safety_center
* * * пример изменения эксперимента (конфига) **superapp_parameters**: https://tariff-editor.taxi.yandex-team.ru/audit?date_from=2019-07-29&date_from_time=18%3A50%3A00&date_till_time=23%3A33%3A33&date_till=2020-04-13&actions=change_experiment&object_id=superapp_parameters
изменения 2-3 раза в месяц, не чаще
* Желание, которое узнал в ходе очной встречи с @ilyasov по постепенной выкатке экспериментов (считай на престейбл) 

### Предлагаемое решение (с решением как частных проблем, так и глобальных)

Параметры эксперимента переносятся в ручку v1/products в стандартном виде клиентских экспериментов:
```json
{
  "typed_experiments": {
    "items": [
      {
        "name": "exp_1",
        "value": {
          ...
        },
        "version": "<revision>:<position>:<locale>",
        "cache_status": "updated"
      },
      {
        "name": "exp_2",
        "value": {
          ...
        },
        "version": "<revision>:<position>:<locale>",
        "cache_status": "updated"
      },
      {
        "name": "exp_3",
        "value": {
          "enabled": false
        },
        "cache_status": "no_cache"
      }
    ],
    "version": 232437 // уже существующее поле, которое не используется клиентами
  }
}
```

В ответ typed_experiments добавляется помимо старых полей два новых поля:
* cache_status (своего рода cache-control), который может принимать три варианта значений:
* * updated - требуется обновить значение эксперимента в ручке
* * not_modified - на основе клиентского запроса мы делаем вывод, что обновление эксперимента не требуется
* * no_cache - хранение эксперимента не требуется (_default для клиентов, если cache_status не вернулся_)
* version - текстовое значение, определяющее 'ревизию' ответа эксперимента - данное поле нужно обновить только в случае cache_status == updated 

В случае, если пришел ответ "updated" - клиенты кэшируют следующую связку со стороны бэкенда:
name, version, value

И при следующем запросе в ручку, отправляют блок известных экспериментов в запросе:
```json
{
"typed_experiments": {
    "items": [
        {
            "name": "exp_1",
            "version": "<version of exp_1 from last response>"
        },
        {
            "name": "exp_2",
            "version": "<version of exp_2 from last response>"
        }
    ],
    "version": 232437 // уже существующее поле, которое не используется клиентами
}
}
```
 
Следующий ответ ручки v1/products содержит:
```json
{
	"typed_experiments": {
		"items": [
			{
				"name": "exp_1",
                "cache_status": "not_modified" // стоит заметить, что отсутствие эксперимента в ответе != not_modified
			},
			{
				"name": "exp_2",
				"version": "<revision>:<position>:<locale>",
                "value": {...},
                "cache_status": "updated"
			},
            {
                "name": "exp_3",
                "value": {
                    "enabled": false
                },
                "cache_status": "no_cache"
            }
		],
		"version": 232437
	}
}
```

### План по переходу
### Этап 0: формирование кеширующей логики для v1/products
* Задача на бэкенд по отдаче typed_experiments в ручке v1/products, где по умолчанию все эксперименты кешируются (бэкенд не будет уметь в no_cache)
* * Используя стандартную функцию получения экспериментов получаем все по консьюмеру
* * Формируем для них version по логике выше
* * Проверяем request и на основе него решаем о статусе (updated / not_modified) и наличии value 

в такой формулировке ^ ~2d

* Задача на клиентов по поддержке superapp_parameters из v1/products и кеширования (? - вопрос связан с оценкой реализации компоненты кеширующей эксперименты в общем виде)

Итог этапа: клиенты смотрят superapp_parameters в v1/products

### Этап 1:
* Задача на бэкенд по формированию typed_experiment в виде библиотеки uservices (~4d)
* Использование библиотеки в сервисе exp3_matcher (https://st.yandex-team.ru/TAXIEXP-345) (~2d)
* Перевод launch (api-proxy) на сервис экспериментов (https://st.yandex-team.ru/TAXIBACKEND-28301) (~2d)

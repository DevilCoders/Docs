## Что такое платная подача

Это заказ такси издалека за доп. плату. Эта плата компенсирует водителю длинную подачу.
Детали [тут](https://wiki.yandex-team.ru/support/taxi/partners/finance/nopay/card/platnaja-podacha/).

## Проблема

![Скрин](https://jing.yandex-team.ru/files/olyagnilova/Снимок%20экрана%202020-12-01%20в%2013.51.06.png)

На картинке — визуализация розыгрыша буферного диспатча. Зеленые точки — это заказы, синие — машины. Видно, что для многих заказов, можно было бы разрешить платную подачу и пригнать машины из области, где плотность заказов ниже. Сейчас мы такие заказы просто теряем.

[Эпик](https://st.yandex-team.ru/TAXIINFRA-2478) и связанные тикеты содержат больше деталей.

## Как вычисляется ETA в routestats

Упрощенно:
1. Идем из `protocol` в `driver-eta` первый раз. Сервис `driver-eta` отдает список кандидатов (водителей), как при поиске исполнителя на созданный заказ.
2. Если в части тарифов не нашли ни одного исполнителя, то идем в ML. Шлем туда зону, тариф и спрашиваем: можно ли включить платну подачу.
3. Если можно включить, то идем еще раз в `driver-eta` с расширенным радиусом поиска водителей.
4. В кач-ве ETA используем время до первого кандидата. Кандидаты отсортированы по возрастанию времени до них.

Рассмотрим детали.

### Как `candidates` ищет исполнителей

Он или набирает n (~10) исполнителей, или останавливается раньше пройдя максимальный радиус поиска.

### Распараллеливание запросов по классам

Раньше мы слали в одном запросе к `driver-eta` список всех включенных тарифов. Но с середины 2020 для ускорения мы ходим параллельно (`GetSplitByClasses`) с разными списками тарифов. Например, параллельно за [эконом, комфорт, комфорт+] и [бизнес, ультима, грузовой].

### Распараллеливание по требованиям

Если в запросе у некоторых классов есть требования (например, перевозка животных), то для таких классов мы шлем отдельные запросы параллельно. Это вызвано тем, что `candidates` не умеет применять требования по классам. В дальнейшем этот код надо унести в `driver-eta` или `candidates`.

### Как включается платная подача

Если зона, способы оплаты и тариф прошли проверку (`FilterPaidSupplyCategories`), и ML сказал (`GetNoCarsOrderCategories`), что можно - тогда включаем платную подачу.

### Второй запрос за ETA для платной подачи

Внутри `protocol/routestats` он делается из `UpdateResponseForPaidSupply`. Отличия от первого запроса:
  * параметр `extended_radius` равен `true`. Он увеличивает радиус поиска в `candidates`.
  * список тарифов в запросе включает только те тарифы, где не нашли машин в первом запросе. В городах обычно это бизнес, ультима и прочие классы с малой плотностью. За городом это может быть и эконом.

### Как корректируется ETA

После ответа `driver-eta` мы идем в ML с ETA и корректируем его (`CorrectEta`). Эта логика нужна и другим клиентам `driver-eta`, поэтому оно должно жить там. После изменений, возможно, новый ML будет сразу и успешно корректировать ETA, проверим в эксперименте.

## Что предлагается

1. Идем в `driver-eta` -> `candidates` только 1 раз и сразу с расширенным радиусом поиска. В эти сервисы для каждого тарифа шлем флаг нового расширенного поиска в зависимости от включенности платной подачи для данного тарифа. Она зависит от зоны, способа оплаты и тп.
2. Скармливаем кандидатов в ML. В ответ получаем ETA и время до целевого кандидата. Если раньше мы брали ETA первого кандидата при платной подаче, то теперь это может быть любое ETA, даже то, которое не встречается среди кандидатов. ML опирается на данные: сурж, found share, список кандидатов от `candidates` и др.
3. Если в нужном радиусе поиска нет кандидатов - отдаем пустой ETA, как и раньше. Но при этом ML может сказать, что заказ все равно надо разрешать (`UpdateResponseForNoCarsOrder`).
4. Как и раньше, если целевой кандидат находится за пределами бесплатного (узкого) радиуса, то к заказу добавляется стоимость платной подачи. Она зависит от расстояния до кандидата минус значение из конфига PAID_SUPPLY_FREE_DISTANCE_TIME.
5. Расстояние/время до кандидата от ML сохраняем в оффер, как и раньше. Возможно, нужно только подменить тут расстояние/время, чтобы брать расстояние не до первого кандидата.
6. В кач-ве эксперимента отключаем корректировку ML-ем ETA в `routestats`: возможно, новый ML сразу будет возвращать более точный ETA, так как у него будет больше входных данных.

### Альтернативные решения

```
Денис Исаев, [27.01.21 18:19]
есть вопросы:
  - рассматривали ли вариант увеличивать радиус при большом сурже? не решает ли это ту же задачу на 80%, но в разы дешевле?
  - почему добавление кандидатов за пределами дефолтного лимита/радиуса так принципиально повлияет на качество ML? то есть почему нельзя на текущих данных это сделать?

Olya Gnilova, [27.01.21 19:45]
Привет! Можем завтра утром? Тебе со скольки удобно? Артем @bndrnk тоже хотел бы поучаствовать

Вкратце ответы такие:

- такое буквально даже когда-то в сервисе было — радиус делился на сурж в какой-то степени, и в каких-то ситуациях это действительно помогало, но часто и вредило. Глобально задача стоит не только в том, чтобы радиус угадывать, чтобы хоть кто-то нашелся, но и в том, чтобы поездки справедливо прайсить: не завышать и не занижать, когда не надо

- прямо сейчас этого нельзя сделать, потому что в случае, когда в первом запросе не нашлось ни одной машины, непонятно совсем что может ответить ML + целевое состояние — это когда радиусы бесплатного поиска очень маленькие, порядка 2-3 км, и сейчас во многих городах уже так. В таких маленьких радиусах часто случаются ситуации, когда машин внутри очень мало. И представь, что есть 10 пинов в близкой окрестности, которые в этом маленьком радиусе видят один и тот же набор из 3 машин — в такой постановке ML всем разрешит бесплатную подачу, либо поймет, что надо разрешить только трем, а остальным запретить, и в любом из вариантов машина найдется только на 3 заказа. Чтобы ML могла отдавать вердикты с бОльшими радиусами, модели нужно видеть такие данные и такие примеры
```

## Гипотеза

```
@olyagnilova:
Есть две части, которые лечим.

1. История про справедливый прайсинг.
Здесь два разнонаправленных эффекта. С одной стороны, какие-то поездки станут дешевле, за счет того что платных подач не будет там, где наверняка найдется кандидат в бесплатном радиусе. Это должно увеличить конверсию и поездки. С другой стороны, какие-то поездки станут дороже, потому что на них правильно предсказывать больший радиус. И если пользователи готовы за нее заплатить, то эти поездки состоятся (а при текущей эвристике не состоялись бы, потому что радиус был бы недостаточно большим). Но в то же время не все пользователи будут готовы заплатить, и это должно ухудшить конверсию.

По нашим расчетам первый эффект должен перевесить второй. Сейчас среди ситуаций, когда мы на пине посчитали, что должна случиться платная подача в 75% случаев кандидат находится ближе, и только в 25% дальше. Детали есть тут: https://st.yandex-team.ru/TAXIML-3223#5fc76600ff658a6bc1570644

Эффекты на конверсию и поездки очень сложно оценить заранее, на них влияет слишком много факторов и любой расчет очень примерный. Вместо этого у нас есть более понятные метрики — доля сброшенных платных подач и found share на платных подачах. Первая метрика для городов, где платной подачи много, держится около 50%, ее хотим опустить до 10-20% как минимум; и еще мы рассчитваем сократить разрыв в found share на платных подачах и на обычных поездках с 10-15пп, хотя бы до 5пп (метрики в атласе: https://atlas.taxi.yandex-team.ru/leaderboard/s/dhubuq). Но в поездки это перевести сложно из-за разнонаправленного эффекта на конверсии.

Итого, есть гипотеза, что конверсии и поездки вырастут, но до эксперимента оценить эффект не можем.

2. История про запрет поездок, когда они невозможны.
Здесь просто есть цель — не допускать провалов CR в сервисе ниже X% (например, 60%, цифра может меняться). Это не даст нам заметного прироста в поездках, но позволит в аномальных ситуациях разрешать только заказы, которые станут поездками с хорошим качеством, то есть с близкой подачей и, возможно, в будущем еще и с высокой ценой. То есть тут мы рассчитываем повлиять на пользовательский ETA, эффективность водителей в первую очередь. 
```

## Риски

1. Гипотезу дорого проверять, и она может не стрельнуть.
2. Саммари может сильно замедлиться. Предпосылки: время фетча ETA [без расширенного раудиуса](https://yql.yandex-team.ru/Operations/X9CxBwPTTvO80NVdOu6SoFviToL5M8G3tD6qEMgPqjM=) и 
 [с расширенным радиусом](https://yql.yandex-team.ru/Operations/X9CxI4xPm5JF7JD84b3DxKuN7pfFoNLFyOCbjvTRaYI=). Но при этом мы и сейчас ходим с расширенным радиусом. Может быть то, что не будет повторного похода окупит то, что теперь чаще будем это делать, и не замедлится, или даже ускорится.
 Если мы замедлимся, то придется потратить трудно-предсказуемое время на ускорение. Один из вариантов ускорения: распространить deadline propagation (aka динамический таймаут) и на походы в ML.
3. Мы породим новый техдолг вместо закрытия старого. [Код работы с ETA](https://github.yandex-team.ru/taxi/backend-cpp/blob/develop/protocol/lib/src/views/routestats/tracker.cpp) сейчас ~3 kLOC в `protocol/routestats`. Если мы добавим туда новый код, то это отложит переезд на новый сервис `routestats`. Минимальная цель: не добавить нового техдолга.

### Как не увеличить техдолг

#### Этап 0: упростить понимание кода - 1d

Сейчас код ETA в `routestats` слишком сложный и объемный. Если инвестировать полдня в упрощение, то оно окупится уже в этом проекте.
1. `tracker.cpp` переименовываем в `eta.cpp`. Оценка - 0ч.
2. Легковесный ETA (`GetEtaLightweight` и связи) выносим в `eta_lightweight.cpp`. Сам код из `protocol` не уносим пока, команда @rgnlax планирует перенести его в новый `routestats`. Оценка - 2ч.
3. Выносим запрос (`GetAltPoints`) альт-пинов из ETA слоя в `routestats/tracker.cpp`: это упростит понимание кода, очистит абстракцию, ускорит `routestats` => правка будет безопаснее. Оценка - 2ч.

В результате должно остаться около 1000 строк кода в `eta.cpp`, и еще 1000 строк в файлах про ML.

Даже если этот этап не делать, все равно этот 1 день потратится на понимание кода: он сложный.

#### Этап 1: пишем новую логику в сервисе `driver-eta` - 10d

Почему не в новом/старом `routestats`, а в `driver-eta`. Преимущества:
  * `driver-eta` используют сервисы отложенных заказов, логистики, внешних и внутренних (КЦ, Алиса, etc) API расчета цены. В этих местах мы [хотим включить](https://st.yandex-team.ru/CORPDEV-1187) логику платной подачи.
  * поход в ML может быть тесно переплетен с разбиением по классам и требованиям. Разбиения должны жить в `driver-eta`, так как полезны многим. Тогда если поход в ML будет отдельно, то это будет мешать.
  * корректировка ETA с помощью ML должна жить в `driver-eta`, то есть часть продуктовой логики там все равно появится. Сейчас эта корректировка делается одним ML, после изменения может делаться новым ML.
  * переезд из `protocol` в новый `routestats` не только не замедлится, но и значительно ускорится. Сейчас код ETA нельзя просто так перенести, так как он выполняется посередине работы `routestats`.
Недостатки:
  * продуктовая логика будет жить в около-инфраструктурном сервисе. Возможно, ей место скорее в `routestats`.
  * не так эффективно распараллеливается работа `routestats`

Преимущества перевешивают, поэтому пишем в `driver-eta`.

1. Получаем всю инфу для экспериментов в `driver-eta`, если ее нет - 0.5d
2. Ходим из `driver-eta` в `candidates` с новыми параметрами для поиска в расширенном радиусе. Вычислить параметры будет нетривиально, так как надо будет вычислить доступность платной подачи для каждого тарифа. Это зависит от способа оплаты, зоны и тп. 2d
3. Ходим из `driver-eta` в ML за инфой о радиусе если включен параметр запроса. Считаем ETA и отдаем радиус. При этом там может оказаться лишняя инфа, которую надо прокинуть для консистентности. Если можно ее повторно запросить из `routestats` - лучше это сделать, ценой скорости работы (ML очень быстрый). Фолбэк на неответ ML - берем ближайшего кандидата, как и раньше. 3d.
4. Делаем поход в `driver-eta` с нужными параметрами из `protocol`, сохраняем в оффер нужный радиус, отключаем корректировку ML-ем ETA - 3d
5. Запускаем и проверяем, замедлился ли `routestats`. 1.5d.

#### Этап 2: выпиливаем ненужный код - 1d

1. Удаляем код ETA + платной подачи из `protocol`. 1d
2. Крутое выполнение, бонусные очки: переносим распараллеливание в `driver-eta`, не оставляя по итогу практически ничего в `routestats` про ETA.


## Итоговая оценка

Умножим на 1.5, итого 12*1.5=18d = 3.5 человеко-недели разработки.
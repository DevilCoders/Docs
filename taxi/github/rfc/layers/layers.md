## Продуктовая задача

### Описание

Сейчас объекты на карте (пикап-поинты, остановки, промо-точки, машинки-драйва, 
рестораны, юзерплэйсы, точки беспилотника) возвращаются в finalsuggest - ручка, 
которая влияет на цикл заказа. 

Хочется убрать из finalsuggest объекты на карте и вынести их в отдельный 
сервис, который будет возвращать слои объектов на карте по bbox-у, уровню зума
и типу экрана  (главный, саммари, в поездке).

Также, сейчас логика отображения объектов на карте (приоритезация, показ на 
разных уровнях зума) размазана на клиентах и на бэке. Хочется, чтобы основная 
логика отображения была на бэке, а не на клиентах.

Также слои позволят устранить "моргание" объектов при сдвиге пина.


### Гипотеза

Сервис позволит навести порядок на карте, делать акценты на нужных объектах.
Предполагается, что пользователю станет проще взаимодействовать с картой.

Сервис повысит отказоустойчивость такси, так как объекты на карте будут 
вынесены из ручки finalsuggest, которая блокирует цикл заказа. 


## Клиентское API

Ручка `/4.0/layers/v2/objects` возвращает объекты по bbox-у и текущему зуму.

*Примечание: api `v1` используется   для получения объектов около точки, как в
pin_drop.*

Для неавторизованных пользователей возвращается информация без персональных 
данных.

Важно, что ручка **не возвращает** точки из зон перекрытий. Они по-прежнему
будут возвращаться в pin_drop.

**Важно**: ручка не является блокирующей, запросы должны выполняться независимо от launch
pin_drop и т.д. (видим примерно как nearestdrivers)

Формат ответа: geojson.
 #### Кэширование 
 В ответе ручки указываются параметры кэширования объектов:
- `bbox`: область валидности объектов. Если экран вышел за пределы этого 
bbox, то нужно перезапросить объекты
- `zooms`: диапазон зумов валидности объектов. Если зум вышел за пределы
                 диапазона, то нужно перезапросить объекты
- `validity_sec`: время валидности объектов. Если с момента последнего 
   получения объектов прошло больше 
   `validity_sec`, то клиент должен перезапросить объекты.
   При этом сами объекты остаются на карте вплоть до `clean_sec` (см. ниже), 
   если не произошло смены экрана или режима.
- `clean_sec`: время, через которое нужно удалить объекты.
   Если с момента последнего получения объектов прошло больше 
   `clean_sec`, то клиент должен удалить объекты.
- `throttle_ms`: время, которое должно пройти после изменений на карте 
    (сдвиг bbox, зум), чтобы пошел запрос
 
Кэш объектов определяется последним ответом ручки и 
считается валидным, если одновременно выполнены условия:
1) Карта находится в пределах `bbox`
1) Зум пользователя находится в пределах `zooms`
1) Последний ответ был не раньше, чем  `validity_sec` назад
1) Тип экрана (главный, выбор точки А, B) не поменялся
1) Режим (такси, беспилотник, еда) не поменялся


Если кэш перестает считаться валидным по причинам (1-3), то клиент должен 
перезапросить объекты (ретраи и таймауты обсудить с клиентами) и удалить объекты,
 если прошло `clean_sec` с последнего успешного ответа. При это перезапрос 
 объектов должен выполниться только тогда, когда с момента последнего изменения
 карты прошло не менее `throttle_ms` миллисекунд. Это нужно для того, чтобы при 
 движении в другую локацию или в процессе отзума не выполнялось лишних запросов.

Если кэш перестает считаться валидным по причинам (4-5), то клиент должен сразу
 удалить текущие объекты и запросить заново.

#### Отображение объектов 

Для каждого объекта в geojson возвращают настройки display_settings
отображения объекта. В этих настройках указываются:
- `z_index`: приоритет объекта. Если у объекта A z_index больше чем у объекта 
B, то при перекрытии объектов A и B, объект B должен быть скрыт.
- `zooms`: интервал зумов показа объекта.

Эти параметры полностью определяются настройки показа 
объектов на карте. Задача клиента: отображать объекты в заданном диапазоне 
зумов и заданным приоритетом.


#### Пример

Запрос
```
POST /4.0/layers/v2/objects

{
    "state": {
        "pin": [37.5368, 55.7495],
        "bbox": [30.12, 50.34, 40.56, 60.67],
        "zoom": 15.5,
        "location": [37.53, 55.75],
        "mode": "normal",
        "screen": "main"
    }
}
```
Ответ
```
{
  "type": "FeatureCollection",
  "bbox": [
    30.10,
    50.32,
    40.58,
    60.70
  ],
  "validity_sec": 30,
  "clean_sec": 60,
  "throttle_ms": 100,
  "zooms": [
    15,
    16
  ],
  "features": [
    {
      "type": "Feature",
      "id": "fbb68f7f0391464092812bcef420a829_2",
      "geometry": {
        "type": "Point",
        "coordinates": [
          37.5893,
          55.7342
        ]
      },
      "properties": {
        "type": "pickuppoint",
        "display_options": {
          "z_index": 200,
          "zooms": [
            15,
            17
          ]
        },
        "style": {
          "image": {
            "type": "tag",
            "name": "custom_pp_icons_black"
          },
          "selected_image": {
            "type": "tag",
            "name": "custom_pp_icons_red"
          }
        },
        "label": {
          "type": "default",
          "zooms": [
            15.5,
            17
          ],
          "text": "Кофемания"
        },
        "behavior": {
          "stick_pin": true
        }
      }
    },
    {
      "type": "Feature",
      "id": "fbb68f7f0391464092812bcef420a829_3",
      "geometry": {
        "type": "Point",
        "coordinates": [
          37.588,
          55.734
        ]
      },
      "properties": {
        "type": "userplace",
        "display_options": {
          "z_index": 220,
          "zooms": [
            14,
            16
          ]
        },
        "style": {
          "image": {
            "type": "tag",
            "name": "userplaces_work"
          },
          "selected_image": {
            "type": "tag",
            "name": "userplaces_work_selected"
          }
        },
        "options": [
          {
            "on": "select",
            "actions": [
              {
                "type": "finalize",
                "prev_log": "{\"type\":\"userplace\",\"userplace_id\":\"work\"}"
              }
            ]
          }
        ]
      }
    },
    {
      "type": "Feature",
      "id": "drive__9a903847df713c89",
      "geometry": {
        "type": "Point",
        "coordinates": [
          37.59,
          55.739
        ]
      },
      "properties": {
        "type": "drive",
        "bubble": {
          "id": "drive_car_bubble",
          "components": [
            {
              "type": "text",
              "value": "Mercedes"
            },
            {
              "type": "text",
              "font_style": "bold",
              "value": "0,48 ₽"
            }
          ],
          "zooms": [
            15,
            16
          ],
          "hide_after_tap": false,
          "style": {
            "bg_color": "#ffffff",
            "font_color": "#000000"
          },
          "selected_style": {
            "bg_color": "#4d40f9",
            "font_color": "#ffffff",
            "hide_chevron": true
          }
        },
        "display_settings": {
          "hidden": true,
          "z_index": 210,
          "zooms": [
            14,
            16
          ]
        },
        "options": [
          {
            "actions": [
              {
                "type": "drive_card",
                "app_link": "https://redirect.appmetrica.yandex.com/serve/963111058078221669",
                "button_text": "Забронировать",
                "deeplink": "yandexdrive://cars/б674вг616?offer_id=886f3c3c-41c95bfd-d989236d-7625b750",
                "image": "https://carsharing.s3.yandex.net/drive/car-models/mercedes_e200_white/mercedes-white-large-30-10.png",
                "name": "Mercedes E200",
                "number": "б674вг616",
                "price": "0,48 ₽/мин",
                "walking_time": 283
              },
              {
                "type": "show_objects",
                "ids": ["drive__9a903847df713c89"]
              }              
            ],
            "on": "tap"
          }
        ],
        "style": {
          "azimuth": 5,
          "image": {
            "type": "url",
            "doublex": "https://carsharing.s3.yandex.net/drive/car-models/mercedes_e200_white/map-2x.png",
            "triplex": "https://carsharing.s3.yandex.net/drive/car-models/mercedes_e200_white/map-3x.png"
          },
          "autoscale": {
            "type": "linear",
            "min_zoom": 15.0,
            "min_scale": 0.6,
            "max_zoom": 19.0,
            "max_scale": 1.0
          }
        }
      }
    }
  ]
}
```


#### Когда дергать

По одному из событий инвалидации кэша (см. Кэширование).
 

#### Раскатка 

Делаем клиентскую ручку `/4.0/layers/v2/objects` и переключаем на нее клиентов под
клиентским экспериментом `?`.


### Почему не как в Картах?
В картах объекты на карте подгружаются с помощью векторных тайлов 
(можно почитать тут https://habr.com/en/company/yandex/blog/475382/).
Тайл - квадратик на карте в проекции Меркатора. На разных масштабах разный 
набор тайлов. На самом мелком масштабе (нулевой) 
весь мир покрывается одним тайлом. На масштабе=1 4-мя тайлами и т.д.
На масштабе N у нас 2^N x 2^N тайлов. Клиент с помощью mapkit подгружает
объекты в тайлах. Например, запрос: 
`https://vec04.maps.yandex.net/vmap2/tiles?lang=ru_RU&x=19810&y=10272&z=15&
zmin=16&zmax=16&v=20.02.17-0` подгружает объекты в тайле (19810,10272) на 
масштабе 15. mapkit кэшируют на определенное время тайлы после подгрузки.

Первая мысль была - давайте сделаем такую же подгрузку с помощью mapkit.
У ребят есть возможность добавить кастомный geojson-слой с тайловой подгрузкой
 (`https://a.yandex-team.ru/arc/trunk/arcadia/maps/doc/proto/yandex/maps/proto/renderer/styling/geojson_layer`).
К сожалению, оказались фичи, которых на не хватает в geojson-слое. Из основного:
- нет подписей
- не получится взаимодействовать с пином на карте. Есть только возможность
взаимодейстий по тапу на объект.
- нельзя поворачивать объекты

Пообщались в ребятами из рендеринга, они сказали, что пока не планируют добавлять
такие фичи. Ну и в целом, если мы захотим что-то новое добавить, то будем 
сильно зависит от группы рендеринга карт.

Поддерживать самим на клиентах тайловую подгрузку объектов на карте кажется 
совсем не простой задачей (вот тут https://habr.com/en/company/yandex/blog/475382/ 
описаны некоторые из сложностей).

Поэтому решили сделать простое кэширование в bbox-е. Бэкенд вовзвращает объекты
для немного "увеличенного клиентского bbox-а" и клиенты считают выдачу валидной,
пока пользователь не выйдет за пределы этого "увеличенного bbox-а". Это довольно 
просто сделать на клиентах и покрывает большинство пользовательских сценариев.


## Реализация бекенда

#### Используемые сервисы

Делается новый сервис `layers`, в котором реализована логика отображения 
объектов на карте. Сервис ходит в сервисы-провайдеры за объектами:

- `umlaas-geo/pickuppoints` - за пикап-поинтами 
- `masstransit/v2/stops` - за остановками общественного транспорта 
- `eda-catalog/v1/shortlist` - за ресторанами еды/лавки
- `yandex-drive/offers/standard` - за машинками Драйва
- `userplaces/userplaces/list` - за юзерплэйсами
- `pickuppoints/zones/v2` - за точками перехода в другие моды (беспилотник)

### Отказоустойчивость и фоллбеки

* При недоступности `layers` не будет объектов
* При недоступности одного из провайдеров не будет объектов этого провайдера

### Нагрузка

#### Нагрузка на `layers`

Ожидается максимальная нагрузка в ~1000 RPS на ручку.
Это оценка сверху от текущего pin_drop. Ручка должна дергаться не чаще чем 
pin_drop.

### Детали реализации

#### Сервис `layers`

Добавляем ручку `/4.0/layers/v2/objects`. 

В сервисе layers делается два конфига 3.0 `layers_cache` с настройками 
кэширования и `layers_providers` с настройками провайдеров объектов.

`layers_cache`:

```json
{
  "clean_sec": 120,
  "bbox_delta": {
    "east": 1,
    "west": 1,
    "north": 0.5,
    "south": 0.5
  },
  "zoom_delta": {
    "less": 0.5,
    "more": 0.5
  },
  "throttle_ms": 100,
  "validity_sec": 60
}
```

`layers_providers`:

```json
{
  "eda": {
    "z_index": 90,
    "zoom_max": 20,
    "zoom_min": 16,
    "extension": {
      "type": "common_extension",
      "image_tag": "custom_pp_superapp_restaurants",
      "selected_image_tag": "custom_pp_superapp_restaurants"
    }
  },
  "drive": {
    "z_index": 100,
    "zoom_max": 20,
    "zoom_min": 16.5
  },
  "modes": {
    "z_index": 120,
    "zoom_max": 20,
    "zoom_min": 16
  },
  "promo": {
    "z_index": 80,
    "zoom_max": 20,
    "zoom_min": 16
  },
  "stops": {
    "z_index": 110,
    "zoom_max": 20,
    "zoom_min": 15.5,
    "extension": {
      "type": "common_extension",
      "image_tag": "stop",
      "selected_image_tag": "selected_stop"
    }
  },
  "userplaces": {
    "z_index": 115,
    "zoom_max": 20,
    "zoom_min": 15.5,
    "extension": {
      "type": "userplaces_extension",
      "home_image_tag": "custom_pp_icons_home",
      "work_image_tag": "custom_pp_icons_work",
      "other_image_tag": "custom_pp_icons_2_red",
      "selected_image_tag": "custom_pp_icon_selected"
    }
  }
}
```
Обработка клиентского запроса состоит из следующих шагов:

1) Составляется список клиентов-провайдеров, в которые нужно сходить за 
объектами. Если клиентский зум не входит в область 
зумов показа объектов определенного типа, то мы не ходим за этим объектом в 
соответствующий провайдер. 
1) Если провадеров нет, то возврашаем пустой список объектов.
1) Определяется bbox для запроса объектов. Берется текущая область клиентского 
приложения и увеличивается на 0.5 зума (примерно в х1.4). Число "0.5" будет в 
конфиге. 
1) Выполняются параллельные запросы в провайдеры по bbox.
1) Выполняется фильтрация объектов. Алгоритм такой: делим весь мир на 
квадртатики. Размер квадратика зависит от зума. Например, на 19 зуме 
у нас квадратик 0.001 x 0.001, на 18 - квадратик х4, на 17 - х16 и т.д.
В квадратике определяется X объектов с наибольшим z_index, остальные объекты 
отбрасываются. Для некоторых объектов (например, остановки) фильтрация не 
выполняется. Размер минимального квадратика определяется конфигом/экспериментом.
1) Возвращается список объектов с параметрами кэширования.


#### Сервисы `umlaas-geo`
Нужна ручка, которая будет возвращать объекты по bbox-у.

### Безопасность

Возможно стоит запретить неавторизованным пользователям забирать объекты


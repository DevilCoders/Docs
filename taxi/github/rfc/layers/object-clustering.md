# Прореживание/кластеризация объектов

### Суть проблемы
От некоторых провайдеров может вернуться слишком мношго объектов на карте.
Например, от Драйва в discovery-режиме может вернуться несколько тысяч машин.
В результате от большого числа объектов клиент начинает тормозить. Помимо этого
большое скопление объектов выглядит на карте как месиво.

### Постановка
Проблему можно решать по-разному:
1. Скрыть лишние объекты
2. Сгруппировать близкие объекты в группы. Так можно например показывать
   количество объектов в кружочках

Технически эти варианты не сильно отличаются. Первый вариант легко получается
из второго выделением в группе главного объекта, который и будет отображаться
на карте. В перспективе можно будет перейти и ко второму варианту.

Группировку объектов также можно решать по-разному:
1. Относить два объекта к одной группе, если расстояние между ними меньше
   некого порогового расстояния `d`, зависящего от зума. В таком случае
   длинные цепочки из объектов объединяются в одну компоненту связности.
   Частично решается выделением больших квадратов со стороной `D` и запретом
   группировки объектов из разных квадратов.
2. Относить объект к группе, если расстояние от него до центра группы меньше
   порогового. Возникают проблемы с детерменированностью: от порядка добавления
   точек будет зависеть, какие группы мы в итоге получим.

Учитывая наши требования, решили остановиться на первом варианте с ограничениям
по большим квадратам.

### Алгоритм
На входе имеем кэшируемый bbox и границу зумов, а также сами объекты с
приоритетами отображения. На выходе хотим получить список объектов с диапозоном
зумов, на которых они должны отображаться.

Определим `D` и `d`
пропорционально `2^(-z)`, где `z` - уровень зума (нижний клиентский,
округленный вниз). Причем пусть `2D/d = k` - целое число. Большие квадраты
(далее тайлы)
расположим при фиксированном зуме независимо от местоположения запрошенного
bbox-а: пусть они идут плотной сеткой с началом в нуле. Таким образом каждый
тайл будет иметь угловые координаты `(x*D, y*D), ((x+1)*D, (y+1)*D)`, где
`x, y` - целые числа.

Кэшированный bbox дополним так, чтобы он состоял из целых тайлов, т.е. теперь
он выглядит как `(x_1*D, y_1*D), (x_2*D, y_2*D)`. Его будем использовать для
запроса объектов у провайдера.

Покрытие bbox-а тайлами:
![](https://jing.yandex-team.ru/files/nknv-roman/uhura_2020-09-11T19%3A26%3A17.787037.jpg)

Получив объекты, попытаемся идти от максимального (или `all_visible_zoom - 1`)
зума к минимальному и для каждого зума `z`, используя пропорциональные `d, D`,
пытаться группировать объекты в рамках одного тайла. Для этого:
1. Каждый тайл разделим на маленькие квадратики (бакеты) со стороной `d/2`.
   Так, на тайл приходится `(2D/d)^2` бакетов.
   Таким образом можно гарантировать, что любая пара точек с расстоянием меньше
   `d` находится в одном или соседних бакетах.
2. Будем все потенциально близкие друг к другу пары точек. Если нашли пару,
   расстояние внутри которой меньше `d`, то объединяем компоненты. Это можно
   сделать за `O(\alpha(n))`, если использовать [систему непересекающихся
   множеств](https://en.wikipedia.org/wiki/Disjoint-set_data_structure).
   При этом храним и обновляем для каждой группы главный объект в соответствии
   с приоритетами.

Бакеты и соединенные точки в них:
![](https://jing.yandex-team.ru/files/nknv-roman/uhura_2020-09-11T19%3A26%3A25.504318.jpg)

Таким образом, на обработку одного уровня зума мы будем тратить
`O(n * b * \alpha(n))` времени, где `n` - общее число полученных от провайдера
объектов, а `b` - размер максимального бакета. В теории это означает, что мы
имеем алгоритм за `O(n^2 * \alpha(n))`. На практике бакеты должны быть
небольшими, так как объекты распределены примерно равномерно. Можно оценить
размер бакета как `b ~ n / ((x_2-x_1)*(y_2-y_1) * (2D/d)^2)`. В реальности
попадание в один бакет большого числа объектов можно считать крайне
маловероятным. Можно попытаться побороть такие случае эвристиками, срезая
количество производимых сравнений расстояния.

Таким образом обрабатываем все зумы в пределах кэшируемого диапозона. На каждом
зуме берем главный объект из каждой группы в
качестве главного для отображения (можно за линейное время). В конце концов,
строим для каждого объекта диапозон зумов, на котором он виден.

Потенциальные места для улучшения:
1. Эвристика или замена алгоритма нахождения близких точек
2. В качестве тайлов можно использовать гексы вместо квадратов. Тогда группы
   будут смотреться более естесственно
3. Сделать проекцию географических координат на экранные, либо измерять
   расстояния не по географическим координатам (в градусах), а в метрах
   (great circle distance)

# Новые экшены
Для взаимодействия с кластером ввести экшен zoom_map_bbox
При тапе на карте на объект кластера нужно призумить карту, чтобы появились объекты кластера и другие более мелкие кластеры

```yaml
ZoomMapBboxAction:
    type: object
    additionalProperties: false
    properties:
        type:
            type: string
            enum:
                - zoom_map_bbox
        bbox:
            description: |
                Область в которой находятся объекты группы и на которую нужно отзумиться чтобы объекты появились
            $ref: "#/definitions/Bbox"
    required:
        - type
        - bbox
```
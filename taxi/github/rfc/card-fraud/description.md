Флоу верификации:

###### POST /4.0/payment/verifications
данные из запроса:
- user_id (PA header)
- user_uid (PA header)
- card_id (request_body)
- idempotency_token (request_body)

логика работы:
- идет в user-api (db.users) по user_id и достает metrica_device_id пользователя
- проверяем по device_id, (uid? card?), idempotency_token верификацию
-- если верификация в статусе драфт - переходим к шагу (6)
-- если верификация в другом статусе - возвращаем id и purchase_token
- создает драфт в таблице верификаций:
```json
{
  "id": "0000000",
  "card_id": "card-x0000000",
  "user_uid": "000000",
  "device_id": "AAAA00000",
  "status": "draft",
  "created_at": datetime,
  "updated_at": datetime,
  "idempotency_key": "xxxxx"
}
```
- (6) начинаем верификацию:
-- идет в ручку /bindings/{card_id}/verify
-- сохраняет trust_verification_id и purchase_token в таблицу верификаций:
```json
{
  "trust_verification_id": "trust_id",
  "purchase_token": "token",
  "status": "in_progress"
}
```
- возвращает id и purchase_token

###### GET /4.0/payment/verifications/status
данные из запроса:
- user_id (PA header)
- user_uid (PA header)
- verification_id (request_body)

логика работы:
- достает из базы верификацию по id
- возвращает ее статус

###### (cardstorage) /v1/binding_status запускает stq таску process_card_verification
```python
def  process_card_verification(user_uid=uid, verification_id=trust_verification_id, card_id=binding_id, status=status, method=method, 3ds_url=3ds_url, 3ds_method=3ds_method, 3ds_params=3ds_params, random_amount_tries_left=2, finish_binding_url=finish_binding_url)
```
в этой таске:
- достаем верификацию из базы по uid, card_id, trust_verification_id
- сравниваем статус верификации, если статус предыдущий или tries_left больше - ничего не делаем. Сравнивать статус верификации нужно по схеме https://wiki.yandex-team.ru/users/jolfzverb/trust-workflow/. Если статусы несравнимы - роняем таску.
- если верификация в базе в терминальном статусе (failed, cancelled) - ничего не делаем, если success - продолжаем
- записываем в базу новый статус верификации
- если верификация не найдена - перепланируем таску на будущее, если таска достаточно старая (конфигурируемый срок, по-умолчанию 1д) - не перепланируем.
- если статус failed - ничего не делаем
- запускаем таску save_verified_card

###### save_verified_card(user_uid=uid, card_id=card_id, device_id=device_id)
- если пара (user_uid, device_id) есть в таблице верифицированных устройств - запускаем удаление из таблицы карт (пп 6)
- достаем все верифицированные карты по (user_uid, device_id) из таблицы карт
- идем в cardstorage/v1/payment_methods (cache_preferred=true)
- если верифицированные карты + карта из параметров составляет тот же набор что и карты из cardstorage:
-- записываем пару (user_uid, device_id) в верифицированные устройства
-- (6) удаляем все карты по user_uid, device_id из таблицы карт
- иначе:
-- записываем карту в таблицу верифицированных

###### /v1/payment/availability:
данные из запроса:
- device_id (доставать из user-api по user_id)
- user_uid (пробрасывать значение PA header'а)
- card_id (если проверяем конкретную карту, например для заказа или изменения способа оплаты)

логика работы:
- если устройство есть в таблице верифицированных устройств - возвращаем (true, [])
- (2) если в запросе нет айди карты - возвращаем из таблицы верифицированных карт все карты (false, [...cards...])
- если в запросе есть айди карты - фильтруем массив из пп2 по этому айди (возвращаем либо пустой, либо один элемент с этой картой)


###### /v1/payment_verifications в сервисе cardstorage после успешного запроса /bindings/verify запускает stq таску save_card_verification
это нужно чтобы на неверифицированном устройстве работали карты, добавленные на этом устройстве.
```python
def save_card_verification(user_id, verification_id, card_id, user_uid)
```
save_card_verification создает запись в таблице верификаций
```json
{
  "trust_verification_id": "trust_id",
  "purchase_token": "token",
  "status": "in_progress",
  "id": "0000000",
  "card_id": "card-x0000000",
  "user_uid": "000000",
  "device_id": "AAAA00000",
  "created_at": datetime,
  "updated_at": datetime
}
```

#### Очистка устаревших данных
Устройства и аккаунты имеют тенденцию устаревать.
Для удаления неактуальных данных предлагается сделать stq очередь и периодическую таску:
###### card_antifraud_device_update(user_id, yandex_uid)
запускать таску в этой очереди будем из /v1/payment/availability c eta=now+1d (конфигурируемый таймаут)
таска обновляет все записи по device_id и yandex_uid в коллекциях подтвержденных карт и устройств, устанавливая updated_ts=now
###### periodic task card_antifraud_cleanup
utils::PeriodicTask (как например в periodic_music_cleanup.hpp/cpp)
таска удаляет все данные из таблиц верифицированных карт и устройств, у которых updated < now - 3m (конфигурируемый таймаут)
так же она удаляет все верификации старше 2d (тоже конфигурируемый таймаут)

## Задача
Блокировать использование карт, привязанных к аккаунту на некоторых устройствах до проведения
транзакции с подтверждением (CVV, 3ds) на этом устройстве

### флоу
- определить какие карты и на каких устройствах должны быть заблокированы
- создать платеж с требованием ввести cvv
- доставить платеж до клиента (launch/paymentstatuses)
- разблокировать использование карты на устройстве после успешного платежа

### мысли
в cardstorage нужно принимать решение о юзабельности карты - заполнять флаг usable
в ordercommit при проверке карты нужно проверять что она валидна на устройстве заказа, не давать заказать если карта невалидна. давать заказать если проверить не удалось.
подумать про веб(?)

нужно ловить логин на "новом" устройстве
нужно не блокировать карты добавленные на "новом" устройстве (они должны прорастать на "подтвержденные" устройства)
нужно блокировать на "новом" устройстве новые карты, добавленные на "подтвержденном" устройстве
нужно уметь обьявлять устройство "неподтвержденным" через скрипты и в дальнейшем через админку
подтвержденным устройство становится когда все карты пользователя подтвердили для него

из всего этого видится два хранилища
uid->\[verified_devices]
uid+card_id->\[verified_devices]



### итого:
paymentmethods ходит в новый сервис для проверки девайса+пользователя+карт:
если устройство подтверждено для этого девайса - возвращаем что все карты доступны
иначе - возвращаем доступные для оплаты карты из базы

в ответе paymentmethods ничего не меняется если все карты доступны, если не все - отмечаем недоступные и пишем что нужна валидация через cvv/3ds.

ordercommit при валидации карты ходит в этот же сервис с той же логикой что и paymentmethods, запрещая использовать недоступные карты.

changepayment проверяет доступность карты так же как ordercommit.

Клиентское приложение при получении в paymentmethods карт, которым нужна верификация по CVV:
1) делает нотификацию пользователю про это
2) делает доступным флоу верификации карты:
окно в котором дергается (новая)ручка verify для карты, поллится состояние верификации(до получения id платежа), вводится cvv, поллится состояние платежа
если что-то пошло не так - клиент вернуться в "старую" верификацию не может и запускает новую.

платеж проходит асинхронно и если статус OK - девайс отмечается верифицированным для данной карты.
если девайс верифицирован для всех карт в кеше cardstorage - он обьявляется верифицированным для пользователя.

cardstorage в случае пустого ответа на ручку paymentmethods ставит таску "отметить девайс верифицированным"

TODO: подумать про верификацию устройства для кошелька/корпов/семейного - похоже что она невозможна.
TODO: подумать что происходит со связанными фонишами

## Опросник из архитектурного ревью

**Название сервиса**

delivery

**Какую продуктовую проблему решает сервис?**

Сервис по началу будет заниматься формированием смс по тарифу Доставка для пользователей и отправкой их через ucommunications. В дальнейшем будет использоваться и для других целей связанных с тарифом Доставка.

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Сейчас смски отправляются из backend py2, но добавлять туда новую логику уже нельзя, поэтому потребовалось место для добавления логики отправки смс.  У тарифа Доставка сейчас нет отдельного сервиса, в который можно было бы дописать эту логику.

**Как именно сервис будет решать поставленные перед ним задачи?**

Из процессинга 2.0 будет ставится stq-таска на отправку смски при возникновении определённого статуса водителя. Новый сервис будет обрабатывать полученную stq-таску и отправлять соответствующую смску.

**Разрабатывается один сервис или система?**

Один

**С кем взаимодействует сервис?**

Получает таски через очередь stq от процессинга 2.
Получает данные через: order-core, user-api
Взаимодействует с сервисом ucommunications: дёргает ручку отправки смс.

**Какие базы использует?**

Временно использует монгу. Коллекции: order_proc, route_sharing_keys, parks и drivers

**Какие периодические процессы?**

Пока никаких.

**Прикрепите схему того, где этот сервис находится в текущей инфраструктуре**

Схема будет довольно простая, не уверен, что имеет смысл её рисовать.

1. Как технически проект влияет на цикл заказа.

    На сам цикл заказа сервис не влияет. Но отправка смс будет привязана к статусу такси, выполняющего заказ и тарифа, по которому выполняется заказ.


2. Кто будет потребителями сервиса.

    Таски на отправку смс будут ставится из процессинга 2.0.

**Какие данные и по какой схеме сервис будет хранить в базе?**

На первом этапе сервис будет хранить в базе информацию о сделанных попытках отправки смс. В качестве уникального ключа планирую использовать order_id.
В результате в базе будет таблица с двумя столбцами: order_id и флаг отправлена/не отправлена.

На втором этапе на каждый заказ может быть две смс (для т.А и т.Б). Поэтому в таблицу добавится столбец отвечающий за то, к какой точке относится смс. Также при избавлении от монги, в качестве фолбека на походы в другие сервисы, могут добавится столбцы, хранящие уже полученные данные от других сервисов.

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

Нет.

**Какая нагрузка ожидается?**

1 RPS. Рассчитал так:
    Взял лог "Result prefixed key express.sms.on_waiting", который выводится один раз при отправке каждой смс по доставке и посмотрел по кибане час за день с самым большим количеством этого лога (500 шт примерно). Поделилил 500 на 3600 с. Получил примерно 0.14 смс в секунду (это не совсем среднее, считал так, чтоб быть ближе к пиковой нагрузке если что). Предполагается в ближайшем будущем будет максимум 2 смски на заказ. И ещё в 2 раза я беру запас. Умножаем на 4 и получаем 0.56 смс. До единицы округлял для красоты, да и в бОльшей точности не вижу смысла.

**Какие фолбеки предусмотрены на сам этот сервис?**

Не предусмотрены, потому что смс по Доставке планируется отправлять именно через этот сервис. И если с ним что-то случилось, то смски по Доставке просто не получится отправить.
Обсудили с менеджером, в случае потери смс, водитель будет звонить, что собственно и является фоллбеком.


**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

В качестве фолбека на сервисы, от которых получаются данные для смс, можно ронять таску в случае не ответа сервисов, а все уже полученные данные писать в базу. При перезапуске таски проверять наличие данных в базе и пытаться получить от сервисов только те данные, которых ещё нет в базе.
На сервис ucommuications никаких фолбеков не предусмотрено, потому что смс без вариантов надо отправить через него. (но вообще, смотри пункт выше)

**Какие возможности масштабируемости закладываются?**

Увеличение количество STQ-обработчиков.

**Какие точки отказа есть в сервисе?**

Ucommunications, user-api, stq, order-core, mongo(order_proc, route_sharing_keys, drivers, parks), база сервиса

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

Не планируется.

**Укажите технические метрики**

Количество выполненных/зафейленых/ожидающих тасок в stq-очереди.
Количество отправленных смс

**Какая функциональность ожидается в сервисе в будущем?**

В перспективе сюда может быть добавлена другая необходимая для тарифа Доставка логика.

**Какое изменение нагрузки планируется?**
Примерно до нескольких сотен RPS.
За ближайший год количество заказов с такими смс может возрасти с 100к до 1500к, т.е. в 15 раз. Плюс в этом сервисе в перспективе могут храниться номера для точек А и Б, что может добавить несколько десятков запросов на каждый заказ. Отсюда и из нагрузки на данный момент получается порядок планируемой нагрузки.

**Активно ли будет изменяться сервис?**

Пока нет. Зависит от развития тарифа Доставка.


## Описание

**(Данное описание этапов несколько устарело, об основных отличиях читать ниже. Я не удаляю старое, чтоб не плодить огромный дифф)**

### Об этапах вообще

Разрботка сервиса делится на два этапа (подробное описание этапов ниже):

* Этап 1. Выкатка фикса с заменой отправки смс из backend-py2 на отправку из backend-py3 через конфиг;
* Этап 2. Добавление отправки смс для точек А. и Б., в связи с выкаткой новой функциональности. И правка недочётов, которые остались с первого этапа (в частности переход с использования монго коллекций на API).
* Этап 3. (будет или нет пока не ясно) Внесение правок, которые связаны с необходимостью фолбека на голосовые шлюзы. Возможно, привлечение фронтов.

### Этап 1

Задача в трекере: [TAXIBACKEND-26577](https://st.yandex-team.ru/TAXIBACKEND-26577)

**Суть решаемой проблемы:**
    
В данный момент при заказе по тарифу Доставка пользователю-получателю приходит смс с примерным содержанием "Спуститесь к машине и заберите посылку". Такая смс приходит вне зависимости от того включено или нет требование "От двери до двери". Получается, что при включённом требовании, мы путаем пользователя неправильной смс. Ведь ему не нужно в этом случае спускаться к машине, водитель должен принести посылку ко двери.
Нужно сделать так, чтобы при включенном требовании приходила смска с текстом типа "Водитель принесёт посылку ко двери...".
Смски отправляются сейчас из backend-py2. Но трогать backend-py2 уже нельзя, поэтому логику новой смс необходимо вынести куда-то ещё.

Не смотря на то, что по последним данным нам разрешили вкатить фикс в py2, перепланировку первого этапа я считаю плохой идеей, ибо всё равно нужно как можно быстрее вынести логику из py2.

**Что планируется получить в результате?**

Для решения проблемы будет создан сервис delivery на python 3. В сервисе на данном этапе будет распологаться только STQ consumer, который формирует смс сообщение и отправляет его через сервис ucommunications. STQ-таски будут ставится из процессинга 2.0. Передаваемую информацию о поездке (телефон водителя и ссылка на расшаривание маршрута) в смсках планируется сохранить так же, как было в py2. Также на данном этапе планируется применить временное костыльное решение с использованием монги, которое в следующем этапе будет поправлено.

**Архитектура решения подробнее**

1. Когда такси переходит в статус 'on_transporting', в Процессинге 2.0 происходит проверка в поле 'enabled': заказ по тарифу доставка или нет? Если проверка вернула истину, то ставится stq-таска на отправку смс. В таску передаются: флаг is_door_to_door (который показывает включена ли опция "От двери до двери") и order_id (чтобы по нему можно было получить данные для отправки);

2. В сервисе delivery происходит обработка таски:
    a. Получаются необходимые для отправки данные:
        - keyset - будет получаться из конфига;
        - key - будет получаться из конфига;
        - sharing_url - собирается из основы, которая получается из конфига, и ключа, который извлекается из монги route_sharing_keys. Сервиса над этой коллекцией, похоже, пока нет;
        - driver_phone - получение данного поля на данном этапе планируется по аналогии с тем, что было в py2. Там сначала пытаются получить из order_proc голосовой шлюз, если не удаётся то переходят к получению открытых номеров. Сначала проверяется конфиг, который отвечает за скрытие номера водителя, затем из dbdrivers.drivers достаётся номер, если не скрыт конфигом. Иначе проверяется по конфигу открыт ли парковый номер и если открыт, то извлекается парковый номер из dbparks.parks. Походы в order_proc, route_sharing_keys, drivers и parks заменятся на следующем этапе на походы в API. Возможно, удастся сразу получать номера из сервисов driver-profiles и parks-replica, но пока не уверен, что они есть в ответах данных сервисов;
        - locale из order_proc и в дальнейшем заменится на поход в апи;
        - extra_user_phone_id -> personal_phone_id - из order_proc, заменится на поход в апи. Также extra_user_phone_id меняется на personal_phone_id при помощи user_api;

    b. Смс отправляется через сервис ucommunications. С менеджером договорились, что будем пытаться отправить один раз, если не получилось, то просто пишем в лог, что не удалось. Посмотри как много таких будет на практике, по ситуации поправим позже отдельно.



**Проблемы и решения**

1. **Не придётся ли в сервисе обрабатывать все закзы, чтобы вычленить из них те, что по Доставке и тем самым держать большую нагрузку?**

    Нет, не прийдётся. Есть возможность фильтровать заказы ещё при запуске обработчика из процессинга 2.0. При помощи поля enabled в конфиге.

2. **Голосовые шлюзы не стабильны (как рассказал нам Дмитрий Курилов на архревью), что будет сделано чтобы побороть проблемы связанные с этим?**

    На данном этапе ничего, потому что требуется как можно быстрее начать отправлять правильную смс. Фикс проблемы со шлюзами отложен на следующие этапы (читай дальше).

3. **Может ли быть по одному заказу более 1 СМС, если заказ отменится?**

    По идее, смс будет отправляться каждый раз, когда такси переходит в статус "on_transporting". Логично предположить, что в этот момент водитель уже везёт посылку и если заказ отменился, то решение дальнейших связанных с этим проблем вне данной задачи. (для Этапа 2 ответ будет несколько другим)

4. **Многие значения в backend-py2 подтягивались из монги из order_proc, route_sharing_keys, drivers и parks, но это плохо с точки зрения микросервисной архитектуры. Как в новом сервисе будет исправлена данная проблема?**

    На данном этапе для экономии времени используются монго коллекции аналогично backend-py2, на следующем этапе планируется заменить все походы в монгу на походы в API:
    order_proc - заменится на поход в новую ручку order-core (https://st.yandex-team.ru/TAXIORDER-740);
    route_sharing_keys - для замены придётся запросить создание ручки/сервиса или сделать самим, пока готового не нашёл;
    drivers - можно попытаться заменить на сервис driver-profiles, если там окажутся новые поля, либо запросить доработку;
    parks - можно заменить на parks-replica, если там окажутся нужные поля, либо запросить доработку.
    Если мы решим отказаться от фолбека на открытые телефоны водителя и парка, то от использования последних двух коллекций просто откажемся.

5. **Как будет происходить переход с логики в py2 на логику в py3?**

    Изначально я думал переключать логику через эксперимент на процент. Но количество заказов по доставке достаточно небольшое, так что переключать на процент нет смысла. Следоватьельно будет использоваться конфиг. Для надёжности планирую завести два конфига: один для py2, другой для py3. При выкатке планирую сначала включить логику в py3 и убедиться по логам, что она запустилась, а затем отключить логику в py2.

    При переключении, пользователям может приходить дубль смс. Но из-за малого числа заказов по Доставке, зааффекченных пользователей будет мало, так что можно считать, что это норм.

6. **Какая будет защита от потери и дублирования СМС?**

    Так как ручка /user/sms/send сервиса ucommmunications не имеет защиты от двойной отправки (там нет ключа идемпотентности), то нормально защитится от этого в нашем сервисе тоже не получится.
    По договорённости с менеджером проекта, было решено делать одну попытку отправить смс, а если не получилось, то писать в лог ошибку. Теряться будет, вероятно, 1 из 1000 смс, предполагается, что в этом случае водитель сможет позвонить пользователю и проблема решится.
    Для реализации этого варианта потребуется БД, в которую будет записываться информация о том, была ли уже попытка отправки смс.

7. **Как будут настроены алерты на размер очереди STQ?**

    Думаю, смска достаточно важная, поэтому надо как можно быстрее будет узнать, если что-то пошло не так. Поэтому планирую выставить 
    warning - 1, critical - 3.

8. **Какие оценки по времени для этого этапа на реализацию?**

    Пессимистичный прогноз: до 3 февраля 2020 года.

### Этап 2

**Вкратце:**

На данном этапе планируется добавить отправку смс для точек А и Б. Также необходимо позаменять походы в монгу на походы в API:
order_proc - заменится на поход в новую ручку order-core (https://st.yandex-team.ru/TAXIORDER-740);
route_sharing_keys - для замены придётся запросить создание ручки/сервиса или сделать самим, пока готового не нашёл;
drivers - можно попытаться заменить на сервис driver-profiles, если там окажутся новые поля, либо запросить доработку;
parks - можно заменить на parks-replica, если там окажутся нужные поля, либо запросить доработку.
Если мы решимы отказаться от фолбека на открытые телефоны водителя и парка, то от использования последних двух коллекций просто откажемся.

### Этап 3

**Вкратце:**

В связи с нестабильностью голосовых шлюзов, на этом этапе планируется придумать и реализовать альтернативное решение, либо новый фолбек, не требующий присылать открытый номер водителя.



**Здесь находится описание этапов после того, как нам позволили вмёржить в  py2 временный код. В целом, всё, кроме содержания этапов остаётся в силе**

### Об этапах кратко:

Этап 1 - перенесение логики из py2 с заменами использования монго-коллекций на использование API, где это возможно быстро;
Этап 2 - замена использования монго-коллекций на API, проработка и решение вопроса о голосовых шлюзах, также возможен дополнительный рефакторинг.

## Этап 1

### На данном этапе планируется:

1. Разработка и выкатка нового сервиса;
2. Переключение отправки смс из py2 на отправку смс из нового сервиса;
3. Выпиливание логики из py2.

### О времени

После Ок по данному RFC на завершение этапа 1 потребуется:
    - 2 дня на допиливание кода, ревью и правки;
    - 1 день на выкатку и переключение;
    - 1 день ожидания и анализа работоспособности нового сервиса в проде;
    - параллельно с допиливанием, выкаткой и анализом может идти выпиливание из py2;

    В результате где-то за 4-5 дней этап 1 будет закончен.

**(Сейчас подробно обсуждать этап 2, наверно, нет смысла. Слишком много неизвестных. В первую очередь, нужно поставить точку в обсуждении первого этапа)**

## Этап 2

### На данном этапе планируется:

1. Замена похода в order_proc на поход в ручку order-core;
2. Замена route_sharing_keys на поход к API (которого ещё нет);
3. Проработка и решение вопроса про голосовые шлюзы (от этого этапа также зависит то, как будут заменены коллекции drivers и parks). Для шлюзов надо либо придумать надёжный фоллбек, либо заменить их на что-то.
4. Фоллбек на сервисы (в связи с тем, что походов в сервисы становится много). В качестве фоллбека планирую писать уже полученные данные от сервисов в базу, ронять таску и при перезапуске вместо получения всех данных по новой читать из базы уже полученные. Также придётся добавить флаг об отправке смс, ведь теперь к одной и той же записи таска сможет вернуться несколько раз.
5. Использование нового ключа идемпотентности у ручки ucommunications /user/sms/send.

### О времени

На завершение этапа в идеале (когда все необходимые ручки над базами готовы) потребуется:
    - 3 дня на переход на ручку order-core и сервис со ссылкой для шаринга маршрута, добавление фоллбека на сервисы и использование нового ключа идемпотентности у ucommunications;
    - 3+ дня на проработку решения по голосовым шлюзам;
    - 3+ дня на применение решения по шлюзам;

    То есть всего 9+ дней.

А не в идеале ещё придётся сколько-то ждать новую ручку в order-core, сервис или какую либо другую замену для route_sharing_keys, ключ идемпотентности у ucommunications, на голосовые шлюзы может уйти больше времени, а также могут потребоваться доработки не только у нас (например, фронтов), что тоже потребует ожидания.

### О разбиении на задачи

Вероятно, в связи с такой кучей блокеров стоит данный этап разбить на отдельные задачи:
    0. Добавить механизм фоллбеков для внешних сервисов;
    1. Перейти на ручку order-core;
    2. Заменить route_sharing_keys;
    3. Заиспользовать ключ идемпотентности у ucommunications;
    4. Проработать решение по голосовым шлюзам;
    5. Применить решение по голосовым шлюзам.

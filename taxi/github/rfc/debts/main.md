### Описание взаимодействия с сервисом долгов

#### Проблема
Раньше долг и заказ были неотделимы друг от друга, поэтому такие задачи как "получение списка долгов" и "общая сумма долга"
приводили к походу в dborders. В последнее время от dborders решили отказаться в пользу стабильности сервиса. Поэтому долги 
надо отделять от заказа.


#### Решение
Необходимо сделать сервис, который будет хранить пользовательские долги отдельно от заказов.
Нужно продумать:
1. Как правильно записывать долг?
2. Как правильно снимать долг?
3. Как ассоциировать долг с юзером (phone_id/yandex_uid)?
4. Что делать в случае отказа сервиса?

##### Как ассоциировать долг с юзером (phone_id/yandex_uid)?
После обсуждения с ИБ пришли к выводу, что сохранять долг надо по yandex_uid и phone_id.
Доставать долги будем запросом типа: 
```
select * from debts where phone_id='' OR yandex_uid IN [один фониш или список всех фонишей привязанных к порталу]
```

Это лучше чем хранить просто по phone_id, т.к решается кейс, когда портальный аккаунт меняет номер телефона.
Кейс, когда юзеру купившеуму симку с долгами, показываются долги старого пользователя остается, но он существует и сейчас, поэтому
хуже мы не делаем.

Это лучше чем хранить по yandex_uid, т.к не будет проблем:
1. uid может поменяться через 3 месяца и потеряются все долги
2. фродеры нагененерили кучу портальных аккаунтов с одним телефоном и разными юидами и бесконечно катаются в долг


#### План решения
В качестве решения предлагается следующая схема:

##### Сервис долгов
Предлагается следующая схема БД:

|              |                                   |
|--------------|-----------------------------------|
| yandex_uid   |                                   |
| phone_id     |                                   |
| status       | долг/не долг                      |
| reason_code  | причина прощения                  |
| created      |                                   |
| updated      |                                   |
| value        |                                   |
| currency     |                                   |
| order_id     | id заказа такси                   |
| order_info   | часть json документа dborders     |

Индекс по yandex_uid.
Индекс по phone_id.
PrimaryKey(order_id)


В сервисе долгов будет одна ручка
PATCH v1/debts/order_id=<order_id>

Далее может быть два варианта патчей, применять всегда нужно только последний.
Рассмотрим их:
###### Установить или обновить долг:
Тело запроса:
```json 
{
  "patch_time": <date>, //время патча для решения гонок внутри сервиса
  "action": "set_debt",
  
  //Специфичная для set_debt информация
  "yandex_uid": "",
  "phone_id": "",
  "value": "",
  "currency": "",
  "created_at": "",
  "order_info" : {}, 
}
```

###### Снять долг:
Тело запроса:
```json 
{
  "patch_time": <date>, //время патча для решения гонок внутри сервиса
  "action": "reset_debt",
  
  //Специфичная для reset_debt информация
  "reason_code": "",
  "yandex_uid": "",
  "phone_id": "",
  "created_at": "",
  "order_info" : {}, 
}
```


###### Логика работы патчей
1. Понять, нужно ли применять патч (patch_ts > даты последнего обновления)
2. Создать запись в БД если нужно
3. Применить патч из запроса


##### Python 2

Python 2 должен контролировать процесс установления/снятия долга.
Для этого предполагается работа подобно notify и chat_processing.

1. stq2 определит, что нужно делать с долгом: снять, записать или обновить
2. Создаст эвент в коллекции debts_processing_events c соответсвующим типом и order_id
3. В `order_info` эвента добавит часть документа коллекции order_proc.
4. Поставит таск debts_processing в очередь.

Предполагается, что записывать или обновлять размер долга нужно из этих мест:
- https://github.yandex-team.ru/taxi/backend/blob/f8d0be3d4411c47aa8d2ba30ff0b80589d6a0c7a/taxi/internal/order_kit/invoice_handler.py#L3981
- после каждой транзакции, чтобы поймать момент когда оплачена часть долга.

Предполагается, что снимать долг нужно из этих мест:
- https://github.yandex-team.ru/taxi/backend/blob/e5edbd5ec3fc40029eee2784a80c966de4370dad/taxi/internal/dbh/orders.py#L2134
- https://github.yandex-team.ru/taxi/backend/blob/f8d0be3d4411c47aa8d2ba30ff0b80589d6a0c7a/taxi/internal/order_kit/invoice_handler.py#L3236
- https://github.yandex-team.ru/taxi/backend/blob/92df6154dfddb64f2c3e69268c57bfb75ba24cb1/taxi-admin/taxiadmin/api/views/cardlocks.py#L422


###### Запись и обновление долга
Ставится stq3 таска в аргументами event=set_debt, order_id=<order_id>, event_time=<event_time>

###### Удаление долга
Ставится stq3 таска в аргументами event=reset_debt, order_id=<order_id>, event_time=<event_time>

###### Откуда брать order_info
На момент постановки в очередь задачи order_info должен присутстовать.
Планируется, что таски будет ставить update_transactions и processing.

- В processing достаточно данных для формирования order_info.
- В текущей схеме update_transactions также хватает данных.
- В новой схеме update_transactions с колбэками будем действовать через processing. 

##### STQ3 очередь debts_processing
Будет иметь аргументы:
event - записать или снять долг
event_time - время события (patch_time)
order_id - id заказа


Порядок работы:
1. Достать заказ из archive_api
2. Софрмировать тело патча
3. Отправть запрос в сервис долгов.

Гонки разрешатся в самом сервисе


##### Миграция существующих долгов
Сейчас в системе за все время существования около 1 000 000 долговых заказов.
Необходимо их все мигрировать в сервис долгов.


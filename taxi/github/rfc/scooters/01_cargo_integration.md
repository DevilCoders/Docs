## Задача

Нужно уметь перезаряжать севшие аккумуляторы в самокатах.

Много полезных вопрос-ответов тут - https://wiki.yandex-team.ru/users/sapunovnik/voprosy-i-otvety-pro-servisnyjj-flou-samokatov/

## Что есть

1. Поднятый бэкенд Драйва (scooter-backend)
2. Отдельный сервис на uservices (scooters-misc)
3. Карго (cargo-orders)
4. Сервис связи с аккумуляторными шкафами (scooter-accumulator)
5. Приложение ПРО

Нужно все это связать воедино и менять эффективно менять аккумуляторы

## Часть 1. Аккумулятор сел

Данные о заряде аккумулятора каждого самоката постоянно отгружаются в SaaS через сервис телематики (scooter-telematics). Сенсор - CAN_FUEL_LEVEL_P (код 2107).

В Драйве есть механизм роботов - процессов, которые могут запускаться раз в какой-то промежуток времени (или по расписанию) и выполнять какую-то произвольную логику. Есть довольно универсальные роботы, которые можно использовать для разных целей. Один из таких - **sensor_to_tags**. Этот робот может следить за значением какого-либо сенсора у какого-либо подмножества машин и ставить на эти машины нужные теги.

Значит, когда аккум сел до определенного уровня, нужно поставить ему опеределенный сервисный тег с приоритетом > 0<sup>*</sup>. Например, **battery_low**.

> <sup>*</sup> если приоритет тега больше нуля, то он перекрывает теги, которые имеют приоритет ниже. Все теги цикла заказа имеют приоритет 0. Если на самокате висит тег с приоритетом выше нуля, то его нельзя взять в аренду обычному пользователю

В Драйве сделано интересно - они ставят теги на каждый порог уровня бака - battery_low_60, battery_low_40 и тд. Возможно это имеет смысл делать и у нас.

## Часть 2. Поставить задачу на замену аккума в севшем самокате

> Мы тут хотим интегрироваться с карго и пописать немного кода. Писать код в беке Драйва не хочется. Вся логика после проставленного тега о севшем аккуме будет в сервисе scooters-misc.

Есть 2 способа в стороннем сервисе узнать о севшем аккуме (ака push и pull модель в solomon):

1. Написать робота в Драйве, который будет периодически отслеживать самокаты с тегом battery_low и пушить его в scooters-misc.
2. В самом scooters-misc поллить ручку `car/list` и вынимать самокаты с фильтрацией по тегу

Предположительно выбираем **2 вариант** потому что не надо писать код в Драйве и в поллинге ручки нет ничего плохого.


Нам нужно как-то помечать самокат в беке драйва, что он взят в процесс замены аккума. Можно это разрулить отдельным тегом. Например, **recharge_processing**.

Тогда будем дергать ручку `car/list` вот с таким условием: `tag:battery_low and not tag:recharge_processing`. Ручка car/list позволяет задавать tags_filter с несложным синтаксисом (`low_battery*-recharge_processing`).

Когда в ответе ручки `car/list` получен разряженный самокат, дергаем `car/info` для каждой полученной машины чтобы получить уникальный идентификатор тега. Создаем в таблице `items` новый элемент с идентификатором `car_id/tag_id` (без уникальным для одной перезарядки). Если такое уже есть, то случилась гоночка (тег `recharge_processing` еще не поставили, а в базе уже записали). Просто скипаем этот самокат.

Внутри самой STQ создаем заявку в cargo:

1. Достаем из конфига все лавки/гаражи с геопозициями. Разговоры про гаражи уже идут. Предлагаю тут сделать составной ключ: `grocery:123` и `garage:321` для какой-никакой дифференциации. Ну и чтобы не было повторяющихся ID никогда.
2. Сортируем полученные сторы (stores) по удаленности от разряженного самоката. Можно использовать [что-то простое](https://www.geeksforgeeks.org/program-distance-two-points-earth/) или воспользоваться какой-то таксишной либой (пока не знаю какой, но уверен, что такая есть).
3. Делаем запрос к `scooter-accumulator/scooter-accumulator/v1/cabinet/accumulator/available_for_booking` и передаем туда `store_ids` списком чтобы получать данные о доступности заряженных аккумуляторов в каждом сторе.
4. Каждому store_id соответствует cabinet_id (шкаф с аккумуляторами). Выбираем самый ближайший (до какого-то N) кабинет с доступным свободным аккумом. Стоит тут передавать алгоритм с параметрами через эксперимент: `{method: nearest_with_available_acc, params: {max_distance_km: 20, max_walk_min: 60}}`
5. Букаем ячейку в выбранном кабинете запросом `scooter-accumulator/scooter-accumulator/v1/cabinet/accumulator/book`. Передаем CabinetId, AccumulatorsCount=1. Ручка возвращает BookId. Добавляем этот ID в базу. Если бук не удался (кто-то уже забукал все ячейки), то переходим к другому кабинету в соответствие с параметрамами алгоритма.
6. Создаем заказ в cargo. В качестве `items` передаем один аккумулятор, в `extra_id` пишем идентификатор из таблицы `tasks`. Пишем настоящий вес. Это позже может упроситить диспатч. Отдаем 3 точки в `route_points`: A - точка кабинета, B - точка самоката, С - точка кабинета (равна точке A). Для точки с типом destination передаем external_order_id. Запрос в cargo идет с ретраями и токеном идемпотентности. Если после всех ретраев ничего не вышло, разбукиваем аккум и перепланируем задачу с задержкой. После создания заявки проставляем `CargoOrderId` у задачи. Важно создать заявку с route_points[].skip_confirmation = False чтобы не было подтверждений по смс.
7. Остальной процессинг происходит в компоненте, который вычитывает события по заявке через ручку [/v1/claims/journal](https://yandex.ru/dev/logistics/api/ref/v1/claims/IntegrationV1ClaimsJournal.html). Компонента - это периодик с дистлоком, который с какой-то периодичностью запрашивает ручку журнала и обрабатывает новые события. Ручка возвращает курсор. Его нужно хранить в базе.


> Один разряженный самокат равен одной заявке в cargo. Так делать лучше потому что в карго много информации об испольнителях и вообще диспатч делают они. В дальнейшем так будет эффективнее делать диспатч.


**Схема базы данных scooters-misc**

![](static/01_cargo_integration/scooters-misc-db.png?v2)


## Часть 3. Этапы цикла заказа в cargo и взаимодействие с Про

Все этапы описаны в https://yandex.ru/dev/logistics/api/about/claim-process.html

**estimating_failed**

Такого кода быть не должно. Значит что-то не так сконфигурено.
Написать CRIT в логи.

**failed**

- разбукать аккум и удалить BookId
- удалить CargoClaimId из задачи
- зашедулить stq на попозже
- написать CRIT в логи

**ready_for_approval**

Нужно безусловно подтвердить заявку через запрос к [/v1/claims/accept](https://yandex.ru/dev/logistics/api/ref/v1/claims/IntegrationV1ClaimsAccept.html).

Это обязательный шаг. Предполагается, что пользователь соглашается с ценой или нет. Мы просто будем всегда соглашаться.

**performer_not_found**

- разбукать аккум и удалить BookId
- удалить CargoClaimId из задачи
- зашедулить stq на попозже

**performer_found** (статус в таксометре: **new**)

- проставить `performer_id` в локальной таблице
- сделать запрос к `scooter-accumulator/scooter-accumulator/v1/cabinet/booking/set_contractor` и выставить контрактора, который будет забирать аккумулятор
- установить в scooter-backend перформера сервисному тегу для истории: `car/details` и `servicing/start`.


**pickup_arrived** (статус в таксометре: **new**)

Здесь нужно дергать ручки открытия шкафа

Возвращаем тут специальный action в ручке `cargo-orders/driver/v1/cargo-claims/v1/cargo/state`:

```json
{
    "type": "battery_exchange"
}
```

Клиент по нему рисует кнопку "Получить аккумуляторы". При нажатии на кнопку открывается новый экран, который отрисовывается [конструктором](https://wiki.yandex-team.ru/taxi/backend/taximeter/constructor/).

[Библиотека конструктора для uservices](https://github.yandex-team.ru/taxi/uservices/tree/develop/libraries/taximeter-constructor)

При открытии экрана клиент дергает `scooters-misc/taximeter/screens/v1/battery_exchange/status?cargo_ref_id=<str>`:

*Ответ*

В ответе мы должны вернуть счетчики (сколько уже получено и сколько еще осталось получить аккумуляторов), плюс кнопку для получения следующего аккумулятора.

Когда все аккумуляторы получены, нужно вернуть кнопку закрытия экрана или сообщение о том, что нужно закрыть экран и сдвинуть слайдер (TODO формат конструктора с @einmalfel)

```json
{
    "constructor_items": [
        ...
    ]
}
```

Для того чтобы курьер мог открыть очередную ячейку, нужно дернуть ручку `POST scooters-misc/taximeter/screens/v1/battery_exchange/open?cargo_ref_id=<str>`

`scooters-misc` сам решит, какую ячейку сейчас нужно открыть.

*Ответ*

В ответе мы вернем конструктор с двумя кнопками: "Аккумулятор получен" и "Ячейка не открылась".

Нажатие на "Аккумулятор получен" должно дернуть ручку `.../status` чтобы отрисовать экран для получения следующего аккума.

Нажатие на "Ячейка не открылась" должно дернуть `POST scooters-misc/taximeter/screens/v1/battery_exchange/broken?cargo_ref_id=<str>&cell_id=<str>` и сразу после дернуть `.../status`. Эта ручка помечает ячейку сломанной. Ручка `open` больше не будет пытаться открыть сломанные ячейки. Когда останутся только сломанные, ручка `status` должна вернуть сообщение "Невозможно открыть N ячеек. Обратитесь к кладовщику". Кладовщик руками даст курьеру аккумуляторы и как-то их пометит через telegram-бот. При валидации на `exchange/init-confirm` эти аккумы будут валидироваться нормально.

При таймауте ручка `open` должна прислать `4xx` код ответа. Клиент покажет модалку "Повторите еще раз".

Если сервис scooter-accumulator пятисотит, то мы ничего никому не даем. Включаем ручной режим и отменяем заказ руками. Или быстро поднимаем scooter-accumulator.

В одном шкафу нельзя открыть одновременно больше одной ячейки. Если произошла "гонка курьеров", то ручка возвращает код 409. Приложение при этом должно показать закрываемую модалку о том, что нужно дождаться очереди.

```json
{
    "constructor_items": [
        ...
    ]
}
```

При передвигании слайдера "Забрал все аккумуляторы" происходит проверка, что все аккумы забраны и ячейки закрыты. Если что-то не так, то выдается сообщение.

**pickuped** (статус в таксометре: **delivering**)

Курьер идет к самокату. В этом статусе нужны 2 вещи:
1) Посигналить чтобы найти самокат в куче
2) Кнопка "Самоката нет", означающая, что самокат сперли

```json
{
    "actions": [
        {
            "type": "find_vehicle"
        },
        {
            "type": "vehicle_not_found"
        }
    ]
}
```

Экшн `find_vehicle` дергает захардкоженную ручку `POST scooters-misc/taximeter/v1/find_vehicle?cargo_ref_id=<str>&point_id=<int:current_point.id>`

Или можно присылать в экшне последнюю часть урла (TODO:@einmalfel)

Экшн `vehicle_not_found` дергает ручку `POST scooters-misc/taximeter/v1/vehicle_not_found?cargo_ref_id=<str>&point_id=<int:current_point.id>`, а затем дергает все остальные как будто бы аккумулятор заменен

> Все равно у нас флоу зацикливается на возврате в лавку. В этом кейсе получится, что мы просто вернем в лавку заряженный аккум, если не смогли поменять его в самокате. Ручку дергать обязательно так как при переводе слайдера будет валидацию и нужно в беке поставить тег, что самоката нет :(

**delivery_arrived**  (статус в таксометре: **delivering**)

Здесь нужно дергать ручки открытия деки самоката и подтверждения замены аккума. Здесь будет 2 экшна:

1) Открыть батареный отсек для замены аккума
2) Ремонт

```json
{
    "actions": [
        {
            "type": "open_battery_door"
        },
        {
            "type": "vehicle_destroyed"
        }
    ]
}
```

Экшн `open_battery_door` дергает ручку `POST scooters-misc/taximeter/v1/open_battery_door?cargo_ref_id=<str>&point_id=<int:current_point.id>`. Если дека не открывается, то курьеру нужно будет решить это через кнопку "Ремонт".

Экшн `vehicle_destroyed` дергает ручку `POST scooters-misc/taximeter/v1/vehicle_destroyed?cargo_ref_id=<str>&point_id=<int:current_point.id>`, а затем дергает все остальные как будто бы аккумулятор заменен. Обоснование тут такое же как в `vehicle_not_found`.

При передергивании слайдера "Аккумулятор заменен" происходит проверка, что в самокате стоит другой аккумулятор (по ID) с полным зарядом.

**pickuped** (вторая точка)

Этот статус возникает, когда курьер поменял аккум и пошел к другому самокату или в Лавку. Здесь нужно убрать с самоката теги `recharge_processing` и `battery_low`. Сначала нужно убрать `battery_low`, потом сделать запрос на `servicing/finish` и затем убрать `recharge_processing`. Самокат снова станет доступен для аренды.

**delivery_arrived** (для второй точки)

Здесь все совпадает с флоу получения аккумов.

**delivered** (статус в таксометре: **complete**)

Весь флоу прошел. Курьер вернул разряженный аккум в Лавку.
Нужно снять перформера с аккумулятора через `scooter-accumulator`.

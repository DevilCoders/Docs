## Ремонт самокатов

* эпик – https://st.yandex-team.ru/SCOOTERDEV-1104
* Задача на первом этапе - https://st.yandex-team.ru/SCOOTERDEV-1105
* тикет-ресерч – https://st.yandex-team.ru/SCOOTERDEV-1197

### Проблема/задача
* **Рабочий-ремонтник не имеет доступа к админке**. Поэтому чтобы провести дианостику, он пишет в специальный чат, где живые люди из небольшой команды за него выполняют нужные команды руками. Слишком много ручных действий
* **Нет никакой истории** того, какой ремонт проводился с самокатом, сколько времени это занимает. Нет возможности провести аналитику в разрезе одного самоката, или в разрезе ремонтника-рабочего.


### Как сейчас
На каждом складе учёт ведется либо в тетрадке, либо в  execel.

### Цель
* Создание истории ремонта самоката. После этого сможем строить разные статистики и оптимизировать труд ремонтников и сокращать время простоя самокатов
* Сократить метрику времени ожидания ответа до 0, дав возможность ремонтникам самим выполнять ограниченный набор команд над самокатом.

### Решение
Нужно создать сервис ```scooters-ops-repair```, который будет реализовывать флоу ремонта.
Через него можно будет начать ремонт самоката, выполнить несколько работ по ремонту-замене конкртеных узлов, и завершить ремонт.

Начало-завершения каждого ремонта и каждой работу будет сохраняться в базу - так мы сможем построить разные статистики.

Также нужна ручка, которая предоставляет информацию о самокате - пробег, дату последнего ремонта, версия прошивок и пр.

Для того, чтобы снизить количество ручных действий в существующем сервисе ```scooters-ops``` сделаем ручку, через которую можно будет управлять самокатом.
По хорошему, мы должны проверить, что ремонтник находится на смене, прежде чем дать доступ к этой рукчке. Но на первом этапе, мы будем логировать все действия с этой рчкой.

Между сервисом и ремонтником будет прослойка в виде ScooterAccumulatorBot.(Про него речь в конце)

### Источники данных о поломках
Данные получаем от энерджайзеров (через саппорт энерджайзеров) и от пользователей (через саппорт пользователей).
Данные проставляются в тэг ```broken``` в свободном формате.

БУдем опказывать эту информацию ремонтникам

### Схемы данных сервиса
Схему данных сделал на подобии заказ-наряда из автосервиса:
* заказ-наряд, где указан дата, исполнитель, заказчик.
* инфориация об автомобиле: марка, номер, пробег.
* список выполненых  работ.
* список запчастей - пока это пропустим


![](static/ops-repairs/scooters_repairs_db.png)

### Ремонты (repairs)

```place_id``` - айди склада. Каждый склад является лавкой и они уже заведены, так как на складах есть точки зарядки.

Статусы ремонта
- исполняется - performing
- отменена - cancelled
- провалена/не может быть исполнена - failed
- выполнена - completed

### Работы (jobs)

Статусы работ
- исполняется - performing
- отменена - cancelled
- провалена/не может быть исполнена - failed
- выполнена - completed

Типы работ
* Оклейка
* Регулировка тормозов
* Крылья( замена/ ремонт)
* Люфт стойки( подтяжка/ замена подшипника/
* Катафоты( замена)
* Порванный трос тормоза( замена)
* Даш Борд/ контроллер( замена/ ремонт)
* Подножка( замена/ремонт)
* Замок парковки( замена/ремонт)
* Грипсы( замена/ очистка)

### Слкад

### Ручки
#### Ремонт
1. ```/repair/start``` - начало ремонта
    ```json
    {
        "repair_id": "", -- выступает токеом идемпотентности
        "performer_id": "",
        "vehicle_id": "",
        "place_id": "" -- айдишник склада
    }
    ```
    * Проверяем, что на исполнителе нет активных работ, создаём в базу сущность, проставляем начальный статус и записываем время начала работы
    * Сохраняем в базу информацию о самокате перед началом ремонта (Пока только пробег)
    * Возвращаем 200/4XX

2. ```/repair/end?repair_id=``` - заверешение ремонта самоката
    - Проверяем, что все работы выполнены, переводим работу в терминальный статус. Записываем время

3. ```/repair-job/start``` - Начало работы над ремонтом/заменой одного узла
    ```json
    {
        "repair_id": "",
        "job_id": "", -- выступает токеом идемпотентности
        "type": "" -- тип работы из ограниченного списка
    }
    ```
    * При началае работы создаем сущность, если еще не, проставляем статус и записываем время начала
    * Тип работ из огранчиенного списка

4. ```/repair-job/end?job-id=``` - Окончание работы
    * Переводим работу в правильный статус и записываем время окончания

#### История ремонта самоката
```/scooter/repair-history?vehicle-id=```
* Ручка вернёт инфорацию о последних ремонтах (тип ремонта и исполнитель) и более подробную информацию о последнем ремонте (тип, время полсденего ремонта, пробег с последнего ремонта)


#### Информация о самокате
```/scooter/info?vehicle-id=```
* Ручка в сервисе ```scooters-ops```.
* Будет брать информацию из двух источников
    * Номера прошивок всех блоков - можно достать из api/taxi/car/details
    * Информвцию о ремонтах - из ручки выше
    * Комментарий из тэга "broken"


#### Управление самокатом
```/scooter/info?vehicle_id=&action=```
* эту ручку сделать в scooters-ops. Там уже есть ручки для сигналаи открытия дэки
* Будем дёргать ручку api/taxi/car/control
* Действия из ограниченного списка
    * открытие деки
    * фонарик/дека
    * запуск Self-test самоката(?)
    * открыти замка
    * блокировка/разблокировка колеса
* На первом этапе слоэно будет реализовать
* Так как по сути это ручка рута, то все действия с самокатом будем логировать в отдельную таблицу.

### Точки отказа
* Бэкенд драйва, в который будем ходить для управления самокатом и для получения информации о самокате.

### Фолбэк
Фолбек не предусмотрен. В случае проблем ремонтники перейдут на старую схему с записью в тетрадку и чат в телеграме.



---
### Работа с ботом
Взаимодействие с пользоваетелем будет реализовано через **scooter-accumulator-bot**. Предложенны флоу, отлично ложится на существующего бота

Для этого в SAB добавим новый тип пользователя ```REPAIRER```. (Такой тип уже есть, надо понять, можно ли его использовать)

В таблицу со стейтом пользователей добавим новые колонки про ремонт - ```repair_id```, ```job_id```, ```place_id``` и . Так же расширим enum со стейтами.

```place_id``` будем запрашивать на отдельном шаге, если у ремонтника не указан. Валидировать будем через scooters_misc


Весь флоу в боте будет выглядеть примерно так:
https://miro.com/app/board/uXjVOxjesGg=/ .
Оранжевым цветом вуказано в каком стейте будет находиться пользователь на данном экране.

![](static/ops-repairs/scooters_repairs_bot_flow.png)


### Интеграция полевого ремонта в ПРО
Полевой ремонт в про вижу так:
создается миссия с точками-самокатами.
При прибытии на точку, исполнитель нажимает начать работу и открывается экран с ремонтом самоката. Этот экран уже взаимодействует с scooters-ops-repair. После окончания ремонта, идёт возврат на экран миссии. Там работник подтверждает, что работа подтверджена, дёргается ручка нового сервиса, который подтверждает, что всё выполнено.


### Вопросы
* Как хранить типы работ и добавлять новые? Можно хранить типы работ в конфиге. Этот конфиг будет читаться в SAB и по нему будут строиться кнопки.
* Бот должен быть доступен только для тех, кто находится на смене. Как это сделать?


----
### Оценка первого этапа работ
1. Архревью + аведение нового сервиса ```scooters-ops-repair``` (1-2д ассинхронно)
2. Создание Таблиц + написание простой логики ручек (2-3д)
3. Написание логики в боте (6д)



### Следующие шаги
1. Интеграция с сервисом смен, чтобы доступ к боту был только, когда человек находится на смене
2. Получение жалоб на самокат из миссию по релокации. В новом ПРО исполнители смогут указывать, какие проблемы они увидели.
2. Автоматизация вывоза самокатов со склада и завоз сломанных самокатов на склад. Сейчас делается руками, но можно создавать драфты на забор самокатов с определнным тэгом, и на последующий развоз их по городу
3.

## Платформа миссий

### Проблема/задача

В операционке самокатов есть следующие задачи:

1. Замена батарей
2. Разнообразная релокация самокатов
3. Мелкий ремонт самоката прямо в городе

Каждая из этих задач - это маршрут обхода каких-то точек и проделывание какой-то работы в этих точках.

Все эти кейсы хорошо обобщаются в следующие сущности:

1. Точки на карте (points) - самокаты, лавки, парковки и прочее
2. Задачи (jobs) - единица работы, которую нужно сделать в конкретной точке
3. Маршрутные листы ака миссии (missions) - это набор упорядоченных точек (points),
    по которым нужно пройтись чтобы совершить какую-то работу в каждой точке


Сейчас в `scooters-misc` все описывается `recharge_task` и `recharge_item`, на что не совсем ложатся
другие задачи (релокация) плюс нет возможности делать несколько задач в одной точке.


Далее будет описан подход на основании описанных сущностей для решения задач операционки


### Схемы данных

![](static/ops-missions/scooters-ops-db.png?v=3)

В процессе разработки что-то может добавиться.


### Работы (jobs)

Статусы работ

- создана - new (default)
- preparing - выполняются действия до начала работы (бронирования аккумуляторов)
- запланирована - planned
- исполняется - performing
- отменена - cancelled
- провалена/не может быть исполнена - failed
- выполнена - completed

#### 1. Получение аккумуляторов (pickup_batteries)

В рамках задачи курьер должен получить аккумуляторы из автоматизированного
или ручного шкафа.

*typed_extra*

```
{
    "bookings": [
        {
            "booking_id": "<uuid>"
        },
        ...
    ]
}
```

*Предварительные действия*

1. Забронировать ячейки с заряженными аккумуляторами


*ЦЗ*

Во время отрисовки экранов будем дергать сервис scooter-accumulator чтобы не было проблем синхронизации состояний между сервисами. Состояние бронирования хранится только в scooter-accumulator

#### 2. Возврат аккумуляторов (return_batteries)

В рамках задачи курьер должен вернуть аккумуляторы

*typed_extra*

```
{
    "bookings": [
        {
            "booking_id": "<uuid>"
        },
        ...
    ]
}
```

*Предварительные действия*

1. Забронировать пустые ячейки для сдачи аккумуляторов

#### 3. Получение снасти (pickup_tackle)

Снасть выдается одна на одну миссию. В typed_extra ничего не храним.
Состояние снасти сохраняется в отдельных таблицах так как scooter-ops является владельцем снастей

#### 4. Возврат снасти (return_tackle)

Аналогично предыдущему пункту

#### 5. Воскрешение самоката (resurrection)

По типу задачи отрисовываем нужные экраны в Про.
Какой-то дополнительной информации на первый взгляд не нужно

Для этого типа работы в миссии должна предшествовать работа с типом `pickup_tackle`

#### 6. Замена батареи (battery_exchange)

В результате задачи курьер должен заменить батарею в самокате.
При замене нужно проверить уровень заряда. Если он не стал выше порога, значит курьер ничего не сменил.

Были попытки проверять смену SN аккумулятора, но заряд надежнее так как заряд присылается самокатом каждый heartbit, а SN только при смене и может потеряться

*typed_extra*

```
{
    "battery_level_before": 10
}
```

Для этого типа работы в миссии должна предшествовать работа с типом `pickup_batteries`


#### 7. Забрать самокат для релокации (pickup_scooter)

Курьер должен отсканировать QR на самокате и поместить самокат в кузов

#### 8. Выгрузить самокат (dropoff_scooter)

Курьер должен отсканировать QR на самокате и выгрузить самокат в заданной точке (или парковке).


### Точки (points)

Типы

1. scooter - самокат

```
{
    "scooter_number": "1234",
    "scooter_id": "<uuid>"
}
```

2. depot - лавка

```
{
    "id": <str>
}
```

3. warehouse - склад

```
{
    "id": <str>
}
```

4. parking - размеченная парковка самокатов

```
{}
```

Статусы

- planned - запланированно посещение данной точки
- arrived - исполнитель прибыл в эту точку и выполняет какую-то работу
- skipped - точка пропущена по какой-то причине
- cancelled - точка отменена со стороны сервиса
- visited - точка посещена


### Миссии

Статусы

- created - создана
- preparing - производятся подготовительные операции для выполнения работы (бронирование аккумуляторо, снастей и прочее)
- wait_performer - ожидание принятия заказа в Про.
- performing - миссия принята исполнителем и выполняется
- cancelling - миссия отменяется
- failed - миссия провалена (отменена или еще что)
- completed - миссия выполнена

Предполагаемый граф переходов статусов миссий

![](static/ops-missions/mission-flow.png)


Маппинг статусов карго на статусы миссий

- new, estimating, ready_for_approval, accepted -> preparing
- performer_lookup -> wait_performer (кажется это не будет так как у нас будет прямое назначение на курьера)
- performer_found, pickup_arrived, ready_for_pickup_confirmation, pickuped, delivery_arrived, ready_for_delivery_confirmation, delivered -> performing
- delivered_finish -> completed


Но даже если многие статусы маппятся в performing мы обрабатываем каждый апдейт и обновляем другие сущности. Например, когда курьер проходит какую-то точку, мы ставим статус visited у point.


### Кейсы использования

1. Создание миссии на перезарядку

Сервис диспатча знает все о самокатах и создает собранную миссию в сервисе.
Делает запрос

```
POST /scooters-ops/v1/missions/create?mission_id=<uuid|idempotency-token>

{
    "performer_id": <db_uuid>,
    "points": [
        {
            "id": "<uuid>",
            "type": "depot",
            "jobs": [
                {
                    "id": "<uuid>",
                    "type": "pickup_batteries",
                    "payload": {
                        "pickup_count": 3
                    }
                }
            ]
        },
        {
            "id": "<uuid>",
            "type": "scooter",
            "payload": {
                "scooter_id": "<uuid>"
            },
            "jobs": [
                {
                    "id": "<uuid>",
                    "type": "exchange_battery"
                }
            ]
        },
        {...},
        {...},
        {
            "id": "<uuid>",
            "type": "depot",
            "jobs": [
                {
                    "id": "<uuid>",
                    "type": "return_batteries",
                    "payload": {
                        "return_count": 3
                    }
                }
            ]
        },
    ]
}
```

В ответ получает id миссии.
После создания миссии начинается её процессинг.
Сначала для всех входящих работ в миссию делается подготовительная работа. На этом этапе
миссия может быть отменена. Об этом должен узнать диспатч.



TODO: возможно тут хорошо использовать procass


### 2. Замена точки в миссии

Диспатч находит более оптимальную следующую точку для миссии.
Делает запрос

```
POST /scooters-ops/v1/missions/replace-point?mission_id=<uuid>&point_id=<uuid>&revision=<int>
    "point": {
        ...
    }
```

Сервис проверяет возможна ли отмена текущей точки. Если курьер уже к ней идет, то нет. Если возможна, то точка помечается как cancelled. Отмена синхронизируется с карго - помечаем точку отмененной у них (карго подтвердили что такая возможность есть, конкретные ручки надо уточнить)

Также проверяем, что у работ (jobs) новой точки может быть выполнен подготовительный этап. Если все ок, то точка добавляется с тем же порядком, что был у старой точки.

Так как в этом месте много подвижных частей (карго, отмена, добавление), то все это стоит делать асинхронно (например, через procaas). Диспатч должен сказать "заменить точку", а ответ должен дойти до него асинхронно.


### Про ревизии сущностей

Ревизия задачи (job) инкрементится, если

- меняется status
- меняется performer_id
- меняется typed_extra


Ревизия точки (point) инкрементится, если

- меняется status
- меняется typed_extra
- меняется порядок или состав работ в рамках точки

Ревизия миссии (mission) инкрементится, если

- меняется status
- изменяется performer_id
- меняется порядок или состав точек в миссии


Ревизия всегда инкрементится при изменении typed_extra. При этом в typed_extra может быть много данных. Если нужно изменить typed_extra в нескольких местах, то нужно это делать за одно обращение к базе и соответственно менять ревизию один раз. Например, в typed_extra будут храниться бронирования аккумов. Нужно сначала забронировать все, а потом записать typed_extra и поднять ревизию


### Про missions_history

При изменении ревизии любой сущности должна быть запись в историю с объяснением причины поднятия ревизии. Чаще всего это будет происходить при изменении статуса. В typed_extra записи истории нужно написать как минимум из какого статуса в какой перешла сущность.


### Про исполнителей

Предполагается, что диспатч будет сразу искать исполнителя на миссию. Диспатч будет сразу при создании миссии передавать ID исполнителя. Однако поле performer_id у миссии будет опциональным.

Это нужно для ручного создания миссий и для периода, когда диспатч еще не будет уметь подбирать исполнителя (но скорее для первого).


### Про идемпотентность

Ранее мы в качестве токенов идемпотентности использовали комбинации идентификаторов тегов и vehicle_id. Только mission_id является токеном идемпотентности. Идентификаторы других сущностей - это uuid. При отмене ничего не удаляем.

### Ручное создание миссий и черновики

Есть кейс, когда мы хотим делать ручную релокацию. Выглядит это как ручное создании миссии. Кажется, что для пользователя заполнять все сущности руками - это большой оверхед. Плюс мы наверняка захотим как-то батчить хотелки менеджеров в более оптимальные маршруты обхода.

Тут появляется концепция черновиков.

Все описанные выше сущности хорошо описывают тот процесс, который происходит при прохождении цикла заказа. Все то, что происходит до создания миссии понятно плохо.


Есть ряд вопросов, на которые можно ответить черновиками

1. Как сделать ручное создание задач?
2. Как диспатчу управлять тем, что к одному самокату не приедет 2 курьера?
3. Как не размазывать логику работы с тегами Драйва по разным сервисам?
4. Как представить задачу релокации в виде точек и работ до создания миссии?


Примерная схемы выглядит вот так:

![](static/ops-missions/drafts.jpg?v=1)


Ключ идемпотентности драфта - это draft_id. Его составляем как и раньше как конкатенацию vehicle_id/tag_id. Для созданных вручную задач будет просто uuid генеренный на фронте. Для задач релокации нужно лочить самокат, то есть навешивать на него тег. Tag_id тут тоже будет.


Драфты будем отдавать диспатчу через ручку с курсором (created_at, draft_id). Ручка будет отдавать все драфты в статусе new.


Статусы драфтов:
- new
- assigned
- cancelled


### Шаги имплементации

- Можно заводить драфты разных типов
  - Создать таблицы, модели и реализовать ручку создания драфта
- Заводятся драфты на recharge и dead (copy paste логики из scooters-misc с небольшими изменениями)
- Можно создать миссию с точками, но без работ
  - Заводим все сущности (job, point, mission). Но при создании пока будет пустой список работ. Валидации тоже пока быть не должно
  - Есть ручка API. В нее надо передавать список драфтов и проверять много всякого
    - Без обратной связи (procaas). Просто ручка, которая добавляет что-то в базу
- Миссия превращается в заявку карго и прилетает на Про
  - После создания миссии начинается её процессинг
  - Формирование заявка карго с провязываением заявки карго с миссией и точками
  - Доработку в карго чтобы можно было создавать заявку сразу с исполнителем
- Можно пройти миссию без работ
  - Переносим и рефакторим логику вычитывания обновлений по заявкам из scooters-misc
  - В истории missions_history это все отображается
- Можно пройти миссию перезарядки самокатов
  - Реализованы все нужные для миссии работы (jobs)
    - Буки аккумов и вот это все
  - Работает отмена миссии (валидно только тут это сделать так как только тут появятся первые работы)
  - Перенесены валидации переходов
- Есть механизм отдачи драфтов другим сервисам. Скорее всего это будет какая-то ручка с курсором, но это не точно

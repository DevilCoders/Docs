# Вынос депозитов из Драйва

Основных целей, к которым хочется прийти после выноса депозита 2:
* возможность списывать депозиты в любом количестве (можем включить на 100% и не переживать, что не вывозим)
* сократить p90/p95/p98 холда депозита

## Как работают списания сейчас:
Биллинг цикл Драйва итеративно берет пачку платежей, идет с ними в Траст, в зависимости от их текущего статуса дергает нужные ручки и обновляет статусы. Когда депозитов в цикле становится много, его продолжительность увеличивается -> частота "поллинга" платежа на предмет авторизации уменьшается (фактически происходит поллинг раз в iteration_time(10-20) секунд)

## Как они могут работать вне Драйва:
Все платежи независимы, интервал поллинга каждого из них не зависит от общего количества

## Кандидаты на замедление
* процессинг (обработка платежа 10-12с в p95*) - тут пространство для оптимизаций минимальное. Сейчас живем на процессинге ``Yandex.Money New Card API`` (по неподтвержденным данным он достаточно быстрый*). Его можно сменить, если есть более быстрые кандидаты, но там могут быть еще и другие комиссии, поэтому вопрос не только технический.
* trust (обработка платежа 15-20c в p95*). Включает себя обработку процессингом, поэтому чистое время Trust'а ~ 3-10 секунд. Есть пространство для оптимизаций, у Траста нет свободных ресурсов для них.
* drive (обработка платежа до 15-40с в p95). Основное отличие от времени Траста из-за устройства биллинг цикла, платеж может авторизоваться, но наш бекенд нескоро об этом узнает

\* все, что отмечено звездочкой, я выяснил в личке с разработчиком из группы платежей, но графиков не видел, т к нет доступов

Переписывание на transactions может сократить нам потери Драйва, но не сократит потерь в trust'е и процессинге (т е можем получить p95 40 -> 20 путем более частого поллинга)

## Бонус
Сейчас команда платежей активно внедряет [PSP](https://wiki.yandex-team.ru/psp/) в transactions. Насколько я понял, это замена Трасту, потенциально работает быстрее, но насколько именно никто не знает. Реалистично в текущем сезоне нам это не поможет

## Что в итоге
* оптимизации Траста позволят в относительно короткой перспективе уменьшить общее время на 3-10 секунд, но из-за планов переезда на PSP в долгосрочной перспективе это не имеет большого смысла
* переезд на transactions позволит:
  * а) переиспользовать часть Такси-инфраструктуры платежей
  * б) перейти на PSP после поддержки без доработок
  * в) устранить замедление на стороне Драйва
* реалистичной оценкой выглядит p95 < 20c после переезда на transactions

### Варианты реализации:
#### Мимикрировать под Драйв
* с точки зрения таблиц в БД все выглядит как обычно
* единственное отличие: биллинг цикл не ходит с депозитами в траст
   
Детализация:
* написать походы в transactions [1w]
* написать логику, которая будет запускать платеж, следить за его состоянием [1w]
* прокинуть информацию о статусе платежа в базу scooter-backend [2w]
* раскатка [1w]
* добавить флажок внешнего депозита в оффер и billing task, не брать такой платеж в billing cycle [1w]
* подумать про саппорт-флоу (в админке нужно видеть депозиты и уметь их возвращать)

Минусы: 
* сложная часть с редактированием табличек как-биллинг-цикл, которая в будущем и не нужна

#### Написать походы сбоку
* в Драйве совсем выключить депозит
* в api-proxy-tag-evolve получать информацию о статусе платежа не из Драйва, а из наших ручек
* после завершения аренды всегда возвращать депозит
* подумать про саппорт-флоу (депозиты всегда возвращаются -> саппортам надо видеть только факт их наличия и (в идеале) статус депозита (захолдили/вернули/ошибка))

**Как можно обрабатывать депозит:**

* а. периодическая таска, следящая за сессией, схема взаимодействия: https://nda.ya.ru/t/i-34sQaS5DcKpH
  * инициирование депозита = постановка STQ-таски ``scooters_payments_session_processor`` после успешного бронирования scooters-offers-book (invoice create + update)
  * отслеживание статуса депозита = http-запрос ``evolve(old_state_riding) -> /payment/check`` (invoice retrieve) (не даем перевести самокат в поездку, пока платеж процессится)
  * анхолд платежа инициирует периодическая stq-таска после окончания сессии (окончание сессии определяется по ответу ``/sessions/current``) (invoice update + clear)
  * на каждом запуске ходит в ``/sessions/current``: нужно для старта платежей (получение методов оплаты поездки + проверить, не хочет ли Драйв внутри захолдить депозит), также пригодится, когда захотим списывать дискретизации вне Драйва (чтобы понимать, сколько стоит поездка в текущий момент)
  * время жизни STQ-таски ~ время жизни сессии. Она по ответу Драйва понимает, что сессия закончилась
* б. event-based вызовы, схема взаимодействия: https://nda.ya.ru/t/PIjrVRnW5DvUUC
  * инициирование депозита = вызов ручки ``/payment/start`` после успешного бронирования (invoice create + update)
  * отслеживание статуса депозита = http-запрос ``evolve(old_state_riding) -> /payment/check`` (invoice retrieve) (не даем перевести самокат в поездку, пока платеж процессится)
  * анхолд депозита = вызов ручки ``/payment/finish``(invoice update + clear)
  * ресайз/возврат (в будущем) = вызов ручки ``/payment/update`` (invoice update)
  * добавление промежуточных платежей можно реализовать безопасно с точки зрения гонок, т к invoice поддерживает версионирование

Плюсы способа (а):
* все платежи инициируются из одного места (в (б) депозит, промежуточные платежи, и анхолд будут инициироваться разными сервисами)

Плюсы способа (б):
* scooters-payments только проводит платежи, но не инициирует их (уменьшается зона ответственности)
* можно использовать общесамокатный источник окончания поездок (события в процессинге)

**Выбираем вариант (б)**

Детализация:
* написать походы в transactions [1w] (+2d на заведение на заведение сервиса)
* добавить обработку депозита [1w]  
* настроить возможности плавной раскатки + раскатка на команду [1w]
* собрать/починить баги, научиться работать с ошибками transactions [1w]

Edge-cases (во всех нижеперечисленных случаях считаем, что пользователь не виноват, и пускаем его в поездку):
* не удалось поставить таску / создать или обновить invoice к моменту перехода в поездку -> поездка будет без депозита
* сломался Траст -> депозит захолдится позже (если не захолдится, то мы пустим фродера)
* холд длится слишком долго (например, больше минуты) -> продолжаем холдить
* при любых ошибках ``/scooters-payments/v1/payment/check``, отличных от 402
  
Если любая из вышеперечисленных проблем имеет массовый характер, политика "пускаем пользователя" может быть пересмотрена

Полезные метрики:
* базовые метрики ручек и очередей
* время авторизации платежа

Минусы:
* сейчас мы не возвращаем депозит, если пользователь накатал на сумму > депозита, а в этом варианте будем -> возможен фрод (технически появляется возможность возвращать депозит после списания за поездку, но надо окнуть с продуктом). С другой стороны, в нем депозит мы сможем включить всем.

Второй вариант сильно проще, т к не нужно будет обновлять таблицы так, как делает Драйв. К тому же, это кажется более правильным вариантом долгосрочно. Предлагаю выбрать его.

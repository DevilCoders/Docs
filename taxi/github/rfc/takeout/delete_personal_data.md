## Задача

Необходимо реализовать в Такси удаление пользовательских данных для соблюдения GDPR. 
Мы должны удалять:
- персональные данные;
- данные, которые могут быть видны в приложении.

Мы не удаляем:
- некоторые данные, которые связаны с платежами
(в уже реализованном решении сохранялся статус блокировки пользователя за фрод, 
а при наличии у пользователя долга можно было отказать в удалении данных, из [TAXIBACKEND-19527](https://st.yandex-team.ru/TAXIBACKEND-19527));

Мы можем не удалять:
- исторические данные, которые хранятся в YT, если они не подтягиваются в приложение;
- некоторые технические данные, которые не являются персональными.

Данные предпочтительно удалить физически из баз.
Если мы не удаляем данные, то обезличиваем их и проверяем, что в приложении они не будут видны.

Описание api реализуемых общеяндексовских ручек [здесь](https://wiki.yandex-team.ru/users/yakushevsky/takeoutrequirements/)

Предварительно Еда и Лавка хранят данные по тем же uid, что и Такси, а данные Драйва с данными Такси не связаны, 
так что Еда и Лавка могут подключаться к takeout в Такси, а Драйв может завести свой.                                

## Предлагаемое решение

Можно реализовать удаление пользовательских данных на основе сервиса `takeout`.
Это можно сделать так:
- сервис `takeout` предложит api ручек, которые необходимо будет реализовать в каждом сервисе, 
который содержит персональные данные;
- сервисы будут подключаться к takeout самостоятельно 
(например, определять необходимость этого при прохождении архревью);
- в свою очередь, `takeout` релизует общеяндексовые ручки 
(удаления данных и получение статуса данных): получает список идентификаторов пользователя, 
передаёт в новые ручки и собирает ответ.

### MVP

На этапе запуска можно удалить:
1) данные из выгрузки takeout
2) данные, которые уже просили удалить (например, email пользователя; можно пробежаться по дьюти)
3) ещё какие-то core-данные, если обнаружатся при разборе существующих решений.

Данные других сервисов (Еда, Лавка) пока удалять не будем, но мы должны уметь быстро и легко подключать новые сервисы.

## Состояние сервиса `takeout` 

Сервис написан в py3, но достаточно давно, поэтому он на железе, без кодогенерации, с прямыми походами в базы.
Для того, чтобы с ним было удобнее работать, имеет смысл сделать техно и перевести сервис на кодогенерацию, 
перевезти его в облако, по возможности - изучить, где базы уже были закрыты сервисами,
и ходить через сервисы.

## Предлагаемое API ручек удаления и статуса данных

Ручки реализует у себя каждый сервис Такси, хранящий персональные данные.

Можно будет (не на этапе mvp) добавить автогенерацию этих ручек при создании сервиса
(аналогично `/ping`, по какому-то флагу).

### По каким идентификаторам можно определить пользователя

В запросе в `takeout` приходит `yandex_uid`. 
По нему нужно определить список идентификаторов пользователя и передать в ручки сервисов.
Возможные идентификаторы:
- phone id;
- user id;
- personal phone id;
- personal email id;
- сам yandex uid.

uid в запросе будет всегда портальным, если запрос пришёл от Паспорта. 
Фониш в запросе может прийти от админки, когда интегрируем с ней. 

Для запроса от Паспорта, вероятно, может найтись связанный фониш (пользователь был зарегистрирован по фонишу, 
потом зашёл через Паспорт), тогда удалим данные и по нему тоже.

### Категории данных

Для того, чтобы пользователь мог видеть, какие категории данных сервиса он может удалить, 
и выбирать для удаления отдельные категории данных, в api общеяндексовских ручек есть поля, 
в которых передаются категории.

Чтобы узнать доступные в сервисе категории, Паспорт будет вызывать `/1/takeout/status/`. 
Категории из ответа и будут показываться пользователю и предлагаться для удаления.

Общего списка возможных категорий для всех сервисов нет, сервис Такси сам определяет, 
какие категории данных он хранит и предлагает удалить.

Список категорий данных помогут составить юристы: https://st.yandex-team.ru/TAXIPROJECTS-1846#60142b2a70e66b1d718dbc41.
Пока будем считать, что у нас одна категория  - все персональные данные.
Мы сможем разработать решение, но для запуска в Паспорте надо будет убедиться, 
что мы не будем разбивать эту категорию, только добавлять новые, если потребуется.

Категории необходимо будет указать [здесь](https://wiki.yandex-team.ru/users/4ernyakov/takeout-2.0-integration/).
Текст, указанный для категорий, будет использоваться в интерфейсе пользователя, в ответе `/1/takeout/status/`
текстов нет.

Для корректного подключения Еды и Лавки к нашему takeout надо будет указать для них отдельные категории данных 
(например, Такси - 1, 2, 3, Еда - 4, 5, Лавка - 6) и записать их в табличку для Паспорта. 
Ручки будут общими для Такси, Еды, Лавки.
Паспорт должен сам суметь разделить категории по сервисам. 

Внутри `takeout` нет необходимости разбивать сервисы по категориям - можно передавать в сервис список категорий для удаления, 
сервис сам определяет, есть ли у него данные этой категории. 
Для оптимизации можно задать список категорий данных, которые требуется удалять из каждого сервиса, в конфиге, но это необязательно.

### api ручек для реализации в сервисах, подключающихся к takeout

api предложено [здесь](generic_takeout_delete.yaml)

### Сохранение статуса удаления

Для этого можно завести базу postgres внутри сервиса. 
В базе будет 1 таблица со столбцами:
uid пользователя (портальный, если есть) - сервис супераппа (Еда/Такси/Лавка) - категория данных - 
статус удаления (удаляется/удалено/ошибка удаления) - время, в которое статус был записан - 
ошибки, если есть.

### Флоу получения статуса данных по takeout

1. Паспорт запрашивает статус данных сервиса вызовом `/1/takeout/status/`.
2. Синхронно идём во все ручки `/status` подключенных сервисов. Отдаём ответ.

### Флоу удаления данных по takeout

0. Паспорт узнал статус данных вызовом `/1/takeout/status/`, чтобы определиться, какие данные можно удалять.
1. Паспорт вызывает `/1/takeout/delete/`
2. Проверяем, не запущена ли уж таска на удаление (статус "удаляется" в базе).
Если запущена - возвращаем OK. 
3. Ставим stq таску и возвращаем ОК, если до этого момента ошибок нет. 
Ключом таски будет uid пользователя, который сохраняем в базе.
В базу записываем статус "удаляется". 
Если таску не удалось поставить - возвращем в Паспорт ошибку.
4. В stq таске ходим в каждый микросервис, реализующий ручку удаления, и удаляем данные.
Порядок удаления данных может быть важен, на этапе mvp можно удалять в последовательности, 
заданной в конфиге.
Если всё успешно удалилось - пишем в базу статус "удалено". Это может пригодиться для разбора проблем и сбора статистики, 
какие данные когда удаляли.

Если в каком то сервисе данные удалились, а в каком-то - нет, 
таска будет полностью запущена повторно, 
состояние данных в отдельных сервисах хранить не будем.

Если в таске были ошибки, можно:
- посылать метрики;
- перезапустить таску (до какого-то количества раз);
- в базу записать ошибки удаления.
Более детально можно продумать на этапе разработки.

### Неполное удаление данных

В ситуации, когда какой-то сервис не смог удалить данные, можно оставлять статус данных "ошибка удаления", 
в базу сохранять ошибки.
в Паспорт возвращать ошибку с сообщением о том, какой сервис не смог удалить (позже обсудить с Паспортом, это уже детали).
Бесконечно ретраить на нашей стороне не надо - об этом договорились с Паспортом.
Количество ретраев зададим конфигом.

### Удаление данных через админку

Необходимо добавить удаление данных в админку. Новое решение должно быть не хуже уже реализованного 
(старое можно оставить под конфигом). 
Будет удобно, если решение сведётся к интеграции вызова новой ручки с админкой.

## Возможный план работы
1. Перевести сервис `takeout` на кодогенерацию
2. Реализовать новые ручки на примере сервисов в выгрузке `takeout`
3. Перевезти takeout в облако
4. Добавить вызов новой ручки удаления данных в админку
5. Рефакторинг ручки извлечения данных

## Алерты

Нужно следить за состоянием удаления данных - ситуация, когда сервис не может удалить данные по запросу, может требовать быстрого разбора.
Продумать алерты, которые помогут это отслеживать, можно позже, во время разработки.
Например, можно реагировать на время выставления статуса "удаляется".

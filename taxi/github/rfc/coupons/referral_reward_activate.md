## Описание ручки `referral/complete`
(запись успешной поездки по реферальному промокоду)

Ручка вызывается из stq-таски `referral_get` с аргументами:
- `order_id`
- `promocode`
- `yandex_uid (A)`

P.s. stq-таска `referral_get` ставится из процессинга при завершении поездки. В этой таске проверяется, что поездка была успешная + что был использован промокод + что промокод реферальный (в купоне прописана серия `_referral_`).

### Workflow ручки:

1. Работа с таблицей `referral` (ищем запись по `promocode`)  
   Обработка ошибки поиска: выкидываем log.error с соответствующим текстом и завершаем работу  
   (Далее писать про обработку ошибок не буду, она подразумевается по-умолчанию)

3. Запись в `referral_completions` (postgress). Поля записи:
  - `referral_id`
  - `yandex_uid (A)`
  - `order_id`
  - `created` = now()
  - (`id` - инкрементальное поле, проставляется автоматически)
  
  Если произошла ошибка вставки по уникальному индексу `order_id` - значит, произошел дубликат stq-таски, тогда log.warning, продолжаем работу.

4. Ставим stq-таску referral_generate_reward с параметрами:
    - `order_id`

## Описание stq-таски `referral_generate_reward`  
(выдача вознаграждения за нового реферального пользователя)

Stq-таска ставится из ручки `referral/complete` с task_id=order_id и аргументом `order_id`

P.s. порядок выполнения stq не важен, т.к. работа основана на порядке в таблице `referral_completions`

### Workflow stq-таски:

1. Проверка условий вознаграждения и получение `reward_token` +`series_id`
   
   1.1 [SQL] Вытаскиваем данные из `referral_completions` и `referral` (ищем запись по `order_id`)
       Если в записи уже есть значения `reward_token` и `series_id` (предыдущая таска их уже вычислила и записала), то переходим на шаг 2.  

   1.2 Достаем конфигурацию условий вознаграждения по `referral.cfg_id`

   1.3 [SQL] Вычисляем уникальных пользователей (yandex_uids), которые ранее совершали поездки по данному реферальному промокоду.  
       Для этого в таблице `referral_completions` делаем выборку `yandex_uids`: `referral_id` = `current_referral_id` и `id` < `current_referral_completions_id` + группировка по yandex_uid.
    ```SQL
    SELECT yandex_uid 
    FROM referral_completion 
    WHERE referral_id = current_referral_id AND id < current_referral_completions_id
    GROUP BY yandex_uid;
    ```
    P.s. id - инкрементальное поле, гарантируется СУБД.

   1.4 Проверка, что за этого пользователя не было вознаграждений  
       Подразумевается, что не было предыдущих реферальных поездок у этого пользователя  
       Если пользователь есть в yandex_uids, то log.info и завершаем работу

   1.5 Вычитываем планируемое вознаграждение  
       Наш текущий пользователь N + 1 по порядку.  
       По N + 1 определяем в какой диапазон вознаграждения мы попадаем.  
       Если диапазона нет или в текущем диапазоне series_id - пустое значение, то логируем и завершаем работу  

   1.6 Генерируем reward_token для последующей идемпотентности.
   
   1.7 [SQL] Записываем `reward_token`, `series_id` в `referral_completions`

2. Вызываем ручку `/grant` c параметрами:  
   - `reward_token` (для идемпотентности выдачи вознаграждения)
   - `series_id`
   - `yandex_uid (D)` 
   Если ошибка в ручке, падаем, чтобы вызвать ретрай stq-таски
   

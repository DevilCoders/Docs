# Реферальная программа

## Получение бонусов в рамках реферальной программы

### Бизнес-описание

Реферальная программа позиционирует себя как эффективный способ
привлечения новых пользователей. Механика работы следующая:

0. Существующий пользователь Петя делится с другом Димой,
у которого еще нет приложения,
своим персональным *реферальным* промокодом с помощью специальной ссылки.
В тексте ссылки Диме обещают скидку на первую поездку.
0. Дима устанавливает приложение, переходя по ссылке,
и ~~сразу получает купон на скидку~~.
Так как пока не работают *deferred deep links*,
Дима должен либо еще раз нажать на ссылку,
либо вручную вести реферальный код в приложении.
0. Дима совершает поездку, используя промокод (далее называем это *активацией*),
в результате чего Пете положен бонус.
Пока бонусом является скидка на поездку в виде промокода/купона,
в будущем возможны варианты с начислением на Яндекс.Кошелек и др.
Описанным способом Петя может получить бонус за N первых друзей,
которые воспользуются его реферальным промокодом.
При этом нет ограничений на количество друзей Пети,
которые могут стать новыми пользователями и получить скидку на первую поездку.

### Техническая реализация начисления бонуса

#### Процессинг заказа

При завершении заказа создается STQ-таска ``referral_activate``
(уже есть заготовленная таска ``user-referrals``),
которая будет фиксировать факт использования реферального промокода в заказе
путем дерганья за соответствующую ручку.

#### STQ-таска ``referral_activate``

Таска ставится с аргументом ``order_id``, ее основные задачи:

- Получение заказа из архива
- Проверка статуса заказа на ``complete``
- Хождение в ручку записи активации промокода до тех пор, пока не запишется

#### Ручка записи активации промокода

В сервисе купонов будет ручка записи активации - факта использования промокода

Пример запроса:

```json
{
  "yandex_uid": "id пользователя, применившего промокод",
  "promocode": "сам промокод",
  "order_id": "id заказа, в котором был использован промокод",
}
```

Логика работы:

0. Проверка реферального промокода и получение ``yandex_uid`` пользователя,
который его сгенерировал.
0. Запись в БД факта активации, соответствующей переданному ``order_id``.
Если запись с таким ``order_id`` уже есть, сработает unique constraint,
лишняя запись не появится.
0. Сохранение текущей версии данных из поля ``seq_no`` в ``cur_seq_no``.
0. Проверка условия, что за данную активацию пользователю полагается бонус.
Если полагается, и у активации отсутствует ``reward_token``,
генерируется ``reward_token`` и происходит апдейт
с условием ``seq_no == cur_seq_no``.
0. Запуск STQ-таски ``referral_generate_reward`` c ``reward_token``,
которая будет заниматься формированием бонуса.

Работает с коллекцией [``referral_promocodes``](#коллекция-referral_promocodes)

#### STQ-таска ``referral_generate_reward``

Таска ставится с аргументами ``yandex_uid``, ``reward_token``,
ее основные задачи:

- Определение типа бонуса и его параметров
- Хождение в ручку начисления бонуса до тех пор, пока не начислится

Тип бонуса и его параметров определяется по правилам, задаваемым в админке рефералки.

Параметром бонуса типа ``промокод`` является серия промокода.

Серия выбирается в админке промокодов исходя из желаемой валюты и номинала.
Если серия желаемых валюты и номинала уже зарегистрирована для использования
в вознаграждениях, то её можно просто выбрать. Если нужной серии нет,
её нужно завести.

Для заведения новой серии нужно не только создать серию промокодов,
но и зарегистрировать её в конфиге соответствий `валюты+номинала` к
`id серии`, чтобы в админке можно было лекго выбрать нужную скерию.
Конфиг должен выглядеть примерно так:

```json
{
  "rub": [
    {"value": "50", "series_id": "series_rub_50"},
    {"value": "75", "series_id": "series_rub_75"}
  ],
  "usd": [
    {"value": "3", "series_id": "series_usd_3"}
  ]
}
```

#### Ручка начисления бонуса

В сервисе купонов будет ручка начисления бонуса - промокода/скидки на поездку.
В дальнейшем планируется перенести ручку в отдельный сервис вознаграждений.

Пример запроса:

```json
{
  "yandex_uid": "id пользователя, которому полагается бонус",
  "reward_token": "токен идемпотентности",
  "reward": {
    "type": "promocode",
    "params": {
      "series_id": "some_id"
    }
  }
}
```

Логика работы:

0. Если для переданного ``yandex_uid`` отсутствует бонус с ``reward_token``,
добавляется запись в массив ``rewards``.
Если запись с таким ``reward_token`` уже есть, сработает unique constraint,
лишняя запись не появится.
0. Сохранение текущей версии данных из поля ``seq_no`` в ``cur_seq_no``.
0. Для типа бонуса "promocode" генерация нового *уникального* промокода
``code``, нужной серии.
0. Запись сгенерированного промокода в поле ``rewards.params.code``
с помощью апдейта с условием ``seq_no == cur_seq_no``.
0. Активация промокода пользователю.
0. Если коммит прошел успешно - запуск STQ-таски ``referral_notify_reward``,
которая отправляет уведомление пользователю, получившему бонус.

Работает с коллекцией [``user_rewards``](#коллекция-user_rewards)

#### STQ-таска ``referral_notify_reward``

Таска ставится с аргументами ``code``, ``yandex_uid``, ее основные задачи:

- Подготовка сообщения для пуш-уведомления (наполнение темплейта из танкера)
- Отправка уведомления

### Новые коллекции

В сервис купонов добавляются новые монго-коллекции,
либо эквивалентные postgres-таблицы.
Определения (скрипт миграции) для таблиц даны в отдельном файле
``referral_reward.sql``.

#### Коллекция ``referral_promocodes``

Это новая колллекция для хранения реферальных промокодов с привязкой
к ``yandex_uid``. Пока не прописаны поля для хранения правил для выдачи
самих купонов на скидки, на это будет отдельный документ RFC.

```python
referral_promocodes = {
  '_id': ObjectId(),          # Генерируется Mongo, нами не используется
  'yandex_uid': string,       # id пользователя, поделившегося промокодом
  'promocode': string,        # сам промокод (буквы и цифры)
  'seq_no': integer,          # счетчик, позволяющий избежать гонок
  'activations': [{           # список активаций промокода
    'yandex_uid': string,     # id пользователя, активировавшего промокод
    'order_id': ObjectId(),   # id заказа, в котором применили промокод
    'reward_token': string,   # токен бонуса (optional)
  }, ... ]
}
```

Индексы:

```yaml
indexes:
- key: yandex_uid
  unique: true
- key: promocode
  unique: true
- key: activations.order_id
  unique: true
- key: (yandex_uid, activations.reward_token)
  unique: true
```

#### Коллекция ``user_rewards``

Данная коллекция будет хранить информацию о выданных бонусах.
В дальнейшем переедет в сервис вознаграждений.

```python
user_rewards = {
  '_id': ObjectId(),          # Генерируется Mongo, нами не используется
  'yandex_uid': string,       # id пользователя, которому выдаем бонусы
  'seq_no': integer,          # счетчик, позволяющий избежать гонок
  'rewards': [{               # список выданных бонусов
    'token': string,          # токен бонуса, ключ идемпотентности
    'type': string,           # тип бонуса, e.g. 'promocode'
    'params': {               # параметры бонуса
      'code': string,         # сам промокод, e.g. 'abacaba123'
    },
  }, ... ]
}
```

Индексы:

```yaml
indexes:
- key: yandex_uid
  unique: true
- key: (yandex_uid, rewards.token)
  unique: true
```

### Оценка сроков

Список задач:

0. ``[1d]`` Создание коллекций в монге
0. ``[3d]`` STQ-таска ``referral_activate``
0. ``[3d]`` Ручка записи активации промокода
0. ``[2d]`` STQ-таска ``referral_generate_reward``
0. ``[2d]`` Ручка начисления бонуса
0. ``[1d]`` STQ-таска ``referral_notify_reward``

## Промокоды супераппа


### Цель
Пока идет [доработка сервиса `coupons`](https://github.yandex-team.ru/taxi/rfc/blob/master/coupons/superapp.md), 
чтобы объединить в себе промокоды различных сервисов и, пока не перевели Еду и Лавку на таксишный биллинг, хотим реализовать быстрый вариант объединения промокодов в супераппе, который позволит:
- сохранить промокод Лавки и Еды в разделе «промокоды»
- при добавлении промокода валидировать его актуальность и получать метаинформацию (описание и к какому сервису принадлежит)
- из карточки конкретного промокода по кнопке вести на шторку Еды/Лавки с примененным промокодом (параметр диплинка)


### Продуктовые ограничения
На данном этапе нас устраивает, что:
- при переходе на шторки Лавки и Еды будет использован промокод первый из списка, а это значит, что он может не подходить по ситуации и не пройти проверку на этапе формирования и оплаты заказа
- промокоды для Лавки и Еды создаются отдельно от таксишных
- сообщения никак не локализуются


### Изменения в архитектуре

Все доработки в сервисе `coupons`:
- закрываем единым экспериментом 3.0 по пользователям
- пишем код, связанный с проверкой промокода в Еде, так, чтобы его можно было очень легко удалить


#### Доработка `/v1/coupons/activate`

API ручки менять не нужно.

1. Для работы с активированными пользовательскими купонами Лавки и Еды заводим новые временные серии промокодов в коллекции promocode_series:
- `external_promocodes_eda`, где поле `services` = ['eda']
- `external_promocodes_lavka`, где поле `services` = ['lavka']

Купоны добавляем в соответствующие серии.

Возможно, дополнительно придется править текущие маски по проверке формата купона (в районе `CheckPromocodeMatchesPattern()`), если в Еде существуют какие-то форматы,
 отличные от `"^[^\\W_]{4,20}$"`


2. Еде в ручку проверки нужно передавать промокоды по `phone_id`, поэтому сохраняем в коллекцию промокодов дополнительно еще `phone_id` - используем тот, который приходит в запросе.

Возможные детали реализации:
При добавлении нового купона, если он не прошел проверку на пригодность в такси, мы должны проверить его в Еде новой ручкой проверки купонов, для этого:
- [сюда]((https://github.yandex-team.ru/taxi/uservices/blob/develop/services/coupons/src/couponcheck/models/coupon.hpp)) добавляем новый тип купонов `EdaExternalCoupon` и метод для него в `CouponResolver`
- [сюда]((https://github.yandex-team.ru/taxi/uservices/blob/develop/services/coupons/src/couponcheck/checks/check_list.cpp)) добавляем новый список проверок `EdaExternalCheckList` - в него добавляем единственную проверку через новую внешнюю ручку Еды - либо исполбзуем `CheckExternalService()` (но овзможно придется доработать), либо пишем новую функцию проверки.
- [здесь]((https://github.yandex-team.ru/taxi/uservices/blob/develop/services/coupons/src/couponcheck/couponcheck.cpp#L205)) видимо временно закрываем проверку `IsLavkaPromocode()` (при необходимости здесь можно добавить аналогичную функцию, которая произведет первичную проверку на то, может ли быть этот код от Еды или Лавки) и возвращаем `EdaExternalCoupon`. 

*Оценка:*
2-4d


#### Доработка `/v1/coupons/list`

1. Поля для UI

Текущий API уже позволяет разделять купоны по сервисам (поле `services`) и давать UI-описание им.
Не хватает только описание статичных UI-элементов (разделителей), поэтому добавляем в ответ (кажется, проще всего это сделать напрямую в коде):
```json
{
    ...
    "ui":{    
        "splitters":[
            {
                "service": "taxi",
                "title_for_one": "Скидка на поездку",
                "title_for_many": "Скидки на поездки"
            },
            {
                "service": "lavka",
                "title_for_one": "Скидка в Лавке",
                "title_for_many": "Скидки в Лавке"
            },
            ...
        ]
    }
}
```
На этапе mvp порядок разделителей можно захардкодить на бэкенде. 
Предполагается, что разделители останутся - удалять этот код при переходе на постоянное решение не нужно.
2. Дополнительная проверка и данные по промокодам

- 2.1 При запросе купонов, если у юзера есть купоны особых серий Еды и Лавки, ходим синхронно в их ручки и проверяем их, также получаем доп. инфу для отображения на UI. phone_id берем из коллекции
- 2.2 По результатам проверки удаляем невалидные купоны из базы.
- 2.3 Возвращаем дополнительные UI поля в ответе из ответа валидации: title, subtitle, description, details.
- 2.4 Отдаем промокоды для сервисов кроме Такси только по эксперименту (по версии клиентов в том числе) - чтобы старые клиенты не начали их прменять в Такси.
- 2.5 Если окажется, что один купон может быть и в Еде и в Лавке, надо будет подумать, возможно отдавать его в обоих сервисах. Пока это открытый вопрос.


*Оценка:*
2-4d


#### Доработка ручек  `/couponcheck`, `/couponreserve`, `/couponfinish`
Все эти ручки должны выдавать ошибки на промокоды Еды. 
Для этого можно в функциях проверки типа `check::CheckOne()`делать разделение логики по флагу, передаваемому в `check_context`. 
В ручке `/activate` передавать `eda_external_check=true`, а в остальных местах `eda_external_check=false`. 
И в зависимости от этого флага также как и от эксперимента (по которому будем раскатывать) включать и выключать логику, описанную выше.

*Оценка:*
1d


#### Добавление действия на клиенте и image_tag в coupon
В Еду и Лавку будет вести диплинк, в который подставляется промокод.
Так как формат диплинка может поменяться, имеет смысл задавать его конфигом и возвращать вместе с промокодом.

Также изображение на экране применения промокода может быть разным для разных сервисов, поэтому его тоже нужно конфигурировать.
Поле decorations использовалось другим образом, и переиспользовать его неудобно.

Можно дополнить полями действия и изображения информацию о промокоде. 
Если промокод может применяться в разных сервисах, в массиве возвращаемых промокодов будут разные промокоды для разных сервисов.

Предлагается добавить новое опциональное поле `actions` в объект `CouponAction` 
и новый тип `CouponImageTag` в массив `decorations`:
```
CouponAdditionalAction:
    type: object
    additionalProperties: false
    properties:
        type:
            type: string
            enum:
                - deeplink
        deeplink:
            type: string
            description: диплинк для перехода в соответствующий сервис (Такси/Еда/Лавка)
        title:
            type: string
            description: текст кнопки
    required:
         - type

CouponImageTag:
    type: object
    additionalProperties: false
    properties:
        id:
            type: string
            example: "image_tag"
        image_tag:
            type: string
            description: image_tag изображения, появляющегося при открытии промокода
    required:
        - id
        - image_tag

CouponAction:
    type: object
    additionalProperties: false
    properties:
        ...
        decorations:
            type: array
            items:
                oneOf:
                    - $ref: '#/definitions/CouponDecoration'
                    - $ref: '#/definitions/CouponImageTag'
                discriminator:
                    propertyName: id
                    mapping:
                        balloons: '#/definitions/CouponDecoration'
                        image_tag: '#/definitions/CouponImageTag'
        actions:
            description: дополнительные действия с экрана основного действия (например, переход по кнопке)
            type: array
            items:
                $ref: '#/definitions/CouponAdditionalAction'
        ...
```

Это изменение не нужно будет удалять после перехода на постоянное решение.


#### Доработка со стороны Еды 
Необходимо сделать ручку, которая позволит проверять купон на пригодность.
В запросе будем передавать:
- phone_id пользователя
- промокод
- зону, в которой происходит запрос (берем ее из запроса)

В ответе ожидаем получить:
- валиден/не валиден
- человекочитаемое описание промокода в локале пользователя (для UI)

##### Предлагаемое API
Запрос:
```json
{
    "phone_id": "phone_id",
    "coupon": "coupon1",
    "service": "eda",       // На случай, если понадобится проверять промокод в каждом сервисе
    "zone_name": "biysk",
    "external_meta": {}     // Задается в админке для коллекции промокодов этого сервиса
}
```

Ответ с валидным промокодом:
```json
{
    "service": "eda",
    "coupon": "coupon1",
    "valid": true,
    "title": "Промокод на <b>{$сумма_скидки/процент_скидки$}</b>",
    "subtitle": "Промокод {$сумма_скидки/процент_скидки$}",
    "description": [{
        "text": "Сработает при {$следующем/первом$} заказе в Яндекс.{$Еде/Лавке/Такси$}"
    }],
    "details": [{
        "text": "Действует до {$дата_окончания$}"
        }, {
        "text": "Минимальная сумма заказа {$минимальная_корзина$}"
    }]
}
```

Ответ с невалидным промокодом:
```json
{
    "coupon": "coupon2",
    "valid": false,
    "error_code": "FIRST_LIMIT_EXCEEDED",
    "error_description": "Промокод действует только на первый заказ"
}
```

#### Удаление изменений
Список того, что надо будет подчистить после перехода на нормальную версию:
- удалить временные серии промокодов (после истечения срока их действия)
- удалить временные промокоды или мигрировать их
- удалить часть кода, добавленного при разработке mvp

Оценка: 1-2d


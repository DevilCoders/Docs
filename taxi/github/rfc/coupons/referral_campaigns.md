# Изменения рефералки. Реферальные кампании

## Общие положения

### Сейчас

1. Текущая реализация рассчитана только на одну рефералку для одного пользователя: `UNIQUE` по `yandex_uid` в таблице `referral.promocodes` и `referral.promocode_success_activations`. 
2. Как (ранее) в рефералке Лавки, рефералка может "исчезать", поскольку реализован следующий флоу: все проверки наличия/доступности проводятся для текущей зоны (и первого найденного `creator_config`), затем отдается код, возможно сгенеренный для другой зоны (или не отдается, если проверки не прошли).

### Новое

1. У пользователя может быть одна рефералка в рамках одной кампании. 
2. Уже есть две кампании: 
    - кампания `common_taxi` -- обычную ("общую") рефералку Такси считаем первой кампанией (`id = 0`)
    - кампания `light_business` -- рефералка бизнес-аккаунта (БА) Такси 
3. Кампания может быть заведена как по стране, так и по зоне. При наличии обоих вариантов, используется конфиг по зоне. В одной зоне/стране может быть несколько кампаний (на текущий момент, не более двух).
4. Если глобально рефералка включена (глобальным рубильником `REFERRALS_CONFIG.enabled`), показываются все доступные пользователю рефералки. Как и в случае рефералки Лавки, рефералка прикрепляется к пользователю и показывается вне зависимости от его текущего местоположения. При этом её отображение (в т.ч. обещание вознаграждения) зависит от географии включения и далее соответствует именно этой географии, а не текущей географии пользователя. Частный случай этого правила: в ситуации если пользователь получил рефералку, которая была задана по стране, а позже была создана рефералка по соответствующей зоне, у пользователя останется отображение с характеристиками страны.

*Примечание*. Речь идет о рефералке Такси. Если, например, рефералка Лавки станет внутренней, то описанные доработки потенциально применимы для такого расширенного случая: в первом приближении внутренняя рефералка Лавки - это отдельная кампания.

##  Использование конфигов

### Сейчас

- [REFERRAL_CREATOR_CONFIG](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/REFERRAL_CREATOR_CONFIG) (uservices)
- [REFERRAL_CONSUMER_CONFIG](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/REFERRAL_CONSUMER_CONFIG) (uservices)
- [REFERRALS_URL_TEMPLATE_MAP](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/REFERRALS_URL_TEMPLATE_MAP) (uservices)
- [REFERRALS_CONFIG](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/REFERRALS_CONFIG) (backend-cpp/launch и uservices, используются только поля/блоки `enabled`, `creator`)
- [REFERRALS_ENABLED_BY_BRAND](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/REFERRALS_ENABLED_BY_BRAND) (backend-cpp/launch)

### Направление движения

- Отказ от устаревшего REFERRALS_CONFIG
- Использование таблиц вместо конфигов REFERRAL_CREATOR_CONFIG, REFERRAL_CONSUMER_CONFIG

### Изменения в работе по конфигов для запуска кампаний (переходный период)

- Отходим от использования конфига REFERRAL_CREATOR_CONFIG в коде uservices: заводим таблицу как копию конфига, для обновления значений - исправляем конфиг и запускаем скрипт синхронизации
- REFERRAL_CONSUMER_CONFIG - без изменений
- Перестаем использовать поля из REFERRALS_CONFIG (на исключением `REFERRALS_CONFIG.enabled` в качестве глобального рубильника): все данные о серии промокодов (номинал, процент, валюта(!), количество поездок со скидкой) нужно доставать из кеша

Это нужно, чтобы не переписывать код работы с REFERRAL_CREATOR_CONFIG в uservices дважды и сразу удобно извлекать данные о географии конфига.

### Изменения в работе по конфигов: подробно

1. создаем таблицу `referral.creator_configs` для хранения аналогичной конфигу информации, дополнительно в каждой записи заводится поле `enabled`
2. пишем скрипт в tools-py3, который сравнивает целиком конфиг и таблицу и
    - проверяет корректность текущего конфига (например, корректность кампаний - см. ниже)
    - обновляет инфо (extra_check, tanker_prefix) о кампаниях, если есть требуется
    - добавляет новую запись в таблицу creator_configs, если не нашел в ней id, который есть к конфиге
    - меняет у записи поле enabled на false, если наоборот записи с таким id (больше) нет в конфиге или гео не указано, т.е. было стерто (в этом случае выдача **новых** промокодов в зоне/стране будет приостановлена)
    - обновляет запись целиком (аналогично добавлению), если изменения требуются (в частности, если у записи стоял enabled = false, а нужно выставить true)
4. запускаем скрипт, чтобы добавить все текущие creator-конфиги; далее при правках конфига придется дополнительно запускать скрипт
5. переписываем код uservices на использование таблицы `referral.creator_configs`

В текущих конфигах предусмотрен следующий подход: чтобы остановить генерацию по конкретному id, нужно стереть географию (пустые зона и страна). Потенциально пустые зоны могут помешать поиску нужного значений экспериментов (например, отображению в shortcuts). Тем не менее эти id (без географии) нужны для работы. Поскольку они есть в таблице `promocodes` c однозначно указанной страной, предлагается на первом этапе использовать это значение географии -- страну (без флага `--insert-with-no-geo` такие *новые* записи будут проигнорированы). Далее, при необходимости, можно будет вручную поправить их географию (восстановить по истории конфига). Всегда стараемся не хранить в таблице строки без географии. 

Многие проверки могут быть проигнорированы, если выставлен флаг `--force`. Скрипт проверяет также конфиг consumer'a и потенциально может быть доработан для перенесения его в соответствующую таблицу, а также для перекрестных проверок между конфигами. Текущие проверки корректности следующие:
- пары гео + кампания уникальны, для записей с гео (оба конфига)
- указанные серии промокодов есть в коллекции promocode_series (оба конфига)
- id в конфиге creators уникальны
- для каждой указанной кампании в конфиге creators однозначно заданы `extra_check` и `tanker_prefix`, и эти кампании есть в конфиге consumers
- количество наград совпадает с лимитом (в противном случае текущий текст обещания награды некорректен, описано ниже; проверка может быть проигнорирована)
- награда только одна (временное ограничение, описано ниже; проверка может быть проигнорирована, но в таблицу будет перенесено только первая серия из наград)

Скрипт можно посмотреть здесь: [PR #2125 tools-py3](https://github.yandex-team.ru/taxi/tools-py3/pull/2125)

## Сценарии работы с рефералкой

### shortcuts

0. в проверке включенности оставляем только глобальный рубильник
1. ищем все реферальные промокоды пользователя (с информацией о кампаниях и географии);

Обращаю внимание, что количество использований промокода в shortcuts не передается и потенциально мы можем начать (постоянно) светить уже исчерпанные предложения. Это редкий кейс (сейчас это будет у 3х человек) и потенциально мы готовы расширять лимит. Можно сделать запрос с количеством (как ниже в get referral), но это скорее всего увеличит тайминги у всех.

### get referral

0. в общей проверке включенности оставляем только глобальный рубильник
1. ищем все реферальные промокоды пользователя (с информацией о кампаниях и географии + о количестве использований!)
2. (по таблице) ищем все конфиги с `enabled: true` для текущий зоне/стране с информацией о кампаниях (для тех кампаний, которые не были выбраны в п.1)
3. по каждой такой кампании (не имеет существующего кода), проверяем включенность в текущей зоне (соответствующий эксперимент, сейчас эта проверка в `CheckCampaign`) + доступность для пользователя (соответствует условиям кампании, если они есть, сейчас эта проверка в `CheckExtra` + соответствует условиям конфига на количество поездок); если ок -- пытаемся вставить в таблицу promocodes новый промокод для этой кампании; если вставили –– возвращаем, если нет –– селектим и возвращаем;
4. кампании, которые имеют код, но количество добавлений исчерпано, потенциально можем выкинуть, но пока что оставляем (сейчас проверка только при переводе `if (rides_left == 0) descr_key = kTankerKeyDescriptionEmpty;` -- из-за [сломанной проверки](https://st.yandex-team.ru/TAXIBACKEND-26423) есть отрицательные rides_left, их нужно занулить)
6. если в результате не находим ни коды, ни доступные кампании –– возращаем пустой вектор, который стандартно будет "обернут" кодом 406 (рефералка недоступна в этом регионе)
7. если есть, то приводим коды к пользовательскому представлению (выполняем `BuildPromocode` + каждый раз используем exp3_helper для соответствующей зоны/страны) и возвращаем результат

Раньше *проверка включенности* (рефералки вообще, глобально) проверяла наличие как минимум одной поездки. Это не нужно делать, если мы уже выдали промокод, а значит проверили раньше, что поездки были. Будем проверять это условие (по значениям `min_orders_card` и `min_orders_total`), только когда переходим к генерации кода. При этом, если у нас уже есть какой-то код и требования его зоны не слабее тех, что нам предстоит сгенерировать, то проверку можно не делать. В противном случае (выданных кодов нет), мы обратимся к сервису статистики один раз (даже если нам предстоит сделать несколько генераций). 

Отмечу, что поскольку мы в первую очередь ищем значения в базе, нагрузка возрастет. Вопрос нагрузоустойчивости может потребовать отдельного рассмотрения, вне текущей задачи. Ожидаем, в первую очередь увеличение таймингов ответов 406 -- случай "пользователь не подходит под требования" (возможно в этом случае -- если нет поездок -- пользователям не следует выдавать и коды внешних рефералок). В случае недоступности ручки, в частности при большом тайминге coupons/referral (protocol-getreferral отвечает кодом 500 начиная с [500мс](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/COUPONS_TIMEOUT_MS)), клиенты отображают то, что у них в кеше.  Поэтому увеличение таймингов 406х ответов, не должно сказаться: кодов всё равно нет и отображать нечего. В целом, в случае осложнений при большой нагрузке, имеем в виду следующие возможные решения:
- паралелльно генерировать и сохранять в базу новые реферальные промокоды
- настроить оптимальные значения для пулов постгреса в config.user.yaml
- паралелльно ходить в базу рефералки и в сервис статистики
- держать (редко меняющееся) значение количества кампаний в кеше и, при получении соответствующего количества кодов пользователя, не делать дополнительных обращений к базе
- денормализовать базу: хранить предрассчитанное количество активаций (точность данного значения некритична), чтобы не вычислять его при каждом запросе
- вынести генерацию новых реферальных кодов в stq

*Отличия* от прежнего: другой флоу проверки включенности (уже выданные коды первичны); несколько кодов и несколько конфигов для создания рефералки, причем какие-то могут быть по зоне, а какие-то по стране.

В описанных выше сценариях (**shortcuts**, **get referral**) требуется отдельное уточнение про использование exp3_helper для соответствующей зоны/страны для получения значений отображения (например, для `BannerProperties` в п.7 выше): 
- для конфига по зоне, exp3_helper можно пополнить кодом страны (взять tariff_settings cache). В этом случае, даже если значения для зоны будут стерты в каком-либо эксперименте, останется fallback на страну. В shortcuts такой подход уже применен для внешних рефералок.
- для конфига по стране, не следует указывать какую-либо конкретную зону (возможно подойдет указать несуществующую зону, в частности, пустую строку). Потенциально можно было бы пытаться с текущей зоной, но 0. выше в общих положениях мы договорились так не делать; 1. у нас нет информации в какой зоне была включена рефералка; 2. отображение в разных зонах может быть разным - соответственно оно может меняться у пользователя при смене зон (и мы этот процесс не контролируем); 3. может быть ситуация, что текущая зона находится в другой стране.

В целом, работу с exp3_helper придется значительно переделать, т.к. создавать его нужно только после получения географии промокодов.

### activate referral

Изменения только в том, что в таблицу успешных активаций дополнительно записываем campaign_id при отсутствии соответствующей пары yandex_uid + campaign_id.

### check/reserve referral

Без изменений.

### complete referral

Без изменений. Проблем в использовании нескольких кампаний не видно: уникальность только по `order_id` и `reward_token`, количество привязано к `promocode_id`. Следует иметь ввиду, что схема базы в тестах py3 будет немного устаревшей (она без `campaign_id`), но это допустимо и различия исчезнут с переносом stq в uservices.

**Внимание**. Код py3 продолжает работать именно с конфигом REFERRAL_CREATOR_CONFIG (берет значения наград и их лимиты), а не c соответствующей таблицей, заполненной скриптом синхронизации. Чтобы использовать таблицы, потребуется доработка базы (см. ниже).

## Новые таблицы в БД
### campaigns -- реферальные кампании

| id    | campaign_name  |  extra_check     |  tanker_prefix |  description   |
| ----- |:--------------:|:----------------:|:--------------:|--------------- |
| 0     | common_taxi    | NULL             | NULL           | Общая рефералка Такси |
| 1     | light_business | business_account | light_business | Рефералка бизнес-аккаунта |

- `id` 
- `campaign_name NOT NULL UNIQUE` -- наименование кампании
- `description` -- текстовое описание кампании (и, возможно, её ограничений)
- `extra_check` -- правила включения (раньше были у зоны)
- `tanker_prefix` -- префикс танкерных ключей (раньше был у зоны)

Каждый `extra_check` имеет свою реализацию в коде.

### creator_configs -- конфиги создателя рефералки
- `id` -- идентификатор конфига
- ~~`extra_campaign`~~  `campaign_id` -- идентификатор кампании
- `enabled BOOLEAN NOT NULL` -- флаг включенности конфига
- `zone_name NULL` -- зона
- `country NULL` -- страна, потенциально можем сделать NOT NULL
- ~~`rewards` -- на первое время json~~ `reward_series` -- первая серия для наград (нужна только чтобы отобразить номинал в тексте, см. ниже -- пояснения)
- `success_activations_limit` -- лимит активаций
- `min_orders_card` -- минимальное количество поездок по карте, default = 0
- `min_orders_total` -- минимальное количество поездок, default = 1
- ~~`extra_check`~~ -- ушло в инфо о кампании
- ~~`tanker_prefix`~~ -- ушло в инфо о кампании

*Пояснения*. В настоящее время тексты рефералки написаны с обещанием скидки для потребителя рефералки и для создателя, но мы не знаем, где будет применять промокод потребитель (consumer) и какую скидку он получит. Точный номинал (возможной награды) мы можем отображать только для создателя рефералки (creator), но и этот момент в общем случае требует отдельной доработки: если наград несколько, то их номинал может быть разный.

Отмечу также, что изначальная проработка предполагала возможность указать диапазон без наград явно, но эта [функциональность сейчас недоступна](https://st.yandex-team.ru/TAXIBACKEND-29477) (+ нет отдельных описаний для этого случая). Также, в случае `max_completion_number < success_activations_limit` мы имеем неявный диапазон без наград, начиная с `max_completion_number` (опять же, нет специальных текстов для этого случая -- а случай особый: наград больше и не будет), но отображаем сообщение об исчерпании только начиная с `success_activations_limit`. Отмечу, что если не использовать таких неявных диапазонов (т.е. указывать явно отсутствие награды в конце `rewards = [..., {'max_completion_number': N, 'series_id': None}]` ), то поле `success_activations_limit` - это просто `max_completion_number` последней награды (если массив наград заполнен верно -- по возрастанию `max_completion_number`).
Несмотря на указанное, поле `success_activations_limit` -- важное. Чтобы получать его оперативно (а не поиском по `rewards`), также переносим его в таблицу.

На момент переходного периода, будем исходить из предположения, что (как и сейчас) в каждом конфиге ровно по одной награде (по одной серии `reward_series`) с некоторым лимитом, который соответствует `max_completion_number`, а случаи `max_completion_number < success_activations_limit` и наличия нескольких наград включаем в проверки скрипта синхронизации. Также исходим из предположения, что в той же зоне (что считаем наиболее частым кейсом) промокод для consumerа имеет тот же номинал (и характеристики), что и награда creator'а, поэтому в текстах, которые пока остаются прежними, для обоих обещаний светим номинал и характеристики серии `reward_series`. 

Отмечу, что выше речь идет именно о _**текстах**_ (обещаний), **функциональность в py3 для нескольких наград продолжает работать**. Полностью от конфига пока не отказываемся. Чтобы в дальнейшем это сделать, требуется завести таблицу наград `creator_rewards` c потенциально несколькими наградами для каждого конфига. Примерная структура:
- `id` --  айди записи (награды)
- `config_id REFERENCES creator_configs (id)` -- айди конфига, для которого награда
- `series_id NOT NULL` -- серия-награда
- `activations_from` -- нижняя граница интервала награды
- ~~`max_completion_number`~~ `activations_to` -- верхняя граница интервала награды 
- Дополнительно: `CHECK (activations_from < activations_to)`

При такой структуре (обе границы) нужную награду можно найти по условию `WHERE current_activations BETWEEN activations_from AND activations_to`, а пустые награды  можно не записывать. Занесение информации в такую таблицу требует доработки скрипта синхронизации или разработки ручек в рамках [задачи по админке рефералки](https://st.yandex-team.ru/TAXIBACKEND-22873) (переносить stq из py3 в uservices и полноценно использовать таблицы лучше после того, как админка готова). После этого можно следует вместо `reward_series` (из `creator_configs`) начать использовать первую награду из `creator_rewards` (или полноценно: награду, соответствующую текущему количеству активаций), а поле `reward_series` удалить.

## Изменения таблиц в БД
### promocodes -- таблица с реферальными промокодами

Нужно добавить поле `campaign_id` с дефолтом 0. Уникальный constraint по `yandex_uid` нужно заменить на уникальный индекс по (`yandex_uid`, `campaign_id`).

Потенциально по `config_id` мы можем узнать кампанию, но в качестве гарантии нужен явный индекс. К сожалению, при этом мы получаем дублирование информации: пара (`campaign_id`, `config_id`) будет встречаться и в `promocodes`, и в `creator_configs`.

Промокод однозначно связан с `config_id`. Имея промокод, всегда можно узнать нужный `creator_config` его географию и кампанию. Конфиг `consumer_config` также ищется с учетом кампании, т.к. активируемый промокод с ней связан ([TAXIBACKEND-29225](https://st.yandex-team.ru/TAXIBACKEND-29225)).

### promocode_activations -- таблица с активациями реферального промокода (любые попытки использования)

Изменений не требуется: здесь в качестве ограничений по-прежнему работают уникальный индекс по паре (`promocode_id`, `yandex_uid`).

### promocode_success_activations -- таблица с успешными активациями

Нужно добавить поле `campaign_id` с дефолтом 0. Уникальный constraint по `yandex_uid` нужно заменить на уникальный индекс по (`yandex_uid`, `campaign_id`). 

Ранее вставка записи об успешной активации происходила только в случае "нет успешной активации для данного пользователя", нужно сделать: "нет успешной активации для данной пары кампания + пользователь". Как и раньше, эта проверка необязательна и используется только чтобы не было лишнего инкремента SEQUENCE для SERIAL поля `id`.

### Миграция

#### Порядок изменений в базе и в коде
1. [миграция-1] добавить новые таблицы
2. [скрипт] заполнить данные таблицы creator_configs: А. скриптом, B. исправить отдельными запросами зоны у выключенных ранее конфигов (B. -- можно позже, по необходимости)
3. [код] перейти на использование creator_configs в коде
4. [миграция-2] добавить поле campaign_id Not Null Default 0 внешний ключ
    - Поскольку в promocodes 3,5 млн записей, следует быть внимательным. Начиная с Postgres 11 (у нас 11.7) такую операцию можно сделать относительно быстро. Проблему с длительным блокированием таблицы может представлять только ситуация, когда alter table вынужден ждать получение эксклюзивной блокировки из-за того что эту блокировку удерживают какие-то другие транзакции. Потому имеет смысл ставить небольшой statement_timeout и повторять попытки выполнения alter table (протестировано в тестинге на таблице в 4,5 млн записей - ок за 2 секунды).
5. [код] начать писать в коде рефералку с campaign_id
6. [[скрипт-2](https://github.yandex-team.ru/taxi/tools-py3/pull/2215)] поправить те значения campaign_id, которые будучи нулевыми (default) являются неверными (light_business)
7. [миграция-3] добавить новые индексы (`CONCURRENTLY`) на пары (`yandex_uid`, `campaign_id`)
8. [код] исправить условие ON CONFLICT на парное:
    - [sql](https://github.yandex-team.ru/taxi/uservices/blob/develop/services/coupons/src/postgres/sql/referral/internal/promocodes/save_or_get_user_referral_promocode.sql#L29), [save_or_get_user_referral_promocode](https://github.yandex-team.ru/taxi/uservices/blob/develop/services/coupons/src/utils/referral.cpp#L51)
    - В этом случае возможна ситуация, что мы пытаемся сгенерировать и записать код пользователю по ещё одной кампании, что из-за старого constraint будет приводить к ошибке. Эту ошибку следует обрабатывать также как ошибку неуникального promocode, т.е. не делать повторных попыток. Также её следует отловить по имени constraint и не логировать (соответствующий код можно удалить после п.10).
    - Пока существует два ограничения (старый по yandex_uid, и новый на пару) мы будем генерировать и выдавать не больше одного кода. Т.к. кампания БА на текущий момент является приоритетом, следует "начинать" с неё (далее порядок будет некритичен, можно удалить после п.10). 
9. [код] если к этому моменту, не было сделано извлечение вектора кодов вместо одного (первого) кода - сделать это; тесты для векторов следует писать вместе с кодом для п.10
10. [миграция-4] удалить старые уникальные constraint по yandex_uid тем самым, открыв возможность нескольких кампаний (сначала -- у `promocode_success_activations`, и только потом у `promocodes`).
11. (опционально) [код] Удалить лишний код из п.8
12. ~~(опционально) убрать Default 0~~

Код миграции можно посмотреть здесь: [PR #13193 uservices](https://github.yandex-team.ru/taxi/uservices/pull/13193)

### Связанные задачи (за рамками исхоной задачи)
- [[Рефералка Такси] Переписать тексты рефералки: убрать обещания для получателя](https://st.yandex-team.ru/TAXIBACKEND-29585)
- [[Рефералка] Вынести CanGenerateReferrals из backend-cpp в coupons](https://st.yandex-team.ru/TAXIBACKEND-29517)
- [[Рефералка Такси] Починить возможность явного указания количества активаций без наград](https://st.yandex-team.ru/TAXIBACKEND-29477)
- [[Рефералка Такси] Удалить старый код из backend-cpp (Handle для referral)](https://st.yandex-team.ru/TAXIBACKEND-29478)
- В качестве глобального рубильника вместо (некодогенеренного) REFERRALS_CONFIG.enabled по аналогии с [COUPONS_SERVICE_ENABLED](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/COUPONS_SERVICE_ENABLED) завести для uservices конфиг REFERRALS_ENABLED
- После перехода на использование данных о серии из кеша можно удалить старые поля (value, currency, percent, percent_limit_per_trip, ride_count) из таблицы promocodes (пока будем продолжать заполнять, т.к. value, currency, ride_count, country - NOT NULL). Стоит отметить что, в случае смены номинала промокода или других его характеристик, эти записи помогли бы нам выяснить старые значения (например, для разбора тикетов Duty). В целом, это общий вопрос (касается не только рефералки), который следует рассматривать отдельно.

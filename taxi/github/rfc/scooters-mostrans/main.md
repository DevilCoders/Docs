# Интеграция с API МосГорТранс

## Контекст
В рамках эпика SCOOTERDEV-889 реализуем вот такое [API](https://scooter.partners.moscowtransport.app/docs/#/):  
Хотим чтобы из приложения МосГорТранса можно было выбрать самокат, забронировать и арендовать его напрямую, без диплинков в Go  
Можно условно разделить задачу на 4 части:
* Информационные ручки с необязательной авторизацией(зоны и самокаты)
* Технические детали авторизации и ручки связанные с регистрацией/авторизацией
* Ручки с общей инфо для пользователя(сессии, долг и т.п.)
* Ручки бронирования, аренды и разблокировки самоката

Имплементация предполагается в сервисе scooters-mostrans, в котором уже есть прошлая версия API(информационная, без авторизации и пр. т.к. использовались диплинки в Go)

## Зоны и самокаты
В немалой части, имплементация уже есть
* GET `/areas` - метод получения списка зон работы и ограничений, не требует авторизации  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/areas/get_areas)
  Есть готовый `ScootersPolygonsCache` который ходит в `scooters-misc/v1/areas` и получает полигоны из БД scooter-backend. Мы можем сделать выборку полигонов по нескольким нужным нам тегам(зоны работы, зоны замедлений, запрещенные зоны, зоны запрета на паузу, зоны парковок)  
  В предыдущей версии API за это отвечали 2 ручки: `scooter/area` и `scooter/parking`, сейчас будет одна ручка с полями-свойствами на каждый полигон  
* GET `/devices` - почти полная аналогичность существующей ручке `/scooter`. Все данные можно получить из scooter-backend, не требует авторизации  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/devices/get_devices)
* GET `/devices/{code}` - более детальная версия ручки `/devices` для конкретного самоката  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/devices/get_devices__code_)  
  Часть инфы уже получается в `/scooter` из scooter-backend  
  Цены будем получать на первом этапе только без авторизации диапазон из конфига, на 2ом в зависимости от наличия авторизации:  
  * с авторизацией получать из `/scooters-offers/v2/offers-create` анонимный оффер(просто цены без гарантий)  
  * без авторизации/временный пользователь брать диапазон значений из конфига

## Авторизация
### Общее
Получение пользовательского авторизационного токена через паспорт, со скоупом `maas_scooters:all`  
Межсервисная авторизация с заголовком `X-API-KEY`  
Паспортный токен прокидывается с заголовком `X-User-Token`  
В случае если новое API будет закрыто за authproxy, надо убедиться, что internal ручки scooters-mostrans не торчат наружу

### Authproxy
Для авторизации запросов предлагаю завести новую `mt-authproxy` через которую запросы от МосГорТранса будут авторизовываться до хедеров API 4.0 и прокидываться в нужные ручки  
За основу кажется можно взять код из `passport-authproxy`(`token_router.cpp`) которая выполняет аналогичные функции по отношению к авторизации запросов из не-Таксишных сервисов Яндекса с той лишь разницей, что в `mt-authproxy` не потребуется авторизация по `session_id` и вместо заголовков `Authorization`/`X-YaTaxi-Authorization` будет использоваться заголовок `X-User-Token`  
Так же на входе надо будет проверить `X-API-KEY` через `uapi-keys` и сделать доступ в прокси по белому списку адресов(которые есть в чате с МосГорТрансом)  
В остальном, точно так же извлекаем токен, идём в паспорт, чекаем скоуп, заполняем заголовки и роутим запрос по конфигу  
По большей части работу выполняет библиотека `base-proxy-passport`(разве что нам не подходит их функция извлечения токена)

### Ручки `/auth/*`
* POST `/auth/token` - ручка получения авторизационного токена по номеру телефона  
  У нас свою основную функцию не выполняет т.к. основная авторизация через Паспорт.  
  Побочная функция - получение временного анонимного токена, чтобы можно было ходить некоторые наши ручки
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/auth/post_auth_token)
* POST `/auth/register` - ручка регистрации пользователя  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/auth/post_auth_register)  
  Предлагаю реализовать заглушкой, кажется что если мы в `/auth/token` всегда возвращаем временного пользователя, то в эту ручку походов не будет

## Сессии, долг, оффер
* GET `/sessions` - получение актуальных бронирований и сессий аренды  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/sessions/get_sessions)  
  <i>NOTE: надо возвращать только сессии, созданные из приложения МТ</i>  
  Можно реализовать прокидывая дополнительный заголовок источника из authproxy
* GET `/user/debt/` - получение суммы задолженности  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/debt/get_user_debt)  
  <i>Временно нереализуем пока не будет апдейта по биллингу</i>
* POST `/user/debt/pay` - оплата задолженности  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/debt/post_user_debt_pay)  
  <i>Временно нереализуем пока не будет апдейта по биллингу</i>
* GET `/offers` - получение оферты использования сервиса в HTML  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/offers/get_offers)  
  Предлагаю пока просто хранить в конфиге HTML и отдавать его по локали(их всего 2)
* POST `/offers` - согласие с офертой  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/offers/post_offers)  
  <i>TODO: для ряда ручек нужно ограничение использования сервиса пользователю до согласия. Если готового решения нет или его сложно обеспечить с нашими особенностями авторизации(чтобы для пользователя-из-MT был отдельный ок оферты), придется хранить в БД</i>

## Бронирование, аренда и разблокировка
* POST `/devices/{code}/unlock` - разблокировка арендованного самоката
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/devices/post_devices__code__unlock)  
* POST `/bookings` - старт бронирования устройства  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/bookings/post_bookings)  
  В части бронирования можно написать код сейчас, а оплату реализовать позже(сейчас пусть ручка возвращает неудачу по причине оплаты)  
  Бронировать, предположительно, будем через ручку `/scooters/api/yandex/book` предварительно запросив настоящий оффер из `/scooters-offers/v2/offers-create` 
* GET `/bookings/{booking_id}` - инфо по сессии бронирования
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/bookings/get_bookings__bookingId_)  
* POST `/bookings/{booking_id}/cancel` - отмена бронирования(ожидаем уточнение флоу, вероятно отменять бронирование стоит не сразу или вообще не отменять, если далее вызван `/rentals`)
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/bookings/post_bookings__bookingId__cancel)  
* POST `/rentals` - не делаем ничего(т.к. всё необходимое можно проверить на `/devices/{code}/unlock`) или проверяем, что пользователь дошел до самоката  
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/rentals/post_rentals)  
  Можно пока добавить код старта аренды, без биллинга до апдейта по нему и с ошибкой по оплате
* GET `/rentals/{rental_id}` - инфо по сессии аренды
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/rentals/get_rentals__rentalId_)  
* POST `/rentals/{rental_id}/pause` - пауза аренды, если возможно
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/rentals/post_rentals__rentalId__pause)  
* POST `/rentals/{rental_id}/resume` - возобновление аренды
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/rentals/post_rentals__rentalId__resume)  
* POST `/rentals/{rental_id}/end` - завершение аренды, фото прилагается
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/rentals/post_rentals__rentalId__end)  

## Уведомления MT
При возникновении изменений в сессиях бронирования/аренды с нашей стороны, нужно ходить в ручки:
* `/mt/bookings` - уведомление об изменении бронирований
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/mt/post_mt_bookings)  
* `/mt/rentals` - уведомление об изменении сессий аренды
  [Swagger](https://scooter.partners.moscowtransport.app/docs/#/mt/post_mt_rentals)  
По большей части, можно уведомления слать прямо в ручках scooters-mostrans

## Общие вопросы
* В ряде ручек есть ответы 400 со спец. кодом на ретраи. Будет ли плохо, если мы будем возвращать 200?
* В ручках связанных с оплатой есть возможность кидать диплинки. Возможно, это упростит нам вопрос с биллингом?
* Было бы неплохо, если бы со стороны МосГорТранса дергалась дополнительная ручка у нас, по номеру телефона определяющая включать ли новый API. Чтобы была возможность протестировать. Ну или какой-нибудь другой вариант тестирования не на пользователях
* Как должна будет работать связь с саппортом для заказов из МТ?
* Узнать флоу вызова ручек со стороны МТ, особенно в части авторизация через Паспорт + ручки `/auth/token` и `/auth/register`

## БД
Пока что кажется, что нам актуально хранить только "принятость" актуальной версии оферты в БД на пользователя. В будущем, возможно, понадобится промежуточное хранение состояний про оферы и дистлоки для уведомлений об истекших бронированиях. Предлагаю пока использовать БД от scooter-backend

## Roadmap
* Апрель 3
  * собрать инфу на Sec Design Review
  * имплементация ручек `/areas` + `/devices` + `/auth/register` + `/auth/token`
* Апрель 4
  * `/devices/{code}` - имплементация с ценами из конфига
  * `/bookings` - имплементация через deeplink
  * `/rentals` - через deeplink
  * `/sessions`, `/bookings/{id}`, `/rentals/{id}` - пока возвращаем пустоту/404
  * `/offers` GET & POST - значения из конфига, пока без подтверждения
* Май 1
  * Реализовать на стороне scooter-backend возможность пометки заказа, через что он был сделан(определение через что предлагаю делать через заголовки)
* Май 2
  * написать authproxy или метод авторизации в существующей
* Май 3
  * authproxy: доступы, первая выкатка, роутинг и т.п.
  * реализовать фильтр текущих сессий по приложению, через которое был сделан заказ
* Май 4
  * `/bookings` + `/rentals` + управление сессиями бронь/аренды без диплинков(но пока отключено)
  * уведомления в `/mt/*`
  * `/sessions`, `/bookings/{id}`, `/rentals/{id}` - нормальная имплементация
* Июнь 1
  * `/user/debt` и оплаты в `/rentals`
  * БД + сохранение состояния POST `/offers` + проверки в прочих ручках
  * включить имплементацию без диплинков по экспериименту на отдельных людей
* Июнь 2
  * починить что отвалится и выкатить на всех
* Июнь 3
  * `/devices/{code}` - имплементация с актуальными ценами(оффер не храним, но отдаем цены с учетом подписки и момента)
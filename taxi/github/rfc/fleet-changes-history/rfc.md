**Название сервиса**

fleet-changes-history

**Какую продуктовую проблему решает сервис?**

Сервис-обертка над таблицей changes БД misc.

Истории измениений всех сущностей хнанятся в одной базе, в будущем планируется 
их разделить. Сейчас ручка записи временно написана в сервисе driver-work-rules 
(так как него уже был доступ к БД misc), но она никак не связана с сервисом, 
поэтому ее нужно отселить и добавить читающую ручку для Оптеума.

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Потому что есть цель закрыть базу за сервисом

**Как именно сервис будет решать поставленные перед ним задачи?**

Сервис будет получать в запросе park_id, ходить с ним во fleet-parks за шардом и
будет записывать в этот шард строку с изменениями объекта или читать  с этого шарда
историю изменния.

**Разрабатывается один сервис или система?**

Один

**С кем взаимодействует сервис?**

fleet-parks - для получения шарда

**Какие базы использует?**

* misc - уже существующая pg база
* redis - фолбэк при недоступности pg

**Какие периодические процессы?**

Возможно, джоба по дозаписи в pg очереди ошибок из redis

**Прикрепите схему того, где этот сервис находится в текущей инфраструктуре**
```
Оптеум            |
driver-work-rules | -> fleet-changes-history -> fleet-parks
driver-profiles   |
fleet-vehicles    |
```

**Какие данные и по какой схеме сервис будет хранить в базе?**

- *park_id*
- *id*         - id записи
- *date*       - дата измнения объекта
- *object_id*  - id измененяемго объекта
- *object_type*
- *user_id*    - id автора изменний
- *user_name*
- *counts*     - количество измененных строк в модели объекта
- *values*     - сами изменения
- *ip*

Indexes:
* *"changes_pkey" PRIMARY KEY, btree (park_id, id)*
* *"idx_changes_date" btree (park_id, date DESC)*
* *"idx_changes_object_id" btree (object_id)*
* *"idx_changes_user_id" btree (user_id)*

**Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

* Сейчс хранится: 410 GB
* Скорость записи: 13.5 Кb/s - в пике и 1.2 Kb/s - в среднем
* Данные после записи не модифицируются

**Какие операции над данными заложены?**

Чтение и запись

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

Да

**Какая нагрузка ожидается?**

* на запись оценивалась по yt по количеству записей в каждую секунду;
среднее значение 2 rps, в пике - 23 rps;
* на чтение оценивалось по логам кибане на ручки ChangesController в диспе;
среднее за сутки - 0.01 rps, в пике - 124 rps

Итого: 500 rps в пике с учетом низкой нагрузки при текущей ситуации

**Какие фолбеки предусмотрены на сам этот сервис?**

Кеш шардов парков

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

Деградация UI (не будет показываться история изменений) или не сохранится
история изменений

**Какие возможности масштабируемости закладываются?**

Увелечение числа машин/ядер сервиса

**Какие точки отказа есть в сервисе?**

Одновременный отказ БД и redis

**Укажите технические метрики**

Дефолтные дашборды

**Какая функциональность ожидается в сервисе в будущем?**

Разделить таблицу changes и положить историю каждой сущности в базу самой 
сущности в одельную таблицу, затем поэтапно переносить функцонал чтения/записи 
истории изменения этой сущности на ответственный за сущность сервис.

**Какое изменение нагрузки планируется?**

Пропорционально количеству пользователей

**Активно ли будет изменяться сервис?**

Нет

## Архитектура

### API

#### *POST /v1/changes*

Ручка для записи изменений в базу.

В теле запроса приходит park_id, изменнения конкретного объекта (ТС, водитель,
условие работы и т.д.) и автор изменений.

Если не удается записать изменения в базу, то они скалдываются в очередь в
redis с ключом EntityChangelog:Errors. Затем джоба, живущая в шарповом
репозитории, дозаписывает эту очередь в базу.

Сейчас база предполагагает сохранение измений сделанных только пользоватлями
диспы, но можно заложить в API другие типы авторов (скрипты и джобы), но пока
поставить на них заглушку. А когда changes будет расщеплятся на несколько
таблиц, будет воможность обрабатыватьи таких авторов.

#### *POST /v1/changes/list*

Ручка для получения истории изменения объекта.

В теле запроса приходит park_id и id объекта, в ответе возвращается массив
изменений объекта.

### Как раскатываем
По порядку переносим потребителей с ручки /change-logger driver-work-rules
на ручку /changes этого сервиса

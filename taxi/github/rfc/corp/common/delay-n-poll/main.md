## Постановка задачи

### Проблема

Массовое назначение лимитом или ЦЗ может занимать продолжительное время, более минуты.

### Решение

Реализовать отложенные операции

### Задача
Написать RFC по реализации отложенных операций для ЦЗ и Лимитов

Верхнеуровнево:
- Фронт будет запрашивать у бека статус операции
- Показывать пользователю нотификацию, что операция выполняется
- Пока выполняется операция бэк блокирует возможность параллельного изменения
- При попытке внести параллельные изменения на фронте должна показываться нотификация, что операция временно не доступна

Реализация отложенных операций при назначении лимитов и ЦЗ на департементы / всех сотрудников

### Доп. инфо

Сейчас по ЦЗ нельзя назначить на всех сотрудников, только по айди департамента (и то это может работать долго).

По Лимитам нельзя назначить на всех сотрудников и по айди департамента.

# Проработка

## Что происходит

### фронтенд

- фронтенд отправляет запрос в ручку (с токеном идемпотентности и с какими-то данными)
- ручка возвращает `task_id` и `status` задачи, а также результат или дополнительные данные для отображения:
  - задача поставлена: `{task_id: ..., status: 'init'}`
  - задача выполнена: `{task_id: ..., status: 'complete', result: ...}`
    (если результат задачи предполагает, например, ссылку или текст)
  - задача выполняется: `{task_id: ..., status: 'running', 'progress': X` (X в процентах, например)
  - задача не выполнена: `{task_id: ..., status: 'error', errors: []}`
  - задача ожидает выполнения: `{task_id: ..., status: 'waiting'}` (если была поставлена в очередь во время лока)
- ручка может вернуть ошибку 423, что означает, что сейчас производится другая операция по этому клиенту
- фронт в соответствии со статусом показывает юзеру что происходит, либо сообщает о завершении
  (либо показывает результат)
- в случае лока фронтенд может либо повторить запрос через какое-то время,
    либо отправить запрос на постановку задачи после снятия лока
    (например, передав параметр `enqueue` — эту часть пока не требуется реализовывать)

### бекенд (запрос)

- получает запрос с данными
- ищет задачу по ключу `token`+`client_id`, то проверяет, есть ли таск с такими данными
  (в отдельной коллекции `corp_long_tasks`)
- если таск есть и он выполняется, вернуть running
- если таск есть и он завершён, вернуть результат (убедиться, что запрос пришёл от того же `client_id`)
- если таск есть и он ещё не начат, то вернуть waiting
- если таска нет, то создать (в коллекции `corp_long_tasks`)
  - записать туда параметры (например, id клиента + id департамента + id лимита или ЦЗ)
  - поставить stq-таску, передав туда только task_id
  - и вернуть init вместе с task_id

### бекенд (stq)

- stq-задача принимает только task_id (id документа из `corp_long_tasks`)
- stq-задача может лочить выполнение таких же задач (если речь про апдейты/инсерты),
  а может и не лочить (если просто нужно вычитать много данных, как в реестрах)
  (см. описание декоратора ниже)
- задача состоит из одного действия над многими документами (балки и чанки)
  - в случае неуспеха останавливаем (?) задачу, выставляя ей статус 'error'
  - после каждого успешного чанка обновляем в монге `corp_long_tasks` счётчики прогресса
- после завершения всех чанков:
  - пишем в `corp_long_tasks` статус успеха и итог (ссылку, числа, результирующий объект, что угодно)
  - удаляем лок (кажется, это можно и до смены статуса таска,
    т.к. лок нужен только чтобы не писать одновременно разные данные в одни документы)
- вроде PROFIT!

#### вопросы
- нужно ли запретить другие задачи с такими параметрами в случае ошибки? или можно ставить повторные?
  - пока никаких ограничений тут не планируем
- как гарантировать, что задача начнёт отрабатывать с того же места в случае падения stq?
  - сейчас не даём такую гарантию, запускаем задачу заново

## Данные и код

### особенности реализации

- ручки для кабинета и stq живут в taxi-corp

### коллекции/таблицы

- `corp_long_tasks`:
  - id
  - stq_task_name
  - stq_task_args
  - status (init, waiting, running, complete, error)
  - progress (при статусе running)
  - result (при статусе complete)
  - created_at
  - updated_at
  - started_at
  - finished_at

- `corp_long_tasks_locks` с индексом по `task_name`+`task_params`+`lock_status`
  (причем он должен быть partial по `status: locked`)
  - id
  - task_name
  - task_params (пока тут только `client_id`)
  - lock_status
  - locked_at
  - released_at

**В упрощённом варианте** можно не хранить локи и их статусы,
тогда документ с локом просто удаляется по завершении задачи.

(Если пользоваться постгресом, то пример локов в postgres можно посмотреть в сервисе taxi-approvals)

### stq-задачи

- задача для смены лимитов (всех в рамках клиента, в рамках департамента или по списку юзеров)
- задача для смены ЦЗ (всех в рамках клиента, в рамках департамента или по списку юзеров)

Локи можно сделать в виде декоратора:
  - декоратор принимает задачу и её id
  - проверяется наличие лока на выполнение таких задач
    (только по client_id, т.к. не придумал, как реализовать локи, чтобы можно было лочить как на client_id,
    так и на client_id+dep_id, причём чтобы client_id+dep_id не давал запустить операции с client_id, и наоборот)
    - локи живут в коллекции `corp_long_tasks_locks`:
      - вставляем документ с `stq_task_name`+`client_id`+`lock_status: locked`
      - если такой лок уже есть, то сработает ограничение на индекс
      - в этом случае задача перепланируется на некоторое время вперёд и её статус становится waiting
    - если лока нет, то проверяется, что нет других ожидающих задач, поставленных раньше:
      это для того, чтобы задачи запускались в порядке их постановки (если так нужно);
      если такие задачи есть, то задача перепланируется на попозже со статусом waiting
  - если успешно выставляется лок `stq_task_name`+`client_id`+`lock_status: locked`, то задача начинает выполняться


### ручки в taxi-corp

#### Ручка для балковой смены лимитов

POST /3.0/users-limits

Заголовок для передачи токена: `-H "X-Idempotency-Token: <token>"`

```yaml
request:
    additional_properties: false
    properties:
        limit_id:
            type: string
            description:  лимит для выставления
        users:
            oneOf:
              - ref$: "#/definitions/ByDepartmentId"
              - ref$: "#/definitions/ByUserIds"
              - ref$: "#/definitions/AllUsers"
        enqueue:
            type: boolean
            description: |
                true, если нужно поставить эту задачу выполняться
                после снятия лока текущей
                (NOTE: на первом этапе не поддерживаем)
    required:
      - idempotency_token
      - limit_id
      - users

response:
    ref$: "#/definitions/TaskResponse"
    
definitions:
    ByDepartmentId:
        type: object
        description: выборка пользователей внутри департамента
        additional_properties: false
        properties:
            department_id:
                type: string
                description: id департамента
        required:
          - department_id
    
    ByUserIds:
        type: object
        description: выборка пользователей по ID
        additional_properties: false
        properties:
            user_ids:
                type: array
                description: список id юзеров, к которым надо применить операцию
                items:
                    type: string
        required:
          - user_ids
    
    AllUsers:
        type: object
        description: применить действие ко всем пользователям
        additional_properties: false
        properties:
            all_users:
                type: boolean
                description: применить для всех пользователей клиента
        required:
          - all_users

    TaskResponse:
        additional_properties: false
        properties:
            task_id:
                type: string
                description: ID задачи (не является stq_task_id)
            status:
                type: string
                description: статус задачи
                enum:
                  - init
                  - waiting
                  - running
                  - complete
                  - error
            progress:
                type: integer
                description: сколько % задачи выполнено (??? если нужно отображать)
            errors:
                type: array
                description: ошибки, возникшие в ходе выполнения
                items:
                    type: object
                    properties:
                        code:
                            type: string
                        message:
                            type: string
        required:
          - task_id
          - status
```

Ошибки:
  - `400` в случае невалидного запроса
  - `404` если не найден `limit_id` или `departament_id` для данного клиента
  - `423` в случае, если для этого клиента уже есть незавершённая задача и `enqueue` не был передан (или был `false`)

#### Ручка для балковой смены ЦЗ

POST /3.0/users-cost-centers

Заголовок для передачи токена: `-H "X-Idempotency-Token: <token>"`

```yaml
request:
    additional_properties: false
    properties:
        cost_centers_id:
            type: string
            description: ЦЗ для выставления
        users:
            oneOf:
              - ref$: "#/definitions/ByDepartmentId"
              - ref$: "#/definitions/ByUserIds"
              - ref$: "#/definitions/AllUsers"
        enqueue:
            type: boolean
            description: |
                true, если нужно поставить эту задачу выполняться
                после снятия лока текущей
                (NOTE: на первом этапе не поддерживаем)
    required:
      - idempotency_token
      - cost_centers_id
      - users

response:
    ref$: "#/definitions/TaskResponse"
```

Ошибки:
  - `400` в случае невалидного запроса
  - `404` если не найден `cost_centers_id` или `departament_id` для данного клиента
  - `423` в случае, если для этого клиента уже есть незавершённая задача и `enqueue` не был передан (или был `false`)

## Список задач

### stq-таски и декоратор для локов (2d)

- продумать, как получать чанки (по updated, по курсору, ещё как-то)
- написать таски
- написать декоратор
- написать тесты

###  ручки для кабинета (1d)

- ручка для лимитов
- ручка для центров затрат
- тесты

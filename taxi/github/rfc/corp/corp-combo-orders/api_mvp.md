# Описание ручек и структуры базы corp-combo-orders на первом этапе

Эпик: https://st.yandex-team.ru/CORPDEV-2596

Дизайн: https://www.figma.com/file/z0rFiziQbIR1d6lv3h4nIm/Заказ?node-id=243%3A7093

Кажется, что на первом этапе, так как заказ будет вешаться на одного сотрудника и показываться
только у него в приложении, можно продолжать делать заказ как и раньше теми же ручками в tax-corp.
В сервисе corp-combo-orders тогда вначале достаточно реализовать только функциональность расчета
оптимальных маршрутов. Как это может выглядеть по шагам:

1) На фронте вбивается адрес точки А, адреса сотрудников и их номера телефонов. Фронт шлет все это
в ручку POST /v1/routes/create для постановки задачи на генерацию оптимального маршрута
(подробнее про вид запроса и ответа будет ниже). 
2) /v1/routes/create создает запись в таблице route_requests, сохраняет точки в таблицу waypoints, 
отправляет запрос в маршрутизацию и ставит stq. Также в таблицу waypoints сохраняются id номеров
телефонов сотрудников из pd (они нам нужны, чтобы вернуть фронту точки маршрутов в виде пар 
адрес-телефон).
3) stq ждет и периодически запрашивает статус задачи в маршрутизации
4) фронт периодически запрашивает решение задачи в ручке GET /v1/routes?route_request_id=12312. 
5) как только фронт получил решенную задачу (бэк перед ответом меняет pd_id на номера телефонов), 
он заполняет формы заказов готовыми маршрутами
6) здесь теперь фронт может сделать обычные заказы, как и раньше через старые ручки, то есть
    - дергает ручку POST /1.0/estimate для каждого заказа
    - дергает ручку POST /1.0/client/{client_id:\w+}/order для каждого заказа *
    - и ручку POST /1.0/client/{client_id:\w+}/order/{order_id:\w+}/processing для каждого заказа **
    
    *, ** - если бэк будет успевать раньше фронта, то можно будет сразу сделать массовые ручки 
    для заказов в corp-combo-orders

Плюсы такого решения:
- Использование старых ручек заказов сильно упростит разработку первого этапа на бэке, да и на
фронте я думаю будет не сильно сложно повторить логику обычных заказов

Для отличия массовой поездки от обычной в реестре и истории можно для массовых заказов прокидывать 
новое поле в монгу в corp_orders.

Можно сделать, чтобы в ручку /v1/routes/create также отправлялся токен идемпотентности, чтобы не 
запускать лишний раз одинаковые задачи.

### Структура запросов/ответов ручек и таблиц базы

#### Ручка создания маршрутов

POST /v1/routes/create

Request
```json5
{
    // "развоз" или "своз"
    "type": "ONE_A_MANY_B",

    // общая точка для всех маршрутов (машин)
    // Для ONE_A_MANY_B это точно A, для MANY_A_ONE_B это точка B
    "common_point": {
      "fullname":"Россия, Москва, Люблинско-Дмитровская линия, метро Трубная",
      "geopoint":[
         37.62188427341478,
         55.7679393937369
      ],
    },

    // список всех остальных точек (адреса сотрудников)
    // на каждую точку есть пассажир, поэтому тут номера их телефонов
    "points": [
        {
            "phone": "+79998887766",
            "fullname":"Россия, Москва, Люблинско-Дмитровская линия, метро Трубная",
            "geopoint":[
                37.62188427341478,
                55.7679393937369
            ],
       },
       {
            "phone": "+79998887755",
            "fullname":"Россия, Москва, Люблинско-Дмитровская линия, метро Трубная",
            "geopoint":[
                37.62188427341478,
                55.7679393937369
            ],
       }
    ]
}
```

Response
```json5
{
	"route_request_id": "2312312",
}
```

#### Ручка получения готовых маршрутов

GET /v1/routes?route_request_id=2312312

Response 
```json5
{
    "type": "ONE_A_MANY_B",
  
    // статус решения задачи. Пока задача еще не routes, то можно не возвращать routes
    "status": "routes",

    "common_point": {
      "fullname":"Россия, Москва, Люблинско-Дмитровская линия, метро Трубная",
      "geopoint":[
         37.62188427341478,
         55.7679393937369
      ],
    },
	
    // список оптимальных маршрутов. Можно понимать как разделения на машины
    "routes": [
        {
            // список точек внутри маршрута, "оптимально" отсортированы
            "sorted_points": [
                {
                    "phone": "+79998887766",
                    "fullname":"Россия, Москва, Люблинско-Дмитровская линия, метро Трубная",
                    "geopoint":[
                        37.62188427341478,
                        55.7679393937369
                    ],
               },
               {
                    "phone": "+79998887766",
                    "fullname":"Россия, Москва, Люблинско-Дмитровская линия, метро Трубная",
                    "geopoint":[
                        37.62188427341478,
                        55.7679393937369
                    ],
               }
            ]
        },
        {
            "sorted_points": [],
        }
    ]
}
```

#### Схема базы

Кажется, что пока нужно три таблицы:
- route_requests - таблица с заявками на генерацию маршрутов
- waypoints - таблица с информацией об адресах сотрудников
- waypoint_groups - таблица, объединяющая точки, попавшие в один маршрут (машину)

Схема:

![alt text](https://jing.yandex-team.ru/files/egorgr/corp_como_db.png)

Подробнее про поля route_requests:
- client_id - id корп клиента из монги из коллекции corp_clients (забыл на схеме нарисовать)
- routing_task_id - внешний id задачи решения маршрутной задачи
- type - тип развоза, enum [ONE_A_MANY_B, MANY_A_ONE_B]
- status - текущий статус задачи, enum [queued, started, completed, cancelled]
- common_point - точка А или точка B, внутри будет fullname адреса и координаты, хранить json-ом 
или можно разделить на плоские поля

waypoints:
- route_requests_id - для связи точек маршрута с заявкой
- point - информация о самой точке, внутри будет fullname адреса и координаты, хранить json-ом 
или можно разделить на плоские поля
- user_personal_phone_id - id номера телефона сотрудника из pd
- waypoint_groups_id - для связи с точек с их группой (группа - один маршрут/одна машина)
- serial_number - порядковый номер точки в оптимальном маршруте

waypoint_groups:
- route_requests_id - для связи готового маршрута с заявкой

Связь waypoints -> route_requests может выглядеть избыточной, так как до route_requests есть связь
через waypoint_groups, но разделения точек по waypoint_groups неизвестны до решения маршрутной задачи.

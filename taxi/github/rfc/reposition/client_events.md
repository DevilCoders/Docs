# client-events

## Обзор

В общем случае для реализации требуется следующее:

* ручка для поллинга состояний водителям при холодном старте, когда таксометр пуст;
* когда появляются какие-либо изменения у водителей, отправлять новое состояние в сервис `client-events`.

В нашем случае существуют ограничения, которые вынуждают разбить переезд на `client-events` в два этапа (далее `milestones`, `M`).

### Milestones

1. Изменения только транспорта доставки данных: уход от схемы `taximeter -> reposition` в пользу `taximeter -> client-events <- reposition`;
2. Уход от частично активной, частично событийной модели отслеживания изменений:
    
    * активно: `tags`, `experiments`
    * событийно: `geo-hierarchies`

    в пользу полностью событийной модели отслеживания изменений:
    
    * активно: `none`
    * событийно: `tags`, `geo-hierarchies`, `experiments (?)`

`experiments (?)` — скорее всего, можно будет отказаться от использования экспериментов в настройках режимов.

### Ограничения

1. На текущий момент полностью поддержана событийная модель отслеживания изменений в геоиерархиях водителей (при переезде между ними генерируется событие, которое мы получаем. Для тегов подобная инфраструктура создана, т.е. можно начать слушать изменения в тегах по топику `reposition`. Для экспериментов ничего подобного не существует (может и не понадобится). С учётом этого, на мой взгляд, разработка подобного решения займёт времени не меньше, чем просто переезд на доставку стейтов через `client-events`.
2. Для небольшой части водителей у нас не существует данных в БД, вследствие чего мы не способны отслеживать изменения для них. Это можно было бы решить за счёт полного перехода на событийную модель (стоит уточнить), но см. пункт 1. Значит, на клиенте необходимо поддержать логику ветвления, откуда брать данные — через старый `polling` или новый `client-events`.

## Реализация M1

### stateful водители

Когда генерируется изменение, необходима гарантия доставки такого изменения до клиента. Это справедливо и необходимо для, собственно, генераторов изменений — `etag-data-updater`, а также ручки, изменяющие состояние водителя, — которые, успешно выполнив свою работу, не должны иметь накладных расходов на отправку сообщения в `client-events`, равно как и в случае повышенной нагрузки не должны создавать бесконтрольную нагрузку на сервис `client-events`. Хороший выбором здесь видится `transactional outbox` + конфигурируемый по частоте запуска и количеству отправляемых событий обработчик `relay`, который будет обрабатывать данную очередь. Либо вставка в несколько таблиц при помощи `CTE`, либо, как обычно, в транзакции, используя применяемый сейчас механизм блокировки на уровне водителя в БД (`SELECT ... FOR UPDATE`).

Стоит учесть, что в момент обновления данных водителю генерируется последовательность состояний, каждый из которых начинает действовать в определённый момент времени `valid_since`. А также существует разделение по типам данных: `state`, `user_modes`, `offred_modes`. Скорость обновления и количество изменений у всех разные. Наиболее частотные — `state`, наименее — `offered_modes`. Имеет смысл задавать для них разные настройки отправки, а также не позволять им перемешиваться в общей очереди между собой. Потому, предлагается иметь различные `outbox-очереди` по каждому типу данных и различные обработчики `outbox-очередей`, соответственно. Все они объединены одной условной схемой, которая повторяет за собой почти полную схему основных `etag_data` таблиц:

* `driver_id_id` — водитель;
* `revision` — ссылка на ревизию данных, которую требуется отправить клиенту;
* `valid_since` — время, начиная с которого можно доставлять данные клиенту; 

Всё это справедливо для водителей, чьи данные мы храним и обновляем самостоятельно.

### stateless водители

Возвращаясь к пункту 2 Ограничений, необходимо сохранить старый `polling` для водителей, чьи данные мы не храним и не можем отслеживать изменения для них.

Таким водителям необходимо отдавать флажок, на основе которого будет происходить ветвление логики, откуда получать данные — из `client-events` или поллинг-ручек. Допустим, к каждому из набору данных подмешивать `boolean`-флаг `polling_fallback`.

На backend'е в ручке, отдающей данные водителям при холодном старте (или logout-login), а также в поллинг-ручках, необходимо различать, для какого типа водителя эти данные — из БД или сгенерированные прямо сейчас.

В первом случае (данные из БД) работаем по стандартной схеме, отдаём данные из БД, Таксометр дальнейшие изменения ждёт в канале `client-events`.

Во втором случае (данные сгенерированы) в генерируемые данные добавляем `polling_fallback: true`, чтобы Таксометр продолжал ждать данные в поллинг-ручках. Как только флажок пропадает, переходим на работу по первому случаю.

    Доработка на Таксометре — поддержка данного ветвления логики.

## Миграция M1

`no-affect` реализация заключается в том, что сперва всем водителям принудительно начинаем проставлять флаг `polling_fallback: true`, сохраняя текущую логику.

Для переключения воспользуемся `configs3.0`. Разбиение по водителям достаточно будет построить разрезах `park_id` и `driver_profile_id`. Можно зафиксировать конкретный(е) парк(и) и брать небольшой процент водителей. В процессе переключения необходимо последовательно манипулировать двумя параметрами, а именно:

1. Включить отправку обновляемых данных в `client-events` as-is , без `polling_fallback` флага (считаем, что `default = false`);
2. Отключить принудительное проставление `polling_fallback: true` в поллинг-ручках в пользу стандартного `polling_fallback: !has_data_in_db`.

Первое переключение позволит заранее доставить данные для водителей в промежуточный транспорт `client-events`, чтобы данные сразу были готовы к передаче на Таксометр.

Второе переключение позволит Таксометру перейти на получение данных из `client-events`.

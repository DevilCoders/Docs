# Что
Уменьшаем нагрузку, создаваемую сервисом tips на базу db.orders.

# Зачем
База критичная для цикла заказа, сейчас на неё от сервиса tips идёт примерно 500 rps на чтение из primary:

![текущая схема работы](https://jing.yandex-team.ru/files/toporkovm/screenshot_39.png)

По графикам запросов к базе видно что тайминги p98 к базе не стабильны - иногда в пике они достигают 100ms, тогда как среднее значение в районе 10ms:

![базе грустно](https://jing.yandex-team.ru/files/toporkovm/screenshot_38.png)

Также сервис tips иногда пятисотит (несколько запросов в день) из-за нарушения подключения к базе.

# Как
Добавляем новую базу к сервису tips, в эту базу пишем id заказов у которых есть чаевые.

Чаевые у заказа могут появиться в двух местах, и в этих местах мы делаем поход в сервис tips:
1. При создании заказа - хук в processing 2.0: если при создании есть чаевые
2. При сохранении фидбека - хук в ручке protocol/feedback: если новый фидбек содержит чаевые

Когда update_transactions вызывает ручки сервиса tips (500 rps), сначала смотрим в нашу базу. В нашей базе есть только заказы у которых когда-либо были чаевые (~10-20% от всех заказов). Если заказ есть в нашей базе, то идём за ним в db.orders (50-100rps).

Новая схема взаимодействия выглядит примерно так:
![схема с БД tips](https://jing.yandex-team.ru/files/toporkovm/screenshot_40.png)

## Проблема: последовательность вызовов в feedback
Сейчас protocol/feedback обновляет чаевые в db.orders (синхронно), после чего сразу ставит таску в update_transactions. Нам важно чтобы перед запуском update_transactions новые чаевые были сохранены в нашу базу, иначе мы их можем не обработать: при запросе от update_transactions увидим что в нашей базе нет такого заказа.

### Варианты решения
1. Делаем синхронный поход из protocol/feedback в сервис tips чтобы сделать запись в базе.
  * Плюсы:
    * Гарантируем нужный порядок вызовов
  * Минусы:
    * Впиливаемся в монолит
    * Ухудшаем надёжность ручки - если tips пятисотят, то feedback тоже должен пятисотить

2. Ставим stq-таску из protocol/feedback если есть чаевые. В stq-таске сохраняем чаевые в db.orders и запускаем update_transactions.
  * Плюсы:
    * stq-таска надёжнее чем наш сервис
    * не ждём базу и сервис при запросе protocol/feedback
  * Минусы:
    * __Возможна гонка__: если пользователь сделает много запросов на обновление фидбека (с изменением размера чаевых), то они могут быть обработаны в неправильном порядке, из-за чего у пользователя будут сняты неправильные чаевые
    * Впиливаемся в монолит

3. Выносим protocol/feedback за api-proxy, делаем синхронный поход в сервис tips:
  * Плюсы:
    * Выпиливаем ручку из монолита
    * Синхронный вызов помогает избежать гонок
  * Минусы:
    * Ручка зависит от доступности вызова tips
    * Более трудоёмко чем впилиться в монолит

4. Выносим protocol/feedback за api-proxy, для чаевых используем stq-таску:
  * Плюсы:
    * Выпиливаем ручку из монолита
    * Надёжнее чем синхронный поход в ручку
  * Минусы:
    * Всё ещё есть возможная гонка при обновлении чаевых
    * Более трудоёмко чем впилиться в монолит


__Выбираем вариант №3__: В ручке `protocol/feedback` помимо сохранения чаевых есть также логика валидации переданого значения чаевых. Если валидация не пройдена - ручка возвращает ошибку, поэтому валидация должна быть синхронной. Следовательно, мы в любом случае будем делать ручку для чаевых и не за чем усложнять, делая отдельно stq-таску


### Проблема: Гонка stq-таски обновления чаевых
> Этот абзац не актуален, так как будем делать без stq-таски

Чтобы избежать проблем с гонкой обновления чаевых при направильном порядке выполнения нескольких stq-тасок можно одним из параметров stq-таски передавать timestamp времени в которое пришёл запрос. В api-proxy для этого можно использовать оператор [`timestamp-now`](https://wiki.yandex-team.ru/taxi/backend/architecture/apiproxy/manual2/#perechenoperatorov).

При обновлении значения чаевых сначала смотрим в БД tips - если `updated_at` заказа в базе больше чем пришедший timestamp, то ничего не делаем. В противном случае обновляем значение в `db.orders` и выставляем новый `updated_at` равным пришедшему timestamp.

_tradeoff_: Это _не решит_ гонку запросов от пользователя до api-proxy, но это никак не решается и в текущей архитектуре. То есть продуктово мы _не ухудшим_


### Порядок запросов в новой ручке api-proxy
1. order-core (получение данных для passenger-feedback)
2. passenger-feedback
3. tips

Запросы passenger-feedback и tips не парралелим, так как логика чаевых завязана на фидбеке и в редких случаях может возникнуть гонка.

### Надёжность ручки
В случае ошибок ручка перезапрашивается клиентом.

Надежность ручки немного ухудшится из-за новой зависимости - сервиса tips, а также из-за того что для сохранения фидбека больше не будет использоваться deprecated-метод из protocol/feedback.

## Структура и размер базы
Структура базы:
```
order_id    str     (primary_key)
updated_at  datetime
```
Индексы базы: по полям `order_id` и `updated_at`

__Хранение данных__: храним информацию о заказах в которых есть чаевые, за последние две недели
  * В базе будут данные о примерно 10% всех заказов такси за последние две недели
  * В такси сейчас где-то 12 миллионов заказов в день
  * В базе будут храниться id заказа (32 байта) и updated_at (8 байт), а также будут индексы по обоим полям - берём сверху, получается 128 байт на запись

Итого: 12млн * 10% * 14дней * 128байт = 2гб
Размер базы с запасом - 10гб
По нагрузке ожидается 20 rps на запись, 500 rps на чтение

__Очистка базы__: очищаем по правилу `updated_at > 2 weeks` с помощью сервиса `archivation`

## Про идемпотентность
В базе мы храним только факт того что у заказа были не-нулевые чаевые, не состояние чаевых на текущий момент.
Поэтому у нас нет гонок при обновлении чаевых - при изменении чаевых мы ещё раз попробуем создать запись с ID заказа в базе. Таким образом мы будем иметь запись даже для заказов у которых раньше были выставлены не-нулевые чаевые, а сейчас выставлены нулевые.

_tradeoff_: Из-за этого будет чуть большАя нагрузка на db.orders чем если бы мы учитывали последнее значение.

# Другие варианты решения
## Заводим новый процессинг для чаевых

Выносим часть флоу чаевых в отдельный процессинг, используя ProcaaS. Чаевые пишем в db.orders из сервиса tips, после чего запускаем update_transactions для обработки транзакций.


Статус "CREATED". Эвенты, создающие новые заказы:
1. Создание заказа: если в заказе есть не-нулевые чаевые
2. Сохранение фидбека: если в фидбеке есть не-нулевые чаевые

Статус "READY_TO_HOLD". Условия перехода из статуса "CREATED" (И):
1. Заказ окончен
2. Прошло 30 минут ИЛИ у заказа положительный фидбек

При переходе в статус "READY_TO_HOLD" ходим в новую ручку сервиса tips, которая сходит в db.orders, обновит чаевые в payment_tech+billing_tech, запустит итерацию update_tx.

Статус "READY_TO_CLEAR". Условия перехода из статуса "READY_TO_HOLD" (ИЛИ):
1. Получен финальный фидбек (пользователь больше не изменит чаевые)
2. Прошло 24 часа (пользователь больше не может изменить чаевые)


Новая схема взаимодействия выглядит примерно так:
![схема с процессингом tips](https://jing.yandex-team.ru/files/toporkovm/screenshot_36.png)

Плюсы:
1. Начинаем отделять процессинг чаевых от процессинга заказа такси
2. Не заводим свою базу, не надо заботиться о оё поддержке

Минусы:
1. Нет выгоды в текущий момент. Вынесение в отдельный процессинг нужно будет если решим дальше развивать чаевые как отдельный флоу
2. Более сложная архитектура
3. Из-за завязанности чаевых на объект заказа получится много запросов из update_tx в ProcaaS - на каждое обновление заказа в update_tx нужно пересчитать чаевые (тк они могли поменяться\отмениться из-за зависимых полей)


# Что надо сделать

1. [0 дней] Завести БД для сервиса tips ([TAXIBACKEND-32486](https://st.yandex-team.ru/TAXIBACKEND-32486))
2. [1 день] Писать в db.tips при создании заказа с чаевыми ([TAXIBACKEND-32487](https://st.yandex-team.ru/TAXIBACKEND-32487))
3. [4 дня] Писать в db.tips при сохранении фидбека с чаевыми
  * Сделать ручку в tips, которая будет валидировать и обновлять чаевые в db.orders, и запускать stq:update_transactions (TODO)
  * Вынести protocol/feedback за api-proxy ([TAXIBACKEND-29559](https://st.yandex-team.ru/TAXIBACKEND-29559))
4. [0.5 дня] Проверять заказ в БД перед походом в db.orders ([TAXIBACKEND-32489](https://st.yandex-team.ru/TAXIBACKEND-32489))
5. [0.5 дня] Настроить очистку базы от старых заказов ([TAXIBACKEND-32490](https://st.yandex-team.ru/TAXIBACKEND-32490))

Грубая оценка - 5 дней

Все таски собраны в [эпике](https://st.yandex-team.ru/TAXIBACKEND-32485)

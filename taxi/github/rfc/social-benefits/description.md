# SOCIAL-BENEFITS


## Задача

В рамках соц. инициатив Я.Лавки планируется разработка программы лояльности для льготных групп населения – предоставление скидок/преференций разного рода для людей различных льготных категорий.

Для контроля и автоматизации системы выдачи льгот необходимо провести ряд доработок и интеграцию с гос. системами, в которых хранится информация о соц.карте, ее держателе и положенных ему льготах.

В аккаунте клиента должна появится возможность ввода нового реквизита – номера соц. карты.

Клиент должен получить уведомление, что ему положена та или иная преференция в зависимости от его льготы.

> Где должно быть уведомление?

Актуальность карты должна проверяться

- при привязке ее к аккаунту
- при оформлении заказа – чтобы не было такого, что карта уже недействительна, а по ней примениться льгота (**прорабатываем вариант, когда проверка будет не на каждую покупку, а в фоне каждые N минут/часов, но это решение еще обсуждается с бизнесом**)

После проверки актуальности карты и применении механики акции сумма заказа должна пересчитываться.


## Дизайн

**TODO**

## Входные данные

Сейчас проект направлен на быстрое появление социальных льгот в Лавке супераппа. Дальше будет интеграция с нативным приложением Еды. Еще дальше захотим использовать социальные льготы для скидок в Такси.

Сейчас активно разрабатывается новый сервис скидок Лавки внутри инфраструктуры Такси. Начальная интеграция будет именно с ним. Здесь нам доступен `yandex_uid` пользователя. Сервис будет иметь ходить в сервис тегов Такси.

Дальше нужно будет заинтегрироваться с сервисом скидок Еды. Еда ничего не знает про `yandex_uid`, но в скором времени должна узнать. А так у них сейчас есть только телефон. Пока их не прорабатываем.

Сервис скидок Такси имеет все возможные идентификаторы. И уже умеет работать с сервисом тегов.

Выполнить требование "проверять актуальность льготы при оформлении заказа" довольно дорого - придется костылить в сервисе скидок. К тому же это не очень контролируемая история так как скидки считаются при каждом показе меню, а это около 100RPS в ближайшие месяцы (@twirl). Сервисы правительства на такое не готовы. Также непонятно, что делать при недоступности сервисов правительства. Делая проверку в фоновом режиме, у нас появляется свой кеш.


## Архитектура

Общая схема взаимодействия выглядит так:

![](static/social-benefits-landscape.png)

Для взаимодействия с сервисами правительств будет поднят новый сервис **social-benefits**. Нагрузка на сервис планируется единицы RPS. Целесообразно писать сервис на **PY3**.

**Будет 4 сценария:**

1. [Первичная привязка льготы пользователем](#первичная-привязка-льготы-пользователем)
2. [Актуализация данных о льготах пользователей. Обновление тегов](#актуализация-данных-о-льготах-пользователей-обновление-тегов)
3. [Обновление данных пользователя и тегов при миграциях yandex_uid (прорастание льгот в портальный аккаунт из фонишного)](#обновление-данных-пользователя-и-тегов-при-миграциях-yandex_uid)
4. [Удаление льготы пользователя (пользователем или саппортом)](#удаление-льготы-пользователя)


### Первичная привязка льготы пользователем

В качестве главного идентификатора, к которому будем привязывать льготу будет `yandex_uid`. Если в дальнейшем ответственность за хранение льготы уедет в Паспорт, это будет нам на руку.

**Таблица `bindings`** - содержит данные о текущих привязках карт. Таблица с временными данными.

```sql
CREATE TABLE bindings (
    id                  SERIAL      NOT NULL PRIMARY KEY,
    personal_benefit_id TEXT        NOT NULL,
    yandex_uid          TEXT        NOT NULL,
    status              TEXT        NOT NULL,
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at          TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    error_code          TEXT
)
```

**Таблица `benefits`** - таблица для постоянного хранения привязок

```sql
CREATE TABLE benefits (
    personal_benefit_id TEXT        NOT NULL PRIMARY KEY,
    yandex_uid          TEXT        NOT NULL,
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at          TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    benefit_types       TEXT[]
    update_error_count  INT         DEFAULT 0
)
```

Процесс двухступенчатый. Сначала запрос на ручку `/4.0/social-benefits/bind`, затем поллинг ручки `/4.0/social-benefits/bind/status`.

**Ручка `/4.0/social-benefits/bind`**

```yaml
post:
    description: |
        Запустить привязку карты. В качестве токена
        идемпотентности выступает benefit_id
        так как это уникальный идентификатор ever
    x-taxi-middlewares:
        api-4.0: true
    parameters:
        - in: body
            name: body
            description: Тело запроса
            required: true
            schema:
                type: object
                additionalProperties: false
                properties:
                    benefit_id:
                        type: string
                        description: Идентификатор льготы
                required:
                    - benefit_id
    responses:
        200:
            description: OK
            schema:
                type: object
                additionalProperties: false
                properties:
                    bind_id:
                        description: Идентификатор привязки
                        type: string
                required:
                    - bind_id
        400:
            description: Льгота уже зарегистрирована в системе
            schema:
                type: object
                additionalProperties: false
                properties:
                    code:
                        type: string
                    message:
                        type: string
                required:
                    - code
                    - message
```

1. Идем в `personal` с `benefit_id` и получаем `personal_benefit_id`
2. Проверяем по таблице `benefits`, что такая льгота еще не зарегистрирована
3. Если запись есть, то сразу отдаем 400
4. Если льготы нет, то проверяем наличие `personal_benefit_id` в статусе `pending` в таблице `bindings`
5. Если нашли такое, то просто отдаем 200
6. Если не нашли или нашли в статусе `failed` (статус `success` предполагает наличие записи в таблице `benefits`), то шедулим stq `process_social_benefit_binding` и отдаем 200. В качестве task_id делаем `personal_benefit_id` чтобы в случае нескольких дерганий ручки за раз не было дублей. STQ гарантирует, что в один момент времени может быть только одна зашедуленная STQ с таким task_id

**STQ `process_social_benefit_binding(binding_id)`**

1. Ищем запись в таблице `bindings` с `id` = `binding_id`. Если не находим, то пишем в логи warning и выходим
2. Если нашли, получаем из `personal` настоящий `benefit_id` и идем с этим в сервис правительства для получения информации о льготе
3. Если сервис правительства не отвечает, делаем N попыток с таймаутом T. После этого обновляем статус на `failed` и выходим
4. Если все ок, то делаем в `benefits` запись. Список льгот записываем как они приходят от сервиса правительства. В `status` таблицы `bindings` ставим `success`.
5. Шедулим STQ `social_benefits_sync_tags`
6. Шедулим отложенную STQ `social_benefits_update`. Откладываем её на конфигурируемое время T.


**Ручка `/4.0/social-benefits/bind/status`**

```yaml
get:
    description: |
        Проверить статус привязки карты.
        Используется для поллинга статуса привязки клиентами.
    x-taxi-middlewares:
        api-4.0: true
    parameters:
        - name: binding_id
          in: query
          required: true
          description: Идентификатор привязки
          type: string
    responses:
        200:
            description: OK
            schema:
                type: object
                additionalProperties: false
                properties:
                    status:
                        type: string
                        enum:
                            - pending
                            - success
                            - failed
                    error_message:
                        type: string
                        description: |
                            Сообщение об ошибки при status == failed
                required:
                    - status
        404:
            description: Not found
```

1. Получаем `binding_id`, идем в базу и отдаем статус.
2. Если ничего не нашли, то вернем 404 (но в нормальном случае такого не должно быть)


### Актуализация данных о льготах пользователей. Обновление тегов

**STQ `social_benefits_sync_tags(personal_benefit_id)`**

> Возможно делать стоит делать sync для всех уидов сразу. В сервисе тегов приоритет имеют маленькие апдейты. У них латенси будет меньше и это хорошо

1. Получаем `yandex_uid` по `personal_benefit_id` из таблицы `benefits`
2. Если нет (значит пользователь/саппорт отвязал льготу), то просто выходим
3. Идем в паспорт и получаем по `yandex_uid` все связанные с ним `uids`. Используем только те, у которых подтвержден телефон
4. Меняем `benefit_types` на внутренние идентификаторы льгот по конфигу
5. Удаляем все теги всех полученных уидов и выставляем новые (или как-то более умно их обновляем)
6. Теги ставим именно по yandex_uid
7. Шедулим отложенную `social_benefits_sync_tags` для следующего апдейта


**STQ `social_benefits_update(personal_benefit_id)`**

> Что делать, если у пользователя отозвали льготу? Нужно ли его уведомлять? Нужно ли в приложении что-то делать?

> Что делать, если сервис правительства не отвечает N количество попыток?

1. Проверяем, что в базе есть запись с `personal_benefit_id`. Если нет, то выходим
2. Проверяем `update_error_count`. Если больше порогового значения, то надо **что-то сделать**
3. Если все ок, идем в `personal` и меняем `personal_benefit_id` на `benefit_id`
4. Идем в сервис правительства и получаем нужную инфу. Если не можем достучаться до сервиса, то перешедуливаем таску на попозже (конфиг) и инкрементим `update_error_count`
5. Если все ок, то обновляем `benefit_types`.
6. Решедулим отложенную `social_benefits_update`
7. Шедулим `social_benefits_sync_tags` с каким-то уникальным task_id чтобы не трогать отложенную (если social_benefits_sync_tags будет запускаться для всех, то тут проблемы не будет)
8. Если не нашли такого `benefit_id`, то нужно **что-то сделать**

### Обновление данных пользователя и тегов при миграциях yandex_uid

Если пользователь привязал карту с фонишным аккаунтом и потом залогинился порталом, мы должны накинуть теги на новый yandex_uid.

Когда происходит событие связки уидов, Я.Паспорт дергает хук, который находится в zalogin. Zalogin в свою очередь может дернуть другой хук или поставить stq в какой-угодно очереди. Этим и воспользуемся.

Когда zalogin будет получать сообщение от паспорта о привязке, мы будем ставить stq для social-benefits.

**STQ `social_benefits_uid_bind(phonish, portal)`**

1. Запрашиваем льготу по `phonish` и `portal` одновременно. Если ничего нет, то выходим.
2. Если у нас в базе лежит phonish, то апдейтим его до phonish
3. Если у нас уже был portal, то ничего не апдейтим
4. Ставим `social_benefits_sync_tags(portal)`


### Удаление льготы пользователя

> Нужны продуктовые уточнения


## Нагрузка

Нагрузка на ручку bind меньше 1 рпс.
Посчитано из расчета количества привязок банковских карт в cardstorage (~1rps).

## Внешние сервисы

- personal (хранение benefit_id)
- сервисы правительств
- zalogin (будет ставить stq)


## Клиентская логика

TODO

## Отказоустойчивость

Зависит от периода обновления тегов. Если будет долгий простой, то теги не будут обновляться и мы можем выдать скидок тем, кому не должны были.

При недоступности сервиса personal не сможем обновить теги для известных пользователей с льготами.

При недоступности zalogin не будут происходить обновления тегов при появлении привязок phonish<->portal.

При недоступности тегов скидки не будут работать.

При недоступности сайтов правительств не сможем обновить теги.


## Мониторинги, алерты, бизнесовые графики, логи

TODO


## Технические ограничения

Есть ограничения на количество запросов, которые мы можем слать на сайт правительств. При **значительном** росте количества пользователей с льготами мы можем не успевать в нужный срок обновлять статус льготы. Для правительства Москвы ограничение в 80RPS.


## Этапы

Подумав, поняли, что на этапы тут сложно что-то разбить. В текущей версии будет один этап до чего-то работающего.

**Задачи (18-21d):**

1. Заведение нового entity_type в сервис тегов (1d)
2. Архитектурное ревью нового сервиса social-benefits (3-5d)
3. Первичная привязка льготы пользователем (5d)
   1. Ручка `/4.0/social-benefits/bind` (2d)
   2. Ручка `/4.0/social-benefits/bind/status` (1d)
   3. STQ `process_social_benefit_binding(binding_id)` (2d)
4. Актуализация данных о льготах пользователей. Обновление тегов (7d)
    1. STQ `social_benefits_sync_tags(personal_benefit_id)` (4d)
    2. STQ `social_benefits_update(personal_benefit_id)` (3d)
5. Обновление данных пользователя и тегов при миграциях yandex_uid (3d)
    1. STQ `social_benefits_uid_bind(phonish, portal)` (3d)
6. Удаление льготы пользователя (2-3d?)

## Безопасность

Оказалось (после разговора с Андреем Аникиным), что номера социальных карт являются персональными данными. Поэтому хранить их мы будем в сервисе **personal**.

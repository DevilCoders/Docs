
# Продуктовое описание

На экране нового мультизаказа хочется иметь точки входа в суперапп аналогичные главному экрану.

![](https://jing.yandex-team.ru/files/privet/2020-11-11T07:47:08Z.3261ee9.png)

В дальнейшем помимо точек входа нас ждет развитие в пользу полноценной шторы с шорткатами.

**На какую продуктовую метрику влияем**: число мультизаказов, просмотры медиа при наличии заказа

### Ограничения

В рамках MVP в шторе не должно быть шорткатов (но они в какой-то момент будут постепенно появляться), не должно быть элементов ведущих на саммари (например, точка входа в Доставку или Ультиму. Исключение: кирпичик/кнопка "куда едем")

## Решение

Для отображения шторы предлагается использовать `4.0/mlutp/v1/products`. Проблемы:

1) Когда запрашивать v1/products?
1) Как v1/products поймет что это экран мультизаказа?
1) Как определять доступность сервисов в случае мультизаказа?
1) Как ограничить выдачу шторы?

## Когда запрашивать v1/products?

При изменении числа заказов (создан новый, завершился старый), изменении маршрута существующего заказа.

Кроме того необходим некоторый интервал поллинга даже при отсутствии изменений, т.к. при 10+ минутах поездки пользователь может получить не актуальную выдачу доступности

## Как v1/products поймет что это экран мультизаказа?

В запросе есть поле state.screen_type, на данный момент его возможные значение — `main`, `on_order`.

Предлагается добавить в этот экран `on_multiorder` (отличие от `on_order` — на `on_multiorder` может быть показана штора )

## Как определять доступность сервисов в случае мультизаказа?

На данный момент мобильные клиенты определяют доступность так: для каждого такси-заказа делается запрос в v1/products, результаты доступнности мержатся и основываясь на них показываются карточки.

Эту логику нужно повторить на бекенде, и, опираясь на неё, формировать выдачу.

Дополнительно уточняем, что на экране мультизаказа в качестве `request.position` нужно использовать локацию пользователя.

Для этого бекенду необходимо (1) знать путевые точки для каждого из заказов и (2) уточнить доступность для нужных точек.

### Полученине информации о путевых точках

#### Вариант 1: back2back получение координат [отказались]

Сейчас клиенты передают массив `state.known_orders` вида `[ "<service1>:<orderid>:<?version>", "<service2>:..."]`. Бекенд может для каждого из заказов обратиться к сервисам вроде `order-core` для получения маршрута.

Достоинства:
* Не требует изменений в api и клиентской разработки

Недостатки:
* Увеличивается число сервисов-участников v1/products, как следствие увеличивается "внутренняя" нагрузка, усложняется обеспечение отказоустойчивости, опасения за тайминги
* Фактически "лишняя" нагрузка на`order-core` — информация о маршруте уже есть на клиенте


#### Вариант 2: расширение запроса v1/products [развиваем]

Более подробную информацию о заказе (вроде маршрута) можно было бы добавить в `state.known_orders`, но из-за типа `List[str]` это поле не расширяемо. Для таких кейсов предлагается в запрос добавить поле `state.known_orders_info` мимикрировав под новый трекинг:

```json5
{
    "state": {
        "known_orders_info": [
            {
                "orderid":"order1",
                "service": "taxi",
                "waypoints": [
                    {
                        "type": "a",
                        "position": [33, 66]
                    },
                    {
                        "type": "mid",
                        "position": [33.1, 66.1]
                    },
                    {
                        "type": "mid",
                        "position": [33.2, 66.2]
                    },
                    {
                        "type": "b",
                        "position": [66, 33]
                    }
                ]
            }
        ]
    }
}
```

Такая структура позволит бекенду без back2back взаимодействия узнать необходимую информацию о заказах. **Важно**: массив `known_orders` всё еще нужно отправлять.

Ограничения в MVP:
* Шлем только заказы Такси. Для заказов других вертикалей (Еда, Лавка, Драйв, shared-заказы) будут проработаны позже.

Достоинства:
* Не усложняется back2back взаимодействие
* Не влияет на отказоустойчивость и производительность серверной ручки

Недостатки:
* Изменения в API, непонятно до каких пор эту структуру можно расширять


### Полученине информации о доступности в нескольких точках

Решив проблему получения точек заказа, остается проблема получения доступности в нескольких точках. Существующие API доступности не умеют принимать на вход массивы точек. В MVP можно делать несколько запросов к ручкам доступности, т.к. сейчас это уже происходит при нескольких запросах к v1/products от клиента.
В дальнейшем необходимо поставить тикеты на доработку ручек доступности сервисов.


## Как ограничить выдачу шторы?

### Вариант 1 — backend-only через screen_type [отказались]

При `screen_type` мультизаказа бекенд может добавлять или не добавлять элементы в выдачу. Например, в MVP можно договориться что бекенд не отдает шорткаты, а также сделать недоступными кирпичики доставки/ультимы/етц.

Достоинтсва:
* Не требует клиентской разработки

Недостатки:
* Поддержка шорткатов на экране мультизаказа будет отличаться и в дальнейшем (появляться будут не все сразу), данный вариант сильно усложнит конфигурацию экспериментов на бекенде, будут факапы

### Вариант 2 — через supported_* в запросе [развиваем]

Клиент может ограничить получаемое множество шорткатов через `supported_*` поля в в запросе.
Например, запрос сообщающий о поддержке только кирпичей и кнопок (без доставки) будет выглядеть так:

```json5
{
    "shortcuts": {
        "supported_features": [
            {
                "type": "taxi:route-input",
            },
            {
                "services": [ "eats", "grocery", "pharmacy", "shop" ],
                "type": "eats-based:superapp",
            },
            {
                "type": "header-deeplink",
            },
            {
                "services": [],
                "type": "header-action-driven",
                "prefetch_strategies": []
            }
        ],
        "supported_actions": [
            {
                "type": "deeplink"
            },
            {
                "type": "taxi:route-input"
            },
            {
                "type": "discovery",
                "modes": [ "masstransit", "drive" ]
            }
        ],
    }
}
```

Здесь были убраны `taxi:summary-redirect`, `drive:fixpoint-offers`, `taxi:header-summary-redirect`, `taxi:expected-destination`, `media-stories`, `invites`, `deeplink`.

Важно: это все еще требует доработки на бекенде:
* Например, мы не умеем сейчас скрывать Такси
* Редирект на саммари теоретически может прийти в `action.type=deeplink`
* Нужно будет сконфигурировать эксперимент блендера, чтобы при неподдерживаемых шорткатах он не прокручивался

Достоинтсва:
* Более явное определение способностей клиента
* Расширяемо без сильного усложнения экспериментов

Недостатки:
* Важно успешно перезапросить v1/products на главном экране, иначе будет странная выдача
* Нужна клиентская разработка
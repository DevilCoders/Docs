# Продуктовое описание

На данный момент логика отображения кнопок в "шапке" шорткатов содержится на клиенте, и её сложно поддерживать при большом числе вертикалей, учитывая, что активные заказы влияют на размер кирпичика. Все необходимые комбинации необходимо описать в коде клиента, при ошибках или желании добавить новый кирпичик нужно ждать выпуска новой версии

Хотим получить такой экран:

![Кирпичики](https://media.github.yandex-team.ru/user/8299/files/0c9b6380-72a2-11ea-8cf0-01616af9f4cd)

## Решение

Частично выносим внешний вид "шапки" шортатов на сервер. Для этого в `modes.[mode=taxi].offers` ответа v1/products добавляем массив `header`. Элементы этого массива будут отображаться на `linear_grid` сетке как шорткаты.

Для этого предлагается ввести 3 новых типа шорткатов (см. `products.md`). Важно: новые типы являются "сквозными", они могут присутствовать как в `.header`, так и в `.items`. Это же верно и для "старых" типов: бекенд имеет право возвращать их в `.header`.

Всё еще не пытаемся решить задачу полноценной верстки "внутри" шортката на бекенде. Это выглядит отдельной задачей по адаптации html/css правил на нашу сетку. Если у вас есть идеи — пишите.

На бекенд переносится логика:
1) Размер "кирпичика"
2) Какой кирпичик за какой сервис отвечает (для связи между кирпичиком и данными трекинга)
3) Потенциальные заголовок и иконка кирпичика
4) Стиль disabled-кирпичиков: на бекенд переносится логика по формированию text_style с нужным цветом. Для формирования disabled-иконки клиент накладывает маску из text_style.color на иконку.

На клиенте остается логика:
1) Конечное формирование внешнего вида (нужно ли показывать иконку, как выравнивать текст). Клиент будет ориентироваться на ширину шортката. (Мы не придумали как верстать контент шортката)
2) Текст для трекинга

## Особенности реализации на клиенте

### Фоллбек шапки

Клиент должен уметь отображать шапку содержащую элемент "Куда едем?" в следующих ситуациях:
* До первого ответа 4.0/mlutp/v1/products
* Если не удалось успешно запросить 4.0/mlutp/v1/products (например, при 500 или таймауте)
* При отсутствии `offers.header` в ответе 4.0/mlutp/v1/products

### Фоллбек иконок

При первом запуске или проблемах с сетью не хотим получить интерфейс без иконок. Для этого на клиент зашиваются "фоллбечные" иконки для Такси, Еды, Лавки и Аптек, которые необходимо отображать до успешной загрузки иконок из шортката.

Для остальных сервисов отображение иконок полностью зависит от getimage. Мы соглашаемся с риском, т.к. он особенно критичен для 1x1 кирпичиков, а они не планируются до конца мая. К этому моменту вопрос с иконками нужно перепроработать.

## Детали реализации на бекенде

### Механика формирования сетки

Наличие `offers.header` в ответе и содержимое сетки будет регулироваться экспериментом `shortcuts_heading_grid`.

Отображение задается следующим образом:
```json
{
    "1":  [6],
    "2":  [4, 2],
    "3":  [6, 3, 3],
    "4":  [4, 2, 3, 3],
    "5":  [4, 2, 2, 2, 2],
    "priority": ["taxi", "delivery", "eats", "grocery", "pharmacy"]
}
```
1) Бекенд определяет количество сервисов с покрытием, назовем это N
2) В эксперименте `shortcuts_heading_grid` выбирается значение по ключу `"{N}"`
3) Сетка заполняется сервисами с покрытием задананными в порядке `priority`

При необходимости кастомизировать представление в случае доступности конкретного сервиса можно либо использовать его доступность в качестве кварга (заложим возможность при разработке), либо заказать доработку.


### Архитектура

Создаем связь между `superapp-misc-v1-availability` и `shortcuts-v1-shortcuts`: задача `superapp-misc` сooбщить `shortcuts` доступность вертикалей (через api-proxy), включая свойство `show_disabled`.

**Фоллбеки**:
* У `superapp-misc-v1-availabilty` есть фоллбек с недоступностью всех сервисов. Он нас не устраивает тем, что при наличии активного заказа в Вертикали мы хотим продолжать показывать кнопку сервиса. Для этого в `shortcuts` будем передавать `known_orders` из запроса клиента, чтобы не исключать сервис из заголовка даже при падении `availability`.
* В фоллбек `blender`/`shortcuts` нужно добавить шорткат `taxi:route-input`


### Аналитика

Нужно анализировать влияние лейаута на клики, заказы и GMV. "Кирпичики" являются важной частью лейаута.

На данный момент

* Сервис `shortcuts` не отправляет логи в YT
* Ручка `/4.0/mlutp/v1/products` не отправляет логи в YT
* `blender` отправляет логи отдельным yt_logger'ом с кастомной схемой, см. `services/blender/yt-uploads/yandex_taxi_blender_yt_request_info.yaml`

Для упрощения аналитики рассмотрены следующие схемы:

#### Вариант 1 — оставляем логгирование только в блендере [не подошел]

Блендер как единая точка логгирования возможен, если реализовать что-то из:
* Перенести о ответственности за динамические кирпичи в блендер. Плохо, т.к. порождает организационную проблему, также сейчас в динамических кирпичах нет никакой персонализации и непонятно как она может выглядеть
* Перенести кирпичи в сервис выше по топологии (например, superapp-misc v1/availability) и использовать блендер как yt-логгер-через-хттп. Выглядит реализуемо, однако сильно размазывает логику шорткатов по v1/products
* Сделать в `shortcuts` отдельную ручку `v1/dynamic-bricks`. Использовать в api-proxy как "источник" динамической сетке и передавать в блендер. Вариант плох преимущественно тем, что увеличит нагрузку на `shortcuts` в два раза, привнесет дополнительные проблемы с сетью.

От логгирования только в блендере отказались, т.к. каждый вариант неидеален и костылен.

#### Вариант 2 — логгировать в shortcuts [выбран]

Оставляем динамические кирпичики в `shortcuts`, но даем возможность их удобно анализировать. План такой:

* Делаем в `shortcuts` репликацию логов в YT по https://wiki.yandex-team.ru/taxi/backend/userver/libraries/yt-logger/#otpravkaserver.logvyt
* Генерим динамические кирпичики в соответстии с "внутренним" API шорткатов, мимикрируя блендер. Подробнее ниже.
* Итоговую шапку логгируем в server.log как JSON, не забыв важные для аналитиков параметры.

**Внутреннее представление динамических кирпичиков**

Во внутреннем представлении хочется бысть консистентными с блендером. Для этого сохраняем `grid.id`, а также используем тот же формат шорткатов, что и блендер (т.е. их "внутреннее") представление.

Внутреннее представление шортката обладает полем `scenario` — внутренний тип шортката внутри `v1/products`. предлагаю ввести следующий маппинг внутреннего/внешних типов для шапки:

* `taxi_route_input` контрол ввода точки Б Такси
* `eats_based_eats` кнопка Еда
* `eats_based_grocery` кнопка Лавка
* `eats_based_pharmacy` кнопка Аптеки
* `header_delivery` кнопка "Доставка"

Тогда итоговый лог будет выглдяеть так:

```json
{
    "grid": {
        "id": "ID_FROM_BLENDER",
        "header": [   // аналог cells  из блендера
            {
                "height": 1,
                "width": 3,
                "shortcut": {
                    "id": "some_id",
                    "scenario": "taxi_route_input",   // SIC!
                    "content": {
                        "title": "Куда едем?",
                    }
                }
            }
        ]
    }
}
```
# Описание

При факапах в Еде/Лавке их отключают в супераппе через эксперимент `superapp_availability`: свойства  `enabled` и `show_disabled` выставляют в  `false` , чтобы у пользователя не было точки входа в вертикаль (т.к. иначе может возникнуть негативный опыт. Например, при проблемах с оплатой пользователь сначала зайдет в вертикаль, наберет корзину, и уже на этапе чекаута увидит ошибку).

При этом продуктово исчезновение кнопок нежелательно (хочется, чтобы UI оставался неизменным).

Вместо этого предлагается при факапах выставлять на бекенде флаг смерти, при котором кирпичики Еды/Лавки будут вести не в вебвью, а на произвольный диплинк (например, диплинк промо-акции с текстом "мы сломались")


## Контекст

Динамические кирпичики (см. `dynamic_bricks.md`) позволяют указывать произвольный диплинк для кирпичей. При факапе можно в качестве диплинка использовать диплинк на промоакцию "мы сломались".

Однако динамические кирипичики поддерживаются не всеми клиентами, для старых версий должно быть актуальным решение через `enabled/show_disabled: false`.

Важно помнить, что сейчас `shortcuts` показывает кирпичики Еды/Лавки основываясь на свойстве `modes` в ответе ручки `superapp-misc/v1/availability`. Кирпичик появится в выдаче, если `(enabled || show_disabled) == true`

### Вариант 1 — дополнительное поле в эксперименте superapp_availability [принят]

#### Шаг 1 — модификация ответа superapp-misc/v1/availability

Создать эксперименты `superapp_deathflag_{service}` с тэгом `superapp_availability`. Эксперимент по-умолчанию отключен, default value отсутствует.

В нем предлагается создать клоз:

`{service}_is_exist=true`
```json
{
  "main": {
    "services": {
      "{service}": {
        "deathflag": true,
      },
    }
  },
  "on_order": {
    "services": {
      "{service}": {
        "deathflag": true
      },
    }
  }
}
```

Условие по `*is_exist` нужн, чтобы мы не начали показывать факапные кирпичики Лавки там, где Лавки никогда не было.

Данный эксперимент **должен включаться руками** при факапе, после факапа выключаться.

Значение `deathflag` нужно отдавать в свойстве `modes` ручки `superapp-misc/v1/availability`.

Важная особенность: данное значение попадет на клиент. Не кажется критичным.

#### Шаг 2 — использвание deathflag в shortcuts для получения "специальных" кирпичиков

В сервисе `shortcuts` помимо стандартных кваргов будет передавать `eats_is_deathflag` и `grocery_is_deathflag`. Для этих кваргов делаем отдельные клозы в https://tariff-editor.taxi.yandex-team.ru/experiments3/show/superapp_bricks_appearance (здесь скорее всего надо будет этот эксперимент разделить, результат получать объединением по тегу), внутри этих клозов у Едового и Лавочного кирпичика в качестве диплинка делаем диплинк на промо-акцию.

#### Шаг 3 - использвание deathflag в shortcuts для активирования сценария

Сейчас кирпичик появится в выдаче, если `mode.(enabled || show_disabled) == true`, см. https://github.yandex-team.ru/taxi/uservices/blob/df3261158848acbdc703fe508994bac12fe806a1/services/shortcuts/src/bricks/coverage.cpp#L45 (в терминах кирпичей, данное условие позволяет сделать сценарий активным)

Расширяем это условие до `(enabled || show_disabled || deathflag)`, чтобы кирпичик попал в выдачу

**Плюсы**
* "Видимость" супераппа регулируется единым тегом `superapp_availability`

**Минусы**
* На клиент "протекает" бекендное поле

Открытые вопросы:
* Как выглядит диплинк на баннер? @trygoginz поможет
* Как обеспечивать гарантию показа таких баннеров? (в теории баннеры могут "протухать".) Поговорить @trygoginz, возможно нужны будут дополнительные мониторинги

## Отклоненные варианты

### Вариант 2 — дополнительное поле в ответе superapp-misc

Создать эксперимент `superapp_deathflags` вида

```json
{ "deathflags": ["grocery", "eats"] }
```

Данный эксперимент **должен включаться руками** при факапе, после факапа выключаться.

Значение эксперимента отдавать в новом поле `deathflags` сервиса `superapp-misc`. Далее флоу аналогичный шагу 2 и 3 из предыдущего варианта (передать значение кваргом в `shortcuts`, если для сервиса активен флаг смерти, форсировать показ кирпичика).

**Плюсы**
* Бекендное поле не протекает на клиент

**Минусы**
* Усложнаяется и без того сложная логика появления кирпичей в выдаче (+1 эксперимент, оказывающий влияние на результат)
* Добавляем "костыльное" поле в корень ответа ручки. Что если появятся ещё какие-то свойства, которые мы хотим сообщить о сервисе, но не хотим нести на клиент?


**Почему отклонили** костыльное поле, тяжело мерджить нынешними средствами

### Вариант 3 — отказ от использования `modes` в бекенде, переход на internal-поле

Использовать поля `mode` из корня ответа `superapp-misc` исключительно для проксирования на клиент. В "бек-ту-бек" взаимодействии использовать поле `internal.modes`. Остальная часть решения из варианта 1.

**Плюсы**
* Бекендное поле не протекает на клиент
* "Видимость" супераппа регулируется единым тегом `superapp_availability`

**Минусы**
* Единовременно перевести всех бекендных потребителей поля `modes` не получится (`shortcuts`, `eda-shortcuts`, `inapp-communications`)
* Поля `modes` и `internal.modes` скорее всего будут дублировать друг-друга на `90%`, люди будут путаться при выборе

**Почему отклонили** см. минусы
# Несколько экранов с шорткатами

## Задача

Сейчас шорткаты отображаются на главном экране, на экранах заказа и мультизаказа. Однако это управляется параметром `state.screen_type`, который задаёт клиент в запросе в `products`. Хочется, чтобы экраны можно было создавать динамически на стороне сервера, а кроме того, добавить возможность открывать их по некоторому `action`.

Для каких целей:
- для отображения "Продуктов" в новой шторе
- для отображения каталогов Лавки/Маркета
<details><summary>Картинки</summary>
![Главный экран](./static/groceries.png)
</details>

## Предложение

### Новый action

Добавляем новый action следующего вида:
```yaml
TypedShortcutsScreenAction:
  type: object
  additionalProperties: false
  properties:
      type:
          type: string
          enum:
            - shortcuts_screen
      name:
          type: string
  required:
    - type
    - name
```

Здесь
- `name` - имя экрана, который открывается. Необходим для определения того, что будет на нём показано.

Как себя ведёт новый экран:
1. При срабатывании этого `action` на главном экране клиент запрашивает описанную ниже ручку и открывает нативную штору поверх главного экрана, заполняя её ответом этой ручки
2. При срабатывании этого `action` на уже открытой нативной шторе клиент запрашивает описанную ниже ручку и отрисовывает содержимое ответа этой ручки в этой же шторе.
3. При необходимости открыть webview оно открывается (рисуется) в этой же шторе.

Отмечу, что под webview в предыдущем абзаце подразумеваются кастомные сценарии Еды/Лавки/других сервисов наподобие `eats_based:x`. Такое ограничение связано с тем, что только у `eats_based`-сервисов есть необходимая обратная связь от веб-страницы в виде колбеков из JS. При необходимости открыть произвольный URL он будет открыт в новом окне, как и всегда.

На первоначальном этапе можно этот `action` на новой шторе, но в дальнейшем полезно сделать следующее:
 
При срабатывани `action` на уже открытой шторе клиент запоминает, на какой шторе он был только что (кладёт её имя в стек/список). На всех следующих экранах, которые будут отрисованы в этой же шторе, клиент рисует кнопку "Назад", по нажатию на которой выбрасыввает имя текущего экрана со стека и запрашивает ручку с предыдущим. В изначальном положении нативной шторы, только что открытой поверх главного экрана, кнопки "Назад" нет, она появляется только при дальнейших переходах.

### Новая ручка

#### URL
4.0/mlutp/v1/products/screen/{screen_name}

#### Схема
[Тут](./screens_main.yaml).

Иными словами, из запроса в `products` выбрасывается поле `supported_vertical_types` (поскольку штора будет принадлежать одной вертикали) и почти все поля из `state` (поскольку там многое про таксишные заказы и польза от этой информации для отображения новой шторы сомнительная).

Описание интерфейса переносится в объект `screen`, в котором за вычетом некоторых полей повторяется содержимое объекта из массива `modes` для `mode`=`taxi`. Поля `modes` и `products` остаются на случай, если в будущем понадобится прокидывать разные параметры для разных сервисов, отображаеммых на одном экране.


#### Заголовок

Для экрана шорткатов сверху нужно отображать заголовок. Так как текущая реализация с header в секции не позволяет убрать фиксированные отступы сверху и снизу, было принято решение расширить API. Новое API предлагается построить на основе компонент, как это было сделано в [дизайне](https://www.figma.com/file/DAk0OApRgm9d7bGeccuJcN/%D0%95%D0%B4%D0%B0%2C-%D0%9C%D0%B0%D1%80%D0%BA%D0%B5%D1%82-%E2%86%92-Go?node-id=5%3A4059). 

Предлагается добавить новое поле typed_header, у которого будет приоритет над header. Схема будет выглядеть следующим образом:

```yaml
TextTemplate:
    additionalProperties: false
    type: object
    properties:
        text:
            type: string
        attributed_text:
            $ref: "extended-template/definitions.yaml#/definitions/AttributedText"

TypedSectionHeader:
    type: object
    additionalProperties: false
    required:
      - type
    properties:
        type:
            type: string
        lead:
            type: object
            additionalProperties: false
            required:
              - type
            properties:
                type:
                    type: string
                title:
                    $ref: "#/definitions/TextTemplate"
                icon_tag:
                    type: string
    
ShortcutsSectionObject:
    type: object
    additionalProperties: false
    required:
      - type
      - shortcut_ids
    properties:
        type:
            $ref: "#/definitions/SectionType"
        shortcut_ids:
            type: array
            items:
                type: string
        typed_header:
            $ref: "#/definitions/TypedSectionHeader"
        header:
            $ref: "#/definitions/SectionHeader"
        tags:
            $ref: "#/definitions/Tags"
```

Пример:

```json
"typed_header": {
  "lead": {
    "type": "app_title",
    "title": {
      "text": "Продукты"
    },
    "icon_tag": "shortcuts_shops_screen_icon"
  },
  "type": "list_item"
}
```



#### Источник данных и схема взаимодействия сервисов

На первом этапе прдполагается прокидывать магазины/шорткаты для них по эксперименту. В дальнейшем при появлении крупных потребителей вроде каталога Лавки или Маркета нужно будет написать для них ручку наподобие `tops` в `eda-shortcuts` (для Маркета, возможно, в другом сервисе). Это будет проработано позже.

### Индикация клиентской поддержки
#### Для action

Для индикации клиентской поддержики для `action` открытия новой нативной шторы клиент отправляет в `supported_actions` объект следующего вида:

```yaml
ShortcutsScreenSupportedAction:
    type: object
    additionalProperties: false
    required:
        - type
    properties:
        type:
            type: string
            enum:
              - shortcuts_screen
```

Пример:
```json
{
    "supported_actions": [
        {
            "type": "shortcuts_screen"
        }
    ]
}
```


### Саджест адресов

В случае, если нативная штора используется, например, для отображения магазинов из Еды, хочется иметь возможность указать адрес доставки. При этом, контекст адреса может меняться в зависимости от сценария использования шторы: например, для магазинов может быть полезно показывать предыдущие адреса доставки из магазинов, а для маркета - адреса пунктов самовывоза.

Для этого предлагается в корне ответа ручки `screens` возвращать поле
```yaml
    suggest_mode:
        type: string
        example: shop
```

Клиент поверх нативной шторы отображает окно выбора адреса. При попытке смены адреса клиент будет забирать саджесты адреса, запрашивая ручки `persuggest` с `mode=suggest_mode`. После выбора адреса клиент должен перезапросить ручку `screens` с `position`, соответствующим новому адресу.

**План работ**:

https://st.yandex-team.ru/TAXIBACKEND-34832

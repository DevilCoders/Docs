# Продуктовая задача

В рамках проекта по интеграции с пунктами самовывоза https://st.yandex-team.ru/TAXIPROJECTS-1471 хочется на главном экране нотифицировать пользователя о возможности доставки из ПВЗ через Такси.

Для этого предлагается отобразить на кирпичике доставки лейбл с числом ещё не отображенных на саммари заказов.

Релевантная цитата из тикета, пункт 10:
> Главная страница, киричик доставки с отметкой (цифра или что-то еще). Отметка-идентификатор срабатывает по правилу - есть посылка в ПВЗ и переход по диплинку на карточку заказа ПВЗ, после идентификатор удаляется и кирпичик работает по принципу переадресации на вертикаль доставки. Также поддержать возможность с какой-то периодичность показывать идентификатор в кирпичике, даже если сработала предыдущее правила перехода по диплинку. Зачем? Чтобы обращать внимание пользователя, если заказ долго не забирается, то "Эгегей, мы можем доставить тебе посылку, потому что у тебя нет времени дойти до ПВЗ, у нас оно есть".

Более формально (нужно окнуть об продукт):
* Вводим понятия "прочитанное" и "непрочитанное" уведомление
* Каждая посылка в ПВЗ (приходит в секции /shipments в /launch) должна создавать непрочитанное уведомление
* Количество непрочитанных уведомлений о ПВЗ необходимо отображать на кирпичике доставки
* При нажатии на кирпичик пользователь должен попадать на экран заказа, уведомление о заказе нужно пометить как прочитанное

> Также поддержать возможность с какой-то периодичность показывать идентификатор в кирпичике, даже если сработала предыдущее правила перехода по диплинку

* Если уведомление отмечено как прочитанное больше чем IDLE_THERSHOLD секунд, однако заказ так и не сделан, пометить уведомление как непрочитанное


## Верхнеуровневые решения


### Вариант 1: Управление нотификациями boxberry на клиенте [принято]

Вся потенциальная логика по отображению нотификации живет на клиенте, бекенд лишь возвращает клиенту рубильник.

* В объект кирпичику доставки добавляем поле `"service": "delivery"`, по которому клиент поймет в каком кирпичике отображать счетчик для доставки
* В ответ ручки 4.0/mlutp/v1/products добавляем typed_experiment `shortcuts_delivery_shipments_attractor` со значением:
```json
{
 "name": "shortcuts_delivery_shipments_attractor",
 "value": {
  "enabled": true,
  "repeated_attraction_interval": 259200 // через rai секунд счетчик появится вновь, если заказ не был сделан. Может отстутсовать, если не нужно привлекать внимание повторно
 }
}
```

Отсутствие эксперимента или `enabled: false` нужно трактовать как отключение счетчика

Недостатки:
* Много логики на клиенте, которая может быть потенциально несовместима с дальнейшим развитием кирпичика доставки


### Вариант 2: Управление нотификациями исключительно с бекенда

Например:

1) Клиент посылает заказы из `/launch.orders.shipments` в запросе `v1/products.state.known_orders` как `shipment:<orderid>`
2) В архитектуру `4.0/mlutp/v1/products` добавляется поход в ручку `some-cargo-service/notifications`. В ручку передается `known_orders`, по которому есть возможность определить необходимость показа нотификаций для заказов. Ручка возвращает нотификации.
3) Нотификации приходят в shortcuts (потенциально через blender), shortcuts модифицирует шорткаты (лепит на них лейблы)
4) При отображении заказов из ПВЗ в UI клиент отправляет запрос в `4.0/mark-notify/v1/` со списком отображенных заказов.
5) Через механизм `mark-notify` сервис `some-cargo-service` помечает уведомление как прочитанное.
6) По крону `some-cargo-service` может помечать уведомления как "непрочитанные" или удалять их.

Потенциальные проблемы:
1) Клиентские запросы к сервису `mark-notify` могут не дойти. Будет потеря уведомления о прочтении нотификации.
2) Флоу `mark-notify` работает с определенной задержкой (сеть + поставить STQ + выполнить STQ), и при быстром возврате на главный экран нотификация может не успеть обновиться
3) При проблемах в `some-cargo-service/notifications` будут флапы интерфейса
4) `some-cargo-service/notifications` нужно консистентное хранилище с рейтом чтения ~1000 RPS и таймингами < 100 мс

Критичность проблем надо обсудить с продуктом.

Решение требует ещё `2д` на допроработку и ориентировочно `5д` на реализацию бекенда (обращаю внимание, что решение может не окнуть продукт)

TODO: посмотреть на сервис `feeds` https://wiki.yandex-team.ru/taxi/backend/architecture/communications/, в нем есть сущность "сообщения" и трекинг их статуса

## Вариант 3: гибридный

Идея аналогичная с personalstate — бекенд используется как "персистентное" хранилище, однако у клиента есть возможность какое-то время работать с локальной ревизией даже если обновление не доходит до бекенда.

# Учет нажатия на турбокнопку/шорткат в выдаче шорткатов

## Продуктовая задача:
```
1. пользователю, который ни разу не нажимал на определённую кнопку в интерфейсе, при первом нажатии показывать фулскрин-онбординг
   1. после первого просмотра онбординг больше не показывать
   2. при переустановке приложения не показывать онбординг заново
2. на шорткатах, кирпичиках и турбокнопках показывать overlay до первого нажатия на соответствующую кнопку
   1. также уметь показывать шорткат до первого нажатия на него (нужно, например, для скидочного шортката)


Доп. задача — уметь отличать в сервисе «новичков»:
   - по отсутствию нажатий на определённую кнопку
   - по отсутствию заказов в определённом сервисе
   - по времени регистрации пользователя
```

## Подход к пониманию проблемы

На самом деле, тут несколько задач, и если я всё правильно понимаю, то они звучат так:
   1. Хотим добавить возможность показа онбордингов к турбокнопкам
   2. Реализовать механизм уведомления клиентов о том, что они просмотрели определённый контент
   3. Научиться размечать пользователей по группам

## Исходные данные

- количество нажатий по турбокнопкам + шорткатам по платформам за день https://yql.yandex-team.ru/Operations/X1Ze8S--PAdXyYPVdKuDk7JHxtjIEjIP8ur_zkfvAp8=?editor_page=main

## Варианты решения проблем:

### Клиентские счётчики промок в v1/products

**Решаем задачу скипа онбординга/промо шорткатов**

Хотим считать, сколько раз пользователь видел определённую промку, и оперативно уметь убирать её из выдачи для клиентов.

- Счётчики работают для онбордингов турбокнопок и шорткатов.
- Счётчики просмотров онбординга должены храниться на клиентах до переустановки.

Как это работает на бэке:
1. Делаем эксперимент с указанием id промок и счётчиком, эксперимент необходимо использовать в сервисе `blender-shortcuts` + `shortcuts`.
2. Отдельный сервис для сбора метрик

для промок с данным свойством, необходимо считать количество открытий/показа и передавать в массив `seen` при вызове ручки `v1/products`. Необходимо передавать счётчики/промки в состоянии `complete`.

```(json)
{
    // вероятно тут, можно сэкономить и отпавлять просто список строк
    "counters": {
        "seen": [
            {
                "id": "some_counter_id", // id счётчика
                "status": "complete",
                "tag": "str_typed_timestamp"
            }
        ]
    }
}
```

#### Ограничения
- На данный момент счётчики работают только для медиа контента из `promotions`, так как у них есть возможность привязки к id

### Онбординг

в каждый элемент шортката/турбокнопки, может добавиться доп объект `onboarding` с описанием целевого действия внутри

```(json)
{
    "action": {
        "mode": "drive",
        "type": "discovery"
    },
    "background": {
        "color": "#F1F0ED"
    },
    "icon_tag": "shortcuts_buttons_drive",
    "id": "discovery_drive:3c0565cd1d8c494e980476698e8fa4e6",
    "service": "drive",
    "text_style": {
        "color": "#21201f"
    },
    "title": "Drive"

    // возможно, данный объект будет встроен и в шорткаты
    "onboarding": {
        "type": "media-stories",
        "action": {
            "media": {
                "promo_id": "some_promo_id"
            }
        }
        "show_policy": {
            "id": "counter_id", // идентификатор счётчика
            "max_show_count": 3,
            "max_widget_usage_count": 1
        }
    }
    ...
    "counters": {
        "tag": "str_typed_timestamp",
        "expired": [
            "counter_id_1",
            "counter_id_2"
        ]
    }
}
```

для промо шорткатов, добавляем объект `show_policy` внутрь шортката.

Как это работает на клиентах:

При нажатии на шорткат/турбокнопку у которого имеется данное поле **ПЕРВЫЙ РАЗ**, необходимо сначала выполнить действие из `onboarding`, последующие разы выполнять основное действие кнопки `action`.

Для онбординга турбокнопок, можно будет завести новый эксперимент, но учесть возможность его мержа с `superapp_buttons_appearance`, тогда, можно будет проводить эксперименты с разными онбордингами.

Онбординг шорткатов:

Можно будет включить на шорткаты с определёным сценарием. Как включить на конкретный шорткат, нужно продумывать отдельно, возможно через админку, но апи это будет позволять сделать.

## Решение задачи хранения счётчиков просмотра контента в такси

Все счётчики хранятся на клиенте и синхронизируются с бэкендом.

### Взаимодействие с бэкендом

`/counters/save` - ручка сохранения клиентских счетчиков, данную ручку нужно дёргать в фоне раз в N секунд, при наличии изменений в клиенстких счетчиках.

`/counters/retrieve` - ручка получения клиентских счётчиков, возвращает сохранённые счётчики для клиента. Данную ручку нужно вызывать при изменения состояния логина.

### Поддержка 

1. офферы промоблоков: используем `id` промоблока
2. промошорткаты: в качестве id используем `promo_id`
3. multiclass_popup: считаем, под id `multiclass_popup`
4. surge_notify: работают внутри заказа, не считаем
5. notifications totw: работают внутри заказа, не считаем
...если я что-то забыл, напомните, попробуем обобщить счётчики и для них.

**Считаем только те нотификации/промообъекты, у которых имеется `show_policy`**

Из этого следует, что во все объекты шорткатов, просмотры которых хотим считать, нужно будет добавить данные объекты.

TODO: добавить пример и согласовать

### Клиентская логика получения счётчиков:

- `новый пользовать + никогда не логинились на девайсе` - создаём новые счётчики, счетчики не сохраняем, пока не появится `yandex_uid`.

- Перезапрос `counters/retrieve` производится при изменении состояния логина со всеми текущими счётчиками. Бэкенд возращает актуальные счётчики для текущего логина.

### API новых ручек

request `counters/save` POST
```(json)
{
    "counters": {
        "seen": [
            {
                "id": "in_progress_id",
                "status": "complete"
            },
            {
                "id": "complete_id",
                "status": "complete"
            }
        ]
    }
}
```

`id` - может не соответствовать id - promotions (это в процессе обдумывания)
`status` - данное поле показывает текущий статус счетчиков. `complete` - в этом случае, бэкенд помечает что условия для выполнения промо данным пользователем - выполнены. В текущей реализации поддерживается только статус `complete`, но в API закладываемся на расширение.
За статусами, следит клиент(обсуждаемо).

response
```(json)
{
    "revision": "som_revision_id", // только для клиентов - для идентефикации текущего состояния кэша
    "call_policy": {
        "interval_seconds": 100 // время в секундах, определяющее интервал между вызовами ручки, данный интервал, не имеет выбирать меньше чем время самого длинного воспроизведения промо, иначе, весь смысл будет невелирован.
    },
    "expired_counters": [
        "counter_id_1",
        "counter_id_2"
    ]
}
```

`call_policy` - нужен, чтобы была возможность управлять нагрузкой со стороны бэкенда.
`expired_counters` - список идентификаторов заэкспайреных счётчиков. Клиентам необходимо удалить из локального кэша счётчики из данного списка.


Клиент, раз в N секунд, делает запрос в ручку `counters/save`, на сохранение текущих изменений, но передаёт все известные счётчики.
По словам Гоши, среднее время просмотра одного промоушена 5-7с. Предлагаю взять чуть больше чем 2х кратный интервал от одиночного просмотра = `15с` в качестве значения по умолчанию.

Нужно попробовать договориться про обработку 429.
Хотелось бы, чтобы клиент мог уметь обработать 429, например в случае проблем с базой и клиент это воспринял, как то, что данные небыли сохранены на бэке, не делать ретрая, дождаться следующего периода отправки запроса. (обсудить)


request `counters/retrieve` POST
```(json)
{
    "counters": {
        "seen": [
            {
                "id": "in_progress_id",
                "status": "complete"
            },
            {
                "id": "complete_id",
                "status": "complete"
            }
        ]
    }
}
```

response
```(json)
{
    "revision": "som_revision_id", // только для клиентов - для идентефикации текущего состояния кэша
    "counters": [
        {
            "id": "completed_id",
            "status": "complete"
        },
        {
            "id": "in_progress_id",
            "status": "complete"
        }
    ]
}
```

Данная ручка будет дёргаться при изменении логина(смена yandex_uid), будет вызываться со всеми ищующимися клиентскими счётчиками, это необходимо, чтобы решать проблему гонок сохранения при перелогине.

Фоллбек: при ошибках в данной ручке, считаем что счётчики переезжают на новый логин.

#### Раскатка фичи

Эксперимент `user_counters_enabled` в лонче?

### Логика бэкенда

#### Выбор идентификаторов

1. `yandex_uid` как единственный верный идентификатором пользователя. Минусы в том, что непонятно как мержить 2 разных фониша, при запорталивании, но в качестве простого варианта, можем просто мержить все счётчики с этимх идентификаторов, считая что это один и тот же пользователь.

#### Schema DB:

Отвязываемся в явном виде от promotions_id, для того чтобы связаться с promotions_id, нужно будет добавить в таблицу `test.counters` счётчик, где `id` - уникальный id счётчика, `link_id` - promotions_id, `link_type` - promotions. 
Новый счётчик можно будет заводить вначале руками, запуском скриптов, затем, добавить спец поле в админку промок и написав ручку для создания связей в сервисе.

Был расмотрен вариант использования `many to one` и хранение `josnb` поля для подсчета счётчиков.

Приемущество данного способа хранения данных с jsonb:
- Позволяет из коробки решать конфликты при конкурирующих запросах
- Позволяет в будущем, реализовать удаление счётчиков и всех связанных с ним записей

```
CREATE SCHEMA test;

CREATE TABLE test.counters (
    id TEXT PRIMARY KEY,
    link_id TEXT NOT NULL,
    link_source TEXT NOT NULL
);

CREATE TABLE test.users_counters (
    yandex_uid TEXT NOT NULL,
    counter_id TEXT NOT NULL,
    
    FOREIGN KEY (counter_id) REFERENCES test.counters(id),
    PRIMARY KEY (yandex_uid, counter_id)
);
```

```
SELECT * FROM test.users_counters WHERE yandex_uid = $1;
```

По пробовал данные запросы на 900к записей в таблице `test.users_counters`: https://paste.yandex-team.ru/1334203

Решаем все конфликты следующим образом - берём максимальное значение счётчиков, и даём предпочтению завершённому статусу.
```
INSERT INTO test.users_counters (yandex_uid, counter_id, show_count, usage_count, status)
VALUES ($1, unnest($3), unnest($4), unnest($5), unnest($6))
ON CONFLICT (yandex_uid, counter_id) DO UPDATE set
show_count = GREATEST(test.users_counters.show_count, excluded.show_count),
usage_count = GREATEST(test.users_counters.usage_count, excluded.usage_count),
status = CASE WHEN users_counters.status = 'complete'
                      THEN users_counters.status
                      ELSE excluded.status
                 END;
```

По пробовал данные запросы на 900к записей `test.users_counters`: https://paste.yandex-team.ru/1334185

#### Расчёт объёма данных

Считал размер записи так:
`SELECT sum(pg_column_size(t.*)) as filesize, count(*) as filerow FROM main.entries as t;`

Одна строчка test.users_counters занимает **48**

Расчёт количества пользователей:
Я использовал количество записей в коллекции `phone_counters`: 83065567, если заложить 30% на рост, то получаем **107985237**

с **30** счётчками: 107985237 * 48 * 30 = 155498741280 **~156 гб** + Стоит учесть индекс, судя по схеме он должен быть чуть больше по размеру таблицы **test.users_counters**, это так же подтверждается эмперически.

Поэтому, для хранения вышеуказанного количества данных, стоит закладывать как минимум 320гб. Но, наверное, стоит сразу взять с запасом 4 шарда по 100гб.

#### Расчёт нагрузки

**Подход на основе аналититических данных**

Можно за основу взять, количество нажатий турбокнопок в приложении, допустив что при каждом нажатии нам придётся показать онбординг.

[Исходные данные](!https://nda.ya.ru/t/I8eRVwO-3Y72QX)

Получается примерно 100rps, без учёта асинхронности процесса на стороне клиентов и других промообъектов.

Я предполагаю, что с помощью правльно выставленного интервала сохранения счётчиков, можно добиться и меньше 100 рпс.

#### Шардирование

будем пользоваться следующей вормулой: `crc32(uid) % num_shurds`

Выбрать количество шардов? Задача для разработчика фичи. Но нужно посмотреть как минимум на предполагаемый rps и текущий лимит нагрузки на nano | micro db.

#### Необходимы компоненты

1. Кэш идентификаторов счётчиков
2. lru кэш счётчиков пользователя (основываясь на том факте, что за сессию, пользователь делает несколько запросов ручки products и др. возможно, тут лучше подойдёт redis, учитывая что хочется хранить данные в кэше внутри "сессии" пользователя, и уменьшить вероятность промохов)
3. lru кэш счётчиков над сервисов счётчиков (возможно, на первых этапах обойдёмся без него, для шорткатов, нужно держать 1к+ рпс)

#### Декомпозиция задач

По сервису:
1. Заведение сервиса
2. Прохождение архревью
3. Настройка окружений
4. Реализация ручек и запросов в базу, с простыми походами в базу, без проверок и кэшей (тут много задач на самом деле)
5. Реализация lru поверх базы / завести редис
6. Пострелять по сервису
7. Запуск
8. Ручка для заведения счётчиков
9. Автоматическая система увеличения интервала сохранения счётчиков на основе сервиса статистики

Интеграции:
1. Интегрироваться с промоушенс: на каком-то этапе, хватит скрипта, затем будет нужна ручка в сервис (для promotions, можно делать id == promotion_id)
2. Интеграция с сервисом в superapp-misc - продумать апи и прокинуть данные в `blender` + `shortcuts`
3. Интеграция с сервисом через lru.
4. Запрос из ручки админки промоушенов в ручку заведения счётчиков

3 вопроса (05.04.2021):
1. отказ в 1 этапе от сетевого взаимодействия (save/retrieve)
- в первом этапе сетевое взаимодействие save/retrieve не используем;
2. директивы удаления счетчиков в ендпойндах
- добавляем в ответ ручки логику работы со счетчиками;
3. контексты счетчиков
- изолируем контекст логики счетчиков по ендпойнтам;

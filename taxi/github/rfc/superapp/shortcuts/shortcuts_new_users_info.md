## Продуктовая задача


### Задачи 
https://st.yandex-team.ru/TAXIPROJECTS-1840 [shortcuts] добавить в кварги признак «новичка»

https://st.yandex-team.ru/TAXIBACKEND-30999 Кварг "новичок"


### Верхнеуровневое описание

Хотим научиться проводить эксперименты на новичках
В первую очередь &mdash; эксперимент с внешним видом турбокнопок

Новичок в зависимости от контекста может определяться через:
1. Дата регистрации в сервисе/вертикали (неавторизованных в сервисе пользователей тоже считаем новичками)
2. Число сделанных заказов в сервисе/вертикали
3. Факт использования какой-то фичи (нажал на шорткат)


## Детализация решения

### Описание
Сразу отметим, что П. 3 решается в смежном rfc https://github.yandex-team.ru/taxi/rfc/pull/566,
поэтому здесь его рассматривать не будем.

Следовательно, нас интересует дата регистрации пользователя и число его заказов.

Саму дату регистрации пользователя в такси определить довольно сложно.
Пользователь определяется несколькими идентификаторами:
* YandexUID &mdash; uid из yandex passport
* UserID &mdash; user id из dbusers, идентификатор сессии
* PhoneID &mdash; идентификатор телефона пользователя 


#### Определение даты регистрации пользователя в такси
Решаем задачу определения нового пользователя по дате регистрации 

Определим виды ошибок:
1. Пользователь старый, но мы его посчитали за нового &mdash; это false-positive или FP
2. Пользователь новый, но мы его посчитали за старого &mdash; это false-negative или FN

Дата создания YandexUID не подходит нам, так как велика вероятность,
что пользователь давно пользовался сервисами яндекса, до того как пришёл в такси,
то есть будет много ошибок FN

Дата создания UserID тоже не подходит, так как это идентификатор сессии
и он создаётся заново при перелогине, поэтому высока вероятность ошибок FP

Дата создания PhoneID выглядит приемлемой для этой задачи, так как запись о телефоне создаётся
тогда, когда на этот телефон человек логинится в такси или ему создают заказ.
Однако если человек сменил номер, то мы ложно сочтём его новичком.
То есть этот метод имеет следующие недостатки:
1. Человеку создали заказ на его номер,
но он не являлся пользователем приложения такси, ошибка FN
2. Человек поменял номер, будет ошибка FP

Кажется, что вероятности этих ошибок не сильно критичны, но нужно исследование.

PS. Кажется, что от ошибок из П. 2 можно избавиться,
если получать по YandexUID все номера пользователя
и брать за дату регистрации пользователя самый старый из них.
Вопрос про исследование необходимости этого поставлен в конце документа:
глава "Открытые вопросы", пункт 2.


#### Определение числа заказов пользователя в такси
Тут варианта 2:
1. Получить число заказов по PhoneID из user-api.
В таком случае мы получим все заказы пользователя с данного телефона,
но возможно упустим заказы с его прежних номеров.

2. Получить число заказов по YandexUID из user-statistics счётчиков.
В таком случае мы получим число заказов пользователя независимо от смены им номера.
Однако, возможно, чтобы получить действительно все заказы, надо ещё делать запросы по связанным YandexUID,
ведь их может быть несколько в зависимости от их типа


### Этап 1

Определяем дату регистрации пользователя как
дату создания записи о телефоне пользователя в БД такси.
Это делается запросом в `http://user-api.taxi.yandex.net/v2/user_phones/get` по
PhoneID

Число заказов пользователя тоже берём из ответа этой ручки,
то есть получаем число заказов сделанных с данного номера телефона.


#### API
Добавляем в запрос к `/v1/blender-shortcuts` поле `user_phone_info` типа `UserPhoneObject`
(из этого типа нам нужны только поля `created` и `stat.total`,
поэтому в сервисе шорткатов у объекта `user_phone_info` оставляем только их)

Изменения в API shortcuts:

`api.yaml:`
```yaml
definitions:
    BlenderShortcutsRequest:
        type: object
        additionalProperties: false
        properties:
            ...
            user_phone_info:
                $ref: "shortcuts/definitions.yaml#/definitions/UserPhoneObject"
```

`definitions.yaml:`
```yaml
definitions:
    Timestamp:
        description: Timestamp in ISO8604 format
        type: string
        format: date-time-iso-basic
        example: "2016-02-07T19:45:00.922+0000"

    UserPhoneStatistics:
        description: User Phone statistics
        type: object
        properties:
            total:
                type: integer
        required:
          - total
        additionalProperties: false

    UserPhoneObject:
        description: User's phone object
        type: object
        properties:
            created:
                $ref: '#/definitions/Timestamp'
            stat:
                $ref: '#/definitions/UserPhoneStatistics'
        additionalProperties: false
```

Заполняем `user_phone_info` при запросе из api-proxy ручки `/4.0/mlutp/v1/products`
(запрашиваем только поля `created` и `stat.total`),
получая нужную информацию по PhoneID
из ручки `http://user-api.taxi.yandex.net/v2/user_phones/get`.


#### На бэке:

1. Добавляем api-proxy resource `user-api-v2-user_phones-get` для ручки 
`http://user-api.taxi.yandex.net/v2/user_phones/get`

2. Добавляем эксперимент `api_proxy_products_get_phone_info` который активизирует 
поход из `/4.0/mlutp/v1/products` в `user-api-v2-user_phones-get`

3. В запрос к `/v1/blender-shortcuts` добавляем поле `user_phone_info` (его yaml описан выше).
В случае его наличия прокидываем в эксперименты кварги
`user_registration_timestamp`, `user_hours_count_since_registration`, `user_total_orders_count`.

4. Добавляем в `/4.0/mlutp/v1/products` поход в `user-api-v2-user_phones-get`
по эксперименту `api_proxy_products_get_phone_info`

Пример запроса в ручку `http://user-api.taxi.yandex.net/v2/user_phones/get`

Request (id &mdash; это PhoneID)
```json
{
    "id": "5e8b12137984b5db624bfbb2"
}
```

Response
```json
{
    "id": "5e8b12137984b5db624bfbb2",
    "type": "yandex",
    "personal_phone_id": "6a4059843d524888bc717d66a77f29d2",
    "created": "2020-04-06T11:27:15.91+0000",
    "updated": "2020-09-24T09:10:24.936+0000",
    "phone_hash": "c7f214c5f4243e9bf3023bb24aa4cb24dddd0fda7d826bdf9e1aa93f41ee9146",
    "phone_salt": "FyeO/l1zDC9Sz26HJLdGa06vQ1QhNDVGHIBB1KsPGcs=",
    "yandex_staff": true,
    "taxi_staff": true,
    "bound_uid": "4041152532",
    "last_order_city_id": "Москва",
    "last_order_nearest_zone": "moscow",
    "last_payment_method": {
        "type": "cash"
    },
    "loyalty_processed": [
        "6ada535e1c643c8a82a8d73d4a48507a"
    ],
    "stat": {
        "big_first_discounts": 0,
        "complete": 1,
        "complete_card": 0,
        "complete_apple": 0,
        "complete_google": 0,
        "total": 1,
        "fake": 0
    }
}
```

Из ответа нам сейчас интересны поля `created` и `stat.total`

Пример запроса в ручку `http://user-api.taxi.yandex.net/v2/user_phones/get` c фильтром полей

Request (id &mdash; это PhoneID)
```json
{
    "id": "5e8b12137984b5db624bfbb2",
    "fields": [
        "created",
        "stat.total"
    ] 
}
```

Response
```json
{
    "id": "5e8b12137984b5db624bfbb2",
    "created": "2020-04-06T11:27:15.91+0000",
    "stat": {
        "big_first_discounts": 0,
        "complete": 0,
        "complete_card": 0,
        "complete_apple": 0,
        "complete_google": 0,
        "total": 1,
        "fake": 0
    }
}
```


#### Таймауты, ретраи, фоллбэки
Поход в ресурс `user-api-v2-user_phones-get` предлагается осуществлять
с таймаутом в 150мс и 1 ретраем, это не должно замедлять ручку `/4.0/mlutp/v1/products`,
Так как запрос выполняется параллельно с запросами в `superapp-misc` и `blender`,
ответы которых также используются для формирования запроса в `/v1/blender-shortcuts`.

В случае ошибки запроса в `user-api-v2-user_phones-get` &mdash; источник отключается
и поле `user_phone_info` не прокидывается в запрос к `/v1/blender-shortcuts`.
Таким образом, в случае ошибки кварги новичка не будут прокинуты в эксперименты.


### Открытые вопросы

1. Как на уровне api-proxy кэшировать ответы `user-api-v2-user_phones-get`?

   Как выставить необходимые ограничения на размер кэша и время жизни записи в нём?
   Скажем, нас устроил бы кэш на несколько десятков минут,
   чтобы кэшировать запросы от одного пользователя во время одной поездки и сдвигов пина.

   Судя по [доке api proxy](https://wiki.yandex-team.ru/taxi/backend/architecture/apiproxy/manual2/#m-kjeshirovanieotvetovresursa),
   текущее кэширование ответов нам не подходит,
   так как там идёт завязка на хедер `Cache-Control` в ответе ручки.

2. Как определять дату регистрации новичка, комбинируя данные полученные по
   YandexUID и PhoneID, чтобы минимизировать ошибки false-positive/false-negative?
   Нужно как-то поэкспериментировать с разными вариантами и собрать какую-нибудь статистику.

   Сильно ли снизит ошибки способ, если по YandexUID получить список телефонов пользователя
   и потом взять за дату регистрации в такси дату создания самого старого из них?

   Ещё мб можно использовать какую-то информацию о датах,
   которую создаёт zalogin при авторизации/регистрации.
   Но эта информация сейчас не отдаётся,
   нужно или искать её в базе или дорабатывать zalogin:
   ```
   Andrei Vasiukevich, [22 Sep 2020, 16:18:27]:
   Понял. А по uid пользователя можно какую-то инфу получить?

   Mikhail Vilkin, [22 Sep 2020, 16:19:23]:
   Тоже подумал об этом, но звучит еще хуже - пользователь ведь мог давно пользоваться сервисами яндекса, просто такси не использовать

   Можно использовать что-то типа время, когда мы себе в базу синкнули связь uid->phone_id из паспорта, но тоже не очень надежно, т.к. они будут обновляться, если человек отвязал номер в паспорте и потом снова вернул

   Andrei Vasiukevich, [22 Sep 2020, 16:34:21]:
   А это время синка какой-нибудь сервис отдаёт?
   
   Mikhail Vilkin, [22 Sep 2020, 16:42:50]:
   Оно в zalogin, если сейчас никто не отдает, то можно добавить по идее
   Скорее всего, не отдаются, потому что это больше какая-то утилитарная инфа, а не пользовательская
   ```

3. Насколько обычно отличается число заказов пользователя,
   полученное по YandexUID и по PhoneID?

# Проблема

Из TAXIBACKEND-30117:
> На данный момент наличие/отсутствие шорткатов (и, как следствие, супераппа) зависит от включающегося по полигонам Еды/Лавки
> Сейчас возможен следующий сценарий:
>
> 1) Пользователь делает заказ через суперапп
> 2) Двигает пин в точку, где не работает superapp_shortcuts
> 3) Теряет точку входа в вертикаль и возможность взаимодействовать с заказом
>
> В случае с Драйвом этот кейс особо критичен: пользователи часто арендуют машину в Москве и уезжают на ней в сел

**Как реализован трекинг активного заказа в мобильном приложении Такси**

Информацию о заказе текущего пользователя в Драйве мобильное приложение узнает из SDK Драйва.

**Когда на клиентах запрашивается 4.0/mlutp/v1/products**

v1/products вызывается если значение эксперимента `superapp_shortcuts` в `*suggest` ручках равно `true`.

### Решение

Предлагается модифицировать условие вызова `4.0/mlutpv1/products` до следующего: либо в `*suggest` ручке пришел `superapp_shortcuts=true`, либо у пользователя есть активный заказ в драйве.

При этом мы не хотим блокировать вызов `4.0/mlutp/v1/products` ожиданием drive-SDK. Для этого на клиентах предлагается реализовать следующую логику:

* При заказе Драйва через суперапп клиентское приложение кеширует информацию о заказе
* При полинге статуса заказа в drive-SDK, обновлять информацию об активных заказах в кэше
* Если drive-SDK не успело ответить к моменту ответа `*suggest` с `supperapp_shortcuts=false`, использовать информацию о заказе в Драйве из кеша

Бекенд при наличии заказа Драйва в `state.known_orders` форсирует показ кирпичика Драйва, чтобы на клиенте была точка входа в драйв и место для размещения трекинга.

### Неполетевшие альтенативы
<details> <summary>кат</summary>

### Вариант A — передача state.known_orders в `*suggest` ручки

Идея:
1) В клиентские запросы к `*suggest` добавить `state.known_orders`. Напомню, что это выглядит так:
```
{
    "state": {
        "known_orders": [
            "taxi:<orderid>...",
            "eats:<orderid>...",
            "drive:<orderid>..."
        ]
    }
}
```
2) В персаджесте шлем кварг `known_orders_services: {"drive", "eats", "taxi"}`
3) Делаем соответствующий клоз в эксперименте superapp_shortcuts

Проблема: получение статуса заказа драйва в SDK не моментально, и нужно будет либо
1) Блокировать запросы в `*suggest` до получения заказа в Драйве (очевидно плохо)
2) Перезапрашивать `*suggest` ручку (непонтяно какую) при ответе от SDK
3) Ждать пока пользователь подвинет пин, и тогда передать активный заказ драйва (не нравится продукту)

Я не понимаю как сделать этот вариант рабочим

## Вариант B — полигоны Драйва

Реализовать решение аналогичное Еде/Лавке:
* Запросить у Драйва ручку получения полигонов доступности сервиса
* Написать поверх неё кеш в persuggest
* Добавить point_services CONTAINS drive

Проблемa:
В драйве нет ручки полигонов доступности. На данный момент были такие планы реализовывать "честную" доступность драйва:

> Такой ручки нет
> У них есть ручка офферов, в ответе которой указан флажок доступности
> можно запросить 0 офферов и получить только доступность))
> План был такой - делается запрос в эту ручку за 1 оффером. Если сервис недоступен, то нет кнопки драйва, иначе если нет офферов, то кнопка серая, иначе кнопка обычная
</details>
**Название сервиса**

order_offers

**Какую продуктовую проблему решает сервис?**

Закрывает прямые походы в базу `order_offers` на походы в сервис.

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Ходить в базу через сервис более безопасно и правильно.

**Как именно сервис будет решать поставленные перед ним задачи?**

На первом этапе будет реализовано чтение из базы нужной информации.
В дальнейшем планируется добавить возможность добавления записи в базу.

**Разрабатывается один сервис или система?**

Один сервис.

**С кем взаимодействует сервис?**

На первом этапе в сервис будет обращаться `tariffs_promotions`, источник промоблоков.
Сервис будет обращаться в сервис конфигов.

**Какие (микро-)сервисы и как используются.**

Сервис конфигов - для получения конфигов с настройками для походов в базу, 
каких-то ещё вспомогательных конфигов.
Больше никакие сервисы не используются.

**Как организованы ретраи внешних сервисов.**

Кроме сервиса конфигов, внешние сервисы не используются.

**Какие базы использует?**

`order_offers`

**Какие периодические процессы?**

Никаких.

**Как технически проект влияет на цикл заказа.**

Если удастся успешно использовать сервис, предполагается, что все сервисы, которые напрямую ходят или будут ходить в базу `order_offers`, будут использовать этот сервис.

**Кто будет потребителями сервиса.**

На первом этапе в сервис будет обращаться `tariffs_promotions`. 
Впоследствии - сервисы, которым потребуется использовать базу `order_offers`.

**Какие данные и по какой схеме сервис будет хранить в базе?**

Будет только база `order_offers` в том виде, в котором она есть сейчас

**Какие таблицы, индексы, уровни изоляции транзакций, особенности запросов и тп. Объем хранимых данных, как их подразумевается чистить. Ресурсы под СУБД (cpu, ram, disk).**

Всё то же, что было для базы `order_offers`, менять не планируется.

**Какие операции над данными заложены?**

На первом этапе - чтение из базы `order_offers` по `offer_id`.
Впоследствии, возможно, добавление записи в базу.

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

Нет

**Какая нагрузка ожидается?**

На старте планируется нагрузка не больше 50-100rps (5% от `routestats`).
Если в дальнейшем на использование этого сервиса переведут запись в базу из `routestats` и чтение из `order_commit` - 
ожидается нагрузка, сопоставимая с `routestats` + `ordercommit` : 4k rps.
Потребуется rate-limiter.
Нагрузочное тестирование не делается.

**Какие фолбеки предусмотрены на сам этот сервис?**

Никаких

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

Никаких.

**Какие точки отказа есть в сервисе?**

Недоступность базы `order_offers`.

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить.**

Сервис внутренний, за продуктовыми метриками следить не планируется.

**Укажите технические метрики**

- утилизация/загрузка базы

**Какая функциональность ожидается в сервисе в будущем?**

Запись в базу из `routestats` и чтение из `order_commit`.

**Этапы разработки:**

- Создание заглушки сервиса - 1d
- Создание и тестирование ручки чтения из базы - 3-5d

Дальнейшая разработка в сервисе будет только после запуска первоначального варианта.

**Какое изменение нагрузки планируется?**

До 4k rps

**Активно ли будет изменяться сервис?**

После того, как будет сделана ручка на запись - нет.

## API

Пока прорабатывается только чтение из базы. 
Ручка чтения должна возвращать значения необходимых полей из базы `order_offers`. 

Для текущей задачи нам нужно иметь только информацию о цене с учётом суржа. 
А в имеющемся коде значения из базы `order_offers` используются в `orderkit` в `backend-cpp` (`OrderMatchesOffer`, `MakeCalcInfo`),
и там требуются почти все поля.

Поэтому пока предлагается сделать две ручки:
1. Ручку, которая возвращает поля, указанные в запросе, чтобы решить текущую задачу. 
2. Ручку, возвращающую всё содержимое базы, используемое в `orderkit` - на будущее.
На мой взгляд, лучше разбить на две ручки, а не делать одну, потому что разные сценарии, очень разное количество обязательных полей,
возвращение цен пока приоритетная задача. Ручку для переноса кода из `protocol` пока не прорабатываем, скорее всего, она будет содержать все поля базы.

Также отдельные походы в эту базу есть в другом коде `backend-cpp` (ml, геопродукте). Ручка для `orderkit` покроет эти сценарии.

api предложено в api.yaml

# Отложенная обработка платежей

## О чём речь

Сейчас в Такси есть два режима работы "в долг":
- Когда у пользователя не хватило денег оплатить поездку или по какой-то другой причине оплата по окончанию поездки не прошла. В таком случае пользователь заносится в базу сервиса `debts` и на логине ему показывается плашка с предложением оплатить долг.
- Когда в Такси/Трасте наблюдаются проблемы, можно включить определённые конфиги (  например, `BILLING_DO_NOT_PROCESS_TRANSACTIONS`), чтобы остановить обработку платежей. После включения такого конфига процессинг (`backend`) не отправляет платежи в `transactions`, а сохраняет локально. После выключения конфига stq-таска будет понемногу разгребать такие платежи, отправляя их в `transactions`.

Хочется реализовать подобные механизмы для любого потребителя `transactions` (в первую очередь для Еды/Лавки), чтобы подобное поведение можно было включать для заданного потребителя с минимальными дорааботками.

В рамках этой проработки будет рассматриваться в основном второй режим (отложенная обработка платежей). Однако в силу того, что у них много общего, при обсуждении второго режима стоит всегда иметь в виду первый.

## Детали реализации Такси
- При включении конфига `BILLING_DO_NOT_PROCESS_TRANSACTIONS` процессинг вместо запроса в `transactions` сохраняет факт необходимости такого запроса в монгу в коллекцию `pending_transactions`.
- Кроме того, после включения конфига `transactions` складывает свои текущие необработанные транзакции в ту же коллекцию.
- Конфиги постоянно мониторит таска `update_transactions_restart`. Она не совершает никакой работы, если конфиг включён, в противном случае ищет в коллекции отложенные транзакции отсортированные по дате создания, и ставит stq-таски в процессинг или `transactiions`.
- Процессинг и `transactions` сохраняют отложенные таски в одну и ту же коллекцию, но с разными префиксами для `id`. Это позволяет таске `update_transactions_restart` понять, в какую из очередей положить таску для возобновления работы: `update_transactions` для процессинга или `transactions_events` для `transactions`.
- И процессинг и `transactions` при включении фолбека сохраняет только `id` заказа/инвойса, поскольку данных в заказе/инвойсе достаточно для работы, ведь процессинг/`transactions` считает дифф того, что уже оплачено и того, что нужно оплатить и делает платёж только если он ненулевой.


## Проблемы решения Такси
- Это супер узкое решение, заточенное чисто под таксишные процессы. В нём эксплуатируется тот факт, что и процессинг и `transactions` используют одну и ту же базу.


## Варианты решения для абстрактного потребителя `transactions`

### Вариант 1: отложенные платежи на стороне `transactions`

- При включении фолбека `transactions` перестаёт обрабатывать stq-таски в `transactions_events` так же, как и сейчас. Задачи, требующие обработки, складывает в отдельную коллекцию.
- При запросе в ручку, которая создаёт таски для обработки в `transactions_events` (это `/invoice/update`,  `/v2/invoice/update/` и `/cashback/update`), `id` такого инвойса также складывется в отдельную коллекцию.
- В `transactions` реализуем таску наподобие `update_transactions_restart`, которая при отсутствии фолбека достаёт из коллекции отложенные задачи (если они есть) и порционно отдаём в `transactions_events`.
- **ВАЖНО**: нужен как общий фолбек (чтобы отключать всё разом при серьёзных/глобальных проблемах Траста), так и фолбек на каждый отдельный инстанс `transactions` (чтобы отключать при проблемах только в процессингах конкретного сервиса). Возможно, можно использовать эксперименты/конфиги 3.0 и мержить по тегу.

#### Плюсы
- Работает для любых текущих и будущих потребителей `transactions`.
- Не меняет интерфейс взаимодействия с `transactions` - потребители так же дожидаются 200 от `/v2/invoice/update` и дальше полагаются на то, что `transactions` рано или поздно обработает этот запрос.

### Минусы
- Разработка (хоть и как будто не очень масштабная) в зоне ответственности команды биллинга.
- Потребители как будто лишаются возможности получить мгновенную обратную связь "сейчас включён фолбек". С другой стороны, факт включения фолбека можно определить из соответствующего конфига/эксперимента.
- Необходима работа с потребителями `transactions` на предмет того, готовы ли они к тому, что колбек может прийти далеко не сразу (сейчас порядок ответа - ~10 секунд). Впрочем:
  - Такая работа необходима при любом варианте решения
  - Альтернатива для потребителей - не получить колбек, но уже потому, что Траст отвечает ошибкой/не отвечает совсем и задача в `transactions_events` не завершается, а периодически поллит Траст.

### Вариант 2: сохранение очереди запросов о проведении платежей в самом потребителеы
- При включении фолбека потребитель `transactions` сохраняет очередь запросов на создание/изменение платежей у себя.
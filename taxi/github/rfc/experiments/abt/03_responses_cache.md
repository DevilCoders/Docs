- [Задача](#задача)
- [Этапы внедрения кешера](#этапы-внедрения-кешера)
- [Оценка сроков](#оценка-сроков)

## Задача

После MVP-запуска ручки оказалось, что время ответа иногда >15с, преимущественно из-за долгого хождения в chyt. Также часто запросы в ручку производятся по одному и тому же набору параметров (версия прекомпьюта, ревизия, revision_days, etc.). Предлагается организовать кеширование ответов ручки. Кеш реализуем и для `v1/metrics/plot`, но конкретный график запрашивается гораздо реже, чем набор рассчитанных результатов конкретного эксперимента.

## Этапы внедрения кешера

1. Запоминание запроса-ответа. Внутри ручки определять, был ли такой запрос на текущем наборе прекомпьютов. Если был - взять закешированный ответ ручки. Целесообразно на данном этапе поддержать кеширование ответов на запросы с фасетами, а также кеширование ответов для `v1/metrics/plot`.  
2. После серии обновления прекомпьютов предпосчитывать ответы ручек: стирать неактуальные записи и перерасчитывать актуальные. Логика меморизации по фасетам при этом не страдает. Под актуальностью я понимаю факт использования записи за последние N дней (N - по конфигу).

## Реализация

Храним предпосчитанные ответы ручек в `postgres`, который уже есть в `abt`.  
Минусы (или, скорее, риски):
* Приложу некоторую статистику. В сервисе `promotions` был прецедент (см. https://st.yandex-team.ru/TAXIBACKEND-29633#5f57a98e035fc353df9096c1) долгого ответа ручки из-за парсинга тяжёлого постгресового jsonb. Посмотрел, что на проде запрос за 5 дней на 5 тестовых групп имеет размер порядка 1Мб. Соответсвенно, в данном случае, ожидаемое время ответа ручки - порядка 2 секунд, что тоже слишком много.  
**P.S.** специально для уточнения ситуации провели эксперимент на парсинг большого закешированного ответа (тип `jsonb`). Оказалось, что с помощью функции `json.loads` 1Мб-ый ответ парсится за 0.02-0.05с, а с помощью `deserialize` переводится в кодогенерённый ответ за 0.11-0.25с.

**Изменения в БД:**
Добавляем таблицу `abt.responses_cache`:
````md
CREATE TABLE IF NOT EXISTS abt.responses_cache
(
    id                      TEXT        NOT NULL PRIMARY KEY -- хеш от параметров по которому можно будет понять наличие данных в кеше
    conditions              JSONB       NOT NULL -- набор параметров, по которому будет происходить обновление кеша (uri/revision/etc.)
    precomputes_tables_ids  SERIAL[]    NOT NULL -- список задействованных прекомпьютов для расчёта данной записи
    accessed_at             timestamp   NOT NULL DEFAULT current_timestamp,
    data                    JSONB       NOT NULL
);
````

На этапе 1 очистка кеша - удлаение всех записей при обновлени какого-либо прекомпьюта.
На этапе 2 реализуем delayed-stq, которая запускает обновление ответов.  
Ожидаемая в реальности работа stq: delayed - для того, чтоб перерасчёт происходил один раз (после того, как ВСЕ прекомпьюты обновлены). stq гарантирует, что при отложенном вызове до, собственно, момента вызова вторая stq с таким же id (который, к слову, можем задать кастомный) не будет поставлена в очередь. stq будет запущена РОВНО один раз ПОСЛЕ ВСЕЙ серии обновления прекомпьютов. Для каждой записи из `abt.responses_cache` stq проверяет условие `accessed_at >= current_timestamp - some_config_value` и принимает решение, перерасчитывать данный ответ или удалять его из кеша.  
Теория: в теории, нет никаких гарантий относительно порядка, времени начала обновления и продолжительности обновления прекомпьютов. Для этого введёна колонка `precomputes_tables_ids`. Отслеживающая изменения прекомпьютов крона ставит в очередь stq каждый раз, когда что-либо изменилось, а stq в момент своего вызова для каждой записи кеша проверяет, было ли что-то из `precomputes_tables_ids` обновлено или нет. Т.о. каждое изменение прекомпьюта будет отслежено, а кеш в любой момент времени актуален (с точностью до времени ожидания и работы stq).

## Оценка сроков.
1. Написание клиента к базе в ручках (кеширование всех запросов) `v1/metrics`, `v1/metrics/plot` + полная инвалидация при обновлениии одного или нескольких прекомпьютов. ~1.5d
2. Перерасчёт актуальных ответов в stq. ~3d
3. Анализ результатов (сколько секунд сэкономили, hit-rate, статистика походов в chyt). ~1d

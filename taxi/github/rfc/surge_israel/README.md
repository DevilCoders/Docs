# Surge in Israel
## Description
Логика EULAs в отдельном сервисе.
**Тикет:** https://st.yandex-team.ru/TAXIPROJECTS-752
**Wiki:** https://wiki.yandex-team.ru/users/ivan-kush/surgeisrael/

**Grafana**
* production: https://grafana.yandex-team.ru/d/7y_rRpWWz/taxi_conductor_taxi_eulas
* testing: https://grafana.yandex-team.ru/d/_YpURpWZk/taxi_conductor_taxi_test_eulas
    
**Хост:** eulas.taxi.yandex.net

**Адреса:**  eulas.taxi.yandex.net/v1/handler_name

**Сервер:** python3

**Нагрузка:** 2000 rps
* launch: 500 rps
* routestats: 600 rps (хотя, мб и не будет ходить в сервис)

**БД:** Postgres
*read-only пользователи*:
* unstable: https://yav.yandex-team.ru/secret/sec-01dbjnebn8j7nsqtnfkfhdh959
* testing: https://yav.yandex-team.ru/secret/sec-01dbwd9m19rbnwy42kxq4kx5xx
* stable: https://yav.yandex-team.ru/secret/sec-01dbwe40kf3wrpy8cm8600tbgt

## Дырки в puncher-е
из: 
* _C_TAXI_TC_
* _C_TAXI_API_
* _C_TAXI_API_ADMIN_

в:

## Ручки:
* **list:** Получение списка eula по фильтру (2 ручки: 4.0 и межсервисная)
* **save:** Сохранение клиенктом списка принятых или отвергнутых eula (2 ручки: 4.0 и межсервисная)
* **new** Создание нового eula. Сейчас не нужна, понадобится, когда появится админка

## Авторизация
* клиент с сервисом ч/з **pass-authorizer**
https://wiki.yandex-team.ru/taxi/backend/architecture/passenger-authorizer/
* межервисное по **tvm**

## Существующие варианты

### Обзор
Используется БД `eulas`
Уже выдаются в launch + zoneinfo

1. **zoneinfo**
поле `need_acceptence`, уже существует + сейчас добавляется туда логика (sdc2 и тп)

2. **launch**
поле `accepted`

## Будущее
1. миграция db.eulas в новую БД
2. новые клиенты берут eulas только из нового сервиса

## Логика работы
1. eulas заводятся в конфиге **EULAS**. Пока в конфиге, потом мб в БД + админка
1. zoneinfo и launch ходят в сервис за списком соглашений, eulas/list
1. routestats ходит в сервис, проверяя принятие соглашения, eulas/check
1. для сохранения клиент ходит напрямую в сервис, eulas/save. Для авторизации используется pass-authorizer
1. при нажатии на "ок/понятно" у соглашения - новым клиентам надо вызывать API микросервиса сразу же, в ответе надо уметь сообщать, что надо перезапросить routestats. При нажатии на кнопку, они блочатся, до получения ответа от сервера.
1. сущности соглашения надо добавить TTL и можно ли его не принимать
1. /routestats 
    * из /routestats ходить в микросервис за получением информции о принятых соглашениях: если среди них есть нужное, то добавляем тариф.
    PS: также уже существует фильтрация тарифов по тегам, см. ф-ию `FilterCategoriesByUserTags` и конфиг `CATEGORY_REQUIRES_USER_TAG`.

### list
Логика фильтров в ручке list:
- **unknown**:
    не показанные пользователю (т.к. у пользователя отсутствуют записи на них)
    1. идёт в конфиг EULAS, первично фильтрует его по зоне и тп
    2. ищет в БД все подтверждённые/отвергнутые клиентом eulas и все их исключает из отфильтрованных в п1
    3. отсылает клиентам eulas, кот. остались
- **accepted**:
    возвращает все принятые пользователем соглашения
- **rejected**:
    возвращает все отвергнутые пользователем соглашения
- **signed**:
    возвращает объединение accepted+rejected
- **all**:
    возвращает unknown+signed

Кеширование использовать не стоит, т.к. при нем может показать сообщение несколько раз пока кеш не обновится


Первичное фильтрование при unknown:
1. смотрит на зону, страну (вытаскиваем на основе зоны) полученную и из конфига EULAS
2. на тарифы завязываться

### save
1. сохраняется в БД сервиса
2. см. раздел **Гонки/Идемпонентность**

### Сервис тегов
https://wiki.yandex-team.ru/taxi/backend/architecture/tags/
не будет использоваться, т.к. там тайминги на обновление кешей, кот. регулируется конфигом - продуктово не очень выглядит

### Флоу
Также смотри раздел **Фолбеки**
Флоу:
1. клиенты вызывают list с фильтром `uknown` за получением eulas, кот. он не подтверждал/отвергал (`uknown`).
2. если ответ ручки не пуст, клиенты показывают всё, что там есть
3. юзер соглашается/отказывается - вызывается save
4. в /routestats вызов /check. Фильтруем тарифы по наличию eula (для этого сделан плагин `plugin_eulas` и конфиг `ROUTESTATS_EULA_REQUIREMENTS_FOR_CATEGORIES_IN_ZONE`)
    Чтобы воспользоваться полным функционалом фильтрации тарифов по eulas в /routestats нужно:
        * включить хождение в сервис /eulas и плагин фильтрации: конфиг `EULAS_SERVICE_ENABLED`, добавить в 3-и эксперименты эксперимент `plugin_eulas` (потребитель: routestats, protocol/routestats), иначе остаются только тарифы, позволяющие статус `unknown`
        * настроить фильтры в конфиге `ROUTESTATS_EULA_REQUIREMENTS_FOR_CATEGORIES_IN_ZONE`: zonename->category->{eula_type, is_eula_required, eula_statuses},
        Смотрим по зоне и тарифу, требуется ли еула. Если true, смотрим, соответствует ли `status` в ответе ручки /check хотя бы 1 статусу из поля `eula_statuses` в конфиге. Если соответствует, то оставляем, не соответствует - отбрасываем
5. /commit не трогаем. Будут в нем как суржовые, так и бессуржевые тарифы. Фильтроваться будет только в `/routestats` плагином `plugin_eulas`
У клиентов также будет страничка, где они могут посмотреть все eula, кот. подтвердили/отвергли.
Там вызывается list с фильтрами signed, accepted или rejected. Checkbox-ы или radiobutton-ы + кнопка Обновить
При просмотре будут кнопки Подтвердить для отвергнутых. Отвергнуть для подтверждённых. - вызывается save

#### Суржовые тарифы
На них должны назначаться водители с большим приоритетом. Это будет осуществляться выставлением больших весов соответствующим тарифам (см. логику работы Dispatch, раздел dispatch (Диспатч) в админке)

### Фолбеки

#### новые клиенты
* новые клиенты идут в отдельную ручку eulas/list с фильтрами `unknown`за получением eulas, он не подтверждал/отвергал:
    * если ответ не пуст, показывают всё, что там есть
    * если не достучались до микросервиса, не показываем никаких соглашений
    1. если достучались до eulas/list:
        * показывают пользователю, далее сохраняют соглашения вызовом ручки eulas/save. На клиенте задизайнить интерфейс, чтобы клиент в eulas/save передавал массив подтверждений, а не по 1-му дёргал - уменьшим нагрузку на сервис.
        * после получения 200 от eulas/save, снова вызывают eulas/list с фильтром signed - получают список всех подписанных (подтверждённых и отвергнутых) - сохраняют на клиенте...
    2. если клиенты Не достучались до ручки eulas/save, ретраить с экспоненциальным бэкоффом и лимитом попыток, сохранив локально факт, пока не достучатся
* вызов /routestats. /routestats считывает конфиг `ROUTESTATS_EULA_REQUIREMENTS_FOR_CATEGORIES_IN_ZONE` и вызывает eulas/check, для тарифов, которые требуют наличие некоторого статуса eula (`rejected`, 'accepted', 'unknown(?)'):
    * получили ответ и сверяем его со конфигом. Фильтруем тарифы в плагине `plugin_eulas`.
    * Не получили ответ от eulas (либо плагин - exp3 (`plugin_eulas`), либо сервис /eulas отключен - конфиг `EULAS_SERVICE_ENABLED`) - фильтруем согласно конфигу, при этом оставляем только тарифы, позволяющие статус `unknown`

### Гонки/Идемпонентность
*см. Questions.md*
Идеи:
1. Несколько OK-ов для 1-го eula (неважно, как это получилось).
Что последним придёт, то и будет записано
2. Предлагать пользователю снова ОКнуть eula, если поменяли в конфиге его длительность.
На 1-е время забить.
Когда появится админка и eulas будут храниться в БД (а не в конфиге), при изменении ttl проходить по базе подписанных соглашений и выставлять в них флаг need_resign.
Конечно, может появится гоночка: клиент сохраняет, когда изменяем конфиг - забить на это, очень редкий кейс.
3. Попеременно быстро ОК/неОК, имеем гонку
после ОК/неОК клиент блочит кнопки пока не дождётся 200 ответа от сервера. Если пропала связь/таймаут,
А так - забить на это, не уровень заказа. На клиенте будет окошко, где он сможет посмотреть. Если что, при следующем запуске увидит, что у него насохранено.
Если не забивать, то использовать версионирование (см. логику работы с order). Но всё-таки забьём.

### Конфиги
* EULAS_ENABLED - включение похода в микросервис
* EULAS - виды eulas
* EULAS_TIMEOUT - таймаут
* EULAS_RETRIES - кол-во ретраев
* ROUTESTATS_EULA_REQUIREMENTS_FOR_CATEGORIES_IN_ZONE - по каким eula фильтровать тарифы

### Заведение новых eulas
В будущем админка, а сейчас ч/з конфиг EULAS.

#### Админка
будет дёргать ручку сервиса eulas, который будет сохранять новые eulas
См. примеры сервиса тегов для типов запросов и тп.

### Хранение принятых пользователем eulas
**БД:** Postgres

```
CREATE TABLE IF NOT EXISTS eulas.users(
  yandex_uid text NOT NULL,
  eula_id text NOT NULL,
  status eulas.status_t NOT NULL,
  valid_till timestamptz NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT current_timestamp,
  created_at timestamptz NOT NULL DEFAULT current_timestamp,
  PRIMARY KEY(yandex_uid, eula_id)
);
```

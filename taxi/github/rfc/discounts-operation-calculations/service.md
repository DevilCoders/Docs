## Скидкопомогатор discounts-suggest / discounts-operation-calculations

### Описание
На еженедельной основе (базово, либо по желанию ОМ) бюджеты для скидок в городе пересчитываются выбранным аналитическим алгоритмом.
Сервис бюджеты не контролирует, а только помогает выбрать бюджет скидок. Контроль осуществляется отчетами в Tableau, алертами в трекере (не часть сервиса).


Эпик https://st.yandex-team.ru/ATLASBACK-518
Саша Белокрылов базово описал свое видение сервиса на вики https://wiki.yandex-team.ru/users/belokrylov-al/kt2/
Вопросы Жени по фронту https://st.yandex-team.ru/TEF-628

### Цель
1. Подбор оптимальной формы скидки для каждого сегмента в городе с целью максимизировать определенную при фиксированном бюджете на город
2. Помощь операционным менеджерам (ОМ) в заведении оптимальных по бюджету скидок
3. (в далеком будущем?) Автоматическое перезаведение скидок

### Use cases
#### 1. Основной для Операционного Менеджера (ОМ)
ОМ хочет скидки на неделю.

**Вопрос:** Где выбирается длительность скидки? Неделя - это некий дефолтный параметр скидки из конфига?

Для этого он выбирает город (набор тарифных зон) из списка.
ОМ видит действующие скидки (заведенные по предложениям этого сервиса) в городе.

ОМ выбирает режим работы в скидки (обычный/экспериментальный). 
В зависимости от режима, ОМ может создать один (обычный режим) расчет или несколько (экспериментальный режим) в рамках одного скидочного правила.

Чтобы добавить расчет, нужно указать алгоритм из списка. 
В случае экспериментального режима дополнительно нужно указать еще и тестовую группу пользователей (имена знаем заранее, не более четырех групп).

Для каждого выбора параметров (алгоритм + группа) можно запустить расчет по кнопке. 
Когда расчет закончится, то в его результате можно увидеть набор графиков неких метрик (напр. ожидаемый рост заказов) в зависимости от бюджета.

[Процесс расчета](#расчет-ожидаемых-эффектов-от-скидки) 
ОМ принимает решение о величине бюджета (число) для каждого расчета, вводит его в формочку.
Запускает [процесс обновления скидок](#обновление-скидки).

Пока в городе есть скидочное правило не в финальном статусе (требующее подтверждений или в ожидании обновления тэгов), 
еще одно обновление скидки в этом городе запустить нельзя.

**Вопрос:** Кажется, что данные для расчетов не так часто меняются. Можно делать предрасчеты в фоновом режиме, скажем, 
раз в день для города и оперировать уже готовыми сущностями. При необходимости можно перезапустить расчет по кнопке. Что думаете?

**Вопрос:** предрасчет делается за вычетом контрольной группы пользователей?
**Вопрос:** как учесть разбиение на тестовые группы при расчете? Можно ли просто мультиплицировать на долю пользователей в тестовой группе?
**Вопрос:** отдельная скидка с бюджетом заводится на (сегмент + тестовая группа)?


#### 3. Отменить скидку
**Вопрос:** Нужно ли поддерживать в нашем сервисе? Нужно ли отслеживать статус удаления скидок по нашим правилам в админке скидок?

#### 4. Добавить новый алгоритм
Новый алгоритм - новый добавленный в [конфиг алгоритмов](#список-алгоритмов-с-их-параметрами)

#### 5. Отключить поставку тэгов алгоритма
Цель: не создавать ненужную нагрузку на сервис тэгов

#### 6. Изменить разбивку на тестовые группы в конфиги экспериментов

### API

Допустимые статусы саджеста: 
    задаются действиями нашего сервиса:
        NOT_PUBLISHED - рассчет сделан но драфт не создан
        NEED_APPROVAL - драфт создан но не окнут
    задаются изменением состояния драфтов и обновляются путем периодического мониторинга статусов драфтов:
        CANCELLED - драфт отклонен/скидка выключена
        APPROVED - драфт окнут и сейчас активен

#### GET v1/cities
Под городом понимается набор тарифных зон, которые определяются аналитиками в конфиге сервиса.
Возвращает список городов, которые заведены в конфиге саджеста. 
Нужно для селектора городов.

Примерный формат ответа
```json
    {
        "cities": [
            {
                "name": "Казань",
                "tariff_zones": [
                    "kazan_centr_discount",
                    "kazan_chasha_discount"
                ]
            }
        ]
    }
```

**Вопрос:** Может быть в этой ручке не нужно передавать список зон, а передавать их по запросу отдельных ручек? 
**Вопрос:** Нужен CRUD для городов? Иначе как корректно защититься от удаления города.
**Вопрос:** Можно ли унести в сервис агломераций? Может ли это принести какой-либо бонус?

#### GET v1/algorithms
Возвращает список названий доступных алгоритмов из конфига. Нужно для селектора алгоритмов
```json
{
    "algoritms": [
        {
            "name": "katusha",
            "description": "описание алгоритма",
            "metric_name": "имя метрики"
        },
        {
            "name": "katusha_exp_1_2",
            "description": "описание алгоритма",
            "metric_name": "имя метрики"
        },
    ]
}
```

#### POST v1/statistics
Запускает расчет статистик 
```json
[
    {
        "discounts_city": "kazan",  # где-то в конфиге/сервисе аггломераций лежит соответсвие "скидочный город" -> "множество тарифных зон"
        "algorithm_id": "<algo ID>",
        "test_group": "test_1" # Optional. 
                              # Расчет проиводится с учетом тестовой группы (возможный набор задается в конфиге эксперимента). 
                              # Если поле не указано, то расчет применяется на всех пользователей за исключением контрольной выборки (тоже указывается в конфиге эксперимента)
    
    },
    {
    
    } 
]
```

Создает объект расчета с оптимальными кривыми для этого предложения.
Возвращает id созданного расчета.(статистику не сохраняем отдельно как объект в базе потому что непонятно зачем хранить статистику которая не привели к созданию саджеста)
```json
{
    "plot": [  #StatisticsModel
        {
            "y_label": "cost_per_extra_offer",
            "x_label": "budget",
            "data": [
                [1000, 98],
                [1200, 54]
            ]
        }
    ]
}
```

#### GET  v1/last_active_rule
    принимает город и возращает информацию по последнему активному правилу
    

#### GET v1/suggests/<suggest_id>
Возвращает 
```json
{
    "discounts_city": "kazan",  # где-то в конфиге/сервисе аггломераций лежит соответсвие "скидочный город" -> "множество тарифных зон",
    "status": "NEED_APPROVAL| NOT_PUBLISHED | CANCELLED | APPROVED",
    "author": "<login>" (NULL if status=NOT_PUBLISHED),
    "multidraft": "url" (NULL if status=NOT_PUBLISHED),
    "created_at": "2020-09-10 23:43:21",
    "classes": ["econom", "business"]  #  из конфига. Для фильтраций    

    "type": "expreriment",  # basic/expreriment а нужно ли различие???
    #  Если type=basic, то basic содержит только один элемент
    "calculations": [
        {
            "algorithm_id": "<algo ID>",
            "budget": 100500,
            "test_group": "test_1" # Не передается, если type=basic
            "plot": [] #StatisticsModel

        },
        ...
    ],
   "multidraft_params": [{
              "algorithm_id": "<algo ID>",
              "multidraft_param#1": "multidraft_param_value#1",
              "plot": [
                { 
                    "label": "segment_name",
                    "y_label": "discount",
                    "x_label": "trip_price",
                    "data": [
                        [1000, 98],
                        [1200, 54]
                    ]
                },
                {...}
              ]  
    }],
    
    
}

```

#### POST v1/suggests 
Подготавливает единый мультидрафт и возвращает все его параметры для предпросмотра

Запрос имеет примерно такую скидку
```json
{
    "discounts_city": "kazan",  # где-то в конфиге/сервисе аггломераций лежит соответсвие "скидочный город" -> "множество тарифных зон",

    "type": "expreriment",  # basic/expreriment а нужно ли различие???
    #  Если type=basic, то basic содержит только один элемент
    "calculations": [
        {
            "algorithm_id": "<algo ID>",
            "budget": 100500,
            "test_group": "test_1" # Не передается, если type=basic
            "plot": [
                {
                    "y_label": "cost_per_extra_offer",
                    "x_label": "budget",
                    "data": [
                        [1000, 98],
                        [1200, 54]
                    ]
                },
                {...}
            ]
        },
        {
            "algorithm_id": "<algo ID 2>",
            "budget": 200,
            "test_group": "test_2"
            ...
        }
    ]
    
}
```

Ответ вида
```json
{
    "id": "suggest_id",
    "multidrafts_params": [
        {
          "algorithm_id": "<algo ID>",
          "multidraft_param#1": "multidraft_param_value#1",
          "plot": [
            { 
                "label": "segment_name",
                "y_label": "discount",
                "x_label": "trip_price",
                "data": [
                    [100, 5],
                    [200, 3]
                ]
            },
            {...}
          ]
          
        },
    ]
}
```

#### POST /v1/suggest/<suggest_id>/publish
см [процесс обновления скидки](#обновление-скидки)
Публикует мультидрафт который
1. Отключает существующую скидку в городе
2. На каждый элемент массива calculations создает драфты по всем сегментам на создание скидки с учетом тестовой группы в calculation

принимает 
```json
 "login": "user_login"
```

возвращает
```json
{
"multidraft" : "url"
}
```

#### GET /v1/suggests
В URL передаем 
1. город
2. статус правила: активный/неативный/ждущий подтверждения
3. offset
4. limit

Получить список скидочных предложений(без детальной информации по статистике и параметрам мультидрафта)

```json
{
    "suggests": [
        {
            "id": "<suggest_id>",
            "city": "kazan",
            "status": "NEED_APPROVAL| NOT_PUBLISHED | CANCELLED | APPROVED",
            "author": "<login>" (NULL if status=NOT_PUBLISHED),
            "multidraft": "url" (NULL if status=NOT_PUBLISHED),
            "created_at": "2020-09-10 23:43:21",
            "classes": ["econom", "business"]  #  из конфига. Для фильтраций
        }
    ]
}

```

#### POST /v1/update_tags
Триггерит обновление тэгов

TODO завести конфиг классификации пользователей по сегментам
1. табличка с сегментами
2. разбиение на тестовые группы
3. ссылка на YQL поставки тэгов для этой классификации


### Процессы

#### Обновление скидки
1. Выключить старую скидки в городе, если она есть. Утверждается, что можно создать драфт на выставление бюджета старой скидки в ноль.
2. Создаем на каждый расчет + сегмент по драфту с указанным бюджетом
3. (возможно) запускаем процесс обновления тэгов

**Вопрос:** Действительно ли достаточно бюджет выставить в 0 в первом пункте? Можно ли просто выключить скидку?

**Вопрос:** Есть проблема, что конфиг экспериментов глобальный, и при измении будет влиять на все старые заведенные скидки. 
Кажется, что уже сейчас можно на разные разбиения по сегментам навешивать разные разбиения на тестовые группы. 
Нужно ли добавить такую возможность или живем с единым конфигом?

см еще [процесс обновление-статуса-скидки-привязанной-к-расчету](#обновление-статуса-скидки-привязанной-к-расчету)

#### Обновление тэгов у пользователей
**Note:** ~~Сейчас хотим от сервиса скидок доработок, которые позволят заводить скидки по двум тэгам. Это позволит
раздельно размечать тэги сегмента пользователя и тэги экспериментальных групп.~~ Доработки будут нескоро.

Там сейчас не хватает разработчиков в команде и задачу в разумном будущем взять не смогут. 
Давайте действовать все-таки по "плану Б": есть основные теги групп, а есть набор их дубликатов с постфиксами _test_1, _test_2,  _test_3, _test_4. Поддерживаем деление на максимум 4 группы, допустим (думаю, этого хватит). Если в городе в конфиге экспериментов заведены группы, то раздаем пользователям из групп, не попавшим в контроль, эти теги с постфиксами (независимо от того, заводился ли на группы бюджет). Основные теги раздаем всем пользователям, не попавшим в контроль.

**Note:** YQL поставка тэгов будет жить в **Research** пуле. По документации YT такой процесс не может называться production, тк в любой момент 
ресурсы research могут порезать в пользу новых сервисов с гарантированной квотой.

В [доке по YQL поставке тэгов](https://wiki.yandex-team.ru/taxi/backend/architecture/tags/yql/?from=%252Ftaxi%252Fbackend%252Farchitecture%252Ftags%252Fyql-in-tags%252F#m-razmerrezultata)
есть ограничение на размер единовременной поставки (1M). Нужно не забыть поправить конфиг в большую сторону для наших тэгов и написать в чатик поддержки тэгов.

У разных алгоритмов может быть разное разбиение пользователей на сегменты. 
Разбиение задается YT табличкой с колонками (user_phone_id, segment_name).
(Таблица на первом этапе создается аналитиками).
В сервисе тэгов для каждого `<segment_name>` заводится *основной* тэг `<segment_name>` с именем сегмента.
Еще заводятся *экспериментальные* тэги `<segment_name>_test_1`, `<segment_name>_test_2`, `<segment_name>_test_3`, `<segment_name>_test_4`.
Считаем, что четырех групп хватит всем.

**Вопрос:** четкий формат названия тэгов?

Для каждого разбиения пользователей на сегменты работает отдельная YQL поставка тэгов.
Поставка заливает как основные, так и экспериментальные тэги.

**Проблема:** при поставке тэгов нужно будет как-то учитывать разбиение на *экспериментальные тестовые группы*, 
которое задается в [нашем конфиге экспериментов](#конфиг-с-описанием-экспериментальных-групп)
**Решение:** заливать не напрямую из таблички аналитиков, а из предобработанной таблицы, 
которая готовится отдельной YQL таской. В ходе этой таски из таблиц выкидываются пользователи контроля + каждый пользователь, попавший в первую группу дублируется в таблице в виде пары <пользователь> - <класс_пользователя>_test_1, каждый попавший во вторую дублируется в виде пары <пользователь> - <класс_пользователя>_test_2 и т.д

**Вопрос:** как логгировать новую разметку на YT? В какой момент времени писать логи событий? 
(нужно уточнить у Саши Белокрылова формат) Можно описать в [соответствующем разделе](#логгирование-разметки-пользователей-на-yt-для-аналитики)

**Вопрос:** Можно ли самому триггерить YQL поставку? (скорее всего можно договориться об использовании ручки из админки YQL поставок тэгов). Можно указать время первого старта + периодичность. Скорее всего можно триггерить через изменение времени первого старта (уточнить)

**Вопрос:** какая регулярность обновления?


#### Обновление статуса скидки, привязанной к расчету
Есть крон-таска, которая трекает состояние мультидрафтов для саджестов в ожидании. Возможно, когда драфт окнут, нужно затриггерить перепоставку тэгов.

#### Подтягивание новичков в скидку
(Кажется отдельного процесса не требуется в силу регулярного обновления тэгов. Достаточно выбрать нужную периодичность)
Либо аналитики при изменении таблички user->segment триггерят поставку тэгов руками.

#### Логгирование разметки пользователей на YT для аналитики
TODO уточнить формат
Нужно понять, как мы можем писать записи только в момент их применения.

#### Добавление нового алгоритма

### Конфиги
Конфигурация происходит через сервис конфигов.

**Note:** решение задавать какие-то сущности через конфиги вносит определенную гибкость в сервис, 
но при этом если не думать при изменении конфигов, то можно все разломать. 
Если проект полетит, то считаю, что в будущем конфигурации ниже стоит отселить в отдельные ручки сервиса,
чтобы иметь возможность навставлять проверок на изменения. 
#### Список скидочных городов
TODO описание
#### Список алгоритмов с их параметрами
TODO описание
#### Конфиг с описанием экспериментальных групп
Конфиг глобален (нет разделения по городам)
TODO Описать преимущества своего велосипеда вместо использования сервиса экспериментов
TODO описание
#### Конфиг со стандартными параметрами заводимых скидок
TODO описание

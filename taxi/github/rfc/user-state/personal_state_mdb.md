## Перенос данных и нагрузки из dbuserhistory в MDB

Тикет на создание MDB Mongo кластера: https://st.yandex-team.ru/TAXIADMIN-22394
(Там же оценка ожидаемой нагрузки)

### Требования (по убыванию важности)
1. Тайминги `/personalstate` не должны упасть в 95 перцентиле
2. Не должно быть потерь пользовательской информации (неконсистентности данных)
3. Плавная выкатка с возможностью вернуться на старую БД
4. Доступная трудоемкость

### Вариант первый: полное копирование
Подразумевается перенос данных скриптом из реплики dbuserhistory.personal_state в фоновом режиме,
а затем переключение нагрузки на новую базу.
Плюсы:
* легко сделать скрипт (на первый взгляд)
* небольшие изменения в сервисе: только эксперимент, переводящий нагрузку в новую базу (по хешу от yandex_uid, например)

Минусы: 
* Требование 2: нельзя обеспечить консистентность данных
  (нельзя синхронизировать перенос данных по yandex_uid и наличие пользовательских обновлений)
* Требование 3: невозможно вернуть нагрузку на старую базу, так как теряются изменения из новой.
* Если переключать плавно, то придется запускать синхронизацию всякий раз когда раскатывам на бОльший процент.
* Более сложный скрипт переноса, который обеспечит идемпотентность запуска.

### Вариант второй: чтение из новой с фолбеком на старую
Тайминги старой Монги в 98 перцентиле составляют 6мс, тайминги всей ручки 150мс.
Если небольшой процент запросов будет ходить в 2 базы, то тайминги не сильно ухудшатся.

Можно использовать новую базу dbuser_state как подобие write-back кеша:

![image](static/flow.png)

#### Эксперимент для плавной выкатки
Заводим эксперимент `user_state_mdb_migration` cо значением `state`:

_bidirectional_: по которому происходит чтение и запись в 2 базы с приоритетом новой dbuser_state (+6мс ко всем UpdatePersonalState, см ниже)

_write_new_: чтение из обоих баз, но запись только в новую dbuser_state 
             (+0мс если запись уже в новой базе)
             в эту группу помещаем, когда мы решили, что данную нагрузку снимать уже не нужно.

_only_new_: чтение и запись в новую dbuser_state

#### Раскатка
* Заводим 1 группу на 10% yandex_uid с `{"state": "bidirectional"}`, смотрим тайминги, нагрузку базы
  Если что-то идет не так, отключаем эксперимент -- данные в старой базе актуальны
* Если все ок, в 1 группе меняем на `{"state": "write_new"}`, заводим группу 2 с `{"state": "bidirectional"}` на следующие 10%
* Если все ок, к 1 группе добавляем +10% из 2 группы, в группе 2 меняем процент на новых пользователей.
* repeat
* Когда в группе 1 окажется 100% пользователей и число "промахов" в новой базе станет небольшим, надо запустить скрипт, который переложит остальные данные (пользователей, которых не было уже долгое время)
из старой базы в новую, если соответствующего ключа (yandex_uid, nearest_zone, brand) там ещё нет.
* Переключаем в группе 1 на `{"state": "only_new"}` и перестаем читать из старой базы
* Убираем код и эксперимент, даем разобрать старую базу

#### Оценка таймингов

Исходные данные:
* Поток только уникальных yandex_uid -- 260rps на максимумах, или 15% от общего числа запросов 1500rps
* Соотношение запросов UpdatePersonalState к GetPersonalState: 30%
* Запрос в Монгу занимает <6мс в 98 перцентиле, и не зависит от операции (find/find_and_modify/update)

(предварительно разделив mongo_find_and_modify на mongo_find и mongo_update)

#### Прирост таймингов чтения в `{"state": "bidirectional"}`

| Операция | new (dbuser_state) | old (dbuserhistory) | Тайминги |
|---------|---------------------|---------------------|----------|
| Чтение |  no  | * | +12мс = +6мс чтение из old, +6мс запись в new |
| Чтение |  yes  | yes | +0мс, чтение и запись в dbuserhistory не нужно, данные идентичны |
| Запись |  no  | * | +18мс = +6мс +6мс чтение из old/new, +6мс доп запись в old |
| Запись |  yes  | * | +12мс = +6мс чтение из new, +6мс доп запись в old |


### Вариант третий: чтение/обновление из старой базы, асинхронная запись в новую

Этап 1:
Get/UpdatePersonalState читает/обновляет данные в старой базе, после каждой операции асинхронно пишет в dbuser_state полученные/обновленные данные.

Этап 2:
Скриптом переносим данные из старой базу в новую, если ключ (yandex_uid, zone, brand) отсутствует в новой
и `updated < stage_1_start_time`
(Полный перенос 125M записей при скорости ~100rps может занять 14 суток)

Этап 3:
Get/UpdatePersonalState читает/обновляет данные в НОВОЙ базе, после каждой операции асинхронно пишет в старую полученные/обновленные данные. (чтобы можно было вернуться на этап 1)

Для плавной раскатки удобно переносить зоны (группы зон) целиком (по всем yandex_uid).
Процент по хешу yandex_uid менее удобен тк придется в скрипте переноса дублировать логику ModSha1WithSalt)

#### Плюсы
Вариант хорош тем, что не подразумевает никаких изменений таймингов, минимальное изменение кода

#### Минусы
В момент переключения чтения со старой базы в новую можно потерять небольшое число записей
(соответствующих ошибкам в detached записях, но судя по логам старой базы вне учений таких событий единицы)

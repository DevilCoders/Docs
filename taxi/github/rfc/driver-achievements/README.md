# Водительские достижения (ачивки)

## Бизнес-описание
Ачивки (достижения) - инструмент мотивации водителей, повышает их интерес к использованию Таксометра и его популяризацию в соцсетях (через возможность "поделиться достижением").
В Таксометре представлены разделом вида "Зал Славы", в котором представлен список ачивок-медалей, которые водитель получил. Также на этом экране отображаются еще не полученные, но доступные водителю ачивки. Ачивки должны иметь широкую возможность конфигурации, красочные  названия и картинки. При шаринге должен быть красивый вебвью -- аналог
Новогоднего промо.

### Свойства ачивок
* Название, например "Вежливый водитель"
* Подробное описание за что выдана ачивка, например "Эта ачивка выдается водителям, которые получили более 1000 комплиментов за вежливость от пассажиров".
* Картинки для отображения на экране Ачивок в Таксометре. У каждой ачивки может быть несколько картинок, для каждого из ее состояний (см. ниже).
* Категория, к которой относится ачивка, например "Салон", "Музыка", "Вождение" и т.д. Ачивки группируются по категориям при отображении в Таксометре.
* Дата выдачи ачивки

### Виды ачивок
Ачивки могут быть простыми ("разовыми") и уровневыми. Пример уровневой ачивки:
  * 1 - "Получил 10 комплиментов"
  * 2 - "Получил 100 комплиментов" и т.д.

У уровневых ачивок есть дополнительные свойства:
  * Свое название и описание для каждого уровня
  * Отдельная картинка для каждого уровня.

### Подробнее про "уровневые" ачивки
Для ачивки "Количество поездок" может быть сколько угодно уровней. Очевидно, уровень не может уменьшаться. В случае, если водитель достигает первого уровня, то для ачивки первого уровня появляется дата получения и начинает отображаться неполученная ачивка второго уровня с прогрессом достижения второго уровня. Границы уровней задаются в момент создания ачивок.
  * Уровневые ачивки могут быть "счетными", т.е. цель состоит в наборе какого-то количества попугаев. Например, "100 комплиментов", "500 комплиментов". Для таких ачивок нужно показывать процент выполнения до следующего уровня, например, "уровень 1 - 100 комплиментов, прогресс 23% от уровня 2".
  * Также уровневые ачивки могут быть не счетными и понятие "процент выполнения" к ним не применим. Например, "месяц в сервисе", "год в сервисе" и т.д.

### Состояния ачивок и переходы
* Разовая ачивка с т.з. пользователя может быть в одном из 3-х состояний:
  * "неизвестная", т.е. пользователь не знает, что такая ачивка существует, она никак не отображается в списке ачивок. В дальнейшем будем называть это состояние `hidden`.
  * "закрытая/залоченная/приглашающая к получению". Пользователь видит эту ачивку в Таксометре и знает, что может ее получить. Назовем это состояние `locked`.
  * "выданная/разлоченная/полученная". Пользователь выполнил условие для достижения ачивки и видит, что получил ее. Назоваем `unlocked`.
* Уровневые ачивки имеют те же состояния, просто в состоянии `unlocked` обязательно имеют уровень (1, 2 и т.д.)
  * также должен отображаться прогресс достижения, к примеру, "текущий уровень 1, прогресс до следующего уровня: 30%".
* Для пользователя ачивка может переходить из состояния в состояние:
  * `locked` -> `unlocked`, т.е. пользователь видел доступную ачивку, а затем получил ее.
  * `hidden` -> `unlocked`, т.е. "внезапно" полученная ачивка. Она может оказаться приятнее той, ради которой нарочно старался водитель.
* Выданные ачивки являются перманентными, т.е. водитель не может их лишиться при очередном пересчете.
* Уровневые ачивки могут переходить на следующий уровень, но не могут понижаться.

### Принципы получения ачивок
* Каждой ачивке ставится в соответствие YQL-запрос, который периодически выполняется cron-таской. Запрос возвращает список `unique_driver_id` тех водителей, которым нужно выдать ачивку. Аналогично работает сервис `tags`.
* Как следствие, водитель не будет получать ачивки мгновенно, как только выполнил условие, а получит их с некоторой задержкой. Зависит от частоты пересчета ачивок.
* YQL-запрос составляет менеджер при помощи аналитиков. Таким образом, заведение новой ачивки не требует менять ничего в коде.
* Более удобным и наглядым с т.з. пользователя выглядело бы получение ачивок не постфактум, а в реальном времени, т.е. как можно быстрее после выполнения необходимого условия. Однако, такое решение потребовало бы более сложной архитектуры, а именно
  * введение колбэков в цикл заказа (в процессинге, либо где-то еще?) по факту обновления различных метрик.
  * добавление новых колбэков/метрик на каждый новый тип ачивки
  * введение механизма предикатов (наподобие экспериментов 3.0) для описания условий получения ачивок.
Вывод: Хоть данный механизм и был бы удобнее для пользователя, считаем его недостаточно гибким для продукта.

### Подробнее про "видимость" ачивок
* Большинство ачивок изначально доступны всем водителям и нужно уметь отображать их в "зале славы" в неполученном состоянии. В этом случае будет отображаться "трафареты" ачивок, чтобы водители видели их, могли просмотреть описание и понять, как получить.
* Но есть такие ачивки, которые должны быть видимы только части водителей, а не всем сразу. Например, ачивка "Пережил коронакризис" не актуальна для тех, кто придёт в сервис позднее, а значит новые водители никогда не смогут её получить и такой "трафарет" будет демотивировать. Это касается и разовых ачивок и уровневых.
* Еще один пример, это ачивка "Стать СМЗ". Ее "трафарет" должен быть виден только водителям из РФ (и то не везде). Таким образом, условие "видимости" ачивки должно быть так же гибко кастомизируемым, как и условие "выдачи" ачивки.

#### Реализация кастомного условия "видимости"
С ходу можно придумать два способа задавать такие условия для таких ачивок:
  * Использовать еще один YQL-запрос, который будет выдавать `unique_driver_id` тех водителей, кому видна ачивка. В БД сервиса для каждого водителя храним не только "выданные ачивки", но и "видимые".
    * Преимущество: само "условие видимости" хранится в той же БД, что и "условие выдачи". Не требуется менять код сервиса при добавлении\изменении ачивки.
    * Недостаток: дополнительный запрос, который требует регулярного пересчета. Если таких ачивок много, то разрастается БД.
  * Использовать эксперименты 3.0 и определять "видимость" в рантайме.
    * Преимущества: можно гибко задавать условия с омощью предикатов экспериментов 3.0
    * Недостатки:
      * Придется передавать множество различных кваргов в сервис ачивок. Т.е. если очередное условие использует кварг, которого нет в других условиях, потребуется менять код и добавлять кварг.
      * Потребуется заводить отдельный эксперимент для каждой такой ачивки. Не получится обойтись одним экспериментом на все ачивки с кастомным условием "видимости", т.к. условия могут пересекаться.
Вывод: используем первый вариант (YQL-запрос для "видимости").

### Типы ачивок для MVP
https://st.yandex-team.ru/CREATIVETAXI-22592#5f05ab3aac78ba7a94b5cc67


### После MVP
Уровневые ачивки реализуем после MVP.

## Архитектура
### Флоу
Базовый флоу от "создания" разовой ачивки до ее "получения" водителем:
* Менеджер получает у Аналитиков текст YQL-запроса, который задает логику "выдачи" ачивки. Результатом выполнения скрипта должен быть список `unique_driver_id` водителей, которые удовлетворяют условию ачивки. Если ачивка доступна не всем водителям, то понадобится еще один YQL-запрос с логикой "видимости" ачивки (аналогично, возвращает список водителей).
* Менеджер создает новый тип ачивки через Админку Ачивок, указывает внутренее название, ключи переводов, иконки и YQL-запрос(-ы).
* Периодический процесс нашего бэкэнда выполняет YQL-запросы в YT, собирает их результаты и обновляет таблицу соответствия "водитель - ачивка" в PG.
* При получении новой ачивки, бэк отправляет пуш в Таксометр с id-шником полученной ачивки.
* Приложение Таксометра запрашивает список ачивок ("зал славы") для конкретного водителя и отображает его пользователю.
* Также, в "зал славы" можно перейти из пуша на основном экране.

### Сервисы
* achievements-py3 (backend-py3)
  * бэкэнд Админки Ачивок - редактирование и создание новых типов ачивок
  * cron-таски, выполняющие YQL-запросы и присваивающие ачивки
  * менеджмент медиа: иконки ачивок (для превью), анимации (для фулскрина с ачивкой), шаблоны изображений для шеринга ачивок
  * отправляет пуши при обновлении информации об ачивках.
* achievements (uservices)
  * view-сервис для мобильного приложения, позволяет получить список ачивок для одного конкретного водителя.
  * также возвращает информацию об одной ачивке (для переходов из пуш-уведомления на клиенте).

### API
#### API Админки Ачивок (achievements-py3)
* Наименования подобны API сервисов `configs` и `tags`.
* Авторизация через Админку Без Кода
* `GET /admin/v1/rewards/list` - список всех типов ачивок, с указанием вида, категории, даты выдачи (краткая информация)
* `GET /admin/v1/rewards/item` - полная информация об типе ачивке из БД, вместе с танкерными ключами, ссылками на изображения и текстами YQL-запросов.
* `POST /admin/v1/rewards/create` - создание нового типа ачивки.
* `POST /admin/v1/rewards/edit` - редактирование ачивки.
* Также в этом сервисе присутствуют cron-таски для выдачи ачивок.
* Также этот сервис отправляет пуши, в тот момент, когда новая ачивка получена водителем. Таксометр, получив пуш, отобразит уведомление "Получена новая ачивка".

#### API Таксометровых ручек (achievements)
* Авторизация через driver-authproxy
* `GET /driver/v1/achievements/reward/list` - полный список всех ачивок у конкретного водителя, в т.ч. "неполученных", вместе с переводами и ссылками на изображения.
  * Эта ручка дергается Таксометром, когда польователь заходит на экран "Зал Славы".
* `GET /driver/v1/achievements/reward/single` - информация об одной ачивке.
  * Эта ручка дергается Таксометром, когда пользователь нажмет на уведомление "Получена новая ачивка". Таким образом загрузится вся информация для отображения фул-скрина с полученной ачивкой.


### Данные
#### Типы ачивок
По типу "видимости" ачивки делятся на:
- `hidden_to_all` - для таких ачивок не нужны тексты и картинки в состоянии `locked`, и не нужно "условие видимости".
- `visible_to_some` - нужны тексты и картинки в `locked` и нужно "условие видимости".
- `visible_to_all` - нужны тексты и картинки в `locked`, не нужно "условие видимости".

Таблица типов ачивок
```
CREATE TYPE visibility_type AS ENUM ('hidden_to_all','visible_to_some','visible_to_all');

CREATE TABLE rewards
(
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code       TEXT NOT NULL UNIQUE, # человекочитаемое название ачивки, например, `superstar`,
  visibility visibility_type,
  category   TEXT,
  updated    TIMESTAMPTZ    NOT NULL DEFAULT (NOW() AT TIME ZONE 'UTC'),
  created    TIMESTAMPTZ    NOT NULL DEFAULT (NOW() AT TIME ZONE 'UTC')
);
```

#### Танкерные ключи
Танкерные ключи, связанные с ачивкой, определяются автоматически из названия ачивки (code), пример:
- `achievements.reward.superstar.title`
- `achievements.reward.superstar.description`

Как следствие, в БД эти ключи не хранятся.

#### Таблица "водитель-ачивка"
Таблица представляет отношение "many-to-many" и может иметь большой размер.
Кол-во уникальных водителей - около 10М, числов видов ачивок - около десятка в MVP, пара десятков всего, т.е. в пределе около 200 млн. отношений.
Понятно, что большинство водителей никогда не получит все ачивки. С другой стороны, кол-во водителей будет расти и число ачивок - тоже может. Примем 200M как первичную оценку сверху.
Каждое отношение "водитель-ачивка" содержит следующую информацию:
* флаг "водитель может видеть этот тип ачивки" в `locked` состоянии
* флаг "водитель получил эту ачивку"
* дату получения этой ачивки (если получена)
* для уровневых ачивок
  * уровень полученной ачивки (1, 2, 3)
  * процент до следующего уровня

Со стороны Таксометра к этой таблице будут запросы вида "получить всю информацию об ачивках для конкретного водителя по `unique_driver_id`".
Со стороны таски импорта будут запросы вида "добавить для водителя по udid флаги ачивки (а также уровень, и процент)".

Способы организации такой таблицы:
* А.  Таблица MxN записей, т.е. 1 строчка на одно отношение "водитель" - "ачивка". Используем составной индекс "udid"+"achievement_id".
  * Недостатки:
    - многократно дублируются одинаковые udid, т.е. неэкономно используется место.
    - чтобы обеспечить уникальность соответствия "udid - reward_id" требуется составной индекс по двум полям, который будет занимать место.
    - если у нас 10М водителей и k видов ачивок, то при добавлении каждой нового вида ачивки, в таблицу будет добавляться 10М записей, что приведет к разрастанию индекса и времени поиска по нему.
    - кажется, что плохо расширяемо, т.е. если захотим добавить какие-то новые поля, нужно будет затронуть все MxN записей.
* Б. 1 запись на водителя, для каждого водителя храним
  * поле-массив `visible_rewards`, где указываем reward_id тех ачивок с кастомым условием "видимости", которые видны этому водителю. Сюда попадут только ачивки вида `visible_to_some`. Для остальных видов ничего не нужно хранить. Для поиска по массивам можно использовать GIN либо GiST индексы.
  * JSONB-поле `unlocked_rewards`, где храним информацию о всех полученных ачивках. ЭТот вариант выглядит наиболее расширяемым, т.к. для каждой полученной ачивки нужно также хранить:
    * дату получения
    * уровень (для уровневых)
    * прогресс (для уровневых)
    * могут появиться другие поля

```
CREATE TABLE driver_rewards
(
    unique_driver_id  TEXT  PRIMARY KEY,
    visible_rewards         rewards[], # references `code` in `rewards`
    unlocked_rewards        JSONB,
    updated    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
);
```
Схема JSONB-поля:
```
additionalProperties:
    $ref: '#/definitions/RewardInfo'

definitions:
    RewardInfo:
        level:
            type: integer
        percentage:
            type: integer
        unlocked_at:
            type: timestamp
        required:
          - unlocked_at
```

Пример JSONB-поля:
```
{

  "super_driver": { # Ключ - это `code` из таблицы `rewards`
    "unlocked_at": "2020-19-07T23:00:00+3", # Обычная ачивка в состоянии "получена"
  },
  "compliments_count" { # Уровневая ачивка уровня 2, прогресс 23% от уровня 3
    "level": 2,
    "percentage" : 23,
    "unlocked_at": "2020-19-07T23:00:00+3",
  }
}
```


### Периодический процесс выдачи ачивок

Таблица с расписанием YQL-запросов
```
CREATE TABLE achievements_pg.uploads_schedule
(
  id          SERIAL PRIMARY KEY,
  reward_id   UUID    /* foreign key references rewards.id */
  yql         TEXT   /* YQL скрипт, назначающий видимость (доступность) ачивок */
  set_state_unlocked BOOLEAN /* если true, то запрос раздает "полученные" ачивки, иначе раздает "видимые" ачивки */
```

#### Пример YQL запроса выдачи ачивок
```
USE hahn;

$all_drivers = (SELECT
    count(order_id) AS order_count,
    unique_driver_id AS unique_driver_id
FROM
    range(`home/taxi-dwh/summary/dm_order`, `2020-05`)
WHERE
    success_order_flg = True and
    taxi_status = "complete" and
    status = "finished" and
    country = "Россия"
GROUP BY
    unique_driver_id);

SELECT
    unique_driver_id
FROM
    $all_drivers
WHERE order_count > 10
```

#### Цикл обновления ачивок

* В сервисе `achievements-py3` есть таблица YQL-запросов, соответствующих ачивкам, с указанием периода как часто нужно их запускать (таблица `uploads_schedule`).
* cron-таска `schedule_upload` в сервисе `achievements-py3`, например раз в 5 минут, проверяет, не пора ли запускать тот или иной запрос (либо на "пересчет выдачи" либо на "пересчет видимости").
  * Если запрос пора запускать, то cron-таска создает YQL-запрос в YT и помещает запись об этом в таблицу импорта (`uploads`), с указанием id-операции в YT.
* Еще одна cron-таска `yql_upload_unlocked`, например раз в минуту, проверяет таблицу импорта (`uploads`), а точнее для каждой выполняемой операции в YT, запрашивает ее готовность.
  * Для каждой операции, которая завершилась (т.е. YT готов отдать результаты), эта же таска вычитывает данные чанками из YT и начинает записывать их в таблицу `driver_rewards` в поле `unlocked_rewards`.
  * Таска `yql_upload_unlocked` - одна на все виды ачивок. Нужно будет экспериментально подобрать размер чанка, чтобы за время выполнения таски, вычитать по 1-му чанку для каждой джобы, которая готова.
  * Но даже если не успели вычитать все данные для какой-то из джоб, они все равно будут вычитаны при следующем запуске этой таски.
  * Считаем, что пересчет будет запускаться достаточно редко (e.g. раз в сутки), чтобы для всех готовых джоб успеть вычитать данные.
* Еще одна cron-таска `yql_upload_visibility` - работает аналогично, т.е. раз в минуту проверяет таблицу импорта, проверяет завершенные задачи на "выдачу видимости" в YT.
  * Для каждой из ачивок записывает их id в ту же таблицу `driver_rewards`, но уже в поле `visible_rewards`.
* Т.к. cron-таски `yql_upload_unlocked` и `yql_upload_visibility` затрагивают разные поля в `driver_rewards`, то их параллельная работа не должна вызывать проблем.

#### Нюансы
При обновлении таблицы `driver_rewards` периодическими cron-тасками нужно учитывать следующие особенности:
- При каждом запуске джоб "выдачи"/"определения видимости" ачивок, YQL-запрос может вернуть очень длинный список udid, в пределе стремящийся к общему кол-ву водителей (около 10M).
- Только при первом запуске такой джобы (после добавления нового типа ачивки) потребуется проапдейтить все записи.
- При последующих запусках, большая часть вернувшегося списка водителей останется неизменной, т.е. нет нужды апдейтить все записи.

### Потенциальные возможности оптимизации (после MVP)
#### При выдаче ачивок cron-тасками (сервис achievements-py3)
1. Для каждой джобы храним хэш-сумму сортированного списка unique_driver_id, полученных во время предыдущей джобы. Если при выполнении очередного скрипта, хэш-сумма полученного списка совпадает с предыдущей - значит нет необходимости перезаписывать таблицу вообще. Эта оптимизация применима как для обновления "видимости", так и "выдачи" ачивок.
#### При отдаче ачивок водителя в Таксометр (сервис achievements)
1. Полный кэш над табличкой `driver_rewards` рискует не влезть в оперативку, однако можно завести LRU-кэш, который должен снизить кол-во обращений к БД.

### Пуши при получении новой ачивки
По логике вещей, именно сервис `achievements-py3` должен отправлять пуши при получении новой ачивки, т.к. именно он производит пересчет, и "знает", что ачивка получена.
Однако, вижу следующий подводный камень:
* Происходит очердной пересчет, обновляется таблица `driver_rewards`, водитель получает ачивку и `achievements-py3` отправляет пуш.
* Таксометр получает пуш, отображает уведомление, пользователь переходит по нему.
* Вызывается ручка `GET /driver/v1/achievements/reward/item`, чтобы отрисовать в Таксометре фул-скрин с ачивкой.
* Эта ручка идет в LRU-кэш над `driver_rewards`, а информация об ачивке из кэша еще не пропала и вернется закэшированное значение (e.g. "ачивка еще не получена").

Вывод: пока обходимся без LRU-кэша в над `driver_rewards` в `achievements`.

### Менеджмент медиа
Помимо статичных картинок (отображаемых на экране списка ачивок), также предполагается иметь анимированные изображения для каждой ачивки, для отображения на фулскрине (просмотр Ачивки). Предполагается использовать анимации в формате `Lottie`.

В качестве MVP-решения предполагается вручную заливать картинки (и JSON-файлы для Lottie) на `s3.mds.yandex.net`.
В рамках несвязанного тикета (https://st.yandex-team.ru/TAXIADMIN-4415) была запилена Таксометровая ручка `/pinpoi`, которая позволяет отдавать наружу произвольные несекретные файлы.
Как выглядит добавление картинки для ачивки:
* Менеджер получает у дизайнеров нужные файлы (png или текстовые JSON-файлы для Lottie).
* С помощью FTP-клиента вручную заливает их на ``s3.mds.yandex.net`, инструкция здесь: https://st.yandex-team.ru/TAXIMETER-8965#5e27c91b9ee85f4bcf8af15b
* Получает ссылку на файл вида: https://taximeter.yandex.rostaxi.org/pinpoi/achievements/test_achievement_1_animation.json
* Такая ссылка доступна без авторизации, считаем что для картинки ачивок - не секретные.
* Эту ссылку он указывает в админке ачивок, при создании/редактировании. Эта ссылка хранится в БД, как соответствующая ачивке.
* У ачивки может быть несколько ссылок на разные картинки, для каждого из состояний отображения
  * для экрана "зала славы": статичная иконка разлоченной ачивки и (опционально) статичная иконка "трафарета", т.е. залоченной ачивки.
  * для фул-скрина - анимированная картинка Lottie.
* Таксометровая ручка отдает список ачивок водителя с ссылками на изображения, Таксометр сам их выкачивает и, при необходимости, кэширует.

В дальнейшем (после MVP) нужно будет либо загружать картинки с помощью  [Админку Изображений](https://tariff-editor.taxi.yandex-team.ru/images), либо реализовать загрузку изображений на S3 непосредственно через Админку Ачивок.


### Требования к ресурсам
#### RPS
Нагрузку на ручку `/driver/v1/achievements/driver-rewards/list` со стороны Таксометра можно оценить следующим образом:
* Если предположить, что ачивки будут обновляться при каждом логине, то можно сравнить с нагрузкой на ручку /driver/authorization/login/new - 50 rps в пике.
* Если предположить, что ачивки будут обновляться каждй раз, когда водитель заходит в профиль - то около 150 rps  в пике

#### Требования к свободному месту
Если взять кол-во udid за 10M (сейчас их меньше) и кол-во ачивок до 100, то общее кол-во записей в driver_rewards стремится к 1000 M. Если предположить, что такая запись уместится в 200 байт (это с запасом), то должно потребоваться не более 200Gb в postgresql.

## Дальнейшее развитие (фичи после MVP)

### Шэринг в соцсетях
Предполагается на клиенте генерировать картинку для шеринга.
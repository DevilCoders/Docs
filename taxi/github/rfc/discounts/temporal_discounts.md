## Временная скидка для Uber

Необходимо поддержать скидку, которая:
- имеет интервал активности, который:
  - начинается в момент запроса на активацию
  - заканчивается по истечении заданного интервала времени (обозначим как discount-duration)
- в случае несовершения заказа во время активности скидки, она деактивируется и может быть активирована снова не ранее чем через 6 часов (обозначим как cool-down)
- в случае совершения заказа во время активности скидки, она деактивируется и может быть сразу активирована снова, без cool-down

### Flow скидок

Клиенты <- routestats <- [pricing-data-preparer](https://github.yandex-team.ru/taxi/uservices/tree/develop/services/pricing-data-preparer) <- [discounts](https://github.yandex-team.ru/taxi/uservices/tree/develop/services/discounts)


### Эксперимент uber-discount

[uber_discount](https://tariff-editor.taxi.tst.yandex-team.ru/experiments3/show/uber_discount)

Значения эксперимента:

Статическая скидка:
```json
{
  "l10n": [
    {
      "key": "discount_notification_text",
      "tanker": {
        "key": "uber_discount_notification_text_static",
        "keyset": "client_messages"
      },
      "default": "У вас скидка 10%"
    }
  ],
  "discount_notification_type": "static"
}
```

Скидка по таймеру:
```json
{
  "l10n": [
    {
      "key": "discount_notification_text",
      "tanker": {
        "key": "uber_discount_notification_text_countdown",
        "keyset": "client_messages"
      },
      "default": "Временная скидка 10%"
    }
  ],
  "discount_notification_type": "countdown"
}
```

Без информирования о скидках:
```json
{
  "discount_notification_type": "none"
}
```

### Решение 1. Таймер на бекенде

Решение не доработано до конца. Сначала будет проверена гипотеза об увеличении конверсии со скидками по таймеру, используя Решение 2. Затем мы можем вернуться и доработать это решение как более приемлемое для использования. 

Текущее решение поддерживаеет либо применение сразу всех скидок, либо отключение их всех. При необходимости нужно доработать решение для поддержки избирательного отключения скидок.

#### `POST /4.0/discount-notifications/v1/discount-info`:

Клиентская ручка

Входные параметры:
- optional bool __is_startup__ = false  // true означает, что вызов ручки происходит при старте приложения и поэтому нужно активировать таймер

TODO: необходимо проработать передачу required-параметров для вызова сервиса discounts: [/v3/get-discount](https://github.yandex-team.ru/taxi/uservices/blob/develop/services/discounts/docs/yaml/definitions.yaml#L832-L842)

Выходные параметры:
```
optional discount_notification { //  объект не возвращается если из эксперимента uber_discount приходит none либо при отсутствии скидок
  enum type // вид информирования о скидке [static,countdown]. определяется на основании эксперимента uber_discount
  string text // текст информирования о скидке. берётся из эксперимента uber_discount
  optional datetime countdown_end_time  // время окончания действия текущего таймера, если тип информирования о скидке - countdown
}
```

#### STQ удаления таймера

При совершении поездки необходимо поставить STQ для очистки в БД поля countdown_end_time.

#### Логика работы клиентов
При запуске приложения клиенты делают запрос в ручку /discount-info, передавая флаг is_startup равный true.
Ручка возвращает тип и текст информатирования о скидке, а в случае скидки по таймеру ещё и момент окончания действия такой скидки при наличии активного таймера.
Если тип скидки - countdown, то ручка активирует таймер в случае его отстутствия либо при наличии таймера, с момента деактивации которого прошло cool-down часов.

Далее клиенты могут вызывать ручку /discount-info, не передавая флаг is_startup, что отключает логику активации таймера.

При вызове /routestats будет выполнена проверка активности таймера. Она произойдёт в сервисе discounts, который будет вызывать следующую ручку:

#### `POST /discount-notifications/v1/check-discount` - внутренняя ручка

Для заданного по user_id (TODO: подумать какой тут идентификтор лучше: user_id, phone_id, yandex_uid) пользователя проверить активность скидки по таймеру.

#### Деактивация таймера при совершении поездки

TODO

#### База данных

```sql
CREATE TABLE discount-notifications.timers
(
  user_id            TEXT PRIMARY KEY,
  countdown_end_time TIMESTAMPTZ NOT NULL
);
```

В случае необходимости схему БД можно расширить для поддержки типа приложения [uber_android, uber_iphone]

#### RPS сервиса

TODO: оценить какой rps запуска приложения Uber

#### Преимущества и недостатки

Преимущества:
- это корректное решение
- логика не дублируется на разных клиентах

Недостатки:
- нужен новый сервис на бекенде, что вероятно сложнее, чем реализация на клиенте

### Решение 2. Упрощённое. Таймер на клиенте. Передача флага disable_discounts в routestats

Решение поддерживает либо применение сразу всех скидок, либо отключение их всех.

Клиенты понимают какую скидку отображать по эксперименту uber_discount.

Отсчёт времени таймера происходит полностью на клиенте. Понадобится сохранение состояния между запусками приложения, чтобы знать состояние таймера.

Во время неактивности таймера клиенты передают флаг disable_discounts=true в routestats, который доходит до pricing-data-preparer:
клиенты -> routestats -> pricing-data-preparer

Сервис pricing-data-preparer, в случае флага disable_discounts=true, не производит поход в сервис discounts за скидками.

Решение не подвержено фроду в том смысле, что хоть пользователи и могут сымитировать активность таймера и получить скидку путём передачи флага disable_discounts=false, однако это не проблема, т.к. скидка и так уже была у них.

#### Логика запуска таймера

Пусть согласно эксперименту uber_discount пользователю показывается временная скидка.  

Клиент хранит состояние таймера между запусками приложения, которое задаётся полем: optional datetime __countdown_end_time__.
Это поле задаёт конечное время активности таймера.

Клиент отображает остаточное время таймера как countdown_end_time - currentTime(), если оно положительно

Клиент обновляет состояние таймера в следующих случаях:
- на старте приложения countdown_end_time присваивается значение currentTime() + timer_duration (5 минут) в следующих случаях:
  - countdown_end_time пуст
  - currentTime() - countdown_end_time > cool-down (6 часов)
- при совершении заказа countdown_end_time присваивается значение null (пусто) 

#### Преимущества и недостатки

Преимущества:
- вероятно проще в реализации, чем реализация на бекенде
- для проверки гипотезы можно реализовать только на одной платформе, избегая дублирования логики

Недостатки:
- дублирование логики работы с таймерами на разных платформах

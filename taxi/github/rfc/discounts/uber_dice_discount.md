## Случайные скидки uber
Если добавим в приложение элемент случайности - возможность получить/не получить скидку при входе, то стимулируем пользователей всегда открывать приложение, чтобы узнать выпадет скидка или нет.

Очень похожая проработка уже [была сделана для механизма временных скидок](https://github.yandex-team.ru/taxi/rfc/pull/502). Поэтому она будет взята за основу и дополнена деталями логики случайных скидок.

Таска: https://st.yandex-team.ru/TAXIPROJECTS-1752

## Решение
Как и во временных скидках будет два решения: 
1. Быстрое, простое и на клиенте
2. Более сложное, более правильное и на бекенде 

### Решение 1: Быстрое, простое и на клиенте
Нам необходимо поддержать 4 группы пользователей:
1. Без логики: если у пользователя есть скидка - он видит ее в приложении
2. 50% вероятность показать стандартную скидку, без кубика
3. 50% вероятность показать кубик
4. Скидки нет: у пользователя не будет скидки, несмотря на то, что в сервисе скидок она есть

При этом берём за основу, что случайные скидки не должны пересекаться вместе с временными скидками.


### Дополнение эксперимента uber_discount
Для того, чтобы это поддержать мы расширим эксперимент [uber_discount](https://tariff-editor.taxi.tst.yandex-team.ru/experiments3/edit/uber_discount) тремя группами:

Группа пользователей 2:
```json
{
  "discount_type": "fixed_with_probability"
}
```

Группа пользователей 3:
```json
{
  "discount_type": "dice_with_probability"
}
```

Группа пользователей 4:
```json
{
  "discount_type": "no_discount"
}
```

"Контрольная группа" (`"discount_type": "none"`) в этом эксперименте соответствует нашей группе 1.

Группы пользователей нужно будет сформировать в админке скидок и добавить в эксперимент конкретные phone_id/номера телефонов. Как возможный вариант заведения таких групп можно рассмотреть такой:
1. Создать тег https://tariff-editor.taxi.yandex-team.ru/tags/tags
2. Протегировать нужных пользователей: https://tariff-editor.taxi.yandex-team.ru/tag-queries/tags
3. В админке скидок в поле "Для кого предназначена скидка" указать созданный тег.


### Логика на клиенте
 
При открытии клиентское приложение читает значение эксперимента. И дальше действует по одному из сценариев:
#### `fixed_with_probability`
- при открытии приложения если currentDate() > `fixedDiscountDateUsed`:
  - разыгрываем скидку 
  - если true: отображаем скидку, `"disable_discounts": false`, `"haveDiscount": true`
  - если false: не отображаем и не учитываем скидку, `"disable_discounts": true`, `"haveDiscount": false`
  - сохраняем в персистентном хранилище `fixedDiscountDateUsed` как currentDate() и результат розыгрыша `haveDiscount`

#### `dice_with_probability`
- при открытии приложения если currentDate() > `diceDiscountDateUsed`:
    - показываем кубик
    - на клик по кубику: 
        - делается задержку на интерфейсе
        - разыгрываем скидку
        - если true: отображаем скидку, `"disable_discounts": false`, `"haveDiscount": true`
        - если false: не отображаем и не учитываем скидку, `"disable_discounts": true`, `"haveDiscount": false`
        - сохраняем в персистентном хранилище `diceDiscountDateUsed` как currentDate() и результат розыгрыша `haveDiscount`

#### `no_discount`
- Не отображаем и не учитываем скидку, `"disable_discounts": true`.

Когда пользователь воспользуется скидкой (TODO: сколько раз? Один?) необходимо выставить `"haveDiscount": false` и дальше отдавать `"disable_discounts": true` до наступления следующего периода.

Так же при откртии приложения необходимо учитывать `"haveDiscount"` и если он выставлен в true и мы находимся во временном промежутку действия ссылки (currentDate() == `diceDiscountDateUsed`), значит розыгрышь уже был и мы можем пользоваться скидкой.

#### Безопасность
Получается, что в случаях, когда мы идём с `"disable_discounts": true` в `/routestats` мы имеем возможность фрода: клиент может не посылать это поле и тогда скидка всегда будет применяться. Но для эксперимента в проработке временных скидок решили этим пренебречь. Решение согласовано с ggarshin@.

Один из вариантов как можно разыграть скидку: берём рандомное целое число и если оно чётное, то true, иначе false.


### Решение 2: Более сложное, более правильное и на бекенде
#### Описано очень верхнеуровнево!


Необходимо будет использовать механизм предложенный в проработке временных скидок.
Чтобы расширить эту схему добавим тип рекламы скидки `discount_promotion_type`. Возможные варианты: `countdown`, `dice`. 
Я так понимаю, что после эксперимента большинство групп (`fixed_with_probability`, `no_discount` и `none`) отпадёт и останутся только `countdown` и `dice`.

Это свойство можно сделать как одно из свойств скидки и, в том числе, добавить в админку скидок. 

В сервис discounts добавим в БД со скидками (TODO: выяснить куда именно):
```
discount_promotion_type   TEXT
```

И при получении этого поля в зависимости от типа получать данные о текущем состоянии скидки.
В случае `dice` необходимо будет проверить был ли кубик показан сегодня. Для этого мы будем разыгрывать скидку у себя, сохранять результат розыгрыша в поле `have_discount` и время в `countdown_end_time` (назвать можно как то немного по-другому) в таблице discount-notifications.timers из проработки временных скидок. 

Как мне кажется хранить и вычислять вероятность и этот таймер можно как в discounts, так и где то в отдельном сервисе и делать межсервисный запрос. Возможно, что вариант с хранением в discounts даже будет лучше, потому что будет работать быстрее.

### Задача

По всем заказам Доставки Курьера и Грузового мы знаем номер телефона получателя.
Если у получателя установлено приложение Такси, нужно показывать заказ в приложении 
и вместо СМС со статусом заказа слать пуш.
Есть несколько сценариев создания таких заказов.

1) Заказы созданные через КК 

    - компания(например ВкусВилл) делает заказ доставки клиенту через КК, заказ должен появляться в клиентском приложении получателя, по таким заказам нужно уметь показывать атрибут "Продавец" (например, "ВкусВилл").
    - компания делает обычный заказ такси для корпоративного клиента, заказ должен появляться в клиентском приложении (так как КК работает поверх int-api, вероятно получится прорастить заказы и для КЦ).

2) Заказы из клиентского приложения
    
    - Один пользователь отправляет Доставку/Груз другому пользователю, заказ должен прорасти в приложение получателя.
    - Третье лицо делает заказ от пользователя A к пользователю Б, заказ должен прорасти и пользователю А и пользователю Б
    - Заказ для другого (похожий сценарий, заказ должен прорасти в приложение того, кому делают заказ)
    
3) Заказы с ЭТН 

    Компания создает заявку на доставку груза от точки А 
    до клиента в точку Б (по факту это обычный заказ по тарифу "Доставка", "Грузовой", "Курьер"),
    инфа о таких заявках хранится и обрабатывается сервисом cargo-claim.
    Такой заказ должен прорасти получателю.
    По заказам В2В нужно уметь показывать атрибут "Продавец" (например, "ВкусВилл").
    Иначе наш юзер будет думать что он вызвал тариф Курьер.


По всем заказам надо показывать:
 - расположение курьера на карте
 - его контакты (софт свич)
 - общая информация о доставке (адрес, статус заказа, тип заказа, ориентировочное время, др.)
 - чат (позже)

---

### Этап 1

На данном этапе делаем прорастание заказов получателю только по тарифам: Доставка, Курьер.

У нас (в протоколе) уже есть ручки sharedroute / sharedroutetrack, которые позволяют без авторизации получать шарилку на любой заказа.
Через них работает наша текущая шарилка заказа.
Ручки принимают в качестве параметра key, по факту это uuid связанный с конкретным заказом. 
Сейчас такие ключи доступны в течение 24 часов после завершения поездки, после чего они удаляются из базы.
Результата этих ручек достаточно для отображения нужной информации о заказе, но сейчас там не прорастет информация о магазине (ВкусВилл), это нужно дорабатывать и др. поля.

Ручки sharedroute / sharedroutetrack находятся в backend-cpp, шарилки хранятся в коллекции route_sharing_keys.
Ключи шарилок сейчас добавляются в route_sharing_keys в py2. Предлагается вынести эти ручки в новый микросервис (order-route-sharing) и логику связанную с хранением шарилок заказов.
Процесс полного переезда опишу в отдельном rfc, в данном rfc делаем MVP для прорастания с учетом будущего переезда. 

Для ускорения процесса запуска, новый сервис пишем на py3. Первым этапом добавляем новую ручку для получения списка ключей,
делаем 2 stq таски: сохранение шарилки со связанным phone_id (если он есть в заказе), проставление finished_at для завершенных заказов и 
1 крону, которая будет чистить базу от завершенных заказов.
В качестве хранилища используем новую базу PG.

1) Ручка получения списка ключей

Делаем внутреннюю ручку, результат которой подставляется в /launch через api-proxy (включаем под конфигом/экспериментом).

```http request
GET /v1/sharing_keys
X-YaTaxi-PhoneId: <phone_id>

Response:
{"sharing_keys": ["<key_1>", "<key_2>"]}
```

Добавляем в тело ответа /launch:
```json5
{
    "sharing_keys": ["<key_1>", "<key_2>"],
    // ...
}
```

Если сервису плохо (500 или таймауты), то отправляем пустой список (с бизнесом согласовано).
При штатной работе сервис таким потерь будет 0, если возникнут малейшие проблемы будем разбираться что происходит с сервисом.  

В среднем 95prc на ручке launch <200мс, предлагаю делать поход в ручку /v1/sharing_keys с 2мя ретраями и таймаутом 100мс. 
Предполагаю что таймаутить будет <<1% запросов. В случае чего, эти параметры можно быстро подкорректировать.

2) Ручки sharedroute / sharedroutetrack 

Переносим ручки sharedroute / sharedroutetrack за PA + api-proxy. Это позволит использовать api-proxy и подключать дополнительные данные без изменения ручек в backend-cpp.

новы пути:
GET /4.0/sharedroute/info?key= (мапим через api-proxy в ручку sharedroute в протоколе, без авторизации)
GET /4.0/sharedroute/track?key= (мапим через api-proxy в ручку sharedroutetrack в протоколе, без авторизации)

Если есть связанные заказы, то эти ручки полятся каждые 5сек (так сейчас на фронте), до тех пор пока заказ не завершится (статус complete в ответе sharedroute).
Если пользователь находится на саммари (или другом экране где не нужно отображать поездку на карте) и есть только плашка сверху, то полить sharedroutetrack не нужно.

Для клиентов нужна доп. информация, что бы отобразить всю инфу согласно дизайну:
* флаг show_point_a - нужно ли показывать адрес точки А на всех экранах (для заказов c2c нужно будет показывать адрес точки А)
* флаг show_track - нужно ли отображать на карте трек курьера (флаг зависит от того в каком статусе находится заказ)
* номер телефона курьера - нужно подмешивать в ответ ручки, данные полученные из ручки ordercontactobtain (если driver.call_mode == 'on_demand')
* перевод фразы с бэка который зависит от статуса и тарифа (магазин собирает заказ, курьер в пути)
* иконка для статуса
* слово доставка в верхней плашке

Для этого расширяем (через api-proxy) ответ ручки sharedroute следующим образом:
```json5
{
    "popup_title" : "Доставка", // NEW
    "status_title" : "Магазин собирает заказ", // NEW
    "status_icon": "express_shared_icon", // NEW тэг картинки
    "status": "driving",
    "driver": {
        ...
        "call_mode": "on_demand",
        "phone_gateway": { "ext": "007" "phone": "+75557775522" } // NEW
    },
    "client_flags":{ // NEW
        "show_point_a": true,
        "show_track": true
    }
    "park": {...},
    "partner": {...},
    "request": {
        "route": [...],
    },
    "routeinfo": {...},
}
```

3) Прикручиваем получение имени магазина отправителя

Для заказов оформленных через КК хотим отображать в качестве адреса отправления наименование организации которая выполняет отправку заказа (например Вкусвилл).
Для MVP имя организации будем получать из конфига по corp.client_id.
Значение corp.client_id будем передавать в stq таску из процессинга и сохранять в базу. Это позволит значительно снизить нагрузку на сервис order-core. 
После MVP данная схема хранения и получения имени компании будет ещё дорабатываться.

Добавляем в сервис order-route-sharing внутреннюю ручку.
Которая будет для заказов с corp.client_id доставать имя компании из конфига (танкерный ключ).


```http request
GET /v1/corp_info?sharing_key=<key>

Response:
{
    "corp_info": {
        "name":"ВкусВилл"
        // возможно, позже захотим возвращать ещё какую-то информацию о компании 
    }
}
```

В ответ sharedroute добавляем информацию о компании:
```json5
{
    "corp_info": {
        "name":"ВкусВилл"
    }
//    ...
}
```

4) Настройка Процессинга 2.0
В процессинге 2.0 нужно добавить 2 обработчика:
- обработчик на создание заказа в такси. На первом этапе ставим stq таску только для заказов по тарифам Доставка/Курьер, связанный номер телефона берем из extra_data точки Б.
- обработчик на завершение (отмену и другие подобные статусы) заказа в такси. Ставить stq таску, которая помечает заказ завершенным в сервисе order-route-sharing.

Ожидаемая нагрузка:
ручки sharedroute / sharedroutetrack - ~1rps каждая (до полного переноса в новый сервис, после ~30rps)
ручка /v1/sharing_keys - ~600rps, соизмеримо с /launch (простая ручка с 1 походом в базу)
stq таска создания шарилки для заказа - ~1tps (тасок в секунду), позже соизмеримо с /ordercommit ~100 тасок в секунду (после полного переезда на новый сервис)
stq таска изменения статуса заказа (когда заказ завершился нужно проставить в базе это время) - ~1tps (тасок в секунду), позже соизмеримо с /ordercommit ~100 тасок в секунду (после полного переезда на новый сервис)

### Этап 2. 

Прикручиваем получение заказов созданных с использованием ЭТН. 

todo:

Заказы с ЭТН хранятся в отдельном сервисе и на момент создания заявки никак не прорастают в order_proc.
Добавляем ручку в сервисе (order-route-sharing), которая будет добавлять созданную заявку в базу с шарилками.
 
### Этап N
После завершения проработки https://github.yandex-team.ru/taxi/rfc/pull/258/files и когда мы начнем переходить на описанную там схему,
следует поддержать логику связанных заказов в общем механизме получения информации о заказах.

### Перехват ключа связанного заказа (сейчас это не делаем и возможно позже тоже не потребуется)

Мы умеем отправлять ссылки на шарилку поездки через SMS, 
можно немного подкрутить бэк, что бы отправлять пуш вместо смс (но это не блокирует раскатку фичи).

Доработки на клиентах:
- добавляем возможность извлекать key из диплинка который придет в пуше
- учимся перехватываем переходы по url https://taxi.yandex.ru/route/<key> (и другие url, которые используются для шарилки)
- поход в ручки sharedroute / sharedroutetrack для отображения информации о заказах
- поход в ручку ordercontactobtain для получения номера телефона водителя/курьера

После описанных доработок на клиенте, появится возможность просматривать заказы, которыми делятся пользователи в нашем клиентском приложении.

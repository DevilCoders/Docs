### Поставка данных для промо "тариф чуть дороже"

#### Текущая архитектура
![image](img/v1.png)

Важная особенность промо с точки зрения пользователя: время между получением цены из routestats и отрисовкой промо должно быть минимальным
и сейчас в проде находится в пределах 1 сек.

При проработке [первой версии](https://github.yandex-team.ru/taxi/rfc/blob/master/tariffs_promotions/tariffs_promotions.md)
было сделано решение на основе данных тариф-цена из оффера.
Это решение подразумевает запуск на небольшой процент (~5% от всех запросов routestats, ~50rps),
с тем чтобы не положить Монгу dbprocessing.
Для расширения эксперимента надо убрать запрос в Монгу.

В числе альтернативных идей на будущее предлагались:
1. Поставка офферов через LB
2. Посылать цены напрямую из routestats в tariffs_promotions.

### Чтение офферов из LB -- не подходит
Лаг записи в LB составляет ~2 секунды [метрики записи в /taxi/taxi-order-offers-log](https://lb.yandex-team.ru/logbroker/accounts/taxi/taxi-order-offers-log?page=statistics&type=topic&tab=writeMetrics&shownTopics=all%20topics&metricsFrom=1606755542210&metricsTo=1607360342210&sortOrder=%22default%22)
что делает его использование неподходящим

### Напрямую из routestats в tariffs-promotions
В новом routestats есть структура `/internal_data/service_levels_data` с ценой по категориям.
Её можно передать как есть в сервис tariffs-promotions, и это будет быстрее,
чем время до появления оффера в secondary Монги.

### План реализации
#### tariff-promotions
* KV-хранилище offer_prices (предположительно на redis), которое будет наполняться
  по ключу offer_id значениями `[(Category,Price)]`
  Удаление записей по таймауту ~10 сек (больше не имеет смысла для данного промо).
  Персистентность при выкатках и т.д. не важна:
  считаем, что в очень малой доле случаев можем допустить, что промо не покажется.
  
* ручка `POST /v1/offer_data` которая добавляет инфу по offer_id.

#### uroutestats
* сразу после получения ответа `POST /routestats/internal` делать запрос
  `POST <tariff-promotions>/v1/offer_data {offer_id: "", category_prices: [...]}`
  Вызов происходит асинхронно, не влияет на ответ и тайминги, выполняется в отдельном task processor.

### Pros & Cons
 Плюсы:
 * решаем вопрос с нагрузкой на Монгу, временно оставляем order-offers без потребителей.
 * уменьшаем вероятность задержки информации о цене в tariffs-promotions (сокращаем число сетевых запросов)
 * Убираем логику получения конечной цены из оффера в tariff-promotions
 
 Минусы:
 * не является универсальным решением для коммуникаций по офферам
   (подобное делает команда DMP на основе вычислений по данным LB)

#### Использование redis
Более привычный нам PGaaS не выдержит такое число вставок (~1000rps), придется либо вставлять батчами через кеш (что увеличит время между появлением данных и их доступностью), либо делать что-то супер-сложное по примеру сервиса тегов (даже думать об этом не хочется)

Mongo тоже выглядит излишне сложным и тяжеловесным решением (из-за того, что является БД с соответствующими гарантиями)
 
в uservices уже довольно много примеров использования, поэтому интегрироваться с ним не должно быть проблемой

### Ожидаемая нагрузка
#### Объем
Для оценки сверху возьмем поток данных в топике taxi-order-offers-log, что всегда меньше 1Мб/сек.
(причем, это не только офферы из приложения ЯТ, а в том числе по web/turboapp/callcenter/etc)
Получаем почти всегда <10Мб
#### insert rate
Оценим как rps ручки routestats -- 1000rps (Не каждый запрос создает оффер)

**Название сервиса**

meters-integration-api

**Реализация**

1. **stq**-таск
2. ручка POST `/driver/v1/meters-integration-api/finish-ride`
    * принимает на вход цену и заказ
    * возвращает цену
    * [docs](api.yaml)

**Какую продуктовую проблему решает сервис?**

Для облегчения работы водителей в Израиле интегрируем "умные" таксометры
фирмы Monitex, которыми можно управлять через интернет.
Сервис консолидирует всю логику взаимодействия с внешним АПИ
физического таксометра, т.е. будет уметь запускать и останавливать поездку
на физическом таксометре, а также обмениваться итоговыми ценами
за поездку (отдавать нашу цену, получать цену с физического таксометра)

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Нужен отдельный сервис, инкапсулирующий логику работы с внешним АПИ компании Monitex
(на самом деле с внешним АПИ любого физического таксометра в будущем)

**Как именно сервис будет решать поставленные перед ним задачи?**

1. **stq** таска будет запускать поездку на физическом таксометре,
передавать нашу цену
1. ручка для получения цены с учетом показаний физического таксометра
    * будет дергаться в конце поездки, для остановки физического таксометра, а также
    для получения цены с физического таксометра

**Разрабатывается один сервис или система?**

Один сервис

**С кем взаимодействует сервис?**

- сервис ходит во внешнее АПИ **Monitex** [docs](meter-rides-api-0.2.json)
- сервис ходит в **order-core**
    - в ручку `/internal/processing/v1/order-proc/set-fields` для записи
    **external_meter_ride_id** в **order-proc**
    - в ручку `/internal/processing/v1/order-proc/get-fields` для чтения
    **external_meter_ride_id** и других полей из **order-proc**
- сервис ходит в **fleet-vehicles** в ручку `/v1/vehicles/retrieve`
- сервис ходит в **driver-profiles** в ручку
`/v1/identity-docs/retrieve_by_park_driver_profile_id`
- сервис ходит в **personal** в ручку `/v1/identifications/retrieve`
- сервис ходит в **driver-orders-builder** в ручку `/v1/setcar/update-lite`
- сервис ходит в **client-notify** в ручку `/v2/push`
- в сервис ходит приложение **Про** (android, ios) в конце поездки

**Как обеспечивается идемпотентность ручки**

Обеспечивается идемпотентностью внешнего АПИ **Mone backend**

**Как делаются ретраи**

Ретраи во внешнее АПИ **Mone backend** не делаются

**Какие базы использует?**

Никакие

**Какие периодические процессы?**

Нет

**Планируется обработка персональных данных**

Нет

Но: мы будем передавать номера удостоверений личности водителей Израиля
во внешнее АПИ физического таксометра компании Monitex
(такие требования к этому АПИ)

**Какие данные и по какой схеме сервис будет хранить в базе?**

--

**Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

--

**Какие операции над данными заложены?**

--

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

--

**Какая нагрузка ожидается?**

<1 rps (сервис работает только для израильских заказов, оценка получена по
статистике числа заказов в Израиле)

**Какие фолбеки предусмотрены на сам этот сервис?**

- В таксометре: при любой ошибке работы с сервисом или неполучении флажка
в обновлении **setcar**, работаем по фолбеку, текущему
сценарию - показываем окошко ручного редактирования цены в конце поездки

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

- При отказе внешнего АПИ **Monitex**:
    * при отказе в начале поездки: **stq-таск** завершается,
    не обновляя **order_proc**, **setcar** обновляем значением
    `is_external_meter_run=false`, посылаем пуш через **client-notify**
    * при отказе в конце поездки: сервис отдает ошибку
- При чтении в **order-proc** (в начале поездки, через сервис **order-core**):
**stq-таск** завершается, не обновляя **setcar**
- При записи в **order-proc** (в начале поездки, через сервис **order-core**):
**stq-таск** завершается, **setcar** обновляем значением
`is_external_meter_run=false`, посылаем пуш через **client-notify**
- При отказе сервиса **fleet-vehicles**: **stq-таск** завершается, **setcar**
обновляем значением `is_external_meter_run=false`, посылаем пуш
через **client-notify**
- При отказе сервиса **driver-profiles**: **stq-таск** завершается, **setcar**
обновляем значением `is_external_meter_run=false`, посылаем пуш
через **client-notify**
- При отказе сервиса **personal**: **stq-таск** завершается, **setcar**
обновляем значением `is_external_meter_run=false`, посылаем пуш
через **client-notify**
- При отказе сервиса **driver-orders-builder**: **stq-таск** завершается
- При отказе чтения из **order-proc** (в конце поездки, через сервис **order-core**):
сервис отдает ошибку
- При отказе сервиса **client-notify**: пуш не отправляется,
на флоу не влияет, ничего не делаем

**Какие возможности масштабируемости закладываются?**

Увеличение количества инстансов сервиса

**Какие точки отказа есть в сервисе?**

1. Отказ внешнего АПИ **Monitex**
1. Отказ сервиса **fleet-vehicles**
1. Отказ сервиса **driver-profiles**
1. Отказ сервиса **personal**
1. Отказ сервиса **driver-orders-builder**
1. Отказ сервиса **order-core**
1. Отказ сервиса **client-notify**

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

Число успешных и неуспешных поездок в Израиле всего и только с новым "умным" таксометром

**Укажите технические метрики**

- Среднее время ответа на запрос
- Время и успешность работы stq

**Какая функциональность ожидается в сервисе в будущем?**

Возможно будем подключать другие страны/других производителей
таксометров - следовательно в зависимости от страны сервис
будет ходить в разные внешние АПИ

**Какое изменение нагрузки планируется?**

Прямо пропорционально количеству активных заказов в Израиле

**Активно ли будет изменяться сервис?**

Нет

**Как раскатываем**

1. **meters-integration-api** раскатываем, ручки включаем по эксперименту по `driver_id`
    * сначала на тестовых водителях
    * потом на всех
1. правки **Про** раскатываем сразу на всех
    * без бэкенда эти правки не должны ни на что влиять
1. новое поле для обновления **setcar** видимо нужно будет прописывать в шарпах и
раскладывать
    * без бэкенда эти правки не должны ни на что влиять
1. правки, чтобы писать в **setcar**
значение из конфига `external_meters_settings`
    * делается специальным конфигом проброса экспериментов в setcar
    * раскатываем независимо
1. правки **fleet-vehicles**, чтобы возвращать поле `permit_num`
    * раскатываем независимо

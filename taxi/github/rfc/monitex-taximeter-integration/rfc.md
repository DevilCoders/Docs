# Интеграция с новыми физическими таксометрами фирмы Monitex в Израиле

## Обозначения

Mone - новый физический таксометр Monitex, умеет в интернет

Старый таксометр - физический таксометр, который сейчас используется
в Израиле, не умеет в интернет

Про - Яндекс.Про (Yango.Pro), приложение водителя

Фолбек - ситуация, в контексте данного файла, когда мы сбрасываемся на текущий
режим работы (ручной ввод цены в Про)

## Что мы решаем

Уменьшаем число действий водителя, автоматизируем флоу водителя

## Как сейчас работает

[ссылка](https://st.yandex-team.ru/TAXIMETER-10285#601adb0ff15baa4143a8609a)

### Флоу для водителя:
1. Водитель берет заказ, едет на него, дожидается пассажира,
нажимает "Поехали" в **Про** и запускает физический таксометр
1. В конце поездки водитель нажимает "Завершить поездку" в **Про** и
останавливает физический таксометр
1. В **Про** появляется окошко ручного редактирования цены, где водитель,
используя кнопки +/- может редактировать цену, чтобы она совпала
с физическим таксометром
    1. если цена по физическому таксометру получилась меньше, чем в **Про**,
    водитель уменьшает цену кнопкой в **Про**, печатает чек с физического
    таксометра
    1. если цена по физическому таксометру получилась больше, чем в **Про**,
    водитель вбивает цену с **Про**, на физическом таксометре печатается чек,
    в нем указана цена и скидка в размере разности между ценами
        * *продуктовый вопросик*: почему бы не менять цену из **Про** на цену
        с физического таксометра всегда? физический таксометр могут накрутить,
        поездив кругами

#### Условие появления окошка ручного редактирования цены:
* **Про** в начале поездки ходит в АПИ `/get_modifications`, получает оттуда
структурку с ценами
    * `/get_modifications` это сервис `pricing-taximeter`, добавляет туда секцию
    с ручными ценами согласно конфигу [manual_price_settings](https://tariff-editor.taxi.yandex-team.ru/experiments3/configs/show/manual_price_settings/current?enabled=all&active=all&name=manual_price)
* в конце поездки **Про** чекает, если в структурке есть непустое
поле `manual_price`, то показывается окошко ручного редактирования цены,
ограничения на ручную цену берутся из структурки

## Как будет

### АПИ Mone backend

[АПИ Mone backend](meter-rides-api-0.2.json)

мок-сервер - https://monmeter-stage.talents.co.il/3rdparty/api/

api key: 7A25432A462D4A614E645267556B58703273357638792F413F4428472B4B6250655368566D597133743677397A244326452948404D635166546A576E5A723475

Краткие обозначения ручек внешнего АПИ **Mone backend**:
* `submit_ride` - стартуем поездку на **Mone**, передаем нашу фикс цену
    * возвращает 201, если удалось стартануть
        * также возвращает айди поездки `rideId`
    * возвращает 206, если всё ещё стартуем, и тогда нужно поллить
    `get_ride_info`
    * "If you use async=true for submit_ride, it should be fairly quick,
    I assume usually less than a second."
        * но мы не собираемся использовать `async=true`, который с вебхуками
    * про таймауты `submit_ride` `async=false`
        * "I assume we will start with 20 seconds and will go up as needed
        but not more than 60 seconds.
        The time it will take the meter to move to "IN_PROGRESS" should be
        pretty fast on normal occasions. 1-2 seconds since we got the
        request. But as this depends on cellular connectivity
        (and the taxi might be in bad reception area like a parking
        garage) this can take longer (same for errors).
        In case we request the driver approval it depends on his action as well…
        * итого: возврат из вызова быстрый, но время до запуска **Mone**
        20-60 секунд OMG, коллеги только собираются тестировать
* `get_ride_info` - информация о поездке по `rideId`
(статус, цена по **Mone**)
    * "it should be fairly quick, I assume usually less than a second"
* `update_ride` - обновляем поездку
    * обновляем статус - переводим поездку в `COMPLETED`
    * ~~передаем нашу цену (цену из **Про**) в поле `priceLimit`~~
    * "this is a sync operation, I didn't set a timeout for this yet,
    but I am guessing it will be set somewhere between 5 and 15 seconds,
    but of course can also be 1 second in practice"
        * 5-15 сек OMG

### Флоу для водителя:
1. Водитель берет заказ, едет на него, дожидается пассажира,
нажимает "Поехали" в **Про**
1. Ждет несколько секунд, **Mone** автоматически начинает поездку
1. В конце поездки водитель нажимает "Завершить", **Mone** останавливается
автоматически
    1. автоматически происходит обмен ценами между **Про** и **Mone**
    1. если цена по **Mone** получилась меньше, чем по **Про**,
    то показываем уведомление в **Про**, что цена
    возьмется по **Mone**, и берем цену по **Mone**
    1. если цена по **Mone** получилась больше, чем по **Про**, то **Mone**
    должен взять нашу цену, а на чеке напечатать нашу цену +
    разность между ценами напечатать как скидку
1. **Mone** печатает чек
1. На все ошибочные кейсы (включая потерю соединения), сбрасываемся на фолбек,
т.е. на текущий флоу, ручной ввод цены в конце поездки,
не забывая уведомить об этом водителя

### Схема взаимодействия с Mone backend

![Flow](flow.svg)

## Метрики

Будем смотреть на метрики "число заказов с новыми таксометрами" и их
долю в общем числе заказов (ожидаем рост),
а также долю успешности заказов (ожидаем, что не будет падения)

Также нужны будут метрики по всем статусам ответов внешнего АПИ, чтобы
сразу понимать, что при интеграции идет не так

## Предлагаемая реализация

Есть два варианта со своими плюсами и минусами

### Вариант I

1. в начале поездки, когда водитель нажимает "Поехали",
в **processing** запускаем **stq-таску**, которая будет ходить в **Mone backend**
    * **stq** будет ходить в **Mone backend** в `submit_ride` (плюс поллить
    `get_ride_info` если нужно)
        * дополнительно будет ходить за данными в **order-core**
        (`/internal/processing/v1/order-proc/get-fields`), **fleet-vehicles**
        (`/v1/vehicles/retrieve`), **driver-profiles**
        (`/v1/identity-docs/retrieve_by_park_driver_profile_id`),
        **personal** (`/v1/identifications/retrieve`)
    * в случае успеха **stq** будет писать в **order-proc** поле
    `external_meter_ride_id` (айди поездки **Mone**; посредством вызова
    `/internal/processing/v1/order-proc/set-fields` сервиса **order-core**)
    * в случае успеха **stq** будет ходить в сервис **driver-orders-builder**
    для апдейта **setcar** флажком (`/v1/setcar/update-lite`)
    * в случае успеха **stq** пошлет специальный пуш в **Про** через сервис
    ~~**communications**~~ **client-notify**,
    для форсирования поллинга **setcar** (`/v2/push`, код пуша `code=1600`)
        * доставка пуша не гарантируется, но можно оптимистично считать, что
        в большинстве случаев она удастся, а там где нет, будем ждать в **Про**
        очередного обычного обновления **setcar**, и если слишком долго ждем
        (больше T секунд), то
        будем фолбечиться на текущий флоу
    * в случае неуспеха на шагах до **driver-orders-builder**, следует так же
    сходить в **driver-orders-builder** и **client-notify**, но передать флажок
    со значением `false`, чтобы **Про** не ждал понапрасну
1. **Про** запустит поездку, но будет ждать флажка в обновлении **setcar**
(**setcar** поллится раз в 10 секунд согласно доке, при получении пуша 1600
форсированно идем за обновлением **setcar**)
    * ждать нужно только при включенном конфиге `external_meters_settings`
    (значение придет в **setcar** и сразу, см. [Детальную реализацию](#детальная-реализация))
    * если флажка в обновлении **setcar** не пришло или пришло `false`,
    то **Про** сбрасывается в фолбек,
    уведомляем водителя, чтобы он включил **Mone** вручную
    * если флажок пришёл и равен `true`, значит удалось стартануть **Mone**
    автоматически, ничего не делаем, уведомление водителю не нужно делать
1. в конце поездки, когда водитель нажимает "Завершить", но до **requestconfirm**,
и после экрана выбора платных услуг,
**Про** ходит в сервис бэкенда **meters-integration-api** с `order_id`
(таксометровый заказ) и итоговой ценой
1. в **meters-integration-api** ходим в **Mone backend** в
`update_ride` и `get_ride_info`
    * получаем цену поездки по **Mone**, валидируем отклонение цены
    от нашей по конфигу
    * возвращаем цену в ответе
1. **Про** получает ответ
    * если ответ успешный, **Про** возьмет цену из ответа
    * **Про** подставит цену из ответа в `manual_price` и
    запустит преобразования цен
    * при этом не будет показывать экран ручного редактирования цены
    * на основе цены из **Mone** и цены из **Про** в преобразованиях цен
    решится какую взять цену
        * уведоляем водителя, если изменили цену
    * если ответ неуспешный, **Про** пойдет по фолбеку, т.е. текущему сценарию

#### Плюсы
* в начале поездки асинхронно ходим во внешнюю апишку

#### Минусы
* минус из первого плюса, т.е. возможна ситуация, что водитель нажал "Поехали",
статус изменился на **transporting**, водитель поехал, но через N секунд
ему приходит уведомление "включите **Mone** вручную", включать что-то в
движении не очень безопасно (N - насколько медленная апишка **Mone backend**)
* ~~если ждать синхронно в этом варианте, т.е. не начинать поездку без ответа от
**Mone**, то время ожидания будет большое (время ожидания ответа от **Mone** плюс
10 секунд, время обновления **setcar** в **Про**)~~ делаем пуш в **Про**, минус
исчезает

### Вариант II

1. в начале поездки, когда водитель нажимает "Поехали", но до **requestconfirm**,
**Про** ходит в сервис бэкенда **meters-integration-api**
1. в **meters-integration-api** ходим в **Mone backend** в `submit_ride`
(плюс поллим `get_ride_info`, если нужно)
    * в случае успеха, возвращаем ОК и **external_meter_ride_id**
    * в случае неуспеха, возвращаем не ОК
1. **Про** получает ответ
    * если не ОК, уведомляем водителя, чтобы он включил **Mone** вручную
    * если ОК, уведомляем водителя, что удалось стартануть **Mone** автоматически,
    прикапываем `external_meter_ride_id` до конца поездки
1. в конце поездки, когда водитель нажимает "Завершить", но до **requestconfirm**,
и после экрана выбора платных услуг,
**Про** ходит в сервис бэкенда **meters-integration-api** с итоговой ценой
поездки и с `external_meter_ride_id`
1. в **meters-integration-api** ходим в **Mone backend** в
`update_ride` и `get_ride_info`, получаем цену поездки по **Mone**
    * на основе цены из **Mone** и цены из **Про** решаем какую взять цену
    * возвращаем итоговую цену в ответе
1. **Про** получает ответ
    * если ответ успешный, **Про** возьмет цену из ответа, подменит, если нужно
    итоговую цену, и не будет показывать экран ручного редактирования цены
        * уведоляем водителя, если изменили цену
    * если ответ неуспешный, **Про** пойдет по фолбеку, т.е. текущему сценарию

#### Плюсы
* вся логика с внешним таксометром относится целиком к водителю, и в этом варианте
эта логика останется целиком на таксометре плюс водительской ручке
**meters-integration-api**

#### Минусы
* в начале поездки синхронно ходим во внешнюю апишку, т.е. можем зафризится
на время таймаута на нажатии "Поехали" (кажется можем ходить асинхронно,
скатываясь к первому варианту)
    * коллеги из Израиля прогнозируют таймауты на ручку ~20 секунд, это
    очень долго

### Вариант III

Всё также как и в варианте II, но на шаге 1 ходим в **meters-integration-api**
прямо из **requestconfirm**, а в ответ **requestconfirm** дополнительно
добавляем результат шага 2

#### Плюсы
* такие же как в варианте II плюс меньше разработки в приложении Про
(эти ресурсы в нехватке)

#### Минусы
* такие же как в варианте II
* увеличивает время работы важной ручки

### Итого: выбрал вариант I

### Детально (Вариант I)
1. в начале поездки, когда водитель нажимает "Поехали", в **processing**
запускаем **stq-таску**, которая будет ходить в **Mone backend**
    * переход из **(assigned, waiting)** в **(assigned, transporting)**
    * запуск **stq-таска** из хуков в **processing 2.0**
    * ставим `max_execution_time` как таймаут на таску
1. **stq-таск** ходит в сервис **order-core** (`/internal/processing/v1/order-proc/get-fields`),
за полями "страна", айди водителя, парка, `alias_id`, наша фикс-цена, `dbcar_id`, `payment_type`
    * `order_proc.order.nz` - по зоне и `tariff_settings` определяем страну
    * `order_proc.order.performer.uuid`
    * `order_proc.order.performer.db_id`
    * `order_proc.performer.alias_id`
    * `order_proc.order.fixed_price.price`
    * `order_proc.candidates[performer_index].dbcar_id`
    * `order_proc.payment_tech.type`
    * в случае неуспеха, завершаем таску
    * таска может сама завершиться, если достигнут таймаут
    * в случае успеха переходим к следующему шагу
1. **stq-таск** проверяет, что заказ в Израиле, иначе завершается
    * проверяем по конфигу `external_meters_settings` (новый конфиг)
    * конфиг включается по стране, типу оплаты (чтобы отсеять b2b),
    категории тарифа
    * в структуру-значение конфига добавляем флажок `"allow_auto_manage": true`
    для Израиля для `payment_type!=corp`,
    для включения автоматизации управления внешним таксометром
    * конфиг чем-то похож на [manual_price_settings](https://tariff-editor.taxi.yandex-team.ru/experiments3/configs/show/manual_price_settings/current?name=manual_price&enabled=all&active=all)
        говорящий о ручной цене
    * после проверки, для каждой страны (пока только Израиль) свой обработчик
    * если проверка не прошла, переходим на шаг 11
1. **stq-таск** ходит в сервис **fleet-vehicles** (`/v1/vehicles/retrieve`),
за полями `taxiLicense`, `vehicleLicense`
    * ходим по `performer.db_id`, `dbcar_id`
    * `car.number` - это vehicleLicense
    * `car.permit_num` - это taxiLicense
    * в случае неуспеха, переходим на шаг 11
    * если какого-то поля нет, переходим на шаг 11
1. **stq-таск** ходит в сервис **driver-profiles**
(`/v1/identity-docs/retrieve_by_park_driver_profile_id`)
    * ходим по `performer.db_id`, `performer.uuid`
    * ходим за полем `number_pd_id`
    * в случае неуспеха, переходим на шаг 11
    * если поля нет, переходим на шаг 11
1. **stq-таск** ходит в сервис **personal** (`/v1/identifications/retrieve`)
за полем `driverId`
    * ходим по `number_pd_id`
    * ходим за номером удостоверения личности водителя
    * в случае неуспеха, переходим на шаг 11
1. **stq-таск** ходит в `submit_ride`
    * передаем в `priceLimit` нашу цену
        * `order_proc.fixed_price.price` или
        `order_proc.current_prices.user_total_price` (они равны в нашем случае)
        * цену нужно сконвертировать в центы
        * алгоритм конвертации берем из конфига
    * передаем `driverId`, `taxiLicense`, `vehicleLicense`
    * ждем ответа
        * если 206, то поллим через `get_ride_info`
        * статусы ответа логируем
        * `RIDE_NOT_APPROVED` - отмена водителем, the driver did not approve
        getting this specific ride from the app
        * `TAXI_IS_BUSY` - водитель уже включил **Mone**,
        the taxi is in the middle of another ride (yes, it can also be
        if the driver started this same ride manually)
        * `DRIVER_NOT_IN_TAXI` - у водителя старый таксометр,
        the driverId/vehicleLicense/taxiLicense
        combination do not match the current driver in the taxi
        (applies also if the taxi is not in the system)
        * `DRIVER_NOT_CONNECTED_TO_APP` - this driver not yet approved
        getting rides from an app
        * `TAXI_OFFLINE` - our server did not manage to connect to the taxi
        at this time
    * если надо поллить `get_ride_info`, то делаем в том же `stq-таске`
        * т.к. если решедулить как я понял таймаут на новую таску будет новый,
        а мы хотим ждать фиксированное время на всю операция запуска **Mone**
    * в случае неуспеха, завершаем таску
    * в случае успеха переходим к следующему шагу
1. **stq-таск** ходит в сервис **order-core** (`/internal/processing/v1/order-proc/set-fields`),
чтобы проставить `rideId` из
ответа АПИ **Mone backend** в поле `external_meter_ride_id` **order_proc**
    * в случае неуспеха завершаем таску
1. **stq-таск** ходит в сервис **driver-orders-builder** (`/v1/setcar/update-lite`),
чтобы обновить **setcar** флажком **is_external_meter_run=true**
    * ходим по `performer.uuid`, `performer.db_id`, `performer.alias_id`
    * [вики по апишке](https://wiki.yandex-team.ru/taxi/backend/architecture/driver-orders-builder/updaterequest-lite/)
    * [дока по апишке](https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/Uservices/driver-orders-builder/api/api/#v1setcarupdate-lite)
    * изменения будем слать в json, наподобие
    ```
    "changes": [
        {
            "field": "taximeter_settings.external_meters_settings.is_external_meter_run",
            "value": true
        }
    ]
    ```
1. в случае успеха **stq-таск** ходит в сервис **client-notify** (`/v2/push`),
чтобы отослать пуш 1600 в **Про** и тем самым форсируя поллинг **setcar**
    * ходим по `performer.uuid`, `performer.db_id`
1. в случае неуспеха на этапах ДО хождения в **driver-orders-builder**,
следует так же повторить шаги с хождением в **driver-orders-builder** и **client-notify**,
    * но значение в обновление **setcar** следует передавать
    `is_external_meter_run=false`
1. **Про** запустит поездку, но будет ждать флажка `is_external_meter_run`
в обновлении **setcar**, но не более T секунд
(**setcar** поллится раз в 10 секунд согласно доке, его обновление форсируется пушем)
    * ждать нужно только тогда, когда в **setcar** есть настройка
    `taximeter_settings.external_meters_settings.allow_auto_manage=true`
    (настройку проставит **driver-orders-builder** по конфигу `external_meters_settings`)
    * если флажка `is_external_meter_run` в обновлении **setcar** не пришло,
    то **Про** сбрасывается в фолбек,
    уведомляем водителя, чтобы он включил **Mone** вручную
    * если флажок `is_external_meter_run` в обновлении **setcar** пришёл и равен `false`,
    то **Про** сбрасывается в фолбек,
    уведомляем водителя, чтобы он включил **Mone** вручную
    * если флажок `is_external_meter_run` пришёл и равен `true`, то удалось
    стартануть **Mone** автоматически, ничего не делаем
1. в конце поездки, когда водитель нажимает "Завершить", но до **requestconfirm**,
и после экрана выбора платных услуг,
**Про** ходит в сервис бэкенда **meters-integration-api** с `order_id` (`alias_id`)
и с итоговой ценой
    * ходит только если ранее
    **Про** дождался флажка `is_external_meter_run=true` в **setcar**
1. в **meters-integration-api** ходим в сервис **order-core**
(`/internal/processing/v1/order-proc/get-fields`) за полями `external_meter_ride_id`,
`fixed_price.price`, `pricing_data.currency`
    * если поля `external_meter_ride_id` нет, возвращаем ошибку
    * если поля `fixed_price.price` нет, возвращаем ошибку, т.к.
    это значит был сброс с фиксы
1. в **meters-integration-api** ходим в **Mone backend**
    * ходим в `update_ride` по `external_meter_ride_id` со статусом `state=COMPLETED`,
    с `paymentMethod=APP`
    * ходим в `get_ride_info`, получаем цену поездки по **Mone**
        * конвертируем из центов в шекели
        * после конвертации нужно убедиться, что цена имеет нужное число
        fraction digits (как в `order_proc.pricing_data.currency`)
    * валидируем цену, сравниваем с нашей ценой на максимальное отклонение
    по конфигу
    * если валидация не прошла, отдаем ошибку
    * в случае успеха, отдаем цену в ответ
1. **Про** получает ответ
    * если ответ успешный, **Про** возьмет цену из ответа
        * на основе цены из **Mone** и цены из **Про** **Про** решает какую взять цену
        * берем цену по **Про**, если она меньше цены по **Mone**, иначе берем
        цену по **Mone**
        * **Про** подставит полученную цену из **Mone** в `manual_price` и в
        преобразованиях прайсинга решение по тому какую цену взять разулится само
        * **Про** не будет показывать экран ручного редактирования цены
        * при этом в случае подмены цены на более низкую **Про**
        уведомляет водителя, что поездка получилась дешевле по приложению
    * если ответ неуспешный, **Про** пойдет по фолбеку, т.е. текущему сценарию

## Новый сервис meters-integration-api

См. [meters-integration-api](service.md)

## Что делать с поездками по нефиксе

### Преамбула
Несмотря на название тарифа в Израиле "Фикс" существует большое число кейсов,
когда происходит сброс с фиксы на нефикс (по таксометру):
1. пассажир в **transporting** поменял точку Б;
1. водитель завершил поездку в другой точке Б;
1. пассажир нажал кнопку "Заказать" до расчета оффера;
1. прорастание точки Б и
цены в водительское приложение не произошло на этапе **waiting/transporting**
из-за того, что водитель был в оффлайне;
1. ~~поездка без указания точки Б;~~ (в Израиле такое запрещено)
1. ...

Также, в Про цена меняется в конце поездки, когда показывается окошко с платными
услугами (багаж, дополнительный пассажир) и добавляются эти услуги.

### Переубеждаем коллег, что это плохо (наши поинты)
1. Мы хотим автоматизировать действия водителя, но не хотим как-то
влиять на физический таксометр
    * сейчас цена на физическом таксометре и в приложении считаются независимо,
    и синкаются в конце поездки вручную водителем;
    * мы хотим, чтобы цены продолжали считаться так же независимо, но в конце
    поездки добавлялась автоматика, синхронизирующая цены
1. Мы имеем большое количество кейсов, в которых мы знаем цену ТОЛЬКО в
конце поездки (см. [Преамбула](#преамбула))
    * нажимаем на пункты: платные услуги в конце поездки ~~и
    поездка без точки Б~~
1. Предлагаемые действия по вызову отмены `priceLimit` потенциально проблемны
    * мы не знаем все места, в которых происходит сброс с фиксы
    * если израильский бэкенд приляжет, мы не сможем отменить `priceLimit`,
    пассажир увидит неправильную цену на **Mone**
    * предлагаемый фолбек для этого случая (водитель будет прямо на **Mone**
    отменять **priceLimit**) - усложняет действия водителя, его понимание
    происходящего

### Переубедить не получилось, что имеем
1. в начале поездки ходим в `submit_ride`, передаем нашу цену
в `priceLimit`
    * **Mone backend** используют эту цену как ограничитель для **Mone**
1. если в поездке, пассажир сменил Б, водитель сам заинтересован
сбросить `priceLimit` на **Mone**
    * такая возможность сброса на самом **Mone** будет
1. мы на своей стороне до конца поездки ничего не делаем при сбросе с фиксы
1. в конце поездки в **meters-integration-api** мы можем
понять, что был сброс с фиксы по отсутствию `order_proc.fixed_price.price`
и сравнивая нашу итоговую цену с нашей изначальной ценой,
и в этом случае возвращать ошибку
1. **Про** получая ошибку, пойдет по фолбеку

## Про платное ожидание

"In Israel it is not legal to charge any amount or to start the meter before
the passenger actually entered the taxi. So even if the driver chose to
wait 10 minutes he cannot start the meter beforehand or add any addition
due to that."

## NB.
1. дополнительные услуги, багаж
    * могут быть добавлены в Mone в любой момент
    * в Про услуги добавляются перед окошком ручного редактирования цены
    * стало быть нашу цену надо слать **Mone backend** уже после
    окошка услуг
1. если водитель при старте поездки или при завершении поездки сначала
нажимает Mone, а потом в Про - происходит сброс на фолбек
    * любой наш запрос из Про в Mone backend после такого действия водителя
    приведет к ошибочному ответу API Mone backend
1. не забыть, что в приложении (по крайней мере на android) сейчас для
израильских водителей показывается окошко с указанием "Включите режим
расчета поезжки на счетчике", его нужно будет менять
    * [ссылка](https://jing.yandex-team.ru/files/artemshmelev/photo_2021-08-09_17-04-38.jpg)
1. правки в **Про** нужны отдельно для android (в первую очередь) и для ios
1. надо ли уведомлять пассажира об уменьшении цены, или быть может он уже
уведомляется?
    * при завершении поездки пассажир видит цену в приложении крупным шрифтом
    * специально сейчас никак не подчеркивается, что мы понизили цену
    * кажется ОК
1. может стоит добавить в ручку `submit_ride` передачу таймаута, сколько
мы готовы ждать включения **Mone**
    * чтобы не получилось например так, что сделали `submit_ride`,
    результат `PENDING`, поллим `get_ride_info`, результат всё ещё
    `PENDING`, отрубаемся, а **Mone** после этого стартует

# Проблема: поездки по таксометру вместо фиксированной цены

## Суть

1. Есть жалобы на цену поездки (поездка по фиксу превращается в поездку по таксометру). Причиной этому служит то, что приложение позволяет пользователю заказать такси (нажать кнопку "Заказать"), не дожидаясь расчёта фиксированной цены (получения ответа `/routestats`). В таком случае поездка проходит по таксометру.

<details><summary> Техническое описание проблемы </summary>
- Клиентский запрос `/routestats` вычисляет предложение (`offer`) с фиксированной ценой на поездку и сохраняет его в базу.
- Вызов `/routestats`, как правило, происходит при открытии экрана выбора тарифа.
- Кнопка "Заказать" на экране выбора тарифа отправляет запрос в `/orderdraft`.
- Предполагается, что запрос в `/orderdraft` будет происходить с `offer_id` предложения, рассчитанного вызовомм `routestats` ранее.
- Однако если сделать запрос в `/orderdraft` до получения ответа `/routestats`, запрос будет отправлен без `offer_id`.
- После получения успешного ответа `/orderdraft` клиент вызывает `/ordercommit`. В `/ordercommit` есть логика, которая ищет оффер для заказа в базе по многим параметрам (главным образом, маршрут), и если он вдруг там оказался (скажем, с предыдущего запуска клиента), заказ будет создан с этим оффером. Однако для свежего вызова `/orderdraft` (по какой-то причине не было предыдущих запросов в `/routestats` или такой запрос ещё не успел рассчитать оффер) оффера в заказе всё равно не будет.
</details>

2. Есть баг на iOS, из-за которой пользователь может уехать на Таксометре при выставлении дополнительных требований к поездке по фиксированной цене. Происходит из-за того, что при добавлении требования (например, детского кресла) происходит запрос в `/routestats` (потому что цена от добавления требования могла измениться), однако если после добавления требования сразу же нажать "Заказать", заказ будет создан без оффера. Таким образом, для такого заказа `/ordercommit` найдёт оффер без требований (т.к. оффер с требованиями ещё не успел рассчитаться), отвергнет его и поездка произойдёт по таксометру.

Очень детальный анализ проблемы (со схемами взаимодействия и предложением фикса) можно посмотреть [здесь](https://wiki.yandex-team.ru/users/maxim45/changedorderprice/changedorderprice/).


## Цель
Уменьшаем количество ситуаций, когда люди рассчитывают на фикс, но получают расчет по таксометру

## Задача
- Не меняя интерфейса и флоу заказа сделать так, чтобы % поездок по таксометру в ситуациях когда routestats не успевает отвечать до нажатия кнопки "заказать" - уменьшился
- Уменьшить количество обращений в саппорт по проблеме "цена поездки с точкой Б была рассчитана по таксометру вместо фикса"


## Варианты решения проблемы

### Клиентский

На текущий момент клиент никак не различает ситуации "отправили запрос в `/orderdraft`, ждём ответа" и "получили ответ от `/orderdraft`, отправили запрос в `/ordercommit`, ждём ответа". В обоих этих случаях рисуется одинаковая анимация поиска машины.

Вместо того, чтобы отправлять запрос в `/orderdraft` по нажатию на кнопку "Заказать", можно в случае, если ответ от `/routestats` ещё не пришёл, после нажатия на кнопку ничего не делать, дожидаться ответа `/routestats` и только потом вызывать `/orderdraft`.

#### Плюсы
- Достаточно понятное и логичное поведение "не едем, не узнав цены"
- Не требует правок `backend-cpp`.

#### Минусы
- Разработка на клиенте
    - Дефицит ресурсов клиентской разработки
    - Долгая раскатка на существенный процент пользователей
- Реализация такого отложенного механизма запроса может потребовать существенных изменений в логике клиента
- ~~Как будто бы на iOS есть [баг](https://st.yandex-team.ru/TAXIDUTY-14988#5f5a7a76e542f4229cfba3ae), из-за которого смена тарифа не всегда влечёт за собой вызов `/routestats`, из-за чего, возможно, реализовать нужное поведение будет сложнее.~~ После общения с клиентской разработкой поняли, что это не баг, а ожидаемое поведение.

В конечном итоге договорились, что вариант клиентского фикса не рассматривается, т.к. требует от клиента обязательно дождаться ответа `/routestats`, что хрупко и опасно: ответ от `/routestats` может не прийти вовсе, а хочется иметь возможность создать заказ с правильным оффером и в этом случае тоже. Кроме того, это не даст возможности отличать ситуации "клиент видел цену" и "клиент не видел цену" (см. также подробное обсуждение ниже в описании серверного фикса).

### Серверный

Если при обработке запроса в `/ordercommit` оффер не был найден или при поиске оффера ни один не подошёл, создать новый. Возможно, проинформировать пользователя на `/taxiontheway` о том, что был найден новый оффер.

Сейчас при обработке запроса в `/ordercommit` в таких проблемных случаях невозможно отличить две принципиально разные ситуации:
- клиент не показал цену пользователю (запрос в `/routestats` не был отправлен/ответ не дошёл до клиента) и пользователь нажал "Заказать"
- клиент показал пользователю какую-то цену, пользователь поменял требования и нажал "Заказать" до того, как клиент смог показать цену для обновлённых требований. 

Отличать эти ситуации важно, поскольку в первом случае цена не была показана пользователю и создание нового оффера кажется логичным и естественным (возможно, даже без дополнительных нотификаций). В то же время во втором случае пользователю была показана определённая цена и если цена поездки с обновлёнными требованиями отличается от показанной ранее, кажется критичным донести эту информацию до пользователя.

Для того, чтобы иметь возможность уверенно отличать эти две ситуации, предлагается добавить в запрос в `/orderdraft` новое поле
```yaml
properties:
# ...
- last_seen_offer:
    type: string
    description: Идентификатор последнего предложения, показанного пользователю
```

Алгоритм заполнения нового поля `last_seen_offer` и старого поля `offer`:
- Вызов `/orderdraft` до того, как какой-либо `offer` был показан: `last_seen_offer=not sent`, `offer=not sent`.
- Вызов `/orderdraft` после того, как был показан `offer` `A` от `/routestats`: `last_seen_offer=A`, `offer=A`.
- Вызов `/orderdraft` после того, как был показан `offer` `A` от `/routestats`, были изменены требования, но ответ `/routestats` для новых требований всё ещё не был получен: `last_seen_offer=A`, `offer=not sent`.


<details><summary> Анализ возможности рассчитать новый оффер по данным из /orderdraft </summary>

`alternative_suggested`: альтернативные точки подачи были получены в предыдущем запросе.
Поскольку для нашего кейса предыдущих запросов не было, можно передавать false.

`city`: город, в котором работает калькулятор тарифов или предварительный расчёт стоимости.
Есть в запросе orderdraft

`due`: время подачи
Есть в запросе orderdraft

`preorder_request_id`: id оффера с интервалами времени для предзаказа
Есть в запросе orderdraft

`estimate_waiting_selected_only`: рассчитывать время подачи только для выбранного класса
Можно передать false

`extended_description`: включать цену и расстояние для описания маршрута
Флаг отображения дополнительной информации о маршруте для клиента, можно передать false.

`format_currency`: если передан, то в ответе передаем валюты в определенном формате
Нам не нужно визуальное представление, можно не передавать

`id`: идентификатор сессии пользователя
Есть в запросе orderdraft

`parks`: исключённые таксопарки
Есть в запросе orderdraft

`payment`: данные для оплаты картой (только при requirements.creditcard=true)
Есть в запросе orderdraft

`position_accuracy`: точноcть определения местоположения в метрах
Как будто можно безопасно передавать 0.

`requirements`: требования к автомобилю
Есть в запросе orderdraft

`route`: маршрут поездки
Есть в запросе orderdraft

`selected_class`: выбранный класс обслуживания
Можно не передавать (или попытаться выковырять из orderdraft, пока непонятно как)

`selected_class_only`: выдавать информацию только по выбранному классу
Можно не передавать (или попытаться выковырять из orderdraft, пока непонятно как)

`skip_estimated_waiting`: флаг, предписывающий не вычислять ожидаемое время подачи
Можно передать false

`suggest_alternatives`: предлагать альтернативные точки подачи
Можно передать false

`summary_version`: версия summary на клиенте
Можно передать 2 как последнюю. TODO: что делать, если появится третья?

`supported_markup`: поддерживаемый клиентом язык разметки
Поддержка разметки клиентом, можно не передавать.

`supported_vertical_types`: поддерживаемые клиентом типы вертикалей
Можно не передавать

`supports_forced_surge`: данные о поддержке клиентом ответа forced_surge
`supports_paid_options`: данные о поддержке клиентом ответа paid_options
`supports_hideable_tariffs`: данные о поддержке клиентом флага is_hidden
`supports_no_cars_available`: данные о поддержке клиентом ответа no_cars_available
Флажки о клиентской поддержке тех или иных фичей, можно передать true

`surge_fake_pin`: исключает запрос из расчета pins/free
Как будто бы вообще не используется в routestats


`tariff_requirements`: требования с разбивкой по тарифам
Есть в orderdraft

`use_toll_roads`: не избегать платных дорог при построении маршрута
Есть в orderdraft

`is_lightweight`: использовать легковесную версию routestats, которая собирает
    информацию, необходимую для главного экрана, но не для саммари.
    Например, легковесная версия считает ETA только для выбранного
    тарифа, так как именно это время используется на пине.
Можно передавать false

`with_title`: который означает, что клиент поддерживает разбиение текста
    кнопки на title и extended_description
Флаг клиентской поддержки, можно не передавать/передавать false

`disable_discounts`: не применять скидки при расчёте стоимости поездки
Не совсем понятно, что с ним делать, но как будто можно передать false

</details>


Таким образом, при необходимости создать новый оффер из `/ordercommit` будет запущена stq-таска, в которой оффер будет создан, а его детали будут помещены в `order_proc`. Тогда при обработке запроса в `/taxiontheway` можно при необходимости отправить в ответе необходимое уведомление.

Поскольку во время расчёта нового оффера может происходить поиск машин, на этапе, когда `/ordercommit` не нашёл оффера, необходимо каким-то образом отметить заказ так, чтобы для него не происходил поиск машины. Здесь, по-видимому понадобятся доработки на стороне партнёрских продуктов.


#### Варианты уведомления пользователя об изменении цены:

##### Вариант 1: уведомление на taxiontheway (как в случае с уведомлением о фактическом тарифе при заказе "Самый быстрый!)

![](./static/multiclass.png)

Снять флаг для того, чтобы возобновился поиск машин, можно будет сразу в stq-таске.

##### Вариант 2: reorder

<details><summary> Немного о том, как работает `reorder`, на примере `forced_surge`:</summary>

- Где-то на протяжении жизненного цикла заказа (но до того, как был найден водитель) в `py2` отрабатывает триггер. Условия, по которым он срабатывает, не так важны, важен результат. Он подготавливает в своих кваргах [данные](https://github.yandex-team.ru/taxi/backend/blob/develop/taxi/internal/order_kit/plg/trigger/surgeprice.py#L130), которые в дальнейшем [записываются](https://github.yandex-team.ru/taxi/backend/blob/develop/taxi/internal/dbh/order_proc.py#L3340) в `order_proc` в поле (массив) `reorder.suggestions`. Пример:
```json
{
    "reorder": {
        "suggestions": [
        {
            "generation": 1,
            "type": "forced_surge",
            "params": {
            "c": {
                "$date": 1603124184777
            }
            },
            "id": "1870b1791636203a801a207fd1bc7128",
            "request": {
            "sp": 1.58
            }
        }
        ]
    }
}
```
- При запросе клиента в `3.0/taxiontheway`, при условии, что заказ всё ещё в статусе `pending`, при формировании ответа будет проверено наличие поля `reorder.suggestions` в `order_proc`. При его наличии, в ответе `totw` по ключу `reorder` появится объект следующего содержания
```json
{
    "reorder": {
        "cancel_button_title": "Cancel",
        "message": "New fare: 363 $SIGN$$CURRENCY$",
        "notification_message": "Demand for taxis has increased and we can no longer find a car at the original price.",
        "options": [
        {
            "button_title": "Accept",
            "decision_id": "1870b1791636203a801a207fd1bc7128"
        }
        ],
        "price_description": "Demand for rides is high and we can't find a car at the original fare. \\n\\nWould you be willing to pay more?"
    }
}
```
Как можно увидеть, `decision_id` здесь - это `id` из объекта в массиве `suggestions` в `order_proc` из предыдущего пункта.

- Клиент при получении такого объекта отрисует такое диалоговое окно:

![Диалоговое окно reorder](./static/reorder_dialog.jpg)

- При нажатии на `Cancel` произойдёт отмена заказа и возврат на экран саммари.
- При нажатии на `Accept` произойдёт запрос в ручку `3.0/reorder` c такими параметрами:
```json
{
  "decision_id": "1870b1791636203a801a207fd1bc7128",
  "id": "7128e2ad676c461e9565634aaf27abcd",
  "orderid": "99eb37c9dbc7268e9253471b790d78d6"
}
```
Здесь `decision_id` получен из totw, а `id` - `user_id` пользователя.


- `3.0/reorder` обновит некоторые поля заказа (подробнее можно посмотреть [здесь](https://github.yandex-team.ru/taxi/backend-cpp/blob/develop/protocol/lib/src/orderkit/order_proc.cpp#L370)) и перезапустит stq-таску в процессинг. Напомню, что в начале этого процесса в `py2` заказ были записаны новые параметры цены, на основе которых этот заказ теперь будет обрабатываться.

</details>

При поллинге `/taxiontheway` клиент получит объект `reorder` и отрисует диалоговое окно, в котором будет предложение поехать по актуальной цене. При отказе заказ будет отменён. При согласии произойдёт вызов `/reorder`, в котором можно снять флаг, блокирующий поиск машин, и продолжить процессинг заказа.


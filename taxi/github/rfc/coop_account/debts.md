### Долги.

Интеграция с сервисом [overdraft](../overdraft/main.md). 
Данный сервис хранит все долги пользователей.

Новая схема записи долгов ставит stq-py3 таску из процессинга в py2, которая обрабатывается в 
[debts-processing](https://github.yandex-team.ru/taxi/backend-py3/tree/develop/debts-processing).

<details>
<summary>Как было до костыля</summary>
<p>

В семейном аккаунте есть два типа пользователей owner и member,
при создании аккаунта owner привязывает свою карту для оплаты поездок всем members. 

Если мы не смогли списать деньги за поездку по аккаунту (например, на карте недостаточно средств),
то мы только деактивируем аккаунт и не даем его удалить.
Помечать долг на member'a, который совершил долговую поездку по семейному аккаунту некорректно
т.к. member ничего не должен знать о проблемах с картой владельца, 
и хочет иметь возможность поехать по своей карте,
если что-то не так с аккаунтом. Поэтому в коллекции *locks на member'а ничего не записываем.

По всем долговым поездкам долг выставляется в order (поле debt), клиенты ходят в ручку
/paymentstatus для получения долгов для текущего пользователя. 
Данная ручка фетчит заказы из монги для пользователя с установленным флагом debt,
что бы можно было их погасить из приложения. Поиск долговых заказов осуществляется по user_id,
в таком случае долг придет пользователю совершившему поездку, а не владельцу аккаунта как хотелось бы. 

Поэтому пришлось подхачить /paymentstatus, что бы у member'ов не появлялось окно с оплатой долга. 
[Тут](https://github.yandex-team.ru/e-usov/backend-cpp/blob/1d855af5104021a01a1b54463edeab4abdea02b3/protocol/lib/src/views/helpers/order_by_payment.cpp#L33) 
исключаем из фетчинга заказы по семейному аккаунту.
 
Сейчас нет возможности оплатить долг за поездки, которые совершал другой пользователь, поэтому 
для owner'а ничего не пишем в коллекции *locks (пишем в cardlocks, закрыто конфигом), 
что бы не блокировать поездки owner'y.

</p>
</details>


#### Продуктовое решение
Хотим записывать все долговые поездки по семейному аккаунту на owner'а 
и что-бы он мог погасить по ним долг из приложения. 
Тогда можно спокойно блокировать owner'а и его карту, до тех пор пока он не оплатит долг, стандартным механизмом долгов.


#### Интеграция 
Расширяем обработку таски debts-processing.
Если поездка по семейному аккаунту, ходим в сервис shared-payments 
за данными владельца аккаунта (yandex_uid и phone_id) в ручку /owner_info, [схема](https://github.yandex-team.ru/taxi/backend-py3/pull/4683/files#diff-f589c69183c92b2f68e7231029d6bda9R21).

Подставляем полученные значения
([где-то тут](https://github.yandex-team.ru/taxi/backend-py3/blob/b5f19725e95df6503d36e2150bed70657222882e/debts-processing/debts_processing/stq/debts_processing.py#L60))
дальше запрос уходит в сервис долгов, там записываем долг на овнера аккаунта.

Также нужно будет мигрировать существующие долги по семейному аккаунту, в сервис долгов


#### Отображение и оплата долга в приложении

1. Доработка ручки /payorder
    
    В ручке находим заказ по order_id и phone_id 
    [тут](https://github.yandex-team.ru/taxi/backend-cpp/blob/be54a17d9463327fcc5b604797af9b5943c07c3e/protocol/lib/src/views/payorder.cpp#L215)
    и [тут](https://github.yandex-team.ru/taxi/backend-cpp/blob/be54a17d9463327fcc5b604797af9b5943c07c3e/protocol/lib/src/views/payorder.cpp#L189), 
    если мы хотим оплатить заказ другого человека, 
    то при таком раскладе это не получится сделать т.к. phone_id в заказе будет другого человека и мы не найдем заказ для оплаты.

    Убираем phone_id из запросов в монгу, тогда будет возможность оплатить любой заказ.

2. Доработка ручки /launch
    
    В ручке формируется список фильтров который отправляется в /paymentstatus.
    Данные фильтры получаются в результате выбора заказов из монги в этой функции [GetPaymentFilters](https://github.yandex-team.ru/taxi/backend-cpp/blob/b26381aeba9ef02c1c283dd16d2a085d4c519d94/protocol/lib/src/views/launch.cpp#L1773),
    для получения заказов также используется phone_id, 
    из-за чего нет возможности получить долговые заказы другого человека.
    Т.к. у нас есть сервис долгов, который хранит информацию о долговых заказах, думаю правильно получать данные фильтры от туда.
    
    * Нужно вынести логику получения фильтра debts в сервис долгов. Сделать ручку, которая принимает нужный ид 
    (user_id, yandex_uid, phone_id точно не знаю как в сервисе хранятся долги) 
    и возвращает либо весь список фильтров, либо только информацию по фильтру debt (нужно ещё продумать этот момент)
    * В /launch добавить поход в данную ручку при формировании фильтра

3. Доработка ручки /paymentstatus

    В ручке формируется список заказов с доп. информацией, по списку фильтров. Заказы по фильтрам получаются так же из монги в функции [OrderSearchByPaymentFilter](https://github.yandex-team.ru/taxi/backend-cpp/blob/9554031dd2683f7cd4e5e2bb4683ee187deeb4ea/protocol/lib/src/views/helpers/order_by_payment.cpp#L9).
  
    * В сервисе долгов реализовать ручку, которая по идентификатору и списку фильтров будет возвращать список заказов с доп. информацией, 
    * В /paymentstatus перестать ходить в монгу и добавить поход в сервис долгов за списком заказов
    
    
##### Сейчас сделан костыль:
 
 1. Когда происходит долговая поездка, в py2 записываем лок(devicelocks, userlocks, cardlocks) на владельца аккаунта
 2. В C++(в /launch и /paymentstatuses) ходим кроме коллекции orders, еще в локи и находим все не оплаченные заказы овнера с типом оплаты coop (которые записали из py2)
 3. В приложении для владельца аккаунта отображаются долговые поездки и он может их оплатить
 4. В /payorder для заказов по coop_account не проверяем phone_id что бы владелец мог оплачивать не свои поездки.

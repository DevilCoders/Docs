## Проработка

### Продуктово

1. Этап 1: пользователь звонит, у него нет активного заказа (он хочет заказать) и попадает в эксперимент (по городу, id, etc).
Мы переводим его на IVR, где озвучиваем саджесты точек A и B отдельно.
Для согласия с предложенной точкой юзер жмет 1, любое другое нажатие переводит на оператора (при этом в следующих этапах хорошо бы передать оператору хотя бы одну выбранную юзером точку).
Если юзер согласен с маршрутом, мы озвучиваем ему цену и время ожидания. Если он согласен, то мы создаем заказ.
2. Этап 2: показываем оператору имеющуюся информацию о выбранной точке А, если точку Б мы не угадали.
3. Этап 3: распознаем "да"/"нет" от пользователя в дополнение к клавише 1.
4. Этап 4: оптимизируем неугаданные адреса: прикручиваем возможность надиктовать адрес, либо озвучить еще несколько предложений.

Базовое описание [тут](https://wiki.yandex-team.ru/users/hawk/Priem-zakaza-po-telefonu-robotom/#jetap1.predlozhenieadresovizexpectedsource/destinations).

### Технически

#### Этап 1

1. Сообщать Oktell-у, что для данного звонка надо переключить вызов на IVR вместо оператора.
Сейчас Oktell на каждый звонок дергает ручку `/can_process_call` в сервис `ivr-dispatcher`.
Эта ручка внутри идет в `/dispatcher/api/action` сервиса `ivr_api`.
Внутри `ivr_api` мы ищем активные заказы юзера (`_find_active_order_by_phone`): если они есть, то говорим, что вызов будем обрабатывать мы, через IVR.
Добавляем туда следующую логику: если номер, на который звонит юзер, есть в конфиге (чтобы уметь включать на определенный город)
и юзер (определяем по номеру, уже фетчим `phone_id`) попадает в эксперимент,
то отдаем `true`: вызов будем обрабатывать мы, через IVR.
Логику добавляем путем создания нового типа worker-а, вопрос только в том делать ли повторный поиск активных заказов или реюзать из текущего воркера.
Оценка: 3д.

2. Добавить новые состояния `ivr-api` для надиктовки и ожидания ответа юзера на два саджеста, озвучивание цены и создание заказа. Сейчас есть следующие состояния:

```python
class State(worker_base.State):
    INFO: str = 'information'
    INPUT: str = 'ask'
    PARTNER: str = 'partner_info'
    CANCELLED: str = 'cancelled'
    CANCEL_ERROR: str = 'cancel_error'
    DRIVER_SWITCH: str = 'driver_switch'
    DRIVER_SWITCH_ERROR: str = 'driver_switch_error'
    SKIPPED = 'skipped'
```

Добавить новые состояния с моками их обработки, покрыть тестами. Оценка 2д (не 1д, потому что тут придется глубоко вникать в текущую стейт-машину).

3. Озвучиваем юзеру саджест точки A и затем Б. Для этого в `ivr-api` заменяем мок, созданный в прошлом шаге на вызов `/v1/expectedpositions`
и `/v1/expecteddestinations` у `integration-api`. Берем самую вероятную точку А/Б из ответа и зачитываем ее юзеру. Нюансы:
   * саджеста одной или обоих из точек может не быть. В этом случае на этапе 1 надо сразу пробрасывать звонок на оператора. Важно не допустить ситуации,
   когда мы озвучили саджест точки А, а потом перевели на оператора (который в этапе 1 ничего не знает об этом саджесте).
   оэтому надо в начале звонка параллельно вызывать оба API и продолжать IVR только если саджесты обеих точек есть.
   * по-хорошему надо озвучить не все точки, а те, у которых вероятность быть выбранными больше порога. Вероятность отдает `mlaas`, в который ходят `/v1/expected*`. Концептуально - надо подтюнить эти ручки, чтобы они отдавали только точки с вероятностью выше заданной. Но команда Степы уже делает эту функциональность в `/persuggest`, возможно, можно его заюзать.
   * если `integration-api` лежит, аналогично надо пробрасывать на оператора.
   * не забыть про мониторинги, алерты: когда точки А нет, точки Б нет, обоих нет, обе есть, `integration-api` лежит и тп.

Оценка: 4д (запас на коммуникацию с гео командой, кросс-сервисные доступы/авторизации, графики).

4. Учимся принимать подтверждения от юзера (нажатые клавиши) по саджестам и по ним или идти дальше в стейт машине или переключать на оператора.
Когда юзер подтверждает предложенную точку нам надо сохранить информацию об этом в контексте (все уже удобно сделано для этого, а хранятся они в `ivr_worker_contexts`).
Не забыть про графики (в тч бизнесовые).

Оценка - 2д: 1д разобраться как сейчас работают такие команды, и 1д реализовать с тестами.

5. Учимся озвучивать цену и время ожидания через вызов `/v1/orders_estimate`.
Если достучаться до API не удалось, то алертим и переводим на оператора. Еще лучше - в самом начале сессии до выдачи юзеру саджестов
делать поход в `/v1/orders_estimate` по полученным саджестам. Тогда мы в случае ошибки переведем на оператора сразу. Минус - задержка увеличится, надо считать 99 квантиль таймингов для принятия решения.
Если `/v1/orders_estimate` ответило что машин нет, то сохраняе эту информацию. И только если мы все угадали для юзера, мы вместо цены озвучиваем ему фразу из конфига типа `машин нет, попробуйте позже`.

Оценка - 3д.

6. Принимать подтверждение цены и времени ожидания - 1д.
7. Создавать заказ. Берем информацию о точках и оффер из контекста, куда мы все уже должны были сохранить. Вызываем у `integration_api` API `/v1/orders_draft` и `/v1/orders_commit`. Нюансы:
   * если не удалось достучаться до драфта или до коммита (таймаут, 5xx)с n попыток, то переводим на оператора и алертим.
   TODO этап 2: класть в stq и сообщать юзеру, что все ОК.
   * если получили ошибку 4xx, то надо зачитать какой-то текст (вопрос к менеджеру какой) и перевести на оператора, алертинг.
Оценка - 3д.
8. Сейчас при заказе через КЦ затем перезванивает робот и сообщает номер назначенной машины. Надо убедиться, что эта и прочая логика не отломается - 1д.
9. Протестить и улучшить по результатам проговаривание адресов. С этим точно будут проблемы: проговариаем через speechkit, он делает это не очень. Возможно, надо будет заменять сокращения и символы в адресе для более качественной озвучки. [Тестить](https://webasr.yandex.net/ttsdemo.html) можно здесь.
9. Тестирование и запуск - 3д. Много времени уйдет, чтобы в первый раз вникнуть в эту область, поднять тестовое окружение, преодолеть все проблемы.

**Итого этап 1: 22д**.
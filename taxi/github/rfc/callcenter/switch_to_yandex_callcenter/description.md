# Переключение на яндексовский коллцентр
## термины

_оператор_ - человек, принимающий звонки и оформляющий заказ от лица пассажира

_oktell_, _октелл_ - наше текущий партнер, через которого мы получаем и отправляем звонки

_коллцентр_ - центр обработки звонков

_оператор связи_ - компания, управляющая инфраструктурой для звонков (сотовой, фиксированной и др).
Звонки от пассажиров проходят в нашу телефонию через инфру операторов связи и уходят через них же.

_IVR_ (Interactive Voice Response)- коробка внутри такси, которая ведет диалог с пользователем при входящем звонке от него и говорит ему статус заказа при исходящем от нас. Состоит из нескольких отдельных процессов (octonode, mrcp, freeswitch), подробности есть на схеме.

_рабочее место оператора_ - программа или сайт, через которую операторы принимают звонки и создают заказы.

_freeswitch_ - сервер для приема и отправки sip-звонков на стороне такси.

_octonode_, _октонода_ - сервер, управляющий поведением freeswitch

_гейтвей freeswitch_- описание sip-сервера для исходящих от нас звонков. Во freeswitch может быть описано несколько _гейтвеев_, и их можно выбирать при исходящем звонке.

## чего мы хотим
Вместо октелла при работе *с телефонными заказами* мы хотим принимать и 
отправлять звонки через яндексовую телефонию (далее _tel_)

  - Операторы должны получать звонки от пассажиров
  - Звонки пассажиров, у которых уже есть заказ, должны роутиться на ivr вместо операторов
  - IVR должен перезванивать пассажиру *с того номера, на который звонил пассажир*
  - IVR может переключить звонок на оператора по нашей инициативе или по инициативе пассажира


## исходящие звонков о статусе заказа

### сохранение будущего исходного номера при входящем звонке
 - яндекс-телефония принимает звонок и отправляе его оператору.
 - рабочее место оператора хватает из заголовков sip _принимающий_ номер
 - при создания заказа интерфейс оператора передает номер телефона, гейтвей и, возможно, другие данные в ordercommit или orderdraft в дополнительном поле additional. Это поле вырезается в integration_auth перед отправкой в protocol. после orderdraft/ordercommit integration-auth, вызывает **новую ручку IVR**, в которой сохраняется связка (order_id, номер телефона коллцентра, гейтвей, дата устаревания). На первой итерации никаких ретраев походов в Ivr не будет, но будет мониторинг на количество ошибок,
 
 Эта ручка должно вызываться для заказов как из oktell, так и из новой телефонии. Я ожидаю, что гейтвей (источник звонка) можно будет получить из заголовков так же, как мы планируем получать номер телефона.
 - этот номер используется для исходящих звонков при уведомлениях


### отправка исходящих звонков
  Сейчас уведомления из processing отправляются в октоноду, а позвонила ли октонода пассажиру проверяется по логам в отдельном сервисе octonode_check_call.
  Планируем перенести эту логику в ivr-api. В очереди notification вместо вызова Октоноды будет вызываться **новая ручка ivr**, которая уже будет ходить в Октоноду и выполнять дополнительные нужные операции
  Поход в октоноду через ivr можно выполнять под экспериментом, фоллбечась на старый механизм.
  
  Решения эта ручка будет принимать по связкам orderid-inbound, описанным выше, а так же по конфигам с дефолтными номерами для перезвона. Если нам не удалось сохранить номер, с короторого мы должны перезвонить, то мы указываем с дефолтного номера через дефолтный гейтвей

### роутинг исходящих звонков
  для исходящих звонков во freeswitch добавляется еще один distributor, в котором указываются адреса sip-нод tel. (сделано)

## входящие звонки от пассажиров в IVR
  куда направлять заказ определяет tel согласно своей таблице роутинга, которой управляем мы из очереди processing через ручки ivr
 - в момент создания заказа (`handle_create`) мы вызываем **новую ручку ivr** для *создания или продления* правила в tel
 - в момент завершения заказа (`handle_finish`) мы вызываем **новую ручку ivr** для удаления правила в tel.

Правило создается с expire = now + order_proc.calc.time + какой-нибудь margin из конфига

## переключение входящего вызова пользователя с ivr на оператора
  переключение на оператора по инициативе пользователя обрабатывается ivr (получили звездочку, кинули на оператора)

  переключение на оператора по нашей инициативе обрабатывается тоже самим ivr.

  Механизмы переключения для oktell и tel различны. Для oktell мы отправляем звездочку sip-сообщением. Для tel мы пока договорились отправлять в tel refer на служебный номер очереди. Способ переадресации задается сейчас переменными сессии в контексте noc, для контекста public все работает по умолчанию. С переменными сессии я связываюсь из-за того, что октонода живет отдельно от остальных проектов и даже не умеет сейчас ходить в наши конфиги.

## форвардинг звонков пользователей на водителей
  гейтвей для звонка водителю задается в старом конфиге (IVR_ORDER_STATUS_WORKER_GATEWAYS), но перекрывается в переменных сессии в контекстах noc
## форвардинг звонков водителей на пользователей
  Пока предполагается работать так, как работали до этого

# обработка странных ответов телефонии
   Ручки телефонии иногда отвечают странно. Нужно пробежаться по всем ручкам в анстейбле с тем роботом, что уже там есть и проверить как 
   они работают. Возможно, расширить или переделать allowed_errors.
   (1d) (сделано)

# новые ручки integration-auth
  * post /orderdraft поход в Ivr, складывание туда данных о звонке (orderid-inbound-gateway-...)(4h)(сделано, заняло намного больше времени из-за просадок с бд, сложностей с тестами). 
  
# изменения в ivr-dispatcher, ivr-api
  * добавление таблицы в БД ivr для хранения связок order-id-inbound + гейтвей + дата создания (гейтвей не добавлен, считаем, что заказ происходит через новый коллцентр. Звонки со старого коллцентра не попадают в новый интерфейс)
  * добавление крон-скрипта для регулярного удаления старых связок (осталось сделать)
  * post /tel/inbound_number сохранение связки orderid-inbound (1d) (реально намного больше)
  * post /routetoivr  - создать/обновить правило на прием звонков от пассажира. После вызова этого метода входящие звонки с указанного номера роутятся на ivr в первую очередь (3h) (намного дольше из-за тестирования и неработоспособности телефонии)
  * post /routetooperator - вызывается из handle_finish, удаляем правило роутинга, после этого звонки пассажира направляются на оператора (4h)
  * get /make_call - выполняет вызов октоноды, подставляя правильный исходящий номер и гейтвей (1d)
  * мониторинг на новые ручки 1h

# изменения октоноды
  * добавить возможность указывать гейтвей при вызове (сделано, есть pr, уже отправлял звонок через яндекс-телефонию)
  * отработать переключение звонков не по звездочке (refer) (2d) (готово)

# изменения процессинга
  * вызывать из handle_create и handle_finish ручки ivr (2d)(готово)

# изменения в рабочем месте оператора
  * вытаскивать из сип-заголовков входящий номер и гейтвей и отправлять их в /ordercommit (не могу оценить клиентскую часть)(готово)

# Новый конфиг с номерами телефонов

Сделать и протестить новый конфиг, в котором будут указаны номер и исходящий по-умолчанию.(не будет сделано)
# итого
  8d 4h + 2d на тестирование
  
# что, если
Правило роутинга еще не создалось, а пассажир уже позвонил - он попадает на оператора, оператор знает что делать. 

Не удалось создать правило роутинга совсем - та же ситуация

Пассажир позвонил после завершения заказа, а правило роутинга еще живое - его направит на ivr, который увидит, что текущих заказов уже нет и перенаправит звонок на оператора.

Не удалось удалить правило роутинга - Правила будут создаваться с разумным ttl (expired) и за их удалением будет сдедить сам бекенд телефонии

Мы не сможем поддержать refer со своей стороны - tel поддержит звездочку от нас

# будущие доработки
**Введение мультизаказа через КЦ** требует доработок фронта и ИВР, но **критично ничего не ломает**. Однако, после включения мультизаказа без доработок ИВР последний будет работать с одним произвольным заказом для входящих звонков и завалит пользователя голосовыми уведомлениями обо всех заказах.

При самом плохом варианте введения в строй мультизаказа оператор будет пытаться создать еще один заказ для пассажира, а бек при превышении лимита отдавать ошибку. Такого не должно произойти, так как фронт сейчас запрещает делать более одного заказа на человека. Думаю, что никто не будет катить фронт без этого ограничения и одновременно без возможности узнать заранее, будет ли принят беком еще один заказ.

  * Нужны будут новые сценарии для входящих звонков IVR. Самый простой способ при мультизаказе отправлять пользователя сразу на оператора. Сложнее - сделать озвучивание деталей каждого заказа и меню для каждого заказа.
  * Возможно, нужна будет доработка и для исходящих.

## про ретраи сохранения входящего номера
Если мы в будущем будем делать ретрай похода в ivr через stq, то получается, что мы должны положить данные в базу на стороне integration-auth/задачи stq для того чтобы положить эти же самые данные в базу на стороне ivr. Это мне кажется странным.

Мы можем сохранить данные как аргументы задачи stq (kw), но нужно будет очень аккуратно написать обработчик этой очереди, чтобы потом ничего не сломалось при изменении аргументов.

## про логброкер
Вместо обработки в процессинге мы можем обрабатывать события клиентом logbroker, но примера клиента логброкера в такси пока нет. Клиент можно сделать в отдельном сервисе либо встроить в ivr. На logbroker можно перейти позже под экспериментом.

В случае с логброкером события обрабатываются отложенно и асинхронно, а для удаления правила нам нужно смотреть на текущее состояние, поэтому логброкер скорее всего не подходит.


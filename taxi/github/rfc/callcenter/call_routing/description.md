# Управление машрутизацией звонков

## Цель
- Распределение звонков по очередям (help/cargo/disp/etc)
- Балансировка звонков между сабкластерами телефонии
- (В будущем.возможно) Блокировка звонков
- (В будущем/возможно) Перенаправление звонков на ivr

## Вводные данные

 - Кластер телефонии будет состоять из нескольких сабкластеров.
 - Каждый сабкластер имеет собственные очереди звонков и ограничения, по кол-ву одновременно подключенных операторов

Поэтому и возникает необходимость балансировки, остальные функции в подарок.
Так же возникает необходимость не только балансировать звонки между сабкластерами, но и операторов.

**В первой версии балансировка операторов ручная**

Нужно:
- Реализовать ручку, которая отвечает, что делать с поступившим звоноком
- Добавить информацию о сабкластерах в данные оператора

Цифры (без учета нагрузки ВЕЗЕТ):
- ~1000 звонков в минуту => 17 RPS
- ~600 операторов
- ~10 subcluster'ов
- ~5 очередей

## Обозначение очередей

На каждом кластере (множество SC = sc1/sc2/sc3) будет набор всех очередей (с бизнесовой точки зрения) (множество Q = help/disp/carg/...), поэтому суммарно на всю телефонию у нас будет [SC]\*[Q] очередей, каждая из которых будет иметь какое-то конечное имя *queue_name*, по которому мы и будем управлять ими в телефонии (*TBD*). Для генерации конечного имени предлагается зафиксировать шаблон, например:
**\<queue\>\_on\_\<subcluster\>**

## Реализация ручки распределения звонков

- сначала принимается решение, на какую очередь отправить звонок. Для этого необходима информация:
    + call_guid - уникальный идентификатор звонка для связывания звонка с последующими событиями от телефонии из logbroker'а
    + called_phone_number - телефонный номер, на который позвонил абонент
- затем принимается решение, на каком из сабкластеров данный звонок будет обработан. Для этого необходима информация по каждому сабкластеру для очереди выбраной на предыдущем шаге:
    + кол-во свободных операторов (не разговаривающих в данный момент и готовых принять звонок)
    + общее кол-во подключенных операторов
    + длину очереди

Информация о звонке передается при вызове ручки.
Остальная информация агрегируется по поступающим событиям из logbroker'а

Поэтому ручка будет реализована в сервисе callcenter-stats, куда поступают все события из logbroker'а.

Описание ручки: [route_call_api.yaml](route_call_api.yaml)

### Распределение звонка по очередям

По отображению телефонов коллцентра в очереди, который хранится в конфиге

### Агрегация событий из logbroker'а

События приходят с задержкой. По логам за 7 дней 98% событий приходят с задержкой < 1,65 sec (величина имет большую погрешность, т.к. время событий в телефонии пишется в секундах).
Это означает, что мы не можем полагаться на состояние очередей и операторов построенному только по событиям (за 1,65 сек мы должны принять решение для 17*1,65 ~ 28 звонков)

Будем достраивать его записывая все решения и сохраняя их, пока информация о звонке не придет из логброкера, см. [call_lifetime.puml](call_lifetime.puml).
Можно попробовать объединить с текущей таблицей calls, добавив дополнительный status и индекс на поле call_guid (*TBD*)

### Распределение звонка по сабкластерам:

- Список сабкластеров определяется по наличию операторов. Если на сабкластере нет операторов, то это равносильно отсутствию сабкластера.
- В качестве приоритета сабкластера можно взять:
    1. Кол-во свободных операторов подключенных к данной очереди на данном сабкластере (от 0 до общего кол-ва операторов) по данным из логброкера (эта информация с задержкой) (строится по таблицам operator_status и operator_talking_status)
    2. **Минус** длина очереди по данным из логброкера (эта информация с задержкой) (строится по таблице calls)
    3. **Минус** кол-во распределенных звонков, но еще не подтвержденных из логброкера

    Последний пункт скорректирует задержку в актуализации как первого так и второго слагаемого. 
    Стоит брать записи с ограничением по времени жизни, чтобы не накапливать "подвисшие звонки".

- Так как сабкластера могут быть разного размера = разное кол-во подключенных операторов, то приоритизировать их лучше с учетом разной пропускной способности пропопоциональной кол-ву операторов.
Для этого значение из предыдущего пункта следует разделить на кол-во подключенных операторов

### Риски

Сервис занимается как минимум 4 задачами помимо планируемой
    + запись истории состояний оператора
    + хранением состояния звонков и отдачей списка звонков в админку (по запросу)
    + отправкой алертов (каждые 3 секунды)
    + сбором и записью метрик (1 раз в минуту)
Сервис использует Postgres DB и logbroker.

1. В случае отказа/недоступности/таймауту DB мы не можем получить информацию по сабкластерам, но можем принять решение по очереди (по конфигу). Можно завести дефолтный сабкластер, на который мы будем назначать звонок.
2. В случае отказа/недоступности Logbroker'а или проблем с записью сообщений в DB (мы делаем это синхронно и последовательно), мы задерживаем получение актуального с точки зрения телефонии представления о состоянии очередей. В этом случае пп1-2 формулы замораживаются в послденем состоянии и мы ориентируемся только на слагаемое из п.3. Если предположить, что в момент отказа 3 слагаемое компенсировало задержки пп1-2, т.е. система была сбалансирована, т.е. звонки были распределены пропорционально *реальной* пропускной способности, то информации из п.3 нам будет достаточно, чтобы распределять звонки пропорционально *теоретической* пропускной способности.
3. Непредвиденные ошибки, таймауты - необходимо иметь ретрай политику на вызывающей стороне. Предлагаемое значение 3х300мс.
4. Полный отказ, недоступность сервиса - необходимо предусмотреть fallback на стороне телефонии (*TBD*)

### Дополнительно

- Писать историю принятых решений и делать это асинхронно после ответа телефонии, чтобы не задерживать ответ звонка
- Предусмотреть принудительный переход на аварийный режим: определяем очередь по конфигу, сабкластер рандомом. Список сабкластеров задается в конфиге.
- Мониторинг времени ответа и ошибок, с оповещением команде разработки коллцентра

## Изменения в управлении операторами

1. добавить поле subcluster в данные об операторе
2. выводить информацию в админке и управлять ее
3. генерировать конечное имя очереди при подключении/отключении

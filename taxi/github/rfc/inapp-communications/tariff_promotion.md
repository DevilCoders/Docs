_Развитие данной проработки производилось в рамках rfc https://github.yandex-team.ru/taxi/rfc/pull/473._
_Данная проработка замержена для истории_

## Бизнес-описание

Хотим сделать так, что бы была возможность гибко настраивать промо блок, который находится под списком тарифов.
Сейчас он используется только для промо нового тарифа Курьер/Доставка [описание тут](all_communications.md#tariff-promotion).

Чем хотим уметь управлять:
- выборка пользователей
- сколько раз показывать (сколько секунд показывать)
- таргетирование с учетом ML

Примеры промоблоков:
- промо нового тарифа (вообще новый, новый в определенной зоне)
- промо тарифа для определенных пользователей (если мы точно знаем что у пользователя есть ребенок промоутим тариф Детский)
- промо поездки в любимый ресторан (текст: В ресторан на бизнесе)
- промо скидки/кэшбэка по плюсу
- нотификация об изменение суржа 

Подробное описание всех бизнес требований [в тикете](https://st.yandex-team.ru/TAXIPROJECTS-1636)

![Дизайн](https://jing.yandex-team.ru/files/e-usov/promo.jpeg "Дизайн")

 
## Техническая реализация проекта

**Как создавать и управлять промкой?**

Создание и конфигурирование промоблока будет управляться через админку промоушенов (сервис promotions, позже переедет в feeds-admin).
В админке указываем нужные тексты (title и subtitle), иконку, диплинк, приоритет показа, частотность показа,
гибкое время показа, наличие тарифов на клиенте (для перехода на определенный тариф), триггеры на скрытие плашки (количество показов, количество кликов). 

**Вид диплинка**

Клиенты поддерживают диплинки вида `yandextaxi://route?start-lat={start-lat}&start-lon={start-lon}&end-lat={end-lat}&end-lon={end-lon}`,
таким же образом можно указать конкретный тариф через параметр `level`. 

Более подробно про вид диплинка можно посмотреть [тут](https://wiki.yandex-team.ru/taxi/mobile/externalrun/#ukazattochkuai/ilib) 

**Как выбирать нужных пользователей?**

Управление выборкой пользователей происходит с помощью тэгов пользователей и экспериментов 3.0. 
Данная логика уже поддерживается в сервисе inapp-communications.

1) Проставляем тэги нужным пользователям (YQL запросом, ML
2) Создаем эксперимент 3.0 по нужному тэгу
3) При создании определенной промоплашки указываем нужный эксперимент для кого она будет рааботать

**Персонализация промок**

Хотим уметь делать персонализированные промо блоки. Задавать определенный адрес точки Б и выбранный тариф.
Предлагается собирать персонализированную информацию в момент подготовки выборки пользователей в ML. 

Например:
Мы находим пользователей, которые часто зазывают из одного ресторан/кафе еду. Мы готовим промо акцию на таких пользователей.
Что бы сказать им, что они могут поехать в свой любимый ресторан на бизнесе. В таком случае нужно разметить таких пользователей тэгами и
подготовить следующие данные:
- id пользователя
- адрес ресторана
- рекомендуемый тариф

Есть вопрос, где хранить эти данные?
- в YT
- во временной таблице в сервисе (в каком сервисе inapp-communications, promotions/feeds-admin)

_todo: продумать детальней_

**Как доставлять промки на клиенты?**

В текущей реализации, промки приходят в ответе ручки /routestats.

Я вижу несколько вариантов попадания промоблоков на клиенты.

1) Новая клиентская ручка в сервисе inapp-communications

    Делаем новую ручку, которая будет дергаться после routestats (подумать над оптимизациями, что бы не дергать каждый раз).
    Ручка должна принимать на вход всю информацию о пользователе (делаем через заголовки PA) и часть ответа routestats (нужно подумать какие нужны поля). 
    
    todo: схема ручки будет позже, возможно отдельным ПРом.
    
    Вся бизнес-логика реализуется в этой ручке. Получаем все доступные промки для конкретного пользователя (подобная логика уже есть), 
    определяем возможность их показа в текущий момент, например если в данной зоне не доступен тариф Курьер, 
    то и нет смысла показывать промку с ним (возможно это получится контролировать на этапе получения промок). 
    Персонализация ответа, например подставляем нужный адрес для точки Б (например адрес любимого ресторана или кинотеатра куда куплены билеты)
    
    Плюсы:
    - отделение некритичной логики от критичной ручки /routestats
    - если что-то сломается с промками, это никак не повлияет на цикл заказа
    - хорошо ложиться в логику сервиса inapp-communications
    
    Минусы:    
    - сложная реализация на клиентах, могут возникнуть проблем с тем что интерфейс будет скакать
    - дублирование данных из ответа ручки /routestats (список тарифов, цены, что-то ещё)
    - ломается обратная совместимость

1) Использование существующей ручки /4.0/inapp-communications/communications
<details>
<summary>не актуально</summary> 
    То же самое что и первый вариант, только используем существующую ручку.
    Данная ручка уже поддерживает набор полезных вещей: дифф между коммуникациями, приоритеты, время показа, получение промоблоков по тэгам/экспериментам.
    type: array
Плюсы (по сравнению с отдельной ручкой):
    - часть нужной базовой логике уже поддержано
    - все коммуникации в одном месте
 
Минусы (по сравнению с отдельной ручкой):
    - дополнительная нагрузка на ручку
</details>

1) Плагин в сервисе uservice-routestats 
<details>
<summary>не актуально</summary>   
    
В данный момент идет разработка системы плагинов для ручки /routestats.
Данную логику промок можно будет реализовать поверх этой системы. 
Как я уже написал выше, сейчас этим промки реализованны в ручке /routestats, 
нужно будет перенести логику связанную ними в новый сервис плагинов. В данном решении, 
так же понадобится новая внутрення ручка в сервисе inapp-communications, 
которая будет возвращать доступные пользователю промки.

Вся логика связанная с показом промок в зависимости от текущей цены поездки, доступных тарифов,
текущего выбранного тарифа и других параметров, которые есть в ответе /routestats, будет реализована плагином.

Плюсы:
- обратная совместимость
- не нужно тащить большое количество параметров в сервис inapp-communications (доступные тарифы, цены, что-то ещё)
- просто поддержать на клиенте и не будет проблем с дерганьем интерфейса

Минусы:
- система плагинов пока что не в проде
- увеличение таймингов ручки /routestats (они и так не маленькие)
- сложнее в реализации на бэке чем первый вариант
    
</details>

После оценки плюсов и минусов всех вариантов, выбран наиболее подходящий вариант - делаем новую ручку в сервисе inapp-communications
 и частично переиспользуем, то что уже есть в ручке /communications.

**Новая ручка /4.0/inapp-communications/tariff_promotions**

Делаем новую ручку /tariff_promotions (или более абстрактно summary_promotions), переиспользуем часть логики из ручки /communications: 
* дифф промок с устройства, что бы не отдавать дважды одинаковый промки
* логику получения промок по тэгам и экспериментам  

В списке`tariff_clasess` в запросе клиенты будут передавать все доступные тарифы пользователю в текущий момент.
Ручка дергается после zoneinfo, routestats в том случае если изменился список доступных тарифов (на клиенте запоминаем доступные тарифы в определенный момент).
При переносе пина в другую зону, список тарифов может поменяться, после этого требуется получить новые промки.
В ответе приходит список коммуникаций `tariff_promotions` - плашка на саммари под списком тарифов.

Что делает ручка:
1) Получаем все доступные промоблоки для пользователя (по тэгам и экспериментам)
1) Фильтруем полученные промоблоки в соответствии с доступными тарифами
1) Если в промоблоке есть персонализированная информация, то получаем её (из YT или БД) и подставляем в нужные поля (диплинг, текст)
1) Отдаем промки пользователю

```
POST /4.0/inapp-communications/tariff_promotions
```

Request:
```json5
{
    "communications_on_device": ["tariff_promo_surge"],
    "tariff_clasess": ["econom", "vip"] // список тарифов доступных пользователю, required: true
}
```

Response:
```json5
{
   "tariff_promotions" : [
        {
            "id": "tariff_promo_1", 
            "options" : {
                "type": "deeplink | surge", // тип промки, сурж является специфичным для клиентов, вся логика связанная с плашкой суржа управляется на клиенте. 
                "tariffs": ["econom", "comfort"], // когда в клиентском приложении выбран один из этих тарифов, промоплашка должна быть показана
                "priority": 2,
                "start_date": "2019-12-10T00:00:00+0300",
                "end_date": "2021-12-10T00:00:00+0300",
                "action_count" : { // названия полей и структура не финальные, открыт к предложениям, required: false
                    "view": 5, // количество показов промоплашки пользователю, required: false. Подсчет ведётся на клиенте.
                    "click": 5, // количество переходов/кликов по промоплашке, required: false. Подсчет ведётся на клиенте.
                },
            },
            "payload": {
                "title": "В ресторан на Бизнесе",
                // "subtitle": "",
                "icon_tag": "tariff_promo_1_icon_tag",
                "action": {
                    "deeplink": "yandextaxi://route?end-lat={end-lat}&end-lon={end-lon}&level=123", // или через tariffClass
                }
            }
        }
   ]
}

```

**Другой вариант получения списков тарифов**

В ходе обсуждения, был озвучен другой вариант получения доступных тарифов. 
Если в ручке с клиентов будет приходить текущая координата пользователя, 
мы сможем на бэке получить список доступных тарифов.

Минусы:
- увеличивает тайминг ручки, добавляется дополнительный поход за тарифами
- не уверен что у нас сейчас есть внутрення ручка, которая вернет список всех тарифов
- возрастает нагрузка на ручку, т.к. придется дергать при каждом изменении пина

## План работ

Проект состоит из 2ух основных задач на стороне бэка, которые бьются на последовательные подзадачи:

1) Разработка клиентской ручки /tariff_promotions в сервисе inapp-communications
- api и моки ручки 2d
- переиспользование логики дифов и работы с тэгами/экспериментами из ручки /communications 4d
- получение нужным промок и их фильтрация по тарифам 4d
- персонализация промоблоков, хранение персонализированных данных (на первом этапе без персонализации данных) 6d

    _сроки не точные, мало экспертизы в данном сервисе_

1) Разработка ручек для создания/удаления/редактирования промоплашек в админке
- нужно попытаться максимально переиспользовать то, что делается для шорткатов (про сложность ничего пока что не могу сказать)  

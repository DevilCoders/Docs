## Библиотека кеширования коммуникаций

### Проблема
В последнее время стало много т.н. коллекций, уходящих внутри витрин из ручки /4.0/inapp-communications/shortcuts в апи-прокси, и далее в блендер. Большие ответы ручки грузят сеть. Хочется уметь кешировать повторяющиеся элементы внутри самого блендера. Также потенциально это позволит сэкономить время на парсинг json'ов. Одно из других возможных мест использования - домик плюса, который ходит в ручку /4.0/inapp-communications/communications.

### Решение
Вынести кеш коммуникаций из сервиса inapp-communications в библиотеку и воспользоваться этой библиотекой в блендере.

### Реализация
Библиотека перенимает в себя следующую функциональность, ныне живущую в inapp-communications:
1. Хранение, наливка и обновление кеша. Предполагается поход в /internal/promotions/list, т.е. без изменений логики
2. 
- (*) Забор YQL-data из БД promotions
- Хождение в танкер
- Построение attributed text с помощью библиотеки "extended template"
3. (*) Матчинг экспериментов

В первом приближении предлагаю переносить кеш полностью (без шаблонизации под конкретного потребителя), несмотря на то, что блендеру требуются только ДШ, сторизы и витрины.

### Сложности реализации

* Многие механизмы построения промок сильно завязаны друг на друга, не хочется "отрывать" и "разводить" этапы построения промок. Постепенный переезд может быть затруднён, возможно, придётся перевозить сразу всё, а это дорого и сильно раздувает blender.

### Плюсы и минусы
Безусловные плюсы:
* Общяя кодовая база и возможность переиспользовать функционал (коммуникации могут потребоваться в любом месте приложения).
* Снижение трафика, нагрузки на диск и размера логов (примерно 70-75% ответов /4.0/inapp-communications/shortcuts не пусты и имеют размер порядка 4-6 кб, в ближайшее время возможно увелические ответов в 3+ раз).

Безусловные минусы:
* Усложнение работы blender'a: новые сущности, которые не предполагались в сервисе.
* Сложности реализации (см. выше).

Минусы, возникающие, если перенести функционал (\*) в blender:
* Увеличение нагрузки на базу и увеличение таймингов: поход в БД за YQL-data непременно влечёт увеличение работы ручки /blender/v1/shortcuts-grid, которая напрямую влияет на тайминги /4.0/mlutp/v1/products. Остальные этапы построения коммуникации менее накладны по ресурсам, но тоже могут занять несколько миллисекунд.
* Дилемма работы с экспериментами: либо создание унифицированного шаблона кварг-билдера с его реализацией в самих потребителях (inapp-communications, blender), либо создание общего списка консьюмеров прямо в библиотеке. Ни один из вариантов не выглядит универсальным и оптимальным решением.

Минусы, возникающие, если оставить функционал (\*) в inapp-communications:
* YQL-able шорткаты придётся строить в одном месте (inapp-communications), а non-YQL-able - в другом (blender).

### Оценка реализации
1. Создание библиотеки и вынос логики хранения, наливки и обновления кеша - 2d
2. Вынос логики YQL-substitution, танкера и построения attributed text - 3d
3. Разработка нового API ручки /4.0/inapp-communications/shortcuts и подключение библиотеки в blender'е - 2d
4. Переезд со старой логики на новую - 2d
5. (*) Вынос логики матчинга экспериментов - 3d

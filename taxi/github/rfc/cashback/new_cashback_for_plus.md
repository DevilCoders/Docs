todo:
paymentstatuses отображение долга в UI

## Про зависимость от прайсинга
Расчет по новому прайсингу. У нас все реализовано на метадате от прайсинга, так что юзеры, не попавшие в новый прайсинг, не получает кешбек за Плюс. И мы по эксперименту кешбека не грузим price modifier.
То есть:
- попал в эксперимент кешбека и в прайсинг - кешбек
- попал в эксперимент кешбека но не в прайсинг - ничего, едешь по полной стоимости
- не попал в эксперимент кешбека, прайсинг неважно - скидка 10%

## Все переделываем
Если коротко - мы не можем включать стоимость услуги кешбека в order.cost потому что это стоимость перевозки парком пассажира. И эту трактовку изменить нельзя, так как она очень много куда проросла. Например, в DWH и по order.cost строится финансовая отчетность и если мы вставим в нее кешбек, она искусственно вырастет на 10% и аудиту это очень не понравится. Патчить репликацию в DWH это неприемлемый чит.

## Новый план
**Есть несколько вариантов, как это сделать в новом прайсинге. Мы выбрали вариант 3, Иоанн ок. Все варианты в new_cashback_for_plus_pricing.md**

### Концепция
Делаем второе флоу стоимости в заказе - стоимости услуги кешбека. Она так же считается в прайсинге, так же считается фикса и пишется в оффер, так же на случай сброса фиксы есть тариф(в роли тарифа выступает коэффициент), так же в конце формируется отдельный cost, и на его основании - отдельное поле в payment_tech. И перед любым отображением пользователю две стоимости нужно суммировать.

### Пример
Пример сразу с учемтом платной подачи:
Поездка 1000 рублей + 500 рублей платная подача, 10% нужно выделить в отдельную услугу.

Ситуация получается такая:
- в routestats нужно показать цену 1500
- и по флоу заказа нужно протащить две пары: 900 + 100 и 1350 + 150, и выбрать нужную в зависимости от наличия ПП

Считаем цену поездки 900, цену ПП 450, отдельно пишем два варианта цены услуги 100 и 150.
В routestats, totw и orderhistory нужно сложить все составляющие для отображения пользователю - он должен видеть общую стоимость поездки.

### Условия
- не даем ни кешбека ни скидки, если:
  - есть композитная оплата, то есть юзер тратит кешбек. Лично мне не очень понятно, но эта концепция уже принята и окнута.
  - если оплата наличными. Мы никакими трюками не сможем сделать отдельную услугу при оплате наличными. Геша явно вслух сказал, что они это бизнесово обсудили и ок. Поэтому весь флоу только про безнал.
  - если есть купон. Прайсинг не смог полностью их поддержать из-за сильной размазанности логики купонов по коду. Если мы еще кешбек навесим, им будет еще сложнее. Ну а нам будет сложно продумать и реализовать, как это будет работать. Геша ок, по крайней мере на первое время точно. Когда прайсинг потом полностью поддержит купоны можно будет убрать.

### Прайсинг
Так как на композитную оплату кешбек начисляться не будет, объединять преобразования смысла не вижу. Фактически, преобразования буду взаимоисключающими, поэтому их порядок друг относительно друга неважен. Но относительно остальных преобразований они должны быть в конце, чтобы в ride.price была уже окончательная стоимость поездки для пользователя: со скидками купонами итд.
В преобразовании про Плюс:
- Уменьшаем цену юзера и водителя до 900 - для основной цены
- Уменьшаем цену юзера и водителя до 1350 - для цены с ПП
- Эмиттим в основной цене мету cashback_fixed_price 100, в цене с ПП - 150. "фикса кешбека"
- Эмиттим 0.(1) коэффициент для расчета кешбека при таксометре - cashback_calc_coeff, "тариф кешбека"
- Эмиттим 0.9 коэффициент для цены за поездку, передаем его в сеткар - cashback_tariff_multiplier

И нам придется отделить преобразование со скидкой за Плюс от преобразование с кешбеком за Плюс. Потому что скидка за Плюс должна идти до купона, а кешбек за Плюс - после.

**Tasks**
Написать преобразование - 0.5d.

### Данные от прайсинга в итоге
- yaplus_coeff = 0.9. Это модификатор, который применится и на стоимость пассажира и на стоимость водителя.
- ride.price = 900. Это стоимость пассажира на стоимость водителя в рублях.
- мета cashback_fixed_price = 100(150 с ПП). Это посчитанная стоимость услуги кешбека в рублях.
- мета cashback_calc_coeff = 0.(1). Это 100/900, коэффициент кешбека. 
- paid_supply = 450. На самом деле в явном виде ее не будет, будет вычислена как 1350-900.

### Почему cashback_calc_coeff 0.(1), а не 0.1
У нас есть рассчитанная стоимость заказа: 1000 рублей. Рейт начисления кешбека - 10%.
То есть, мы делим 1000 на 900 за перевозку и 100 за кешбек. В полях заказа будет ехать 900 и множитель 0.9, и этот же множитель 0.9 попадет в сеткар.
Представим, что произошел сброс на Таксометр. Таксометр насчитал 2000, наложил множитель 0.9 и прислал в order.cost 1800. Чтобы для 1800 посчитать корректный кешбек в 200, нам нужен коэффициент 0.(1), не 0.1.

### routestats
- В коде,который формирует цену, которая станет зачеркнутой `result.main.value = price + paid_supply_price.value_or(0);` прибавляем еще мету cashback_fixed_price из цены с ПП. Получится 900 + (1350 - 900) + 150 = 1500.
- Брендинг кешбека научить показывать готовое значение кешбека, причем с учетом того, что отдельно может придти старый кешбек на скидках.

Отдельные моменты:
- По идее для отсутствия точки Б ничего не меняется, только в оффер фиксу мы не запишем, так что этот кейс заработает сам по себе.

**Tasks**
- Починить, чтобы прайсинг брал меты из цены с ПП - tbd, прайсинг сам оценит и сделает. А может, это уже правильно работает и делать не придется.
- После этого проверить, что display_price правильный. Это про композитку, но раз уж продумали. Можно тесты дописать. 1d.
- Научиться прибавлять cashback_fixed_price. С хорошими тестами. 3d.
- Брендинг кешбека научить показывать готовое значение кешбека, причем с учетом того, что отдельно может придти старый кешбек на скидках. 3d.

### оффер
Ничего дополнительного в оффер не пишем, все наши переменные поедут в `pricing_data.user.meta`

### мультикласс
Ничего делать не нужно: мультикласс уже умеет работать с pricing_data

### ordercommit
pricing_data переложится сам. Даже для заказов без точки Б прайсинг отработает(уже в ПРе этот код) и в ордерпроке в pricing_data появятся нужные нам меты
Нужно только флажок is_cashback на основе очередной новой меты сделать. Может, уже конфиг сделать?)

**Tasks**
- Флажок is_cashback на основе меты cashbak_price и cashback_calc_coeff. 0.5d.

### setcar
Таксометр не должен ничего знать о кешбеке. Для него это обычный заказ по Плюсу - то есть нужно сделать мультипликатор 0.9 на основе yaplus_coeff. Сейчас мы сделали 0.9 только для водителя.
В качестве фиксы в сеткар уйдет 900(1350)

**Tasks**
- Собственно сделать мультипликатор. 1d.

yaplus_coeff есть ли

### totw
- При отображении стоимости суммировать стоимость поездки и стоимость кешбека. Это может быть
	- fixed_price.price + meta.cashback_fixed_price для поездки по фиксе в процессе поездки.
    - Мету достаем из additional_prices с ПП, если ПП есть и из основных цен, если ПП нет.
    - И считаем цена + ПП + нужная cashback_fixed_price. 900 + 0 + 100 = 1000, если нет ПП и 900 + 450 + 150 = 1500, если есть.
	- cost + cashback_cost для последнего totw после завершения заказа
	- но для поездки без точки Б нужно просто показать минималку по тарифу: не нужно умножать ни на 0.9 скидки по Плюсу, ни домножать на 1.(1) для прибавления стоимости услуги кешбека
- В принципе, у нас будет и мета display_price. Она правда используется еще композиткой, если для этого сценария будет ок показывать только ту часть, что будет оплачена картой, то можно для первого пункта показать просто display_price.
- При платной отмене тоже пишется cost. Думаю, в этом месте кешбек никому не нужен, поэтому просто пишем в cost что насчитали. Если минималка 200 - не делать 180+20, а делать просто cost 200 и все.
- По кешу не нужно делать ничего, даже если есть cashback_fixed_price и cashback_cost, прибавлять их не надо.
- Делаем только в протокольном totw. Патчить поля с ценами заказа через api-proxy сейчас будет довольно сложно и нет смысла: order-core сейчас сработает только на 5 человек или если протокол упадет.

**Tasks**
- Научиться прибавлять cashback_fixed_price и cashback_cost - в backend-cpp. 4d.

### requestconfirm
- для фиксы переложить стоимость кешбека из meta.cashback_fixed_price в cashback_cost. 
  - в обычный cost нынешним флоу будет записано 900(1350) 
  - Мету достаем из additional_prices с ПП, если ПП есть и из основных цен, если ПП нет.
- для таксометра, установки цены диспетчером итд нужно взять стоимость заказа и умножить на meta.cashback_calc_coeff. И записать в cashback_cost.
- пункты выше нужно делать только если заказ завершается по безналу. Если по кешу - не нужно делать ничего. То есть сброс на кеш сработает сам по себе - стоимость кешбека просто отвалится
- мой код с правкой цены, если заказ был сброшен на кеш, нужно удалить. Этот трюк был для сценария, где у нас цена юзера выше, теперь это не так.

**Tasks**
- Грохнуть мой код про сброс на кеш. 0.5d.
- Научиться перекладывать для фиксы cashback_fixed_price в cashback_cost - 2d.
- Научиться считать cashback_cost на основе cashback_calc_coeff и cost - 3d.

ожидание - с фиксой не попадет на кешбек, а с таксометром - попадет. Мб посинится с прайсингом в таксометром.

### Что будет в order_proc в итоге
- fixed_price.price = 900 - фикса пассажира за поездку
- fixed_price.driver_price = 900 - фикса водителя за поездку
- paid_supply = 450 - цена ПП
- мета cashback_fixed_price = 100 - фикса за услугу кешбека
- мета additional_price.cashback_fixed_price = 150 - фикса за услугу кешбека для заказа с ПП
- мета cashback_calc_coeff = 0.(1) - коэффициент кешбека
- cost = 900(1350) - итоговая стоимость поездка для пассажира
- driver_cost = 900(1350) - итоговая стоимость поездка для пассажира
- cashback_cost = 100(150) - итоговая стоимость поездки для водителя

### update_transactions
Обсудили с Ваней, получается примерно так
update_transactions + transactions работают так:
 - антифрод/завершение заказа/сапорт меняют order.payment_tech.sum_to_pay
 - update_transactions дергает invoice/create или invoice/update и передает данные из payment_tech в transactions
 - transactions делает свой инвойс со своим payment_tech, создает billing_tech.transactions и следит за соответствием сумм транзакций инвойсу

В этих условиях как лучше организовать оплату кешбека
 - order.payment_tech можно вообще не трогать. В invoice/update можно отправить сразу cashback_cost, нам не нужна дополнительная прослойка
 - нужно где-то хранить параметры оператора, вероятно в конфиге - billing_client_id, нужные ИНН для чека, название услуги. update_transactions будет брать эти данные и слать в инвойс. Этим же конфигом может пользоваться сервис биллинга, который грузит данные в тлог.
 - вероятно, в tlog будет две папки, одна для оператора кешбека, одна для OEBS

Какие остались вопросы:
- явно будут транзакции, где списывается только стоимость кешбека. Если такая транзакция зафейлится, нормально ли вешать долг на заказ? Или для транзакций, содержащих только услугу кешбека, нужно делать какую-то свою логику? Если придется, то это в py2. Ответ - не не придется, если не получается оплатить услугу, вешаем долг.
- нужно ли как-то думать об НДС на эту услугу? Пока обсуждается этот вопрос.

**Tasks**
- Если мы в инвойс отправлять будем сразу cashback_cost, то нам делать ничего не нужно. Но задачку заведем на всякий случай. 3d.
- Работы в update_transactions правильнее делать биллингу.

### antifraud
Как будет с кешбеком
 - вся сумма в начале - спишем 900 и 100, две транзакции, два чека
 - вся сумма в конце - одна транзакция, один чек с двумя позициями
 - кусочные списания - спишем 1+ частей в процессе поездки, остаток спишем в конце. Вместе с остатком спишем за услугу кешбека. То есть один чек с одной позицией за поездку, и второй чек с двумя позициями.

Нужно доработать: как минимум научиться в начале списывать все, а возможно и в кусочные списания встроить кешбек.

**Tasks** 
- списывать вместе с фиксой и кешбек. tbd, не факт, что нам делать
- встроить кешбек в кусочные списания. tbd, не факт, что нам делать

### debts-processing
Сумму долга сервис debts получает из invoice/retrieve. И там будет информация о долге по кешбеку, но в отдельном поле. И нам нужно научиться учитывать долг по кешбеку.
Достаточно ли будет просто научиться видеть этот долг или нужно будет делать что-то еще - нужно будет разобраться в процессе.

И в целом нужно проверить явно, что будет с заказом, у которого долг только по кешбеку. Потому что пока непонятно, как отработает связка debts-processing + update_transactions.

**Tasks**
- в `_extract_unpaid_value` научиться забирать значение из поля `cashback`, не только `ride`

### сервис кешбека - начисление
Логика для кешбека отдельной услугой должна отличаться от логики кешбека на скидках: теперь в инвойсах от transactions будет прямая сумма, которая уходит как оплата услуги кешбека и ровно эту сумму нужно начислить. То есть хранить рейт и самим умножать на стоимость заказа не нужно.
Нужно научиться эту сумму из инвойсов забирать и собственно начислять.

Мб начислять сразу из транзакции? Сервис кешбека не при делах.

**Tasks**
По задачам лучше Дане Коноваленко расписать. И есть зависимость от решения по update_transactions.
Даня оценивает примерно 5d.

### сервис кешбека - rates_processing
Для этого кейса сервис рейтом владеть не будет. Нужно быть только готовым к тому, что в ордере флаг is_cashback будет, а рейт никакой выпускать не надо. 

**Tasks**
- Поправить на кейс кешбека без рейтов. 1d.

### orderhistory
Работает на payment_tech.user_to_pay. Нужно суммировать стоимость поездки и стоимость кешбека из payment_tech
Нужно будет еще посмотреть на инфу об ожидании: мб ее нужно будет домножить, но вряд ли.

**Tasks**
- Собственно правильно отображать. 3d. Тоже есть зависимость от решения по update_transactions.

### Отчеты на почту
Отчеты берут стоимость из user_to_pay, складывают ride и tips. То есть 100 рублей списания за услугу кешбека в отчет не попадут никак.
Нужно, чтоб попадало.

**Tasks**
- Учесть кешбек в сумме в отчете. 1d.

## DWH
Обсудили, то, что в полях заказа типа order.cost будет только часть, которая уйдет парку, то есть 900 - это ок.
Поля, которые интересуют DWH:
$tariff_cost - есть order.tariff_cost от Таксометра, есть не в каждом заказе - 900
$tariff_cost - и есть order.billing.real_cost от нашего биллинга - 900
$cost_for_commission - вероятно order.billing.cfc от нашего биллинга - 900
$user_cost_w_vat - order.payment_tech.user_to_pay.ride - 900
$user_cost_wo_vat - order.payment_tech.without_vat_to_pay.ride - 900
$order_cost_w_discount - order.cost - 900(кстати, тут же не вычтен купон еще, вас это не смущает?)

И в тлоге будет отдельная запись про услугу кешбека на 100 рублей.

### сапорты
Сапорты могут менять стоимость заказа напрямую плюс они акцептят цену диспетчера и если стоимость заказа больше 5000. Причем, ЕМНИП, акцепт это запись disp_cost в cost, то есть фактически изменение стоимости заказа.
- при изменении цены сапортом - пересчитать cashback_cost
- Надо чтоб сапорты знали про отдельную услугу кешбека и могли изменить ее стоимость. Для сапортов не нужно объединять цены. Нужно, чтобы они имели контроль на ситуацией для конкретного пользователя.
- Нет, нельзя чтоб меняли, потому что мы им не владеем. Но нужно тогда пересчитать стоимость кешбека, если сапорт изменит стоимость.
Отображение кешбека сделаем, но не сразу.
Тут мне наверное нужен Костя, помочь обдумать.

**Tasks**
- при изменении цены сапортом - пересчитать cashback_cost. Продумать возможные корнеркейсы. 2d.
- tbd, но кажется, тут еще довольно много.

### Тестирование
Нам нужно будет тестирование, потому что вариантов много.
Юра говорит, что наши сапорты бек тестировать не умеют, надо подумать отдельно.

Придется самим

**Tasks**
- Оформить тест кейсы. 1d.
- Придумать, как их провести. Самим или testsuite. 4d.

### Оценки итого
MVP
- основное флоу заказа 19d +
- сервис кешбека 5d +
- проект биллинга не мы
29d + биллинг

Сразу после MVP
- правки прайсинга не мы +
- правки в админке для саппортов tbd +
- тесты 5d

### Отдельные детали
- Альтпины и антисурж должны взлететь по идее сами по себе: при выборе альтернативы она станет основной и мы автоматом достанем нужную мету.
- Может быть проблема с тем, что пассажир на таксометре видит 900, а платит 1000
- Антифрод мы не трогаем, поэтому обычная поездка по фиксе для новичка спишет в начале поездки 900 и после завершения еще 100. Это будет ресайзом транзакции, по идее, не новой, но все-таки отдельно.

Набросок преобразования, так как пока мы не определились с окончательным вариантом
```
let display_price = -1;
if(fix.payment_type as payment_type) {
  let corp_type = payment_type == "corp";
  let wallet_type = payment_type == "personal_wallet";
  let corp_acc_type = payment_type == "coop_account";
  let good_type = !corp_type && !wallet_type && !corp_acc_type;
  if (fix.user_data.has_yaplus && good_type) {
    if (fix.category_data.yaplus_coeff as yaplus_coeff) {
      if (fix.experiments as exp && "cashback_for_plus" in exp) {
          // no cashback for cash
          if (payment_type == "cash") {
                //you get nothing, even discount
            } else {
              // save unsplitted yet ride.price as display price
              display_price = ride.price;
              
              let cashback_rate = 1 - yaplus_coeff;
              let cashback_fixed_price = ride.price * cashback_rate;
              let ride.price = ride.price - cashback_fixed_price;
              let cashback_calc_coeff = cashback_fixed_price/ride_price;
              emit("cashback_fixed_price", cashback_fixed_price);
              emit("cashback_calc_coeff", cashback_calc_coeff);
          }
        } else {
            ride.price = ride.price * yaplus_coeff;
        }
    }
  }
}

if (fix.complements as complements) {
  if (complements.personal_wallet as personal_wallet) {
    let base_price = (display_price != -1 ? display_price : ride.price)
    display_price = (base_price > personal_wallet.balance)
        ? (base_price - personal_wallet.balance)
        : 0;
    
    let display_min_price = (fix.tariff.minimum_price > personal_wallet.balance)
        ? (fix.tariff.minimum_price - personal_wallet.balance)
        : 0;
    emit("display_min_price", display_min_price);
  }
}
if (display_price != -1) {
  emit("display_price", display_price);
}
```

## Тест кейсы
### Кейсы со скидкой
У юзера есть скидка 20% и Плюс. Поездка 1000 рублей.
Что будет со старым Плюсом:
Цена водителя будет 900, цена юзера будет 720. В конце мы сделаем транзакцию в пользу Такси на 720. Водитель получит 720 и компенсацию 180. м
Что будет с новым Плюсом:
Прайсинг насчитает 1000 стоимость водителя, 800 стоимость пассажира. Последнее преобразование Плюса сделает 900 стоимость водителя, 720 стоимость пассажира, 80 стоимость услуги кешбека. В конце мы сделаем транзакцию на 720 в пользу Такси и на 80 в пользу оператора кешбека. Водитель получит 720 и 180 компенсацию. Итого 900 и все ок.

### Кейсы с купоном
Купон прайсинг уже учел в ride.price и в routestats ApplyCoupon в этом случае не сработает.
Но на min_price отработает, поэтому нужно проверить, что при поездке без точки Б и купоном в routestats все нормально покажется.
А вот дальше routestats, особенно в requestconfirm, может сломаться. Так что надеемся, что купоны делать не будем.
Убедиться, что не будет артефактов от того, что мета `price_before_coupon` будет выпущена до нашего разделения цены на поездку и услугу кешбека, то есть будет 1000 в нашем примере.

### increased_price_params
Проверить, что не будет артефактов

### Проверить, что с антифродом все нормально пройдет
Что 900 сразу и 100 в конце поездки будут нормально выглядеть для юзера.

### Долги
Проверить явно, что будет с заказом, у которого долг только по кешбеку.

## Задачи, если оставить как есть
- тотв для кейса сброса на кеш
- патч цены при установке диспетчером или водителем
- патч цены при установке саппортом
- правки компенсаций биллинга для кейса сочетания со скидками

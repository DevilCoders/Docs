**Название сервиса**

Cashback Levels (Уровни кешбека)

**Какую продуктовую проблему решает сервис?**


*Что хотим*
1) В зависимости от накопленных баллов за месяц проставлять пользователю уровень кэшбэка
2) Уровень кэшбэка влияет на размер скидки, которую получает пользователь в различных сервисах (например: в лавке обычный пользователь получает 1%, а пользователь с кэшбэком 2го уровня 5%)
3) Раз в месяц пользователь получает обновление уровня 


*Зачем уровни*
1) Лочить самых ценных пользователей внутри яндекса на больший период
2) Создать программу лояльности, чтобы можно было запустить кошелек


*Кто будет использовать*
1) Приложения яндекса: такси, еда, лавка, ппя и тд
2) Морда
3) Сайты Афиши, Кинопоиска и тд


**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Сейчас этот код находится в сервисе plus, хочется вынести его в отдельный сервис, текущие сервисы связанные с кешбеком написаны на py3 и не могут выдержать нагрузку, которая может быть послана на сервис

**Как именно сервис будет решать поставленные перед ним задачи?**

Первого числа каждого месяца будет запускаться пересчет уровня, уровень будет расчитываться на основе транзакций за прошлый месяц, в учет идут только заказы, за которые был получен кешбек, рефанды кешбека не должны учитываться. Расчитванный уровень будет записываться в сервис тегов по yandex_uid, этот тег смогут вычитывать все потребители сервиса тегов (discounts, driver-scoring и тд). Так же в сервис будет отдельная ручка для получения уровня

[Ссылка на тикет с продуктовым описанием](https://st.yandex-team.ru/TAXIBACKEND-28803).

**Разрабатывается один сервис или система?**

Сервис

**Сколько и какие сервисы входят в систему?**

1

**С кем взаимодействует сервис?**

Сервис ходит в:
* personal-wallet, без ретраев, в случае недоступности сервиса stq таска отложится на более поздний период по алгоритму exponential backoff
* tags, аналогично personal-wallet

**Какие базы использует?**

Postgresql

**Какие периодические процессы?**

Периодическая таска запускающая пересчет уровня пользователя 

**Прикрепите схему того, где этот сервис находится в текущей инфраструктуре**

1. Как технически проект влияет на цикл заказа.
2. Кто будет потребителями сервиса.

**Какие данные и по какой схеме сервис будет хранить в базе?**

CREATE TABLE IF NOT EXISTS plus.cashback_levels
(
  yandex_uid             TEXT           NOT NULL,
  cashback_amount        DECIMAL(15, 4) NOT NULL,
  level                  INTEGER        NOT NULL,
  created                TIMESTAMPTZ    NOT NULL DEFAULT NOW(),
  updated                TIMESTAMPTZ    NOT NULL DEFAULT NOW(),
  last_calculated        TIMESTAMPTZ    NULL,
  PRIMARY KEY (yandex_uid)
);

CREATE INDEX last_calculated ON plus.cashback_levels (last_calculated);

**Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

не более 30 млн записей (не более гигабайта)

**Какие операции над данными заложены?**

* Добавление уровня пользователя
* Чтение
* Обновление накопленного кешбека
* Пересчет уровня

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

нет


**Какая нагрузка ожидается?**

Ожидается нагрузка 500+ RPS на ручку `/v1/cashback/level`

**Какие фолбеки предусмотрены на сам этот сервис?**

-

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

При недоступности любого из сервисов уровень пользователя не будет обновлен,

**Какие возможности масштабируемости закладываются?**

горизонтальные

**Какие точки отказа есть в сервисе?**

база

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

Распределение уровней пользователей

**Укажите технические метрики**

стандартные метрики: 
* core-files
* 500
* stq-fail

**Какая функциональность ожидается в сервисе в будущем?**

Этапы разработки:

1. MVP: заглушки на сервере для быстрого тестирования клиентов -  3д
  * либо обоснование почему заглушки не нужны.
2. Показ заказов в заново открытом приложении - 10д
  * Подзадача 1, без нее нельзя запускаться так как X - 3д
  * Подзадача 2, без нее нельзя запускаться так как Y - 2д
  * Интеграция с клиентами - 5д
3. Показ заказов всегда - пушим их юзеру - 6д
  * Подзадача 1 - 3д
  * Подзадача 2 - 3д
4. Подчистка техдолга - 7д
  * Подзадача 1 - 3д
  * Подзадача 2 - 4д

**Какое изменение нагрузки планируется?**

...

**Активно ли будет изменяться сервис?**

нет


### Как раскатываем

Раскатка будет зависеть от уровня раскатки кешбека:
* Технический запуск на команду
* Запуск на яндекс
* Постепенное наращивание процента

При необходимости каждый из компонентов расчета можно отключить по отдельности


# Бизнесовая задача

## Продуктовое описание

После первого заказа с кешбеком будет расчитан уровень пользователя в соотвествии с количеством заработанного кешбека за последний месяц.

Первого числа каждого месяца будет пересчитываться уровень пользователя, если пользователь за опредленный период не набрал достаточный уровень кешбека, то его уровень сбрасывается

Пользователь попадает в систему как 0-й уровень, который не имеет никаких привилегий в сервисе. По мере получения кешбека его уровень растет (считается не текущий баланс пользователя, а количество прироста кешбека за заданный период времени). 

Точкой отсчета (время попадания в базу) решили брать время получения первого кешбека, первого числа каждого месяца будет выполняться пересчет уровня в зависимости от истории транзакции пользователя за последний месяц.

Привилегиями от уровня могут пользователя все пользователи, в не зависимости есть ли у них плюсовая подписка или нет.

Каждый месяц при перерасчете уровня у пользователя высчитывается реальный уровень (т.е. фактически можно за первый месяц перепрыгнуть сразу на последний уровень лояльности, а не по +1 каждый месяц)

Уровень лояльности будет единый для всех сервисов яндекса

## Зачем это надо

1) Лочить самых ценных пользователей внутри яндекса на больший период
2) Создать программу лояльности, чтобы можно было запустить кошелек

## Дизайн

По словам Геши это будет "`В меню плбса будем и в шорткатах наверное`"

# Архитектура

## База данных

```
CREATE TABLE cashback.loyal_levels
(
  yandex_uid             TEXT           NOT NULL,
  cashback_amount        DECIMAL(15, 4) NOT NULL,
  level                  INTEGER        NOT NULL,
  created                TIMESTAMPTZ    NOT NULL DEFAULT NOW(),
  updated                TIMESTAMPTZ    NOT NULL DEFAULT NOW(),
  last_calculated        TIMESTAMPTZ    NULL,
  PRIMARY KEY (yandex_uid)
);
```

Ожидаемое количество записей в базе - 30 млн (верхняя планка)

Немного пояснений по полям:
* cashback_amount - количество кешбека, который заработал пользователь за расчетный период уровня


## Основной флоу

* Пользователь совершает свою первую покупку за которую получаешь кешбек 
* Из billing-wallet делается коллбек в очередь `process_balance_change`
* Внутри таски происходит поход за историей кошелька в сервис billing-wallet, на основании этой истории расчитывается полученный кешбек пользователем за этот месяц, который записывается в поле cashback_amount
* Раз в Х минут, запускается крон таска, которая идет в таблицу `loyal_levels` и вытаскивает оттуда 1к записей (управляется конфигом), у которых last_calculated=NULL или last_calculated < floor<month>(NOW()) (текущая дата округленная до первого числа месяца)
* Для каждой такой записи запускается отдельная stq таска `loyality_calculation`, с аргументом yandex_uid, task_id = yandex_uid
* Внутри таски, выполняеся поход в сервис `billing-wallet` за списком кошельков пользователя (ручка /search), вытаскиваются рублевые кошельки и по ним получается история из сервиса `billing-wallet` (ручка /statement) за последний месяц
* Внутри таски суммируются все пополнения кешбека и по конфигу определяется уровень пользователя, который апдейтится в таблице


## Правила расчета уровня

* Нужно агрегировать кешбек полученный за заказ (на случай различных рефандов, и тд)
* Игнорировать транзакции на трату кешбека
* При переливке баланса с одного аккаунта на другой *не* учитывать транзакции по переливке баланса (при привязке фониша к порталу)

### Пример расчета

Допустим имеем следующую историю для фониша:
1) Получен кешбек за заказ Х +100 рублей
2) Рефанд кешбека за заказ Х -10 рублей
3) Трата кешбека в заказе Y -20 рублей
4) Рефанд кешбека по заказу Y +5 рублей
5) Привязка к порталу (-75 рублей)
6) Получен кешбек за заказ Z +40 рублей

(100-10) + 40 = 130  рублей - итоговый кешбек фониша

Допустим конфиг уровней выглядит следующим образом (слева уровень, справа необходимый баланс):
```
levels: [
  {
    "type": "bronze",
    "value": 1,
    "conditions": {
      "cashback_amount": 5
    }
  },
  {
    "type": "silver",
    "value": 2,
    "conditions": {
      "cashback_amount": 20
    }
  },
  {
    "type": "gold"
    "value": 3,
    "conditions": {
      "cashback_amount": 60
    }
  }
]
```

тогда итоговый уровень лояльности пользователя будет 3, так как 130 > 60

## Миграция уровня

Для ситуаций, когда пользователь хочет привязать свой аккаунт к порталу, необходимо не терять его уровень, для этого будет реализованна stq таска `cashback_level_transfer`, которая при привязке фониша к порталу из сервиса uid-notify будет ставить эту таску.

Алгоритм работы таски:
* Удостовериться, что надо обрабатывать миграцию: проверить конфиг на отключение миграции и что дата миграции была в этом месяце
* Вытащить из базы уровень портала и фониша
* Если портала нет в базе, то создать дефолтный
* Вычислить новый уровень портала как max(портальный уровень, фонишный уровень), новый уровень фониша вычисляется как самый высокий уровень без требований
* Обновить через транзакцию уровень портала и фониша
* Проставить новые теги фонишу и порталу 




## Ручка получения уровня пользователя

Ручка, которая будет отдаваться во внутрении сервисы яндекса для получения уровня пользователя

Принимает на вход: yandex_uid и сервис

Внутри идет в таблицу `cashback_levels` и формирует ответ на основе таблицы, если записи нет, то возвращается 0-й уровень пользователя


Пример ответа:
```
{
    "level": "silver",
    "last_calculated": "2020-01-28T12:08:48.372+03:00",
    "cashback_amount": "200",
    "next_level_cashback": "1000",
}
```


## Как всем обновлять уровень в начале месяца

* у нас будет от биллинга колбек при изменении баланса кошелька (https://st.yandex-team.ru/TAXIBILLING-3192)
* этот колбек будет вызывать stq таску, которая будет пересчитывать полученный кешбек за этот месяц и записывать в базу (но не обновлять уровень пользователя), таким образом в базе у нас теоретически будет более менее лежать правдивый полученный кешбек за месяц
* когда кто-то будет ходить в ручку получения уровня пользователя, мы будем вытаскивать из базы кешбек пользователя, его текущий уровень, дату последнего пересчета уровня, если месяц даты последнего пересчета совпадает с текущим, то будет возвращать уровень который записан в базе, если нет, то брать сумму кешбека мапить ее через конфиг в уровень и возвращать его, сумма расчитанного кешбека за этот месяц пока не будет возвращаться


ну а тем временем, первого числа каждого месяца у нас будет запускаться какая-нибудь периодическая таска, которая для всех юзеров будет апдейтить уровень в базе

какие могут быть проблемы: stq таска, которая будет вызываться из коллбека биллинга должна осторожно считать кешбек, т.е. в случае, когда последний пересчет уровня был в последнем месяце, то она не должна записывать новую сумму кешбека в базу до тех пор пока группа не будет пересчитана

## Коллбек из биллинга

* Биллинг будет ставить stq задачу в нашу очередь, в которой будет передавать yandex_uid, wallet_id
* С этим yandex_uid необходимо сходить в ручку `/search` сервиса billing-wallet и отфильтровать оттуда только рублевые кошельки
* Далее со всеми рублевыми кошельками сходить за историей изменения баланса за текущий месяц в ручку `/statement`
* Сделать агрегацию суммы по order_id 
* Если сумма отрицательная и это не перевод баланса с кошелька на кошелек, то необходимо игнорировать сумму
* иначе прибавить к переменной-аккумулятору
* Создать запись в таблице `cashback_levels`, если запись уже есть, то обновить только поле-аккумулятор cashback_amount


## Почему агрегируем на стороне сервиса, а не на стороне биллинга

* billing-wallet ничего не знает про рефанты, была идея в ручке charge (personal-wallet) делать распоряжение в orders, чтобы зачислять начисленный кешбек на отдельный счет-агрегат, но это решение ломается о тот факт, что кешбек может быть начислен через ручку траста о чем мы не узнаем 
* плюс, чтобы поддержать миграцию аккаунта, надо делать отдельное платежное поручение, которое надо создавать в очереди миграции personal-wallet 
* есть еще некоторая продуктовая логика при расчете заработанного кешбека: когда происходит миграция фониша на портал, надо учитывать это в заработанном кешбеке (у фониша это надо вычитать, а у портала прибавлять)

вобщем как итог для правильного расчета заработанного кешбека нужно вытаскивать историю из биллинга и агрегировать ее по заказам, что можно сделать внутри своего сервиса

## Коллбек из медиасервисов (для кейса плавающего окна расчета, пока не будет реализовываться)

TBD

Из некоторого источника (логброкер или коллбек, пока обсуждается) в сервис будет приходить событие что пользователь оплатил плюсовую подписку, после этого будет ставится stq таска. Таска должна в таблице `loyal_levels` поставить дату последнего расчета уровня равную дате покупки подписки (если нет флага has_plus), если есть флаг has_plus, то ничего не делать


## Крон для очистки базы

В такси очень много пользователей, которые очень редко пользуются яндекс такси, они захламляют базу, для оптимизации расчета рейтинга надо ее чистить


Немного чисел:
* За ноябрь и декабрь 2019 года 27_164_757 уникальных yandex_uid совершило как минимум одну поездку https://yql.yandex-team.ru/Operations/Xs_Bl2im9YmO7hcn0DebSJugPxTogdObzManTLwftLI=
* При этом 14_663_292 из этого числа совершило хотябы одну поездку в ноябре и декабре https://yql.yandex-team.ru/Operations/Xs-5YJdg8uFF53uJbXNrV0lkminRWQngrirHmsH6blI=


Предлагаемая оптимизация: удалять пользователей из базы, кешбек, которых за прошлый месяц составил 0


## Кешбек за уровень и влияние на диспатч водителя

В зависимости от уровня пользователя нам хочется предоставлять ему более интересные предложения:
* Повышенный кешбек 
* Диспатч особых водителей: с более высоким рейтингом и с более высоким доступным тарифом (к примеру на заказ эконома преподчитать водителя, у которого доступен комфорт, это не механика апгрейда класса). Правила диспатча будут храниться на стороне эффективности, с нашей стороны необходимо передать просто уровень пользователя


### Повышенный кешбек 

Для выдачи специальных кешбечных скидок, надо в сервис скидок прокидывать уровень пользователя (в ручки /v1/calculate-discount и /v1/peek-discount), за существующими скидками надо ходить в следующих местах:
* routestats
* ordercommit

Предлагается добавить новый опциональный параметр `cashback_level` в запросы ручек `/v1/calculate-discount` и `/v1/peek-discount`, который будет браться из ответа ручки `/v1/cashback/level` сервиса plus.
Таким образом в routestats и ordercommit добавится новый поход в сервис plus (необходимо согласовать с protocol-guards)

### Прокидывание уровня пользователя в диспатч

Необходимо как-то прокидывать информацию о пользователе для диспатча, возможные варианты:
* Прокидывать в acquire_candidate, yandex_uid, и получать 3-5к RPS на ручку уровня пользователя (1.2к RPS если сделать ручку балковой)
* При создании заказа, в metadata-storage записывать уровень пользователя:
  - можно записывать в существующий неймспейс, но это можно делать только ((https://github.yandex-team.ru/taxi/backend-cpp/blob/9446aba0c4dd80fa0b4087ad7c631d1852513bf8/protocol/lib/src/orderkit/commit_state_handling.cpp#L560 тут)), это правка в коммите + нагрузка коммитом поход в сервис за получением уровня пользователя. 
  - писать в отдельный неймспейс, но надо решить с какого места (возможно делать коллбек из процессинга в stq очередь из которой записывать уровень пользователя, но могут быть гонки при таком подходе)

Если учесть тот факт, что в routestats и ordercommit нам нужно будет ходить за уровнем пользователя, чтобы получать персональные скидки, то правки можно сделать в ordercommit


### Использование сервиса тегов

Можно проставлять уровень не только в базе сервиса, но и через сервис тегов, по yandex_uid, но есть пару проблем:
* Есть быстрое решение, добавить новый entity в теги, сделать правки в диспатче и скидках, чтобы в теги ходить с yandex_uid, но этот вариант не очень нравится ребятам со стороны тегов, так как фича тегов в том, что можно затегать пользователя по одному тегу, например по yandex_uid, а получить тег этого пользователя по user_id
* Есть долгое решение, но правильное, им надо будет написать сервис склейки, где они будут все свои идентификаторы (user_id, personal_phone_id и тд) клеить к yandex_uid 

Пока обсуждается

## Продуктовые метрики

* Количество пользователей в разрезе по уровням

## Технические метрики

* stq fail
* core files
* 500
* etc

## Изменение нагрузки 

Подключение новых сервисов:
* Еда
* Лавка
* Афиша
* Кинопоиск


# Разработка

## MVP

Минимальное количество задач для базовой работоспособности сервиса:
* Крон таска отслеживания момента пересчета уровня (2d)
* Stq таска пересчета уровня пользователя (3d)
* Ручка уровня для внутренних сервисов яндекса (1d)
* Крон таска для очиски пользователей (1d)
* Крон таска для коолбека от биллинга (3d)

## Вводные
Мы делаем отдельную услугу кешбека. То есть в основных полях заказа едет стоимость за поездку, отдельно едет стоимость услуги кешбека, платятся они отдельно. Соединяются только перед показом юзеру, в частности в тотв.

В прайсинге есть понятие метаданных. Ты можешь изменить цену поездки и можешь заэмиттить отдельное значение meta_name:meta_value. Мы уменьшаем цену поездки с 1000 до 900 и эмиттим cashback_price:100.

## totw
Тотв показывает стоимость заказа юзеру и берет ее из нескольких источников:
1. для статуса complete - берет 'order.cost'.
2. для остальных статусов - если есть order_info.cc, берет ее. Это current cost, который постоянно шлет таксометр.
3. если нет, берет order.fixed_price
4. если нет, берет предварительный расчет из calc.allowed_tariffs

## Проблема
В тотве нужно показать общую стоимость заказа, то есть сложить стоимость поездки и стоимость услуги кешбека.

## Как можно сделать
### Вариант 1
В общих полях заказа типа `fixed_price`, `cost` хранить общую стоимость, и поездку и услугу. Это генерирует очень стремные артефакты при сбросах на кеш и необходимости убрать кешбек и при расчете компенсаций водителю, которые делает биллинг. От этой идеи мы отказались.

### Вариант 2
Сделать отдельную ручку в сервисе кешбека, в api-proxy проверять, кешбечный ли заказ, и если да, то идти в эту ручку. Повторить в ней логику из текущей totw и навесить сверху наш кешбек. Не нравится ни Илье ни Юре, поэтому тоже отказались.

### Вариант 3
Заводим в проке структуру `price_for_client` и пишем ее из разных мест. Храним в ней с одной стороны разбивку, с другой стороны - версию цены. Типа сначала первая версия расчетная. Потом мы стали показывать версию с такса. А в конце финальную. Это удобно и для показа, и для расследования того, что там пользователю показывалось. Цена - это важный параметр, хочется, чтобы он был зафиксирован.

1. Заводим в прайсинге мету `display_price_for_client`
2. Первую расчетную версию `order_proc.price_for_client` пишем в `ordercommit` на основе собственно меты `display_price_for_client`
3. Делаем в `order-core` ручку для добавления новой версии в структуру `order_proc.price_for_client`.
4. Учим таксометр с новым прайсингом в процессе поездки поллить не только current cost, но и меты.
5. Дергаем ручку в `order-core` из того места, которое будет принимать current cost и меты от таксометра. Сейчас это длинная схема через `core-engine`, REDIS и второй питон.
6. В `requestconfirm`, который пишет `order.cost`, пишем финальную версию `order_proc.price_for_client`
7. В тотве просто берем текущую версию `order_proc.price_for_client` и показываем
8. Пока нет таксометра с прайсингом, ставим во втором питоне костыль, которые посчитает и прибавит кешбек на основе current cost. Для кейса 2 здесь [totw](##totw)

Плюсы:
- история цены для юзера
- очень простой код в тотв  
Минусы:
- некрасивый костыль во втором питоне на сейчас
- тотв лишается логики выбора и формирования цены для показа, она уходит в места, где будут писать `order_proc.price_for_client`. То есть логика размажется по репозиториям.
- вряд ли сможем сходу заложить идеальную `order_proc.price_for_client`, ее будут менять и расширять

### Вариант 4
Вариант 3 по сути, только заводим не отдельное поле в `order_proc`, а учимся иметь историю `pricing_data`.

1. Заводим в прайсинге мету `display_price_for_client`
2. Учим таксометр с новым прайсингом в процессе поездки поллить не только current cost, а полную структуру расчета с разбивкой и метами.
3. Прайсинг учится хранить в проке(или не в проке) несколько состояний `pricing_data`: первую расчетную, промежуточные от таксометра и финальную от таксометра.
5. В `requestconfirm`, который пишет `order.cost`, пишем финальную версию `pricing_data`. В этом пока не уверен, возможно, лучше оставить `order.cost` как есть.
6. В тотве смотрим на наличие фиксы, на статус заказа, выбираем соответствующую `pricing_data` и берем ее `display_price_for_client`
7. Пока нет таксометра с прайсингом, ставим в самом тотве костыль, которые посчитает и прибавит кешбек на основе current cost. Для кейса 2 здесь [totw](##totw)

Плюсы:
- История не только цены для юзера, а всех расчетов по заказу.
- Прайсинг может сам решить, как и где им это удобнее хранить.
- Логика выбора цены для отображения остается в тотве. В одном месте, не размазывается.  
Минусы:
- Мы, кроме меты `display_price_for_client` в первоначальном расчете прайсинга для кейсов 3 и 4 здесь [totw](##totw) , не можем сейчас сделать ничего. Только надеяться, что когда-нибудь прайсинг до этого дойдет. А пока у нас будет костыль в тотве для кейсов 1 и 2.

### Выводы из вариантов
- Нам очевидно нужна какая-то нормальная история цен для показа юзеру и понятная структура их выбора. Нынешние костыли в totw, которые мы еще ухудшим своим кешбеком, нужно убирать.
- Нам нужен прайсинг на всем флоу заказа, не только тот, что мы посчитали один раз для оффера. Если у нас будет прайсинг одной и той же структуры на этапе оффера, в начале заказа, в процессе исполнения посчитанный на таксометре, финальный посчитанный на таксометре - можно будет сказать, что прайсинг действительно забрал всю логику с ценами себе. И можно будет любые проекты делать на прайсинге без необходимости ставить костыли.

## Решение
- Мы заводим в проке новою структуру вроде `current_prices` и будем держать в ней мапу с ценами для показа юзера. При создании заказа, получении нового current cost и завершении заказа мы будем обновлять состояние этой структуры. Totw и order-core будут просто брать значение из этой мапы.

- Коля обсудит с таксометром возможность получать от них trip_details в процессе выполнения заказа, аналогично тому, как сейчас приходит current cost.

- Команда моделей ценообразования подумает, как можно рассчитывать прайсинг на основании этих trip_details и часть результатов(итоговую цену, некоторые меты) сохранять в прок. В идеале, в ту мапу, что мы сделаем.

Итоговое светлое будущее: таксометр шлет trip_details раз в например 5 минут, некий сервис вызывает сервис прайсинга с этими trip_details, складывает часть рассчитанных результатов в прок. Историю этого поля мы сразу отправляем в YT, в проке храним только текущее состояние.

## Реализация решения с `current_prices`
### Структура
Мапа с параметрами. Храним только текущие значения, без истории.
```js
{
  "current_prices": {
  	"user_total_price": 100.0, // общая стоимость заказа для юзера. Сейчас поездка + кешбек. Если будет что-то еще, должно входить тоже. Ей может пользоваться антифрод.
  	"user_total_display_price": 100.0, // общая цена для показа юзеру. Ее мы будем отдавать в totw и order-fields. Специально разделяем переменную для антифрода и для отображения: задачи разные и значения могут оказаться разные
  	"cashback_price": 10.0, // Стоимость отдельной услуги кешбека. Пока не нужна, но может пригодиться.
  	"kind": "prediction"|"fixed"|"taximeter"|"final_cost" // детали ниже
  }
}
```
Про kind:
- `prediction` - цены из предварительного расчета, которые пишет `ordercommit`. Там будут значения из `order_proc.order.calc.allowed_tariffs`
- `fixed` - фикса. `order_proc.order-fixed_price`
- `taximeter` - цены, которые мы построим на основании current cost от таксометра. В будущем вместо current cost будет расчет прайсинга
- `final_cost` - финальная цена, на статусах `complete` и `cancelled`. Для кешбека сумма 'order.cost' и 'order.cashback_cost'

### Задачи
Писать в мапу:
- Добавить эмиттинг меты `display_price_for_client` в преобразовании про кешбек.
- В `ordercommit` писать первые версии цен. Или `fixed` или `prediction`. Теоретически может быть так, что цен не будет, судя по коду. Случается ли такое в реальности, непонятно. Пишем мету `display_price_for_client`, если она есть. Иначе просто пишем те цены, что есть.
- В backend-py2 при получении current cost от таксометра пересчитать мапу и обновить
- В requestconfirm после расчета cost и cashback_cost записать последнюю версию
- Протягивать мапу через сервис мультикласса: в `ordercommit` писать варианты по каждому классу, в backend-py2 - забирать нужный
- После назначения водителя проверять, если применилась платная подача, то обновить цены с учетом цены ПП
- При отмене тоже обновлять мапу с `"kind": "cost"`

Читать из мапы:
- в тотве делаем конфиг-рубильник. По нему идем или в мапу или по старому флоу. Если мапы нет, тоже фолбечимся на старый флоу: это позволит нам сейчас, например, не делать ее запись при отмене и просто показать ее стоимость по старому.  Нужно помнить, что цена в мапе будет уже с учетом купона, чтобы второй раз его не применить.
- в order-fields по тому же рубильнику берем цены из мапы вместо `order.cost`
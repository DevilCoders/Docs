# Контекст

 В рамках проекта [TAXIPROJECTS-1853](https://st.yandex-team.ru/TAXIPROJECTS-1853) мы делали новый экран поиска исполнителя на заказ: добавляли таймер и прогрессбар, предполагая, что это снизит уровень беспокойства пользователей, что в свою очередь приведет к снижению доли отмен на экране поиска заказа.

 В рамках того же проекта (и той же гипотезы) мы хотим улучшить UX: сделать плавную анимацию поиска и плавные переходы между экранами (саммари->поиск->драйвинг). Также ожидаем, что это увеличит completion rate. 

Выглядеть это должно как-то так:
![картинка](https://jing.yandex-team.ru/files/andreykostin/photo_2020-12-02_19-35-13.jpg)


# Задача
1. Реализовать плавный переход между:
- экраном саммари (водители поблизости);
- поиском (кандидаты на заказ);
- назначением (конкретный водитель из кандидатов);
2. Момент отправки офера водителю отобразить на клиентах (подсвечиваем машину)



# Предлагаемая реализация 

Ранее уже прорабатывалось [здесь](https://github.yandex-team.ru/taxi/rfc/pull/626/files?short_path=19b1ecc#diff-19b1ecc8c95c3b977c8ec4fdb89c1a78).
Основные отличия данной проработки:
1. Вместо подмешивания водителей в driver-map используем алгоритм поиска кандидатов для подсчета ETA - это максимально приближенный результат к тому что нужно
2. Добавляем отображение опрашиваемого водителя на клиентах (ранее не прорабатывалось)


## Машинки-кандидаты на экране поиска

Плавный переход между саммари и поиском на данный момент и так обеспечивается: клиенты шлют в `/nearesdrivers` текущих отображаемых водителей и они гарантированно попадают в ответ ручки.

Проблема только в том, чтобы отобразить ровно те машинки, которым мы будем слать офер (кандидатов на заказ).

На данный момент кандидаты нигде не хранятся. Точнее кандидат попадает в поле `order_proc.candidates` в тот момент, когда ему уже послали офер (т.е. будущих опрашиваемых водителей из заказа и из какой либо другой бд достать нельзя)

Единственный верный способ получить кандидатов - это сходить в ручку `candidates/order-search`
(текущая реализация `/nearestdrivers` ходит в `candidates/searchable` - там используются другие облегченные алгоритмы)


### Создаем новую ручку `/order-candidates` в `driver-map`

Создаем ручку аналогичную `/nearestdrivers`, которая будет ходить вместо `candidates/searchable` в `candidates/order-search`.  Запрос будем формировать аналогично тому как это делается в  `/eta` (так мы получим максимально приближенный результат к тому что нужно - для этого нам дополнительно от клиентов понадобится `zone_id` (все остальные новые параметры получаем из конфигов и хедеров авторизации) 

Клиенты будут ходить в эту ручку вместо `/nearestdrivers`. Т.е. фактически мы здесь перекидываем ~1200rps с одной ручки в `candidates` на другую. Однако нагрузка на CPU будет значительно больше. Поэтому будем раскатывать через эксперимент (вне эксперимента будем использовать `candidates/searchable`). 

Также для уменьшения нагрузки на `candidates` мы можем передавать на клиенты время последнего получения актуальных  данных, которое клиенты пошлют в следующем запросе. Если время менее некоторой пороговой величины (например менее 30сек), то мы можем не ходить в `candidates` а просто отдать на клиенты свежие траектории для водителей переданных в поле `current_drivers`.

И добавляем в ответ этой ручки хедер `X-Polling-Delay` в котором будем передавать период поллинга (в `/nearestdrivers` он сейчас захардкожен на клиентах и равен 5сек)


**Почему лучше вынести в отдльную ручку а не реализовать альтернативный алгоритм в /nearestdrivers?**
1. Мы меняем api: теперь нам нужны авторизационные данные из passenger-authorizer (в /nearestdrivers можно ходить без авторизации) и нам нужно доп поле в запросе: zone_id.
2. Мы будем использовать другой алгоритм поиска, который дает бОльшую нагрузку на candidates и мы хотим отдельно контролировать эту нагрузку.
3. Тайминги новой ручки будут сильно отличаться от таймингов /nearestdrivers (в большую сторону). Для мониторинга лучше не смешивать


## Опрашиваемый водитель на экране поиска

**Ограничения**: Мы не можем гарантировать доставку опрашиваемого водителя до перехода в статус driving, поэтому на клиентах мы также реализуем вариант анимации без опрашиваемого водителя. 

### Вариант 1
Можно добавить кандидата в ответ ручки `/order-candidates`, но в этом случае мы накинем на `order-сore` нагрузку ~2500rps (в максимуме). Кроме того, мы вряд ли сможем установить период поллинга этой ручки меньше времени принятия офера (среднее значение принятия ~5сек), а значит клиенты часто будут получать неактуальный данные.

**Откуда взялось число 2500rps?**
1. Берем поток новых заказов в новый год ~280rps (источник: графики /ordercommit) 
2. Умножаем на среднее время поиска исполнителя  ~45s (источник: [атлас](https://atlas.yandex-team.ru/s/YdZi2N)), получаем ~12600 заказов одновременно могут находиться в состоянии поиска исполнителя (в пике) 
3. Делим на период поллинга ручки ~5s получаем ~2520rps - это предельная нагрузка на ручку.

В обычные дни нагрузка будет ~1200rps. 

### Вариант 2 (предпочтительный) 
Наиболее целесообразно слать текущего опрашиваемого кандидата через пуш. Для горячих клиентов время доставки пуша < 1сек (что намного лучше периода полинга ручки `/order-candidates`).
Отправлять пуш будем в stq-таске, которую будем ставить из processing2.0 по событию для `reason=sean`. Таску реализуем в сервисе driver-map.
Если пуш не будет доставлен - это ок, мы закладываемся на отсутствие гарантий доставки. 


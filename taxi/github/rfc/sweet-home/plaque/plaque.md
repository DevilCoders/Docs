# Раскрывающийся шильдик

> Дизайн - https://www.figma.com/file/zWSt3vNWyrVQPQYX7YI23B/Go-%D0%9F%D0%BB%D1%8E%D1%81?node-id=36668%3A0

- [Требования](#требования)
- [Анализ](#анализ)
  - [Структура](#структура)
  - [Контекст](#контекст)
  - [Приоритет сценария](#приоритет-сценария)
  - [Трекинг количества показов](#трекинг-количества-показов)
- [Предлагаемое решение](#предлагаемое-решение)
  - [Флоу статического конфигурирования SDK](#флоу-статического-конфигурирования-sdk)
  - [Формирование шильдика](#формирование-шильдика)
  - [Условия показа](#условия-показа)
  - [Время показа шильдика и другие параметры](#время-показа-шильдика-и-другие-параметры)
  - [Подстановка динамических данных в виджеты](#подстановка-динамических-данных-в-виджеты)
  - [Предлагаемое API](#предлагаемое-api)
  - [Флоу формирования шильдиков](#флоу-формирования-шильдиков)
  - [Как будем хранить и фильтровать на бекенде](#как-будем-хранить-и-фильтровать-на-бекенде)
  - [Трекинг количества показов на бекенде](#трекинг-количества-показов-на-бекенде)
- [Скоуп работ](#скоуп-работ)


## Требования

Нужно реализовать шильдик, который будет раскрываться из **беджика баланса** SDK, при этом нижняя часть виджета может иметь динамический контент.

Важно:

- разное состояние виджета в зависимости от текущего контекста
- в случае, если можно применить несколько состояний, нужно уметь выбирать одно, наиболее актуальное
- для любых промо коммуникаций на шильдике мы не должны спамить показами - должна быть ротация состояний


## Анализ

> Часть, в которой Бильбо осознаёт, с чем мы имеем дело.

### Структура

Исходя из дизайна мы структуру, представленную на картинке:

<img src="./images/01-header-footer.png" width="400">

Имеем следующие компоненты:

- header - статическая составляющая, которая не зависит от контекста
- footer - динамическая составляющая

Каждый компонент может содержать определённый **виджет** - функциональный элемент шильдика.
Нажатие на каждый из этих виджетов должен производить некоторое действие (переход в домик, переход по диплинку и тд).

| <img src="./images/02-headers.png" width="400"> | <img src="./images/03-footers.png" width="400"> |
| -- | -- |
| Виджеты для header | Виджеты для footer |

### Контекст

Сейчас есть понимание, как должен вести себя виджет в Такси и подобных сервисах с "быстрым заказом".
Сервисы с длинным чекаутом пока находятся в состоянии неопределённости.
Поэтому рассмотрим понятие контекста на примере Такси.

Сценарии, в которых может участвовать виджет в Такси:

- выделенное отображение баланса
- продажа подписки/активация баллов
- управление композиткой
- отображение сообщения о списании/начислении баллов
- отображение всевозможного прогресса

Каждый из сценариев может иметь смысл в зависимости от того, в каком контексте сейчас находится пользователь.
К контексту можно отнести:

- на бекенде (текущая информация о пользователе)
  - наличие подписки
  - тип подписки (мульти vs простая подписка)
  - количество баллов
  - сервис, в котором реализуется сценарий
- на клиенте (данные пользовательской сессии)
  - выбранный тариф
  - текущее состояние заказа
  - текущий экран

Таким образом, **контекст определяет, какой сценарий мы должны отобразить.**

### Приоритет сценария

Видно, что несколько сценариев могут быть применимы для одного и того же контекста.
Для такой ситуации нам также необходимо присвоить **приоритет сценария**, в зависимости от контекста.

### Трекинг количества показов

Можно выделить **промо сценарии**, в которых мы что-то предлагаем (например, купить подписку).
Важно соблюдать баланс в показе промо сценариев, чтобы не возникало навязчивого эффекта.

Чтобы ограничить количество показов разных типов шильдиков необходимо запоминать, когда и какие коммуникации уже были показаны.
Это можно делать как на клиенте, так и на бекэнде.

При реализации на клиенте (**state-less backend**):

- SDK сохраняет факт показа коммуникации в локальном хранилище
- трекинг количества показов не синхронизирован между приложениями на девайсе пользователя (мы можем показать одну и ту же коммуникацию несколько раз подряд в Такси и Драйве)
- невозможно сбросить память показов коммуникаций (на самом деле можно, создав такую же коммуникацию с другим идентификатором, но это усложнит сбор метрик)
- метрики показа можно будет получить из AppMetrica
- клиенты самостоятельно должны регулировать, когда и какая коммуникация должна быть показана, бекенд всегда присылает **все коммуникации**

При реализации на бекенде:

- на бекенде предоставляется ручка, например `/mark-seen`
- SDK ходит в эту ручку как только пользователь увидел конкретную коммуникацию
- при формировании списка коммуникаций для отображения, бекэнд принимает решение, какие коммуникации мы должны показывать и когда
- мы можем собирать метрики на бекэнде 
- мы можем настраивать гибко настраивать маркетинговые коммуникации

> Мы не можем задавать параметры показа через эксперименты, так как они не доступны в SDK.


## Предлагаемое решение

> Часть, в которой Бильбо пытается со всем этим что-то сделать.

Я вижу несколько вариантов формирования шильдика:

1. клиент запрашивает состояния шильдика для каждого экрана в отдельности (поллинг)
   1. нет логики определения проиритета на клиентах, вся логика на беке
   2. множество запросов, что нежелательно на слабых соединениях
2. клиент один раз запрашивает все состояния шильдика и условия их активации (статическая конфигурация)
   1. минимальное количество запросов, они потребуются только при изменении подписочности
   2. необходимо будет реализовать логику выбора виджетов в соответствии с клиентским контекстом 

В процессе обсуждения мы единогласно выбрали **статическую конфигурацию** (второй вариант), его дальше и буду рассматривать.

### Флоу статического конфигурирования SDK

Верхнеуровневый флоу выглядит следующим образом:

1. SDK получает идёт в ручку `/v2/sdk-state`
2. `sweet-home` формирует backend context, на основе которого собирает все подходящие для данного контекста  шильдики
3. отфильтрованный список штльдиков возвращаются в составе расширенного ответа `/v2/sdk-state` (описано [далее](#предлагаемое-api))
4. SDK парсит полученную структуру
5. В ответ на события в приложении, SDK формирует подходящий для текущего контекста шильдик
6. SDK принимает решение о необходимости показа шильдика

В виде диаграммы:

<img src="./images/20-flow.png" width="900">

### Формирование шильдика

Предлагается формировать шильдик из так называемых **виджетов** (`widget`).
Пример описания виджета кнопки покупки:

```json5
{
    // уникальный ID виджета
    "widget_id": "кнопка покупки",

    // тип виджета - определяет его внешний вид
    "type": "BUTTON",

    // поле с описанием указанного типа
    "button": {
        "text": "Активировать"
    },

    // действие, производимое при нажатии на виджет
    "action": {
        "type": "DEEPLINK",
        "deeplink": "диплинк на открытие домика"
    }
}
```

Виджеты в шильдике располагаются сверху вниз (хедер - сверху, футер - снизу), то есть у нас **вертикальное расположение** (`vertical layout`).
Рассмотрим на примере шильдика покупки:

<img src="./images/21-plaque-example.png" width="200">

Для такого шильдика будет использоваться 2 **виджета** - баланс и свитч:

```json5
// описание шильдика
{
    // для учёта показов и сбора метрики
    "plaque_id": "уникальный id данного шильдика",

    "layout": "VERTICAL",  // сейчас только VERTICAL - вертикальное расположение

    // список ID всех виджетов по порядку их расположения на шильдике
    "widgets": [
        "баланс",
        "кнопка покупки"
    ]

    // other fields goes here
}
```

Так как в дальнейшем мы будем реализовывать карточку Плюса, мы можем добавить тип расположения `GRID` и точно также задать расположение элементов списком.

Благодаря такой схеме мы можем без лишней сложности и достаточно гибко формировать шильдик любого вида.

### Условия показа

Для выбора шильдика, соответствующего текущему клиентскому контексту, необходимо проверять **условия показа**.
Уловие показа состоит из **частных условий**, такие как:

- screen - экран приложения
- order_state - состояние заказа
- tariff - выбранный тариф (если применимо)

В API это будет выглядеть следующим образом:

```json5
{
    // ...

    // условие показа состоит из одного или более частных условий
    "condition": {
        // список экранов, которые удовлетворяют условию показа
        "screens": [
            "main",
            "summary"
        ],

        // список необходимых состояний заказа
        "order_state": [
            "transporting"
        ],

        // список необходимых тарифов
        "tariff": [
            "econom"
        ]
    },

    // приоритет, который необходимо будет присвоить шильдику, в случае, 
    // если условие показа было удовлетворено
    "priority": 100
}
```

Для того, чтобы **условие показа** было удовлетворено необходимо, чтобы

- текущий клиентский контекст включал информацию для **частного условия** (screen, order_state, etc)
- значение из клиентского контекста было среди значений частного условия
- все частные условия были удовлетворены (объединение через И)

Если условие показа было удовлетворено, то шильдику присваивается указанный приоритет (`priority`).

### Время показа шильдика и другие параметры

Мы также должны уметь управлять параметрами показа шильдика.
На данный момент можно выделить самые базовые:

- через какое время шильдик должен быть показан при удовлетворении условий показа
- через какое время неактивности шильдик должен быть спрятан

В объект шильдика предлагается добавить поле `params`:

```json5
{
    "params": {
        // через какое время шильдик должен быть показан при удовлетворении условий показа
        "show_after": 10,  // seconds

        // через какое время неактивности шильдик должен быть спрятан
        "close_after": 30,  // seconds

        // здесь же мы можем настраивать периодичность показов
        "schedule": {
            "type": "ONCE_PER_WEEK"  // количество показов - не чаще раза в неделю
        }
    }
}
```

### Подстановка динамических данных в виджеты

Баланс, сумму списания и другие динамические данные SDK подставляет в виджеты на основе клиентского контекста.
Например, клиенты должны уметь самостоятельно подставлять правильное значение в виджет композитки:

```json5
{
    "widget_id": "композитка",
    "type": "SWITCH",
    "switch": {
        // клиент подставляет число самостоятельно. NB: вид плейсхолдера не финальный
        "text": "Списать {{COMPOSITE_PAYMENT_AMOUNT}} баллов"                    
    },
    "action": {
        "type": "SEETING",
        "setting_id": "айди композитки"
    }
}
```

Определение, какие данные нужно подставить, лежит на SDK, а предоставление этих данных - на клиенте.
В примере выше, клиент должен уметь вычислить, какое значение будет оплачено композиткой при выбранном тарифе (в случае Такси) - равное стоимости поездки или балансу кошелька (если баллов не хватает на полную оплату).

Я считаю, что подстановка данных - это клиентская задача, следовательно клиенты должны не ломаться, если бекенд прислал невалидные данные.
Также, мы должны исключить ситуацию, когда в проде будут показываться сломанные строки (с неподставленными занчениями).
Следовательно, для подстановки текстов предлагается следующий план:

- бэк присылает as-is строки с плейсхолдерами
- SDK пытается подставить все допустимые для данной версии переменные
- гарантии предоставляются на этапе создания переводов
- SDK по возможности добавляет валидацию
- если у клиентов не получается сделать валидацию, мы добавим валидацию на стороне бэка

В идеале, SDK должно уметь токенизировать строки и определять наличие переменных.
В таком случае можно будет сразу фильтровать виджеты с неподдерживаемыми переменными, но это зависит от ресурсов клиентской разработки.

На первом этапе предлагаю просто **внимательно следить за переводами**.

### Предлагаемое API

Предлагается расширить протокол ручки `/v2/sdk-state` новым полем `plaque` со следующим содержанием (внешний вид виджетов см. в разделе [структура](#структура)):

```json5
{
    "plaque": {
        // список всех возможных виджетов, которые могут быть использованы 
        // в шильдике (как для футеров, так и для хедеров)
        "widgets": [
            {
                // уникальный ID виджета
                "widget_id": "кнопка покупки",
                // тип виджета - определяет его внешний вид
                "type": "BUTTON",
                // поле с описанием указанного типа
                "button": {
                    "text": "Активировать"
                },
                // действие, производимое при нажатии на виджет
                "action": {
                    "type": "DEEPLINK",
                    "deeplink": "диплинк на открытие домика"
                }
            },

            // примеры других виджетов
            {
                "widget_id": "композитка",
                "type": "SWITCH",
                "switch": {
                    "text": "Списать {{COMPOSITE_PAYMENT_AMOUNT}} баллов"                    
                },
                "action": {
                    "type": "SEETING",
                    "setting_id": "айди композитки"
                }
            },

            {
                "widget_id": "инфо об изменении баланса",

                // клиенты отображают изменение баланса, указывая 
                // соответствующее значение на своё усмотрение
                "type": "BALANCE_CHANGE",
                "balance_change": {
                    "text": "Будет зачислено",
                    "type": "income"  // income, expense - влияет, будет + или -
                }
            },

            // здесь же задаются виджеты для хедеров
            {
                "widget_id": "баланс",
                "type": "BALANCE",
                "balance": {
                    "title": "ваши баллы",
                    "title_opacity": 80  // от 0 до 100, где 0 - полностью прозрачный 
                                         // текст, 100 - полностью непрозрачный
                }
            },

            // лесенка, progress, пасхалка, etc
        ],

        // конечные шильдики
        "plaques": [
            {
                // для учёта показов и сбора метрики
                "plaque_id": "уникальный id данного шильдика",

                // как располагаются виджеты в шильдике
                "layout": "VERTICAL",

                // из каких виджетов состоит шильдик
                "widgets": [
                    "баланс",
                    "инфо об изменении баланса"
                ],

                // условие показа данного шильдика
                "condition": {
                    // список необходимых состояний заказа
                    "order_state": [
                        "transporting"
                    ]
                },

                // приоритет, который необходимо будет присвоить шильдику, если 
                // удовлетворено условие показа
                "priority": 100,

                // параметры показа шильдика
                "params": {
                    "show_after": 10,  // seconds
                    "close_after": 30  // seconds
                }
            }

            // другие шильдики
        ]
    }
}
```

Предполагается переиспользовать существующий механизм действий (`action`) из ручки `sdk-state`.
Благодаря этому мы сможем реализовать сразу два сценария:

- покупку/активацию подписки (через диплинки)
- переключение композитки (через `type: setting` или диплинк)

Если у виджета **не задано действие**, то нажатие на данный виджет ведёт в домик.

### Флоу формирования шильдиков

Если в ответе ручки `/v2/sdk-state` пришло поле с описанием шильдика, происходит следующее (верхнеуровнево):

- SDK парсит виджеты (`widgets`)
- все виджеты, для которых неизвестен тип или тип действия (`action.type`), фильтруются. мы не должны упасть при неизвестных типах
- SDK парсит шильдики (`plaques`)
- все шильдики, в которых указаны недоступные в данный момент виджеты (из поля `widgets`), также отфильтровываются

Далее, каждый раз, когда изменяется клиентский контекст (открывается новый экран, изменяется состояние заказа, etc), происходит следующее:

- клиент собирает параметры, необходимые для SDK (выбранный тариф, текущий экран). эти параметры предопределены в SDK и являются частью его интерфейса
- эти параметры передаются в SDK, из них формируется клиентский контекст
- SDK фильтрует список шильдиков по условиям показа с помощью данного контекста
- формируется сортированный по убыванию приоритета список шильдиков
- шильдик с наивысшим приоритетом используется для отображения
- если по какой-то причине не удалось отрисовать шильдик, то пробуем со следующим по приоритету и тд

### Как будем хранить и фильтровать на бекенде

Всё просто, храним **в конфигах**.

Предлагается хранить виджеты и шильдики по принадлежности к сервису, аналогично настройкам.
Будем различать общие (`common`) и сервисные (`taxi`, `drive`, etc) шильдики и виджеты.

Внутри сервиса будем фильтровать шильдики с помощью существующего механизма **требований** (`requirements`), который уже реализован в сервисе `sweet-home`.
Это позволит нам осуществлять предварительную фильтрацию по наличию/отсутствию подписки и тп.

Необходимо будет добавить новый тип требования - **тип подписки** (мульти, обычная).

Для виджетов фильтрацию по требованиям проводить не будем, так как их будет относительно немного, а также чтобы не усложнять разработку.
При необходимости, требования для виджетов мы сможем добавить позднее.

В остальном структура виджетов и шильдиков (конфиги) повторяет структуру из API.
Например, виджеты будут выглядеть следующим образом:

```json5
{
    // список общих виджетов
    "common": [
        {
            "widget_id": "кнопка покупки",
            "type": "BUTTON",
            "button": {
                "text": "Активировать"
            },
            "action": {
                "type": "DEEPLINK",
                "deeplink": "диплинк на открытие домика"
            }
        }
    ],

    // список виджетов, специфичных для Такси
    "taxi": [
        {
            "widget_id": "композитка",
            "type": "SWITCH",
            "switch": {
                "text": "Списать {{COMPOSITE_PAYMENT_AMOUNT}} баллов"                    
            },
            "action": {
                "type": "SEETING",
                "setting_id": "айди композитки"
            }
        }        
    ]
}
```

Аналогично для шильдиков:

```json5
{
    // список общих шильдиков
    "common": [
        {
            "plaque_id": "уникальный id данного шильдика",
            "layout": "VERTICAL",
            "widgets": [
                "баланс",
                "инфо об изменении баланса"
            ],

            // условия показа могут быть специфичные для сервиса
            "condition": {
                "order_state": [
                    "transporting"
                ]
            },
            "priority": 100,
            "params": {
                "show_after": 10,
                "close_after": 30
            }
        }
    ],

    // список шильдиков, специфичных для Такси
    "taxi": [
        // композитка, лесенка
    ]
}
```

При формировании шильдиков для клиента, бекэнд формирует backend-контекст и на его основе достаёт необходимые шильдики.

### Трекинг количества показов на бекенде

Если мы решаем делать трекинг показов на беке, то предлагается следующее решение.

Для этого добавляем новую таблицу с примерной схемой

```sql
CREATE TABLE plaque_show_statistics (
	yandex_uid    TEXT NOT NULL,
    client_id     TEXT NOT NULL,
    plaque_id     TEXT NOT NULL,

	show_count    INTEGER NOT NULL,

    -- момент первого показа
	created_at    TIMESTAMPTZ,

    -- момент последнего показа
    updated_at TIMESTAMPTZ,

    UNIQUE (yandex_uid, client_id, plaque_id)
)
```

Ожидаемый размер скорее всего будет около похожей таблицы в passenger-profile - ~38кк строк, индекс (yandex_uid, brand).
Очищать можно по давности последнего показа.

> Хранить события показа в виде отдельных событий выглядит большим оверхедом.
> В случае необходимости для сборов метрики, мы можем добавить отдельную реплицируемую таблицу с событиями показа.
> В общем случае, AppMetrica должно хватить, так как это клиентская тема.

Когда клиент показывает шильдик, то на бекенд отправляется запрос `/v2/mark-seen` (v2 - потому что мы работаем только с ручкой `/v2/sdk-state`) со следующим протоколом:

```
POST /4.0/sweet-home/v2/mark-seen

Request:
{
    "plaque_id": "айди шильдика"

    // дополнительная информация, например экран
}
```

При фильтрации шильдиков для показа учитываем статистику показа конкретного шильдика.


## Скоуп работ

> Очень примерные сроки

- поддержка моделей виджетов и шильдиков на конфигах - 1d
- фильтрация виджетов и шильдиков в зависимости от контекста - 4d
- расширение протокола ручки `/v2/sdk-state` - 1d

Если делаем трекинг показов на беке, то

- поддержка статистики показов + фильтрация - 2-3d
- реализация ручки `/mark-seen` - 1d

Если делаем поллинг, то

- дополнение контекста клиентскими данными при фильтрации - 3d
- легковесная ручка формирования шильдика - 2d

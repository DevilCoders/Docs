### Общая схема овердрафта
Овердрафт - это возможность поехать в долг с некоторым лимитом.
Планируется что овердрафт будет работать на движке долгов.

#### Продуктовый взгляд
1. Юзер у которого есть долги видит плашку на главном экране
2. Он может поехать в долг если стоимость заказ не превышает лимит
3. Он может поехать за кеш если стоимость заказа превышает лимит
4. Юзер может попасть в овердрафт, если во время поездки проблема с картой

_Важные замечания:_

_Все описанное ниже будет работать только при наличии у юзера эксперимента 3.0_

#### Главный экран/Саммари
На старте приложение ходит в `launch`, где может получить признак наличия долга.
В этом случае клиент делает запрос в `paymentstatuses` и получает список долговых заказов.
Если список с долгами не пуст - в приложении отображается плашка "Есть неоплаченные заказы на сумму X рублей"

#### Создание заказа

Если у юзера есть долги, то на этапе создания заказа надо понять проходит ли новый заказ по лимиту или нет.
Проблема в том, что сейчас order ходит в базы orderlock, которые лишь отвечают на вопрос "Есть ли у юзера неоплаченные заказы?".
В овердрафте надо знать не только этот факт, но также и размер долга. Размер можно достать из `dborders`.

В итоговый order_proc нужно эти лимиты записать.
Предлагается писать структуру следующего вида:
```js
'payment_tech': {
	'overdraft_info': {
		'overdraft': true,
		'remaining_limit': "<limit>"
	}
}
```

Если цена нового заказа для юзера превышает лимит, `ordercommit` отвечает `406 DEBT_USER`


Если у юзера долгов нет, то записать лимиты также нужно. Это нужно для сервиса антифрода.
Когда у юзера фейлится оплата по карте, антифрод должен проверить лимиты и либо сбросить на кеш, либо сделать овердрафт.
В этом случае предлагается писать так:
```js
'payment_tech': {
	'overdraft_info': {
		'remaining_limit': "<limit>"
	}
}
```


#### Во время поездки
Если заказ изначально был не офердрафтовым, то на статусе транспортинг антифрод попытается списать деньги. Транзакция может зафейлится и это еще одна точка входа в овердрафт. Антифрод должен установить `overdraft:true`. 
Клиент в свою очередь будет уведомлен пушом и через taxiontheway (payment_changes).

Юзер может попытаться оплатить заказ через интерфейс.
Оплата текущего заказа через ручку changepayment
Оплата старых долгов будет через payorder. 


#### Антифрод
Антифрод получает на вход прок, в котором может быть или не быть структура:
```js
'payment_tech': {
	'overdraft_info': {
		'overdraft': true,
		'remaining_limit': 500
	}
}
```

В зависимости от этого, существуют следующие варианты развития событий
1. `payment_tech.overdraft_info` отсутствует. 

Антифрод работает по старым правилам. В случае зафейленной транзакции сбрасывает на кеш.

2. `payment_tech.overdraft_info` есть,`overdraft: False`.

Антифрод начинает транзакции. Если транзакция зафейлилась, смотрит на `remaining_limit`.
- `cost` > `remaining_limit` -> сбрасывает на кеш
- `cost` < `remaining_limit` -> устанавливает `overdraft: True`.

3. `payment_tech.overdraft_info` есть,`overdraft: True`. 

Антифрод не начинает транзакции.

4. `payment_tech.overdraft_info` есть,`overdraft: True` и сменилась точка Б или способ оплаты

Антифрод устанавливает `overdraft: False` и переходит к шагу 2.


#### Главные проблемы
1. В ordercommit нет возможности получить общую сумму долгов, только факт наличия долга. Чтобы получить общую сумму придется из orderlocks достать айдишники долговых заказов и сходить с ними в dborders. 
2. Юзер должен явно подтвердить долговую поездку, для этого в orderdarft надо отправить `accepted:['overdraft']`.
Прежде чем это произойдет, он должен узнать что следующий заказ будет овердрафтовым. 
Узнать это можно двумя способами:
* Сделать draft, попытаться закоммитить, его и получить `406 OVERDRAFT_ALLOWED`. (Ordercommit должен знать размер текущего долга)
* Не делать лишний заказ и вернуть информацию в routestats, также записать в оффер инфу. (Routestats должен знать размер текущего долга)

_Сейчас только paymentstatuses знает размер текущего долга_ 

3. Мультивалютные долги в paymentstatuses.

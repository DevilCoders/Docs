# Начисление произвольных баллов

## Как мы начисляем сейчас

Сейчас начисляем скриптом, которых ходит напрямую в траст.

## Решение

Раздел в админке, в котором указываются:

- Ссылка на табличку yt, которая в формате uid + сколько баллов
- Тип баллов
- Контекст выдачи
- Есть плюс или нет
- Product id (могут быть любые продукты)
- Service token (могут быть любые сервисы)

- дата, когда начислить (в доработках)

Используем новое API transactions для начислений.

## Реализация

### Фронтенд

**(нет оценки, зависит от фронтенда)** 

Раздел (страница) в админке: "Начисление баллов кэшбека".
В разделе есть форма с полями, перечисленными выше.
В разделе есть список заявок с указанием статуса выполнения и хранения.

При заполнении поля со ссылкой на таблицу показывается кнопка "Предварительная оценка"
(либо данные автоматически подтягиваются, это зависит от фронта).
При нажатии на кнопку отправляются данные в ручку (**отдельную или ту же?**),
которая возвращает статистику по таблице:
- число UID'ов
- число уникальных UID'ов
- наличие разных/повторных сумм для одного UID'а (если есть)
- сумму баллов по всем UID (с учётом уникальности и без неё)

После получения данных появляется также чекбокс "Согласен с этими расчётами",
чтобы менеджер понимал свою ответственность за это начисление :-)
(возможно, этот этап согласия будет заменён просто драфтом, в котором будут указаны суммы и числа)

При заполнении остальных полей (**какие из них обязательны?**) становится активной
кнопка "Начать начисление" (или "Начислить").

При нажатии на кнопку отправляются данные (ссылка на таблицу и прочие детальки)
в сервис драфтов, который их проверяет (ручка check) и применяет (apply).

После отправки заявки появляется драфт.

После подтверждения драфта заявка создаётся и появляется на странице списка заявок.

При клике на заявку в списке видим карточку заявки,
там уже присутствует кнопка "Проверить статус". При нажатии на эту кнопку
отправляется запрос (**см. ниже**), возвращается текущий статус
(число обработанных строк, сумма выплаченных баллов и что ещё там нужно).
(в MVP можно обойтись без отдельной карточки, нужные данные будут прямо в списке).

Также регулярно обновляются статусы у заявок, которые ещё не завершены
(поллинг фронтами при наличии в списке заявок с невыполненными статусами
либо просто каждые N секунд). (это уже в доработках фронтенда)

### Танкер

Ключи переводов для текстов в драфте,
  см. https://wiki.yandex-team.ru/taxi/backend/architecture/approvals/#dobavlenienovyxtipovdraftov

### Ручки (~12d)

#### Ручка для оценки объёма заявки (1d)
Запрос:
```
POST /v1/admin/topup/evaluate
```
```json
{
  "table_path": "//hahn/some/path/to/table"
}
```

Ответ:

```json
{
  "uids_count": 100,
  "unique_uids_count": 98,
  "total_amount": 100500,
  "duplicates": {
    "1234567890": [
      100,
      150
    ],
    "9876543210": [
      300,
      300
    ]
  },
  "is_allowed": false
}
```

Что есть в ответе:
- число UID'ов (всего и уникальных)
- наличие дубликатов UID (в т.ч. с разными суммами)
- суммы в выплате (с учётом уникальности и без неё)
- булевый признак, будет ли такая таблица принята к начислению
  (в зависимости от настроек обработки дубликатов, см. ручку `check`)

В примере выше есть два дубликата: первый с разными суммами, второй с одинаковыми.
Если таблица не найдена, возвращает 404.
Если таблица в неизвестном формате (нет полей UID, amount), то возвращает 406 (?)  

Если запрос к таблице будет выполняться слишком долго, то эта ручка должна
 создавать черновик заявки в таблице `topup_requests`,
 ставить stq-таску на оценку черновика и возвращать id заявки.

В этом случае для получения оценки нужно ходить в ручку проверки заявки `/v1/admin/topup/check`,
 которая для черновика будет возвращать статистику (если статистика уже готова).

#### Ручка для проверки заявки (~3d)
Для драфта.

Запрос:
```
POST /v1/admin/topup/check
```
```json
{
  "table_path": "//hahn/some/path/to/table",
  "cashback_type": "marketing",
  "comment": "за хорошее поведение на заправках",
  "has_plus": true,
  "product_id": 123,
  "service": "fuel"
}
```

Ответ:

```json
{
  "change_doc_id": "some_id",
  "diff": {
    "current": {},
    "new": {
      "table_path": "//hahn/some/path/to/table",
      "cashback_type": "marketing",
      "comment": "за хорошее поведение на заправках",
      "has_plus": true,
      "product_id": 123,
      "service": "fuel",
      "payments_count": 100,
      "uid_count": 98,
      "total_amount": 100500
    },
  },
  "data": {
    "table_path": "//hahn/some/path/to/table",
    "cashback_type": "marketing",
    "comment": "за хорошее поведение на заправках",
    "has_plus": true,
    "product_id": 123,
    "service": "fuel",
    "payments_count": 100,
    "uid_count": 98,
    "total_amount": 100500
    }
}
```

Проверяет, что таблица существует, что число UID и сумма к выплате соответствуют указанным в заявке.

При желании можно через конфиг настроить поведение при наличии дубликатов в таблице:
- фейлиться при любых дубликатах
- разрешать дубликаты с разными суммами, начислять разными платежами
- разрешать дубликаты с разными суммами, начислять одним платежом
- разрешать дубликаты с одинаковыми суммами, начислять разными платежами
- разрешать дубликаты с одинаковыми суммами, начислять одним платежом

Если сначала создаётся draft заявки, то в поле `data` возвращается также id записи в `topup_requests`.
Возможно, при этом достаточно и в запросе передавать только этот id, остальное ручка может взять из PG.

#### Ручка для создания заявки (~3d после реализации stq)
Для драфта (вызывается сервисом approvals после одобрения черновика).

Запрос (принимает в теле содержимое поля `data` ручки `check`):
```
POST /v1/admin/topup/apply
```
```json
{
  "table_path": "//hahn/some/path/to/table",
  "cashback_type": "marketing",
  "comment": "за хорошее поведение на заправках",
  "has_plus": true,
  "product_id": 123,
  "service": "fuel",
  "payments_count": 100,
  "uid_count": 98,
  "total_amount": 100500
}
```

Ответ:

```json
{
  "status": "succeeded"
}
```

Проверяет, что данные в таблице yt соответствуют (по сумме и числу UID) заявке
  (проверка аналогична тому, что делает ручка check)
- делает записи в таблицах `topup_requests` (сама заявка) и `topups` (начисления),
- возвращает ок
- (**какие ошибки могут тут возникнуть?**)

Если сначала создаётся draft заявки, то в ручку передаётся также id записи в `topup_requests`.

#### Ручка для проверки статуса заявки (1-2d)
Запрос:
```
GET /v1/admin/topup/status?id=<topup_request_id>
```

Ответ:

```json
{
  "id": <topup_request_id>
  "stage": "succeeded/processing/failed",
  "counters": {
    "processed": 45,
    "pending": 55,
    "total": 100
  },
  "errors": [
    "table has changed",
    "some other problems"
  ]
}
```

Читает данные из таблицы `topups`, подсчитывает статистику, отдаёт ответ.

Возможно, дёргается только после подтверждения драфта, т.к. раньше и нет самой заявки!
Если реализуется схема с созданием черновика заявки в таблице `topups`, то 
 возвращает статус `draft` и оценку по заявке (если уже есть).

Возможно, ручка не нужна, т.к. статус и так будет в списке заявок (?)
Если нужен расширенный статус (список статусов по каждому UID/начислению), то ответ ручки надо расширять.

Кандидат на попадание в список доработок.

#### Ручка для получения списка заявок (~2d)
Запрос (пока без фильтров):
```
GET /v1/admin/topup/list
```

Ответ:

```json
[
  {
    "table_path": "//hahn/some/path/to/table",
    "cashback_type": "marketing",
    "comment": "за хорошее поведение на заправках",
    "created": "2021-02-01T100:00:05+0300",
    "updated": "2021-02-01T100:00:05+0300",
    "archived": null, # или отсутствует
    "status": {
      "stage": "succeeded/processing/failed",
      "counters": {
        "processed": 45,
        "pending": 55,
        "total": 100
      },
      "errors": [
        "table has changed",
        "some other problems"
      ],
    },
    "has_plus": true,
    "product_id": 123,
    "service": "fuel",
    "payments_count": 100,
    "uid_count": 98,
    "total_amount": 100500
  },
]
```

Читает данные из таблицы `topup_requests`.

Уже включают в себя текущий статус, т.к. храним его в таблице заявок.
Счётчики состояния опциональны, т.к. их придётся либо хранить в базе и регулярно обновлять,
  либо пересчитывать при каждом запросе списка.

#### Ручка для отмены заявки
(? до какого момента это можно делать и как поступать с оставшимися начислениями)
Уточнить и добавить в доработках.

### Хранилища

#### Таблица заявок на начисление `topup_requests`

Поле | тип | что это | для чего | нужен ли индекс | зачем индекс
-----|---|---|---|---|---
id | string | id заявки | используется для идентификации заявки | да | primary key
table_path | string | ссылка на таблицу в YT | для получения данных по заявке | нет | 
payments_count | integer | число строк в таблице | для отображения в админке | нет |
uid_count | integer | число уникальных UID в таблице | для отображения в админке | нет |
total_amount | integer | сумма баллов итого к начислению | для отображения в админке | нет |
cashback_type | string |Тип баллов | для передачи в биллинг | нет | 
comment | string |Контекст выдачи (произвольный коммент) | для передачи в биллинг | нет |
has_plus | boolean | Есть плюс или нет | для передачи в биллинг | нет | 
product_id | string | Product id (могут быть любые продукты) | для передачи в биллинг | возможно | для поиска начислений по сервису
service | string | Service token (могут быть любые сервисы) | для передачи в биллинг | возможно | для поиска начислений по сервису
created | datetime | время создания | ??? | да | для поиска
status | string | статус заявки ( _draft / evaluated / pending / processing / failed / complete_ ) | для отображения в админке | да | для архивирования
updated | datetime | время обновления | время завершения выплаты (?) | да | для архивирования старых выплат (?)
archived | datetime | время завершения архивации | для понимания, что детали надо искать в YT | нет |

Данные вставляются сюда ручкой создания заявки `/v1/admin/topup/apply` (одна строка на запрос).

Читаются ручками:
- списка заявок `/v1/admin/topup/list`
- проверки статуса заявки `/v1/admin/topup/status`

Читаются stq-задачами:
- `create_topup_tasks` (читает самые старые записи со статусом pending)

Обновляются stq-задачами: 
- `check_topup` (меняет статус и updated, если все выплаты завершены)

Может обновляться задачами репликации (если не сложно реализовать) и архивирования.


#### Таблица задач на начисление `topups`

Поле | тип | что это | для чего | нужен ли индекс | зачем индекс
-----|---|---|---|---|---
id | string | id выплаты | используется для идентификации выплаты | да | primary key
parent_id | string |id заявки на выплату | для объединения выплат одной заявки | да | для поиска списка выплат по заявке
stq_task_id | string | ссылка на stq-таску (может отсутствовать, пока таска не создана) | для проверки статуса таски (?) | да (?) | для поиска заявки по stq-таске (если она упала, например)
yandex_uid | string |UID, на который начислить | для передачи в биллинг | да | для поиска выплат по UID (для разбора вопросов)
amount | integer | сумма баллов к начислению | для передачи в биллинг | нет |
cashback_type | string |Тип баллов | для передачи в биллинг | нет | 
comment | string |Контекст выдачи (произвольный коммент) | для передачи в биллинг | нет |
has_plus | boolean | Есть плюс или нет | для передачи в биллинг | нет | 
product_id | string | Product id (могут быть любые продукты) | для передачи в биллинг | возможно | для поиска начислений по сервису
service | string | Service token (могут быть любые сервисы) | для передачи в биллинг | возможно | для поиска начислений по сервису
created | datetime | время создания | ??? | да | для поиска
status | string | статус выплаты (_pending / processing / failed / success_) | для отображения в админке, для чтения/обновления stq-тасками) | да | для архивирования
updated | datetime | время обновления | время завершения выплаты (?) | да | для архивирования старых выплат (?)

Данные вставляются сюда ручкой создания заявки `/v1/admin/topup/apply` (балком).

Читаются ручкой проверки статуса заявки `/v1/admin/topup/status`.

Читаются stq-задачами:
- `create_topup_tasks` (читает самую старую запись со статусом отличным от complete/failed)
- `send_topup` (читает конкретную запись по id)

Обновляются stq-задачами:
- `send_topup` (меняет статус и updated)
- `check_topup` (меняет статус и updated)

Вычищается раз в N дней, архивируется в YT (**посчитать квоту на хранение**). 

Вычищение и архивацию **отдельной задачей на доработки** (вряд ли она будет большая первое время).


### STQ-задачи (~8d)


#### Создание новых выплат (планировщик начислений) `create_topup_tasks` (~2-3d)
Раз в минуту либо с перепостановкой себя.

Проверяет таблицу `create_topup_tasks` (находит самую старую невыполненную заявку),
 выбирает её выплаты из таблицы `topups`, создаёт stq-таски `send_topup` на новые выплаты, 
 если старые уже завершены.

При этом учитывает TPS из конфига (**какого?**), ставит TPS * 60 задач на соответствующие секунды
 (если это реально — ставить таски на конкретные секунды).

Либо ставит TPS * 1 задач и перепланируется через секунду
 (можно поиграться с настройками через конфиг).
Если начислений к выплате не найдено (всё уже отправлено), то перепланируется, например, через минуту
 или 15-30 секунд.


#### Выплаты `send_topup` (~2-3d)
По одной задаче на каждую выплату. Ставим с прицелом на 5 TPS.
Тут нужно предусмотреть корректную работу при падении в любой точке задачи.

Аргументы:
- id начисления

Поскольку stq имеет доступ к таблице `topups`, то достаточно просто id выплаты,
  остальное она сама будет читать из базы.

Ходит в ручку transactions `v2/topup/create`:
```
POST v2/topup/create
    id: string  # ID начисления
    billing_service: string  # ID трастового сервиса, см. https://nda.ya.ru/t/iYpViBL43go2xA
    yandex_uid: string  # UID владельца кошелька
    wallet_account: string  # ID кошелька
    amount: string  # Сумма начисления строкой (например, "123.45")
    product_id: string  # ID продукта в Трасте
    currency: string  # Трехбуквенный код валюты
    payload: object  # payload для отправки в тлог
        cashback_type: string  # Тип баллов
        comment: string  # Контекст выдачи
        has_plus: boolean  # есть ли Плюс (из формы либо из Паспорта)
```
После этого (если биллинг ответил ок) проставляет статус `processing` в соответствующей строке `topups`.


#### Обновление статусов выплат `check_topup` (2d)

Аргументы:
- id начисления

Запускается после отправки выплаты в биллинг, ходит в ручку `v2/topup/retrieve`:
```
    id: string  # id начисления
```
При терминальном статусе (`finished: true`) завершается, сделав пометку в таблице `topups`.
 Также может инкрементить счётчик выплат в `topup_requests` (если он там хранится)
 и обновлять статус заявки, если все выплаты завершены.

При промежуточном статусе перепостанавливается на +1 минуту, например
 (**узнать в биллинге, сколько времени идёт начисление**, вынести в конфиг).


### cron-таски

#### Архивирование выплат `archive_topups`

Раз в сутки (конфиг?) проверяет заявки в таблице `topup_requests`:
- для всех завершённых заявок (в статусе `complete`), у которых `updated` старше недели,
  удаляет соответствующие записи в `topups` и проставляет поле `archived`
  
При этом остаётся вопрос, действительно ли все такие выплаты уехали в архив?
  Пока полагаемся на корректную работу механизма репликации.


### Репликация

В репозитории `dmp-rules` заводятся правила, по которым выплаты из таблицы `topups`
 будут отправляться в хранилище. Таблицу `topup_requests` реплицировать пока нет потребности.
**Параметры нужно будет согласовать с командой репликации.**


## Вопросы

### Что если таблица поменяется между оценкой и начислением?  
Скорее всего пофиг на данном этапе.
Но можно в ручке apply вшить проверку, что таблица содержит то же число UID и суммы, что и в заявке. 
Если отличаются, то заявка фейлится с указанием причины (расхождение данных до и после одобрения).

### Что понадобится для разработки и тестирования

- список типов cashback_type
- пример таблицы в YT (решить где будут жить эти таблицы, кто их будет создавать, какие туда понадобятся доступы)
- список значений product_id (продукт -> его id)
- список сервисов для конфига
- конфиг для обработки дубликатов (**в доработках**)
- список текстов для переводов в драфте

### Как предусмотреть различные валюты в баллах?

- добавить поле валюта и начислять в одной заявке только одну валюту
  (при этом проверять, что все кошельки, на которые хотим начислить, будут в одной валюте)
- добавить столбец с валютой?
  (придётся усложнять ответ ручки проверки, считая суммы по каждой валюте отдельно)
- пока никак?

### Отрицательные начисления

- будут ли?
- поддержит ли это новый механизм transactions?

### Другие вопросы

## MVP (~14d)

### Ручки (~7d)
- POST /v1/admin/topup/check (~2d) (минимум проверок, нужных для аппрува драфта)
- POST /v1/admin/topup/apply (~3d)
- GET /v1/admin/topup/list (без фильтров) (~2d)

### Хранилища
- Таблица заявок на начисление `topup_requests`
- Таблица задач на начисление `topups`

### STQ-задачи (~7d)
- Создание новых выплат (планировщик начислений) `create_topup_tasks` (~2-3d)
- Выплаты `send_topup` (~2-3d)
- Обновление статусов выплат `check_topup` (2d)

## Скоуп задач
* [Billing] Поддержать topup в transactions (**сроки?**)
* [Taxi] Завести stq-задачи и хранилище для временного показа в админке (~8d)
* [Taxi] Завести ручки и конфиги для фронта (~12d)
* [Frontend] Раздел в админке (**сроки?**)

## Случайные скидки с лутбоксами в Uber

### Требования

[Продуктовое описание](https://st.yandex-team.ru/TAXIPROJECTS-1752)

###### Важные: 
* Если пообещали человеку скидку, она должна быть максимально быстро присвоена пользователю, 
желательно сразу после анимации кубика.
* Рольнуть скидку можно только в тех зонах, где мы разрешаем.
* Должна быть возможность в разных зонах настраивать разные лимиты промокодов и 
разные вкроятности выпадения скидки

### Решение на базе промокодов

Промокоды из коробки предоставляют возможность выдать скидку на одну поездку, 
что на данный момент не поддерживается сервисом discounts. 
Также промокоды - это более понятный, чем скидки, механизм выдачи вознаграждений.

Со стороны антифрода неизвестно о каких-либо проверках, 
которые могут сработать в случае выдачи большого количества промокодов.

Поэтому за выигрыш в лутбокс будем выдавать промокод.

Новые ручки планируется добавить в сервис coupons, так как это быстро и сильно связано на текущем этапе.
со следующими условиями:
1) Весь код про рандомизацию пишем в стороне (можно даже в отдельной высокоуровневой либе), 
чтобы его можно было быстро вынести. Он никак не должен переплетаться с основным кодом купонов
2) Вся поддержка рандомящих ручек - на команде Убера
3) Если рандомные скидки выстреливают и начнут активно развиваться - 
отселяем функциональность в отдельный сервис
### Конфигурация группы пользователей

Пользователи, для которых включены случайные скидки (далее __целевые пользователи__), 
задаются с помощью  эксперимента random_discounts(схема в random_discounts_exp_schema.yaml).

Данный эксперимент одновременно включает логику и задает конфигурацию: 
вероятность победить и серию промокода, 
Этот эксперимент может включается как по зонам, так и на конкретных пользователей.

### База данных

Планируется сделать отдельную бд random_discounts для наших таблиц, чтобы не сильно зависеть от бд сервиса купонов
```sql
CREATE TABLE random_discounts.random_discounts
(
  random_discount_id   TEXT PRIMARY KEY,   -- токен идемпотентности, также используется для вызова /internal/generate
  yandex_uid           TEXT NOT NULL,      -- yandex_uid пользователя
  device_id            TEXT NOT NULL,      -- device_id пользователя
  completed_at         TIMESTAMP NOT NULL, -- время вызова ручки /random-discount-roll
  discount_series      TEXT,               -- Серия выйгранного промокода, null, если проигрыш
  discount             INTEGER,            -- выйгранная скидка, null, если проигрыш
  discount_limit       INTEGER,            -- лимит выйгранной скидки, null, если проигрыш
);

CREATE INDEX id_completed_idx 
ON random_discounts.random_discounts(yandex_uid, completed_at);
```

Убер имеет в день примерно 600к активных пользователей, 
на первом этапе планируется открывать только на часть зон.
А так же, для активных пользователей записи в базе будут переиспользоваться 
так что ожидаемая нагрузка на базу - несколько десятков миллионов записей 

Примерный объем данных:   
В [коллекции user_phones](https://yql.yandex-team.ru/Operations/5f9bdd4753f3547f7e485447?editor_page=main) 
лежит ~ 17 миллионов телефонов с типом "uber" (будем считать, 
что это максимальное число пользователей для которых мы создадим запись в таблице)

Примерный размер одной записи - 160байт
получил используюя функцию:  
`SELECT sum(pg_column_size(t.*)) as filesize, count(*) from coupons.random_discounts t;`

Возьмем рост в 50%  
И того получим самый максимум в один день (Если открыто на всех и роляют все):  
```math
      17 * 10^6       *   1.6 * 10^2    *  1.5   = 4 * 10^9 ~ 4 Гб
кол-во пользователей     размер записи     рост
```
Индекс и прочее увеличивают размер примерно в 2 раза
Итого - 8гб в день

Если будем чистить данные раз в 5 дней, нам нужно будет заложиться на 40гб

###### Взаимодействие с базой
![Взаимодействие с базой](img/random_discounts.png)

### Ручка 4.0/v1/random-discount-status
Ручка будет закрыта за passenger_autorizer

Ручка проверяет, можно ли сейчас сыграть данному пользователю
возвращает текущий статус случайной скидки 
и дополнительную информацию по отображению

Входные параметры (объект request):
  - yandex_uid (из passenger_autorizer)
  - device_id (из заголовков)
  - zone (передается кваргом в эксперимент)

В ответе возвращаем:
- статус
- пробрасываем из эксперимента тип лутбокса is_autoroll
- сообщение которое нужно отобразить на клиенте
- оставшийся срок действия текущего промокода возвращается только если состояние inactive
(более подробно в random-discount-status.yaml)


####### про is_autoroll
для тестов хотим разделить пользователей, на тех, кто может сам сделать "бросок кубика"
и тех кому просто будем случайным образом показывать скидку
соответственно значения is_autoroll:
false - пользователь сам делает бросок, показывается анимация
true - пользователю не показывается анимация, а просто сообщается о получении скидки
##### Логика
Если пользователь __не__ попал в эксперимент random_discounts, 
то ручка позвращает status = disabled.

Если пользователь попал в эксперимент:

Проверяем зону прошлой поездки пользователя:  
Делаем запрос в сервис user-api */v2/user_phones/get* 
[yaml](https://github.yandex-team.ru/taxi/uservices/blob/4937ea073d3e0a214b64761610f706717305ee82/services/user-api/docs/yaml/definitions.yaml#L199)

Если request.zone != зоне полученной из user-api, то возвращаем  status = disabled  
Если из user-api получили ошибку, то возвращаем  status = disabled  

Если в эксперименте пришло `need_check_prev_ride == false` не делаем эту проверку

Пример запроса:
```sql
SELECT
       completed_at
FROM random_discounts.random_discounts
WHERE 
    yandex_uid IN (request.yandex_uid, fonish1, fonish1)
    OR 
    device_id = request.device_id
ORDER BY completed_at DESC LIMIT 1;
```

По request.yandex_uid или request.device_id получаем последнее по дате 
значение completed_at из таблицы random_discounts:
  - если completed_at не найдено, то возвращаем status=active  
  - если (current_time() - completed_at) >= promo_delay, то возвращаем status=active   
  (прошло достаточно времени между бросками)
  - если (current_time() - completed_at) < promo_delay, то возвращаем status=inactive  
  (НЕ прошло достаточно времени между бросками)
  
promo_delay будет взято из эксперимента  

###### Ожидаемая нагрузка

По грубым прикидкам: ручка будет вызываться вместе с zoneinfo
Сейчас это, 
[если верить кибане](https://kibana.taxi.yandex-team.ru/goto/fde030cd6b5430d95c054fc54688575a), 
50-60rps в пике для всех зон.  
На первом этапе ожидаемая нагрузка 10-20rps


### Ручка POST 4.0/v1/random-discount-roll
Ручка будет закрыта за passenger_autorizer

Производит розыгрыш, в случае выигрыша выдаёт промокод, возвращает результат розыгрыша.

Входные параметры (объект request):
  - yandex_uid (из passenger_autorizer)
  - device_id (из заголовков)
  - zone 
  - токен идемпотентности (из заголовков)

В ответе возвращаем:
- результат броска (выйграл \ проиграл \ не может бросать сейчас)
- код промокода
- сообщение которое нужно отобразить на клиенте
- размер скидки (нужно для анимации на клиенте)
- обновленный статус(аналогично ручке status)
(более подробно в random-discount-roll.yaml)

##### Логика
Полностью повторяется проверка из ручки status

Если не проходит по эксперименту:
Мы делаем запись в базу о том, что пользователь сыграл неудачно.
И возвращаем информацию о проигрыше.

Если пользователь не может совершить бросок, состояние inactive:
то мы возвращаем 200 и roll_result = conflict
Это означает, что клиенту нужно обновить у себя статус, 
на тот который вернулся из ручки roll.

Далее, смотрим, есть ли у нас данный токен идемпотентности в базе: 

- если нет :  
     * срабатывает логика случайного броска
     * в случае неудачи записываем в базу:   
        ```
        completed_at = current_time()  
        discount=null, 
        discount_series=null,  
        discount_limit=null,  
        device_id= device_id из запроса
        ```  
          и отправляем сообщение о проигрыше
     * в случае выйгрыша :  
        1. записываем в базу   
              ```
              completed_at = current_time()  
              discount= значение скидки,   
              discount_series= серия выйгранного промокода
              discount_limit= значение лимита,  
              device_id= device_id из запроса  
              ```  
        2. вызываем ручку /internal/generate 
           сервиса coupons для выдачи промокода пользователю
           
        3. возвращаем результат выйгрыша 
- если токен есть в БД:  
    это повторный запрос
    * если discount != null, значит пользователь выйграл и нужно удостовериться, 
    что содался промокод, повторяем шаги 2 и 3  случая с выйгрышем
    * если discount == null, значит пользователь проиграл 
    отправляем сообщение о проигрыше

Серия промокода (для выдачи) определяется случайным выбором 
из поля discount_settings эксперимента random_discounts, 
в котором задаются серии промокодов вместе с вероятностями их выиграть

###### Точки отказа

- Запрос в internal/generate
- Запись в базу
- Лаг сети

В случае отказа internal/generate вернем 500, code: "promocode_generate_error".
Клиент может повторить попытку c тем же токеном:
Новый промокод в данном случае не создается. 
При повторном запросе мы просто попробуем сделать еще один промокод

Если за время ретраев сервис купонов не оживет, то клиент выведет сообщение, 
которое вернется в ручке status (скорее всего о проигрыше) 
А в базе у нас останется запись о победе пользователя

В данном случае возможна ошибка:  
если после получения такой 500, клиент сделает запрос в status,
то он получит статус inactive, хотя по сути игра не произошла
(но возможно это и хорошо, если сервис промокодов не отвечает, 
то не стоит делать ретраи)

В случае невозможности записи в базу вернем 429, на который клиент будет считать,
что у нас проблемы, и  покажет сообщения из status, 
выставит у себя текущий статус disabled и выключает фичу до следующего запуска

Если произойдет лаг в сети:  
Мы ответили клиенту, а он не получил сообщение, и делает перезапрос.
По токену идемпотентности достаем данные из базы, 
повторяем сообщение о победе или проигрыше

###### Запрос в coupons/internal/generate
[api](https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/Uservices/coupons/api/api/#internalgenerate)

Необходимые поля:
- application_name (будет взято из passenger_autorizer)
- brand_name       (будет взято из passenger_autorizer)
- yandex_uid       (будет взято из запроса)
- series_id        (будет взято из значения эксперимента)
- token            (будет взят из запроса)
___
- promocode_ttl  Этого поля пока нет в ручке, планируется добавить. 
                 значение будет браться из эксперимента discount_settings.promocode_ttl

###### Ожидаемая нагрузка
в пиковом случае, если все пользователи, которые будут видеть кубик будут играть, 
то нагрузка ожидается сравнимой с  *4.0/v1/random-discount-status* 


### Общий Флоу случайных скидок

![Общий Флоу](img/urd_new_flow1.png)

1. Будем подмешивать ответ ручки __/v1/random-discount-status__ в ответ zoneinfo через api-proxy 
(это позволит не делать лишние запросы при запуске приложения), 
так клиент будет получать статус кубика при любой смене зоны
2. Если пользователь решает сыграть, то делаем запрос в ручку __/random-discount-roll__ для фиксации факта игры и выдачи промокода в случае выигрыша
3. В случае выигрыша нужно сделать запрос в  __/routestats__ для обновления стоимостей экрана summary с учётом добавленного промокода

Если клиент решит, что ему необходимо обновить информацию о состоянии 
он сам может напрямую дернуть ручку /status 

#### Ограниченное время действия промокода

В случае выигрыша промокод выдаётся на 24 часа. Необходимо обсудить с мобильной разработкой как отображать оставшееся время действия промокода в часах, т.к. в данный момент оно отображается в днях.

Т.к. в настоящий момент сервис coupons не поддерживает такое ограничение на время действия промокода, то возможны 2 варианта решения это задачи:
  - Поддержать эту возможность в сервисе coupons. Для этого необходимо:
    1. - добавить в коллекцию [promocode_series](https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/Mongo%20collections/taxi/promocode_series/) время жизни промокода с момента активации: `ttl`.
       - поддержать новое поле `ttl` в [админке](https://tariff-editor.taxi.yandex-team.ru/promocodes/for-passengers/), либо для начала сделать возможным правку этого поля через скрипт.
    1. более простая альтернатива предыдущему пункту - добавить поле `ttl` в коллекцию [promocodes](https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/Mongo%20collections/taxi/promocodes/) в ручке `internal/generate`
    1. добавить проверку истечения `ttl` в [код](https://github.yandex-team.ru/taxi/uservices/blob/5f3b07ec2f739086eb49c52951d8afc0445408cc/services/coupons/src/couponcheck/checks/checks.cpp#L310), как вариант по аналогии с [реферальными промокодами](https://github.yandex-team.ru/taxi/uservices/blob/36406ade08fd5d887265d9510f95165af07990aa/services/coupons/src/couponcheck/couponcheck.cpp#L185)
  - Запускать периодический процесс отзыва промокодов. Здесь необходимо учесть то, что кол-во промокодов большое и, вероятно, будет необходим индекс в базе данных.

Более корректным представляется первый вариант (через сервис coupons)


### Этапы реализации

##### Этап 1
Задаются N зон cо своими наборами промокодов, 
промокоды будут действуют только внутри своих зон 
(задается при создании промокодов)
  
Тогда можно делать ролл только один раз в день, 
только если пин в одной из разрешенных зон + промкод действует только в этой зоне 
  
Возможная проблема:
человек из любой зоны может рольнуть в разрешенной, передвинув туда пин, 
но промокод получит только в разрешенную зону, это вроде ок продуктово, 
но может как-то повлиять на статистику 

###### Разработка
 
- Ручка /v1/random-discount-status (2.5 дня)
- Ручка /random-discount-roll (2.5 дня)
- Доработка в сервис промокодов по ограничению времени действия промокода (???)
- Добавление мониторингов на количество скидок (+ алертов на количество запросов в ручку roll)
- Добавление дополнительной защиты от фрода:
    будем смотреть на зону последней поездки пользователя и давать сделать ролл только в ней 
    возможно через order_history:  [пример кода получния последнего заказа](https://github.yandex-team.ru/taxi/backend-py3/blob/42d6f16d75a96c263a6e843740c731d818b2c470/services/taxi-shared-payments/taxi_shared_payments/stq/util.py#L29)

#### Этап 2

Создается серия промокодов с которые действуют по всем зонам, но у них маленький лимит
  
Добавляем в эксперимент один матчинг для всех, кто не попал в первоначально заданные зоны. 
Тогда можно ролять везде, но если пользователь в выделенном регионе - 
он получает промокод именно для этого региона. 
А если пользователь в обычном регионе - он получает промокод на все зоны, но с маленьким лимитом
  
###### Разработка
- Очистка базы от неактивных пользователей

#### Этап 3

В случае если данная идея с рандомной выдачей наград разовьется, 
тогда планируем вынести обе ручки в отдельный сервис

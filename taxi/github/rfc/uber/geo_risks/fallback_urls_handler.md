# Обход рисков разделегирования хостов для разных приложений

## Задача

Из-за геополитической ситуации наши хосты могут быть заблокированы в разных странах. 

Чтобы не страдать из-за блокировок, нужно возвращать на клиент список запасных хостов.
Для каждого приложения (go, yango, uber, vezet, ...) нужно уметь возвращать отдельный подходящий список.

## Существующее решение

Для подобных сценариев давно была сделана ручка, возвращающая список фоллбэчных хостов. 
Клиент получал хосты из ручки и начинал перебирать по порядку, если недоступен обычный.
https://st.yandex-team.ru/TAXIBACKEND-7071 - здесь была реализация.

Позже была сделана доработка - хосты стали возвращать в зашифрованном виде, чтобы их нельзя было подменить.
По каким-то причинам ручку с бинарными данными делать не стали.
Сделали раскладку конфига в бинарном формате из админки кроной на прокси.
Такое решение существует сейчас, работает для yango, go, uber.
Конфиг для всех приложений одинаковый, раскладывается на tc и uc одинаково.

Существующее решение не устраивает тем, что не получится завести отдельный конфиг для каждого приложения.

## Возможные решения:
1. Сделать ручку в сервисе `uservices`, которая вернёт конфиг для приложения в бинарном формате. 
Приложение будем определять из запроса.
2. Переиспользовать логику в py2, возвращающую зашифрованный конфиг 
(https://wiki.yandex-team.ru/taxi/backend/api/admin/#polucheniebinarnyxkonfigovdljacdn).
Считаю, что минус в том, что py2 - легаси, переиспользовать решение может быть сложнее, чем сделать новое. 
Доступ к гитхабу и вообще существование py2 на данный момент под вопросом. 
3. Поправить конфиг nginx так, чтобы в нём определялось приложение и выбирался нужный конфиг. 
Выглядит костыльно, ручку сделать будет правильнее.
4. Отдавать конфиг с хостами для всех приложений, разложенными внутри конфига по приложениям,
и разбираться на клиенте, какие хосты нужны. Будем пересылать лишние данные, лишняя логика на клиенте, 
тоже выглядит костыльно.
 
Считаю, что правильный вариант - делать ручку в uservices. Дальше о таком варианте.

## Реализация

### Выбор сервиса

Если нет более-менее подходящего сервиса в uservices - новый создавать будет долго, 
можно сделать ручку в `superapp-misc` (насколько я понимаю, сервис заводился для того, 
чтобы дописывать любой функционал, слишком маленький для отдельного сервиса - https://st.yandex-team.ru/TAXIARCHREVIEW-73). 
Ресурсов подкинем (возможно даже, что не очень много/не потребуется. Сейчас 2000rps, расходуется 15-20% cpu. 
Если прилетит ещё 6000rps - должны выдержать. Можно подкинуть по инстансу в каждый ДЦ, на всякий случай).

### Конфиги приложений
Возможные варианты:
1. Общий конфиг с секциями по приложениям. Самый простой вариант.
2. Общий эксперимент, приложение матчится кваргами. Более гибко. Но эксперимент - всё-таки временная сущность.
3. Конфиг 3.0, свой для каждого приложения. Более постоянно, чем эксперимент. Можно матчить кваргами. 
4. Конфиг 3.0, общий на всех.

Думаю, надо выбрать между вариантами 3 и 4.
Сделаю 4 вариант - достаточно простой и общий.

### Приложение в запросе

Проще всего было бы разместить ручку за PA. По видимому, это сделать не получится - хотя бы 
из-за пользователей, использующих приложение в первый раз. 
Тогда предлагаю присылать с клиента заголовок навроде `X-Request-Application`, в котором будут 
данные про приложение.

### Ответ

Изначальная реализация содержала в себе не только фоллбэчные урлы, но и список хостов, где можно запросить конфиг, 
и время `updated`.

Уточнила у клиентского разработчика, что нужно и используется. Нужно всё то, что сейчас собирается в py2 
в коде шифрования конфига. Это `base_urls_groups` - фоллбэчные урлы, `sources` - где можно их запросить, 
`expired` - время истечения.

`sources` заполняется из конфига `CLIENT_PROXY_URLS_LIST`. Думаю, что так и надо оставить, 
подойдут одинаковые для разных приложений.

`expired` - это текущее время + значение из конфига `PROXY_CONFIG_TTL`, так и надо оставить.

Структура ответа до шифрования будет такой:
```
{
    'expired': время истечения,
    'sources': список урлов для перезапроса конфига,
    'base_urls_groups': список фоллбэчных урлов для приложения,
}
```

### Схема ручки

```
/4.0/superapp-misc/v1/fallback-url-list
        get:
            description: |
                Ручка, получающая список запасных урлов для приложения, 
                с которого сделан запрос.
            parameters:
              - in: header
                name: X-Request-Application
                type: string
                description: информация о приложении в том формате, в котором приходит от PA
                required: true
            responses:
                '200':
                    description: OK
                    content:
                        application/json:
                            schema:
                                type: object
                                additionalProperties: false
                                properties:
                                    client_config:
                                        type: string
                                        format: binary
                                        description: | 
                                            Значение конфига со списком урлов, 
                                            подходящих для данного приложения, 
                                            и вспомогательной информацией.
                                            Возвращается в зашифрованном бинарном виде.
                                required:
                                  - client_config
                '404':
                    description: Not found
```

### Детали реализации

Бинарные данные из сервиса в uservices возвращать можно.

Для этого нужно указать в api ручки 
```
type: string
format: binary
```

Пример: https://a.yandex-team.ru/arc/trunk/arcadia/taxi/uservices/services/userver-sample/docs/yaml/api/api.yaml?rev=r8948357#L1602

Шифрование реализуем заново в ручке.
Про шифрование в uservices: https://wiki.yandex-team.ru/taxi/backend/userver/crypto/
Договариваться с ИБ заново не будем, потому что решение уже было раньше, только актуализируем.

Шифрование AES поддержано: https://wiki.yandex-team.ru/taxi/backend/userver/crypto/#blochnoeshifrovanie

Генерация подписи SHA-256 тоже поддержана: https://wiki.yandex-team.ru/taxi/backend/userver/crypto/#proverkacifrovojjpodpisi

Имплементация в py2, можно смотреть, как пример: 
https://github.yandex-team.ru/taxi/backend/blob/develop/taxi/internal/proxy_config.py

Ключ `PROXY_URLS_AES_KEY` надо будет положить в виде секрета (`API_TOKEN_TAXI_PROXY_URLS_AES_KEY`)

### Реализация на уровне nginx

Добавим в конфиг nginx для protocol-proxy новую ручку `/app/explicit-app-config` 
(по аналогии с существующей `/app/config`), из неё будем ходить в новую ручку в uservices.
Если можно на этом уровне ретраить - думаю, надо сделать стандартно так, как делали бы для обычного запроса ручки.

### Перезапрос конфига с клиентов

С клиентов будет запрашиваться новая ручка. Ответ немного отличается от ответа nginx 
(конфиг приходит в поле ответа, а не сам по себе), поэтому надо поддержать поход в новую ручку nginx и разбор ответа.

### Фоллбэк на случай недоступности superapp-misc

Если новая ручка не отдаёт ответ - клиент так же, как и раньше, ходит в `/app/config`. 
Изначально была мысль реализовать такой фоллбэк прямо на уровне nginx, но не удалось выяснить, 
можно ли так сделать (возможно, что и нет). 
Конфиг будет, как и сейчас, общий для всех приложений. Разделение по приложениям здесь будет делать или сложно, или костыльно.
В итоге, текущая реализация похода в `/app/config` без изменений остаётся в качестве фоллбэка.

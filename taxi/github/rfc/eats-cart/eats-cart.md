# Микросервис корзины Еды

## Предпосылки задачи

Сейчас логика работы корзины написана в Коре Еды (монолит на php).
Для [продуктового и технического развития](https://wiki.yandex-team.ru/users/meboroukhina/klassnaja-korzina/) корзины, необходимо вынести её в отдельный микросервис.

## Как работает сейчас

Очень подробное описание есть на [Wiki](https://wiki.yandex-team.ru/eda/dev/backend/services/cartv1/).

Если коротко, корзина пользователя хранится в БД `bigfood`(mysql) в таблицах `carts, cart_items, cart_items_menu_options, cart_promos, cart_additional_info`. При запросе происходит join с таблицами `places, orders, promocodes, place_menu_items, place_menu_options, promos`.

Кроме того, лок для изменения корзины хранится в redis. Там же хранятся данные о текущем сурже корзины.

Уже сейчас некоторые данные для ответа ручки корзины берутся из внешних микросервисов. Это расчёт стоимости и времени доставки и суржа.

## Что хотим сделать

В идеальном будущем для работы корзины кора вообще не используется: все зависимости в микросервисах, сама корзина тоже в отдельном микросервисе.

### Как будем к этому идти

Технически для выноса корзины из Коры будет два этапа:

1. вынос основной логики корзины из Коры
1. вынос зависимостей корзины из Коры.

### Первый этап

На первом этапе будет вынесена логика хранения (таблицы `carts, cart_items, cart_items_menu_options, cart_promos, cart_additional_info`) с походами в Кору за информацией по place, по меню, заказам, промокодам и акциям.

За информацией по доставке и суржу нужно будет разу ходить в соответствующие микросервисы.

Есть альтернативный способ получить часть информации: ходить в ручку [/v2/catalog/slug](https://wiki.yandex-team.ru/users/nk2ge5k/eats-catalog/#/api/v2/catalog/slug) сервиса [eats-caalog](https://wiki.yandex-team.ru/users/nk2ge5k/eats-catalog/).

### Второй этап

Этот этап на самом деле идёт немного в параллель к первому. Уже идёт работа по выносу меню ресторанов из Коры, проработка перехода на микросервис акций, в плане перейти на микросервис промокодов. Всё это будет в отдельных проработках.

## Технические детали выноса корзины

Я предлагаю разделить логику работы корзины на взаимодействие с клиентами и с другими сервисами.

### Клиентские ручки

Приведу их здесь просто списком с короткой информацией.

#### Ручка запроса корзины (GET /v1/cart)

На вход ничего не принимается, возвращается либо объект с пустыми полями, либо объект с текущей корзиной. Считается, что у пользователя может быть только одна корзина, она и возвращается (хотя гарантии нет, иногда корзин больше одной, и на бэке выбирается свежая)

#### Ручка добавление item-а в корзину (POST /v1/cart)

На вход передаётся item_id, количество и набор опций. Place определяется по item_id, опять считаем что корзина только одна у пользователя. В любой непонятной ситуации бэк создаёт новую корзину и удаляет старую.
По поводу очистки старой корзины (спросить пользователя) логика реализована на клиентах.
В ответ приходит item_id, cart_item_id и полный объект корзины.

#### Ручка изменения item-а в корзине (PUT /v1/cart/cart_item_id)

На вход подаётся cart_item_id (в урле), item_id, кол-во и опции.
В ответ приходит объект корзины.

#### Удаление item-а из корзины (DELETE /v1/cart/cart_item_id)

На вход приходит cart_item_id (в урле), в ответ полный объект корзины.

#### Синхронизация корзины (POST /v1/cart/sync)

Удаляет старую корзину и делает батч-добавление item-ов. Используется клиентами для очистки корзины.

#### Ручки удаления недоступных item-ов

DELETE /v1/cart/disabled-items - удаление из корзины недоступных товаров

DELETE /v1/cart/unavailable-items-by-time - удаление из корзины товаров недоступных для заказа по времени

DELETE /v1/cart/unavailable-promos - удаление из корзины недоступных акционных товаров.

#### Ручка удаления корзины (DELETE /v2/cart)

Алиас `/v1/cart/sync` с пустым набором товаров.

#### Информация о промокоде

GET /api/v1/cart/promocode/proposal - примерка промокода к корзине

GET /api/v1/cart/promocode/proposal/paymethod - примерка промокода к корзине

Не производят никаких изменений с корзиной, только отдают информацию о промокоде

#### Применение промокода

POST /api/v1/cart/promocode — применить промокод

DELETE /api/v1/cart/promocode — удалить промокод

### Серверные ручки

POST /api/v1/get_cart — получить корзину только с id и ценами, без доп. информации.

### Разбор конкретных полей ответа корзины с указанием источников

Объект ответа корзины содержит следующие поля:

Информация о заведении:

`place_slug` — строковый идентификатор ресторана
`place` — информация о ресторане, можно получать из eats-catalog
`country` — информация о стране и валюте, можно получать из eats-catalog

Информация о товарах в корзине (массив items):
`id` — идентификатор cart_item_id, должно храниться в новом микросервисе
`item_id` — идентификатор `place_item_id` товара в меню, должно храниться в новом микросервисе
`name` — название позиции, получаем из меню
`price` — сохранённая при добавлении товара в корзину цена (целочисленная)
`decimal_price` — сохранённая при добавлении товара в корзину цена (дробная)
`item_options`: — массив опций применённых к позиции, идентификаторы и количества должны храниться в новом микросервисе

- `group_id` — идентификатор группы опций, хранится в новом микросервисе
- `group_name` — название группы опций, получаем из меню
- `group_options`:
  - `id` – храним в микросервисе
  - `name` — получаем из меню
  - `quantity` – храним в микросервисе

`quantity` — количество товара, хранится в микросервисе
`description` — копия поля из `place_menu_item`
`weight` — копия поля из `place_menu_item`
`promo_type` — храним локально в списке применённых к корзине акций, получаем из Коры
`promo_price` — храним локально в списке применённых к корзине акций
`place_menu_item` — объект позиции меню, полностью получаем из коры

Данные о доставке — получаем из eats-catalog:
`delivery_date_time`
`delivery_date_time_iso`
`delivery_fee`
`delivery_time`
`available_time_picker`
`shipping_type`
`charges`

Информация о стоимости корзины — вычисляется
`subtotal` — хранится у нас
`total` — вычисляется
`surge` — получаем из внешнего сервиса, храним значение в БД
`yandex_plus` — получаем из внешнего сервиса

Информация об акциях и скидках — информация о применённых акциях хранится в микросервисе корзины, подробности акций получаем извне:
`promos` — храним у себя, получаем при добавлении из коры
`discount` — скидка по промокоду, вычисляется как `subotal+delivery_fee-promo_discount-outcome_discount`
`promocode` — храним у себя, добавляется специальными ручками, проверяется в коре
`promo_items` — храним у себя, получаем из коры
`promo_notification` — отдаётся только при добавлении айтема, вычисляется по применённой акции
`discount_promo` — скидка по промо-акциям, получаем из коры при добавлении, храним у себя

Прочее:
`requirements` — получаем из eats-catalog
`updated_at` — храним у себя
`expenses_holding` — судя по коду Коры, объект всегда пустой.

### Необходимые доработки в коре

Нужен метод получения place_menu_item по place_menu_item_id.

### Необходимые доработки в других сервисах

В eats-products нужен метод полученя айтемов по массиву легаси-идентификаторов

В eats-catalog нужен метод получения информации о place, доставке и сурже по place_slug.

### Необходимые доработки на клиентах

Чтобы запрашивать айтемы для ритейла не в коре, а в eats-products, нам нужно понимать что пользователь пытается добавить блюдо для ритейла. Для этого нужно в запросах от клиентов получать place_slug, чтобы по нему получить информацию о типе заведения и из нужного места получить информацию об айтемах.

## Хранение данных

Данные будем хранить в PGaaS.

### Корзина

- `id` идентификатор корзины, uuid4
- `revision`
- `place_id` идентификатор ресторана
- `subtotal`
- `total`
- `delivery_fee`
- `discount`
- `outcome_discount` ?
- `shipping_type`

### Привязка корзины к пользователю

`eater_id`
`cart_id`
`cart_revision`

### Содержимое корзин

`id` идентификатор блюда в корзине
`cart_id`
`place_menu_item_id` строковый идентификатор блюда: для старого меню это число, для нового нет
`price`
`quantity`
`cart_promo_id` идентификатор применённой акции

### Опции блюд в корзине

`cart_item_id`
`option_id`
`quantity`

### Применённые акции

`id`
`cart_id`
`promo_id` идентификатор акции
`discount` размер скидки по акции
`cart_item_id` опционально блюдо, которое добавилось по акции

### Промокоды

`cart_id`
`code`
`percent`
`limit`
`value`
`description`
`type`

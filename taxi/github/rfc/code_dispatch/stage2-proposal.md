 
# Проработка этапа 2 (рефакторинг)

## Основные проблемы, которые необходимо решить 
1. Коллекции `code_dispatch_codes` и `code_dispatch_assignments` сейчас в монге в `dbmisc`, а должны быть в postgresql
2. Даны обещания вынести основной функционал в отдельный сервис (мотивация: расширять driver-protocol и processing крайне не рекомендуется, из py2 скорее всего не получится ходить в postgresql)
3. Настройка, включение и отключение фичи раскидана по множеству конфигов и экспериментов, нужно максимально сгруппировать все рубильники и регуляторы

## Предлагаемые решения
1. [1д] Объединяем коллекции code_dispatch_codes и code_dispatch_assignments в одну (code_dispatch.assignments) и переносим в postgresql (с учетом  разговоров с админами, удалением из монги, создание схем и всех остальные телодвижения): 
```
{
  'area_id': 'zenit' # уникальный идентификатор района код-диспатчинга
  'code': '123456' # уникальный код в рамках одного района код-диспатчинга
  'order_id': 'orderid' # id заказа
  'driver_id': 'driverid' # опционально id водителя (заполняется перед стартом процессинга)
  'park_db_id': 'parkid' # опционально id парка (заполняется перед стартом процессинга)
  'status':'pending|processing|assigned|error' # статус назначения: ожидание (бординг)|обработка кода (процессинг заказа)| заказ назначен | ошибка назначения
  'error_code': 'driver_not_found_in_tracker' # опционально код ошибки (нужен в т.ч. для последующей расшифровки на таксометре)
  'created_at': 'dtstamp' # время создания
  'updated_at': 'dtstamp' # время последнего обновления
  'changes': [...] # лог изменений
}
```
2. Создаем сервис (вероятно с названием codedispatch). Делам в нем следующий набор ручек
   * [1д] Создание сервиса, настройка БД
   * [3д] `/order/create` - внутренняя ручка (в будущем может стать клиентской при соответствующей доработке клиента), в которую будет ходить `ordercommit`, отвечает за генерацию кода для заказа с привязкой к зоне и запись связи заказ-код в `code_dispatch_assignments` (переносим соответствующий код из `ordercommit`)   
   * [3д] `/order/assign` - авторизованная водительская ручка, отвечает за назначение заказа на конкретного водителя (запись `driver_id` и `park_db_id` в `code_dispatch_assignments`) и подталкивает processing в stq (переносим код `driver/order/assign`)
   * [3д] `/assignment/status` - авторизованная водительская ручка для поллинга статуса назначения. Основная задача - наибыстрейшее обнаружение проблемы назначения заказа с расшифровкой (возможно на текущем этапе придется совместить с ручкой `codedispatch/order/assign`, чтобы не переделывать таксометр) 
   * [4д] `/drivers-lookup` - внутренняя ручка, в которую ходит lookup из stq - отвечает за поиск водителя, который ввел код заказа. Переводим эквайринг водителя с ручки svo на новую ручку из пункта ниже.
3. [3д] Добавляем в tracker возможность эквайринга конкретного водителя (наверно расширяем API /acquire). Будем ходить из lookup (stq).
4. [1д] Делаем единый эксперимент 3.0 для включения/выключения код-диспатчинга во всех его проявлениях (переименовываем plugin_code_dispatch в code_dispatch, удаляем dispatch_code_zenit).
5. [учтено в п.2] Рефакторим конфиги:
   * Объединяем CODE_DISPATCH_QUEUE_ZONES и CODE_DISPATCH_SETTINGS - делаем единый конфиг для настройки зон код-дисптча (можно обозвать CODE_DISPATCH_ZONES_SETTINGS). Возможно туда же нужно перенести (в качетчве настроек для каждой зоны отдельно) CODE_DISPATCH_INSTRUCTIONS, CODE_DISPATCH_ORDER_EXPIRE_TIME, CODE_DISPATCH_DRIVER_DUE_OFFSET (может какие-то еще, по каждому конфигу наверно надо отдельно обсуждать)
   * убераем костыльные конфиги CODE_DISPATCH_PROCESSING_CHECK_IN_TRACKER, CODE_DISPATCH_DRIVER_SEARCH_RADIUS (и возможно CODE_DISPATCH_DRIVER_DUE_OFFSET)
   * читаем CODE_DISPATCH_GENERATOR_SETTINGS (настройки генератора кода) в `codedispatch/order/assign` для парсинга и валидации кода введенного на таксометре
   * проверяем включенность CODE_DISPATCH_PROCESSING_ENABLED в местах связанных с процессингом заказа (codedispatch/order/assign, codedispatch/assignment/status, в lookup в stq)
6. [учтено] Делаем все по нормальному - отделяем логику от представления, бизнес-логику можно вынести в модель, представление отделить от http-хендлера и т.п.


ИТОГО: 19д


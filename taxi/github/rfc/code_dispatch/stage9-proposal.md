 
# Этап 9 (беклог доработок)
## Основные проблемы которые необходимо решить 

1. Нет возможности настроить несколько очередей с разными тарифами, опциями и точками посадки в одной зоне перекрытия.
2. Не проверяем водителя зарание и не контролируем въезд на линии по заданным требованиям.

На данном этапе не решаем задачу букинга произвольной машины в произвольном месте (кажется это отдельная история, в которой возможно даже не нужен код-диспатч). Т.е. продолжаем развивать тему Зенит Арены с диспатчем по коду в зонах перекрытий, с физической очередью машин, где пользователь не может выбрать произвольную машину и не работает обычный флоу заказа.

## Предлагаемые решения 
### Технически
1. Район в котором будет действовать код-диспатч (code_dispatch_area) разделяется на N линий физических очередей + M зон-парковок ожидания. Как могут выглядеть данные по ним в конфиге:
```
{
  [
    'code_dispatch_area_id': # идентификатор района, в котором осуществляется диспатч по коду
    { 
      queue_lines: 
      [
        {
          'line_id': 'line_3', # идентификатор линии
          'classes': [...], # тарифы
          'cars_requirements': {...} # другие требования к машинам (кресла, определенные квоты на грейды и т.д.)
          'max_count': 50 # максимальная вместимость линии          
        },
        ...
      ],
      waiting_zones:
      [
        {
          'zone_id': 'P11', # идентификатор зоны(парковки) ожидания
          'available_queue_lines': [...] # список линий, на которые возможен выезд с данной зоны ожидания
          'available_waiting_zones': [...] # список других зон ожидания, на которые возможен выезд с данной
                                           # возможно сюда также имеет смысл добавить примерное время перегона (или просто некие веса ребер) на другие зоны ожидания и линии
          'max_count': 100 # максимальная вместимость зоны (парковки)
        },
        ...
      ], 
      other_dispatch_available: true # возможен ли другой диспатч в этой зоне (например с подачей к пикап-поинтам по барабанам в шереметьево) 
    },
    ...
  ]
}
```
2. При попадании машины в зону ожидания (детектируем в labor) запускается проверка машины на соответствие общим требованиям и требованиям каждой линии (доработка ручки `codedispatch/driver/check`. По результатам проверки информация по машине о соответствии требованиям линий и текущем статусе пишется в  коллекцию `code_dispatch.driver_info`, поля примерно такие:
```
{
  'park_db_id': 'park_id',          
  'driver_id': 'driver_id',             
  'code_dispatch_area': 'svo',      
  
  'available_queue_lines': [...] # линии, требованиям которых удовлетворяет данный водитель
  'not_available_queue_lines' : [ # линии, требованиям которых НЕ удовлетворяет данный водитель
    {
      'line_id': 'line_1', # идентификатор линии
      'reasons': [...] # список причин по которым водитель не подходит
    }
  ]
  'status': 'waiting|in_line|failure' # статуc (в зоне ожидания|в очереди на линии|должен покинуть район код-диспатча)
  'reasons_for_failure': [...] # причины, по которой данный водитель не может принимать заказы
                              # и должен покинуть район код-диспатча или выполнить некоторые рекомендации
}
```
Если водитель прошел проверки, то ставим `status = waiting`, в противном случае `status = failure` и пишем причины в `reasons_for_failure`, после чего push-уведомлением вынуждаем дернуть ручку polling/state (см. п.6).
3. По мере заполнения/освобождения зон ожидания и линий необходимо перегонять машины с зон ожидания на линии. Здесь может быть 2 варианта реализации диспатча:
- Вариант, когда перемещение машин контролируем сами. Это можно реализовать через воркер в labor, который будет перегонять машины исходя из `available_queue_lines` и `time_activated`(положения в очереди) для каждого водителя и текущего распределения машин на графе, вершинами которого являются зоны ожидания и линии очередей, а ребрами - возможные переходы между ними. Перегон машин предположительно можно осуществлять при помощи сервиса reposition.
- Вариант Шереметьево - перемещение контролирует подрядчик. Он дергает соответствующую ручку (которую нужно написать) для получения информации какие машины можно нагонять на первую линию, и создает фиктивные заказы на эти машины (механизм уже существует и работает). В этом варианте мы просто должны отдавать подрядчику список подходящих водителей исходя из настроек соответствующей линии.
4. При попадании машины на линию-очередь проверяем требования по текущей линии и если водитель им соответствует, то в code_dispatch.driver_info ставим `status = in_line`, в противном случае `failure` и в любом случае push-уведомлением вынуждаем дернуть ручку polling/state (см. п.6)
5. В ручке polling/state ищем информацию о водителе в коллекции code_dispatch.driver_info и проверяем `status`. Если in_line - выставляем в секции code_dispatch признак отображения на таксометре формы ввода кода заказа. Если failure - выставляем  признак отображения причины неудачи с расшифровкой. Опционально можно показывать водителю подробную информацию по каждой линии с подробным описанием почему он не проходит по требованиям к конкретной линии. 

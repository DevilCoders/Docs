## Задача
Для проекта карго заказы по тарифу Курьер должны быть всегда по фиксе, вне зависимости от того, что говорит таксометр.
Собственно кейсы в которых надо фиксировать стоимость:
1. водитель завершил далеко от точки назначения
2. водитель не закрыл заказ, поехал кататься
3. водитель отменил заказ
4. пользователь отменил заказ, после того, как водитель его взял

### Кусок флоу заказа
1. Мы создаем заказ, в order_proc пишется поле fixed_price.
2. При переходе заказа в терминальный статус(complete, cancelled) мы пишем поля order.cost, order.driver_cost.cost - это финальная стоимость заказа для пассажира и водителя соответственно.
3. Процессинг берет order.cost, пишет его в order.payment_tech.sum_to_pay и запускает update_transaction, которая на основании sum_to_pay делает транзакции на оплату.

### Про переходы в терминальный статус
Это два варианта:
1. Ручка requestconfirm с переходом на статус complete или reject.
2. Ручка taxiontheway или int-api/orderscancel с отменой пассажиром.

### Requestconfirm на complete
1. Фикса, условия сброса в нее и тариф уходят есть в клиенте таксометра от сеткара.
2. При завершении поездки клиент проверяет эти условия и шлет цену заказа и метод расчета.
3. requestconfirm берет то, что прислал таксометр и собственно пишет cost'ы.

### Requestconfirm на reject
1. Если статус waiting и водитель провел в нем достаточно много времени(10 минут), то отмена будет платной для пассажира.
2. Если отмена платная, то ручка ее посчитает и запишет в cost'ы.

### taxiontheway
1. Сложная логика в OrderCanceller, которая решит, платная отмена или нет.
2. Расчет стоимости отмены в виде минималка+стоимость ожидания.
3. И все это пишется в cost'ы.


### Кейсы
1. водитель завершил далеко от точки назначения - это будет Requestconfirm на complete
2. водитель не закрыл заказ, поехал кататься - заказ в итоге закроет диспетчер и это будет Requestconfirm на complete. Пока не закроет, мы ничего не можем сделать.
3. водитель отменил заказ - Requestconfirm на reject
4. пользователь отменил заказ, после того, как водитель его взял - taxiontheway

### Как собственно решить задачу - обычный флоу
#### Кейсы 1-2, через Requestconfirm на complete
**Вариант 1(выбрали его)**
protocol/lib/src/views/requestconfirm/taxi_requestconfirm.cpp::DriverCost и GetCostInfo, примерно в этих функциях в самом начале делаем иф на тариф курьер и просто возвращаем data.order->fixed_price и data.order->driver_fixed_price

**Вариант 2**
Ставите тут еще один иф на тариф Курьер protocol/lib/src/views/requestconfirm/taxi_requestconfirm.cpp:1134, и полностью убираете старый наркоманский флоу с определением костов. 
Пишете в своей функции что-то вроде
```
bset.append("order.cost", data.order->fixed_price);
```
И вуаля, готов cost. Кажется, ничего из того, что было бы записно, вроде calc_info, вам не нужно.

#### Кейс 3, водитель отменил заказ - Requestconfirm на reject
Тут чуть похуже, вам нужно повлиять на две вещи:
1. факт того, что отмена платная. Это здесь protocol/lib/src/views/requestconfirm/data.cpp/UpdatePaidCancel
2. собственно стоимость платной отмены. Это CalcCancelCost там же.

#### Кейс 4, юзер отменил заказ - taxiontheway
Тут чуть похуже, вам нужно повлиять на две вещи:
1. факт того, что отмена платная. Это в protocol/lib/src/orderkit/order_canceller.cpp/CurrentCancelState
2. собственно стоимость платной отмены. Это CalcPaidCancelCost там же.


### Как собственно решить задачу - декаплинг
 - У декаплинга полностью своя логика определения цены. В requestconfirm на complete у нас просто свое флоу определения костов. В отменах мы не влияем на определение факта платная отмена или нет, но заменяем расчет
 - Мы не пишем order.driver_cost.cost. Мы пишем order_proc.decoupling.user_price_info.cost и .driver_price_info.cost, в payment_tech.to_pay едут тоже наши косты.
 - Антифрод на корпы не запускается

#### Кейсы 1-2, через Requestconfirm на complete
Вот тут protocol/lib/src/views/requestconfirm/decoupling.cpp:377 ставим иф на тариф Курьер и пишем
```
decoupling_cost_info.user = CalcDecouplingUserCostFixedCalcMethod
decoupling_cost_info.driver = CalcDecouplingDriverFixedPrice
```
Получим косты по фиксе из order_proc + стоимость платного ожидания, как ее пришлет таксометр. Косты запишутся и поедут уже сами.

#### Кейсы 3-4, водитель или юзер отменил заказ - Requestconfirm на reject и taxionteway
Расчет платной отмены у нас единый для обоих кейсов.
Вот тут ставим иф на Курьер protocol/lib/src/common/decoupling.cpp:286 и
```
    decoupling_cancel_cost.user.cost = decoupling_info.user_price_info.fixed_price
    decoupling_cancel_cost.driver.cost = decoupling_info.driver_price_info.fixed_price
```
Косты запишутся и поедут уже сами.

Вероятно, придется дотащить инфу о классе заказа, кажется ее там нет.


### Кажется, это неважно
#### Антифрод(запускается для заказов по карте, кошельку, apple/googlepay для пассажиров, которым анти фрод не доверяет)
1. Мы создаем заказ, в order_proc пишется поле fixed_price.
2. Фикса, условия сброса в нее и тариф уходят в клиент таксометра через сеткар.
2. Таксометр сложным путем пишет в поле order_proc.order_info.cc фиксу, возможно с ожиданием. Антифрод смотрит на эту сумму, выбирает какую часть ее оплатить, пишет эту часть в order.payment_tech.sum_to_pay. И запускает update_transaction, которая на основании sum_to_pay делает транзакции на оплату.
3. Процессинг берет order.cost, пишет его в order.payment_tech.sum_to_pay и запускает update_transaction, которая на основании sum_to_pay делает транзакции на оплату. Или еще списывает или возвращает после антифрода.

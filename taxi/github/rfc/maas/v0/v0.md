
# Описание проекта MaaS 

Совместно с Мосметро продаем абонементы для поездок на Метро и Такси.
Абонемент имеет ограниченный период действия и предоставляет пользователю:
- неограниченное количество поездок на Метро
- ограниченное количество поездок на Такси, для каждой их которых накладываются доп ограничения:
  - поездка должна быть либо к Метро либо от Метро
  - поездка должна быть в пределах некоторого радиуса от метро (~~5км)
  - поездка имеет ограничение по стоимости (~~1000р)
  
**Мотивация:** 
- GR проект
- протестировать оффер, который фиксирует полную стоимость поездки — с точки зрения привлекательности пользователям:
  - польза для нас: повышение частотности и улучшенный прогноз спроса
  - польза для пользователя: страхование от сурджа


**Аналитика:** 
- до ближайшего метро — 2% от всех поездок в Москве 
- из любой точки Москвы до ближайшего метро ехать <= 5 км — то есть можно делать продукт «абонемент на поездку до ближайшего метро» 
- 80% поездок до ближайшего метро укладываются в 210₽ — очень скученно в районе 160-180₽


# Метрики

Метрики, на которые будем смотреть в первую очередь:
- активность пользователя c абонементом (поездок в месяц) в сравнении с обычной активностью
- утилизация / горение (сколько забираем себе)
- реальная средняя стоимость поездки / субсидии водителям

Ориентировочные цели в пилоте:
 - продать 10к абонементов
 - выкатать 100к поездок 




# Реализация

В проекте принимают участие 3 стороны со следующими ролями:

- **ВТБ** - основное связующее звено между всеми транспортными сервисами MaaS. Отвечает за матчинг пользователей Яндекса и Мосметро и создание единого maas-пользователя. Реализует процессинг оплаты абонемента. Предоставляет всем участникам MaaS доступ к единой базе тарифов, пользователей и приобретенных ими абонементов (подписок). 
- **МосМетро** - продает абонемент. В приложении Мосметро отображает маршрут такси до ближайшего метро и по диплинку открывает приложение YandexGo. Позволяет пользователю совершить поездку на метро по абонементу, используя привязанную к абонементу банковскую карту. Передает/получает информацию о совершенных поездках на метро/такси в/от ВТБ.
- **ЯндексGo** - предоставляет точку входа для покупки абонемента (сама покупка осуществляется через WebView ВТБ). Позволяет пользователю совершать поездки к/от метро по абонементу. . Передает/получает информацию о совершенных поездках на такси/метро в/от ВТБ.

В теории возможно расширение списка участников (и возможно продажа более сложных составных продуктов). Например на данный момент в MaaS также участвует Велобайк, но в пилоте мы делаем совместный абонемент только с МосМетро.  


На текущий момент отдельно проработано взаимодействие с ВТБ/Мосметро:
- [API](https://github.yandex-team.ru/taxi/rfc/blob/master/maas/v0/external%20interaction/maas_external.yaml)
- [описание API](https://github.yandex-team.ru/taxi/rfc/blob/master/maas/v0/external%20interaction/maas-external.md)
- [sequence diagram](https://github.yandex-team.ru/taxi/rfc/blob/master/maas/v0/external%20interaction/yandex-vtb-mm.plantuml)

Абонемент реализовываем на нашей стороне как надстройку над промокодами. Для этого создаем следующие сервисы: 
- `maas` - сервис будет отвечать за хранение данных о maas-пользователях. А также за логику выбора точек B при поездке до ближайшего метро
- `maas-authproxy` - открытый наружу сервис для всех внешних ручек, в которые будет ходить ВТБ. Задача сервиса - авторизовать внешний запрос и проксировать его во внутренний сервис `maas`. 


![картинка](https://jing.yandex-team.ru/files/andreykostin/maas%20-%20principal%20diagram.png)

В будущем сервис `maas` может быть разделен на 2 сервиса:
- `maas-users` - для работы с пользователями
- `maas-subscriptions` - для работы с абонементами 

В первой MVP-версии пока предлагаю срезать на этом и делать общий сервис `maas`.

Все ручки сервиса maas-authproxy будут реализованы следующим образом:
1. получили запрос в ручку `/maas-authproxy/v1/<handler>`  
2. авторизовали запрос по API key (проверка хэш(секрет+ключ) == хэш_из_конфига )
3. перенаправили запрос во внутренний сервис `maas` (в соответствующую ручку `/maas/v1/<handler>` )
4. при необходимости запросы/ответы могут адаптироваться пот внутренний/внешний API, но скорее всего мы будем просто проксировать запросы как есть. 

> Далее везде, где упоминается внешний запрос (от ВТБ/Метро), то всегда подразумевается запрос, который проходит следующий путь:
> `/maas-authproxy/v1/handler` (сервис `maas-authproxy`) ->  `/maas/v1/handler` (сервис `maas`)



## Пользователь MaaS

Пользователь maas - это попытка создать единого пользователя Такси + МосМетро и присвоить ему идентификатор `maas_user_id`.

При первой покупке абонемента мы будем матчить наших пользователей и пользователей Мосметро по номеру телефона. На стороне метро телефон обязателен. На нашей стороне пользователю также придется указать номер, чтобы абонемент пророс в его YandexGo (Сообщаем об этом пользователю при покупке абонемента). 

При последующих покупках идентификатором пользователя будет являться `maas_user_id`, который будет присвоен пользователю на стороне ВТБ при первой покупке абонемента. На нашей стороне мы привяжем этот идентификатор к найденному `yandex_uid` (портальный предпочтительней, но если его нет, то привяжем у фонишу). 

Нужно учитывать, что пользователь может купить абонемент на стороне Мосметро - в этом случае в момент покупки на нашей стороне пользователя может еще не существовать, поэтому мы будем хранить связь `maas_id -> personal_phone_id`, и привяжем его к `yandex_uid` уже после того, как пользователь авторизуется. 

На текущий момент исходим из того, что  `maas_user_id` всегда соответствует только 1 номер телефона. В идеале `maas_user_id` должен быть привязан к человеку, а не к телефону (хотя бы потому, что банковская карта, по которой будет осуществляться проход в метро, привязана к человеку). Предполагается, что при смене телефона пользователем в одном из сервисов партнеры MaaS будут уведомлять друг-друга. 

Нужно учитывать, что если пользователь зарегистрирован c нашей стороны по фонишу, то при смене телефона он потеряет свой промокод. 
~~**TBD:** здесь нужно понять должны ли мы при смене телефона оставлять промокод у старого фониша или мы должны его аннулировать и выдать новый промокод новому фонишу. А если абонемент привязан к портальному, то непонятно, должны ли мы привязывать к нему новый фониш по телефону, который получим от ВТБ, или пользователь должен сделать это своими руками.~~
В пилоте договорились о том что не будем распространять смену телефона пользователя между транспортными сервисами.

При хранение пользователей в бд `db_maas_users` будем соблюдать следующие правила:
1. в каждый момент времени связь `maas_user_id` -> `personal_phone_id` должна быть 1:1 
2. Если связь `maas_user_id` -> `yanex_uid`  может быть определена, то она должна быть также 1:1

> В идеальном мире с п.2 у нас не должно было бы возникнуть никаких проблем. Но реальность такова, что у пользователя может существовать множество фониш аккаунтов и ни одного портального - в этом случае нам будет сложно выбрать какой-то 1 фониш  (потому что при авторизации паспорт использует какую-то свою сложную логику для выбора нужного фониша) - проще всего нам будет отложить этот выбор до момента авторизации пользователя. В случае, если мы найдем портальный uid, то в подавляющем большинстве случаев для personal_phon_id -> yandex_uid у нас будет связь 1:1, но, в общем случае связь может оказаться многие:многие, и если мы столкнемся с этой проблемой, то будем поступать также, как с фонишем.


### Дешевое решение для матчинга пользователя (для MVP)

Вместо yandex_uid иcпользовать phone_id, который никогда не протухает (но может смениться в процессе удаления  через takeout). Это позволит легко и однозначно идентифицировть пользователя. А во время авторизации получить phone_id сразу в заголовке (не нужно искать связанных uid). 

Минусы:
- при смене телефона в Такси maas_id отклеивается от этого пользователя (но он сможет перепройти регистрацию при покупки нового абонемента). 
- phone_id - это таксишное легаси, которое не рекомендовано использовать (потому что номер телефона может переходить от одного пользователя другому и phone_id перейдет вместе с ним).

Кажется, что для пилота перечисленные минусы можно считать несущественными. А в будущем нам не составит труда перейти с phone_id на yandex_uid.


### Создание пользователя MaaS 
Если пользователь не покупал ранее абонемента, т.е. для него еще не задан `maas_user_id`, то нам необходимо его зарегистрировать
В зависимости от того, с чьей стороны пользователь совершает первую покупку его создание может инициировать Яндекс.Такси или Мосметро. Во всех случаях создание пользователя происходит через API ВТБ, которое по номеру телефона создает новый `maas_user_id` и уведомляет об этом всех участников MaaS.

#### Создание пользователя MaaS - инициатор YandexGo
Если мы инициируем создание пользователя, то нам нужно передать номер телефона на сторону ВТБ/Метро. Чтобы сделать этот процесс прозрачным для пользователя, мы будем явно отображать на экране тот номер телефона, который собираемся послать (если у пользователя нет номера, то мы попросим его ввести). Для регистрации пользователя создадим отдельную клиентскую ручку `/4.0/maas/v1/user/register`, которая будет вытаскивать телефон пользователя по `yandex_uid` и передавать его в API ВТБ.
В базу `db_maas_users` записываем связь `maas_user_id` -> `personal_phone_id` и `maas_user_id` -> `yandex_uid`. uid берем портальный если есть,или фониш, который пришел от `passenger-authorizer`.

#### Создание пользователя MaaS - инициатор Мосметро
В этом случае ВТБ уведомит нас через ручку `/maas-authproxy/v1/users/create`, в которую передаст телефон и `maas_user_id`. В этой ручке мы сохраняем в бд `db_maas_users` связь `maas_user_id` -> `personal_phone_id`, а также пытаемся найти и сохранить связь  `maas_user_id` -> `yandex_uid` (портальный предпочтительней)

**Примерная реализация:**
1. Получаем `phone_personal_id`: идем в `personal` в `/v1/phones/bulk_store` и по номеру телефона получаем `phone_personal_id` (если такого id нет, то он будет создан). 
2. Записываем в бд `db_maas_users` связь `maas_user_id -> phone_personal_id`  
3. Пытаемся найти `phone_id`: идем в `user-api` в ручку `/user_phones/by_personal/retrieve` и по `phone_personal_id` получаем `phone_id` (вроде как помечено deprecated, но при этом другого варианта на данный момент вроде бы нет)
4. **Если пользователь нашелся**: 
   1. Получаем `yandex_uid`: идем в `zalogin` в ручку `/v1/internal/phone-info` и по `phone_id` получаем все связанные `yandex_uid`. 
   2. Среди полученных `yandex_uid` пытаемся найти портальный, если находим записываем связь `maas_user_id` -> `yandex_uid` 
   3. Если среди полученных `yandex_uid` не нашлось портального, то ничего не делаем, ждем пока пользователь к нам придет с каким-то конкретным фонишем.
5. **Если не нашли пользователя на нашей стороне**: ничего не делаем. Будем ждать пока пользователь сам придет и зарегистрируется в такси. В какой-то момент этот пользователь постучится к нам в ручку `/subscription/info` и там мы его по `personal_phone_id` сматчим.

**Альтернативная дешевая реализация для MVP**
После того как нашли `phone_id` - сразу пишем в базу и ничего не делаем



## Абонемент MaaS

Абонемент будет иметь неограниченное количество поездок на метро и фиксированное количество поездок на Яндекс.Такси. А также будет ограничен по времени действия. С точки зрения Яндекс.Такси абонемент может находиться в одном из следующих состояний:
- reserved - зарезервирован, но не активирован, не виден пользователю (промокод не выдан, но мы готовы это сделать по предложенным условиям тарифа)
- activated - активирован, доступен для использования (промокод выдан)
- expired - срок действия абонемента истек - терминальный статус (промокод просрочен)
- canceled - аннулирован и не может быть использован (например в следствии неудавшейся оплаты) - терминальный статус (промокод не выдан или отозван)

Уникальным идентификатором абонемента является `pass_id` - его определяет ВТБ. Т.к. промокод выдается пользователю по `yandex_uid`, то и абонемент также привязывается к конкретному `yandex_uid`. Но т.к. непосредственно в момент покупки с нашей стороны мы можем не найти пользователя, то абонемент какое-то время может жить без привязки к `yandex_uid` (промокод в этом случае не выдается - ждем пока пользователь приедет с нашей стороны). В общем случае абонемент всегда привязан к `maas_user_id` и имеет какой-то тариф определенный через `tariff_id`.

**Ограничения для пилота:** в каждый момент времени пользователь сможет иметь только только 1 активный абонемент. Т.е. в каждый момент времени по одному `maas_user_id` не может существовать более одного абонемента со статусами `reserved|activated`.
(Это ограничения со стороны нашего UI, а также со стороны ВТБ/Метро)



## Покупка абонемента

Пользователь может купить абонемент либо на сайте/приложении Мосметро, либо в YandexGo. И в том и другом случае оплата производится на стороне Мосметро (при участии ВТБ).

Не зависимо от того с чьей стороны будет инициирована покупка абонемента, будут выполнены следующие этапы:

1. Если покупка происходит в первый раз, то ВТБ создает maas-пользователя и присваивает ему `maas_user_id`  (см. раздел про создание пользователя). Если пользователь уже существует, то никаких действий не требуется.
2. Перед оплатой абонемента, ВТБ должно зарезервировать его на нашей стороне - для этого они отправляют запрос в ручку `/maas-authproxy/v1/subscription/reserve`. Возможные причины отказа в резерве:
   - закончился бюджет для выдачи промокодов. **TBD:** кажется бюджет может быть неограничен.
   - только для пилота: у пользователя есть активный абонемент, т.е. cо `status=activated|reserved`
   - антифрод (в пилоте наверное ничего такого здесь не будет)
   - условия тарифа не соответствуют ни одному из вариантов заданных на нашей стороне (в пилоте задаем конфигом)
   - `user_token` не соответствует пользователю с переданным `maas_user_id` - только в том случае, если покупка происходит через YadexGo (см. особенности покупки через YandexGo)
   - разные маловероятные технические ошибки (например абонемент с этим id уже выдан другому пользователю) - но от них придется тщательно защититься, т.к. это будут запросы с внешней стороны
3. Если продажа абонемента возможна, то в базу `db_maas_subscriptions` пишем:
    - `pass_id` - внешний id абонемента
    - `tariff_id` - внешний id тарифа
    - `maas_user_id` 
    - `promocode_series_id` - серия промокодов, подходящая под заданные условия
    - `expiration_datetime` - срок действия
    - `status=reserved` - статус
    - `yandex_uid` - только в том случае, если существует связь `maas_user_id -> yandex_uid`
    - `tariff_info` - условия тарифа (стоимость, кол. поездок, длительность в днях - как минимум в пилоте пригодиться, потом можно будет избавиться)
4. ВТБ запускает оплату (а если мы решили что не можем продать, то не запускают и возвращают пользователю ошибку).
5. Если оплата завершена успешна, то ВТБ дергает `/maas-authproxy/v1/subscription/activate` с ранее определенным `pass_id`. В результате чего абонемент активируется и становится доступен для использования пользователем. **Реализация:**
   1. Если к этому моменту с нашей стороны уже существует связь `maas_user_id -> yandex_uid`, то стьавим stq-таску, в которой выдадим пользователю промокод через ручку `/internal/generate` (сервис `coupons`). Выданный промокод пишем в `db_maas_subscriptions`. **TBD:** нужно понять, что здесь может пойти не так, и что с этим можно сделать (к этому моменту пользователь уже оплатил абонемент и мы должны выполнить свою часть сделки).  
   2. В базе `db_maas_subscriptions` по `pass_id` изменяем статус на `activated`.
   3. Если мы не нашли связь `maas_user_id -> yandex_uid`, то ничего не делаем. Будем ждать пока пользователь объявится. 
6. Если оплата завершена неуспешно, то ВТБ дергает `/maas-authproxy/v1/subscription/cancel`, в результате чего абонемент будет аннулирован, т.е. перемещен в статус `canceled`. 

**Альтернативный вариант реализации:** можно выдавать промокод пользователю в момент его резерва и не давать его использовать пока ВТБ не сообщит нам об успешной оплате (перед примением промокода будет производиться его внешняя валидация, которую мы реализуем в cервисе `maas` и в которой будем проверять, что абонемент находится в статусе activated). А в ручке `/maas-authproxy/v1/subscription/cancel` отзывать промокод при помощи ручки `/3.0/coupondeactivate` (для которой нужно будет сделать внуреннюю варсию) Но этот вариант нас всеравно не избавляет от той проблемы, что пользователь может не сущетсвовать с нашей стороны на момент покупки, а значит здесь мы также можем столкнуться с проблемой выдачи промокода уже после того, как пользователь заплатил за абонемент.

### Особенности покупки через YandexGo

![дизайн экрана покупки](https://jing.yandex-team.ru/files/andreykostin/Spectacle.K17076.png) 

Точка входа - шорткаты.


#### Отображение доступных тарифов (покупка через YandexGo)
В сервисе `maas` создаем клиентскую ручку `/4.0/maas/v1/product-info`. Ручка будет ходить в соответствующую ручку ВТБ, которая будет приниматься на вход `maas_user_id`. 
В случае, если maas-пользователь существует, ручка `/4.0/maas/v1/product-info` вернет:
- `maas_user_id` 
- список существующих типов абонементов с описанием каждого
- все необходимые элементы UI
В случае, если если maas-пользователь не существует (т.е. это первая попытка купить абонемент), то ручка  `/4.0/maas/v1/product-info` вернет 401. Получив такой ответ, приложение должно будет предложить пользователю зарегистрироваться в MaaS (см. раздел про создание пользователя) 

**Альтернативный вариант реализации:** в случае, если `maas_user_id` не существует, мы можем использовать API ВТБ, которое не требует `maas_user_id` (такой вариант тоже будет реализовываться). Минус здесь в том, что в этом случае мы лишаем ВТБ/Метро возможности сегментировать пользователя, а также показываем пользователю те тарифы, которые возможно будут ему недоступны. А плюс в том, что мы сразу можем показать пользователю предлагаемые условия, не заставляя его перед этим регистрироваться (регистрацию запустим только в том случае, если пользователь захочет купить абонемент).

#### Оплата через WebView ВТБ  (покупка через YandexGo)
После того, как пользователь сделает свой выбор, мы отправляем его на экран оплаты, который будет реализован через WebView ВТБ. В качестве параметров в WebView мы будем передавать:
- `maas_user_id` 
- `tariff_id` - id тарифа покупаемого абонемента
- `user_token` - токен aвторизации пользователя, который будет использован для проверки на этапе резервирования абонемента на нашей стороне

Токен создаем на нашем бэке и записываем `hash(token+salt)` в нашу базу `db_maas_users` по `yandex_uid` с некоторым ttl. Когда ВТБ придет к нам в ручку `/maas-authproxy/v1/subscription/reserve`, то мы проверим переданные в эту ручку `user_token` и `maas_user_id`



### Особенности покупки через Мосметро

Покупка происходит через приложение или через сайт Мосметро.
Основные отличая от покупки через YandexGo:
- не используем для проверки пользователя `user_token`.
- если maas-пользовтеля не существует то ВТБ создаст его и уведомит нас о его создании
- на нашей стороне пользователя может не существовать как в момент создания maas-пользователя так и в момент продажи абонемента 

#### Отображение доступных тарифов (покупка через Мосметро)

Мосметро/ВТБ должны будут придти к нам в ручку чтобы получить список доступных для данного пользователя тарифов.На текущий момент мы договорились о 2х возможных вариантах:
 - `/maas-authproxy/v1/available-tariffs` - отдает информацию о доступном количестве абонементов для продажи по каждому тарифу (пока предполагается, что Метро/ВТБ будут дергать эту ручку раз в день)
 - `/maas-authproxy/v1/available-tariffs/user` - отдает информацию о доступных тарифах для конкретного maas-пользователя (если пользователь к этому моменту еще не существует, то его придется предварительно создать через ручку `/maas-authproxy/v1/user/register`). Здесь мы сможем предварительно провести все те же проверки по этому пользователю, которые мы осуществляем в `/maas-authproxy/v1/subscription/reserve`
  
В обеих ручках ВТБ/Метро передает нам условия тарифов, которые мы будем проверять на соответствие нашим внутренним условиям тарифов для абонемента.

#### Регистрация пользователя после покупки абонемента через Мосметро

Наша основная задача здесь: правильно привязать `yandex_uid` к `maas_user_id`. Все что для этого нужно - получить авторизованный клиентский запрос в одну из следующих ручек: 
- `/4.0/maas/v1/subscription/info` - ручка для получения информации о действующем абонементе 
- `/maas/v1/shortcut` - ручка отдающая шорткат для поездки по абонементу

В этих ручка реализуем следующий алгоритм поиска maas-пользователя:
1. Ищем `maas_user_id` по `yadex_uid`. Если нашли, значит успех.
2. Если не смогли найти, то пытаемся получить для этого пользователя `personal_phone_id` и найти по нему `maas_user_id`. Если смогли найти, то в базу `db_maas_users` записываем  `yadex_uid`: если в запросе пришел фониш, то пытаемся по нему найти портальный и использовать его, если не находим, то берем тот фониш, что пришел в запросе. Далее:
   1. По этому пользователю в `db_maas_subscriptions` ищем абонемент со статусом `reserved|activated` и также привязываем к нему `yandex_uid`
   2. ставим stq таску, в которой по найденному абонементу выдададим пользователю промокод через ручку `/internal/generate` в сервисе `coupons`, а затем запишем его значение в `db_maas_subscriptions`. **TBD:** Что делать, если не вышло выдать пользователю промокод? 
3. Если `maas_user_id` так и не нашли, то пишем в базу `db_maas_users`: `yandex_uid` + `personal_phone_id` + `maas_user_id=None` - если в следующий раз найдем натукую запись на этапе 1, значит можно не пытаться продолжать поиск. При этом, если в дальнейшем maas-пользователь будет создан, то мы просто добавим по этому `personal_phone_id` новый `maas_user_id`, а `yandex_uid` уже будет автоматически задан.

> С учетом того, что по одному `personal_phone_id` могут существовать множество `yandex_uid`, а `personal_phone_id` является уникальным, то при осуществлении записи в бд в п.3 мы будем всякий раз переписывать `yandex_uid` на более свежий. При этом это никак не повлияет на уже выданные промокоды - они останутся закреплены за старыми `yandex_uid`.

> Данный подход может дать достаточно большую нагрузку на сервис `zalogin` (до 1000RPS). Чтобы ее уменьшить мы можем записывать в бд отрицательные результаты матчинга пользователей, и при повторных запросах использовать их.


**Как MVP вариант**:
Будем матчить пользователя не по uuid, а по phone_id (который получим в хедере авторизации) - такой подход избавляет нас от надобности ходить в другие сервисы.



## Поездка на Такси 

С точки зрения процессинга заказа - почти ничего не меняется, заказ будет оплачен промокодом. 
Основные изменения коснуться:
- точки входа для использования специального промокода-абонемента
- выбора пользователем точек A и B
- проверки промокода перед и в конце поездки. 
  
![картинка](https://jing.yandex-team.ru/files/andreykostin/Spectacle.D17076.png)


### Точка входа

Точкой входа будет являться кнопка в шорткатах (приходит в ответе `/products`), которая будет являться переходом на `ловушку вертикали` для абонемента (как это сейчас делается например для вертикали доставки). 

Вертикаль абонемента должна быть скрыта в обычном режиме саммари, т.к. на текущий момент саммари+роутстатс умеют работать только с 1 промокодом, а значит этот режим мы должны оставить для использования обычных промокодов (сейчас клиенты просто берут первый из списка промокод и отправляют его в `/routestats`). 

Для этой вертикали в `/zoneinfo` мы будем передавать специальный флаг, означающий, что она должна быть скрыта до тех пор пока клиенты не получат ее в ответе `/routestats` или при переходе на нее в режиме ловушки. Кроме того для этой вертикали мы добавим отдельный флаг, означающий, что она используется для поездки по абонементу - он послужит сигналом для клиентов слать в `/routestats` промокод абонемента (вместо обычных промокодов). **TBD:** возможно также здесь стоит добавить отдельный для этой вертикали список доступных методов оплаты (у нас будет разрешена только карта). 

Промокод абонемента клиенты будут получать через ручку `/4.0/subscription/info`. При этом среди обычных промокодов, полученных от сервиса `coupons` через существующую ручку, не будет промокода на абонемент (мы отфильтруем его в выдаче по новому сервису `maas`).

В ручке `/products` мы будем отдавать кнопку ловушки только если у данного пользователя есть действующий абонемент. Если по какой-то причине в `/products` ловушка пришла, а в `/4.0/subscription/info` абонемент не пришел (т.е. клиентам нечего отправить в routestats в качестве промокода на абонемент), то клиенты будут отправлять пользователя на страницу покупки абонемента.

В идеальном мире клиенты не должны ходить в ручку `/4.0/subscription/info` до тек пор пока не получат в `/products` ловушку на вертикаль абонемента (чтобы не давать лишней нагрузки на сервис `maas`). 


**TBD:**

Мы должны ограничить разрешенные способы оплаты в этой вертикали (только карта). Для этого предлагается в ответе `/routestats` слать `tariff_unavailable`, если выбран не тот способ оплаты, (и в `message` можно любой текст прислать). И чтобы автоматически переключать выбор пользователя на выбранную ранее карту предлагается сохранять его в `/personalstate` - добавляем там новое поле в `selected_options_in_verticals`


### Выбор доступных точек A и B

Выбор точек обусловлен следующими ограничениями:
 - одна из точек должна находиться у метро
 - другая точка не более чем в 5км от Метро
 - зона действия абонемента - везде где есть Московское Метро + 5км. 

Все ограничения по дальности расположения точек будем считать по прямой, а не по дальности пути. Преимущества такого подхода в следующем:
- дешевле разработка
- для пользователя более прозрачная и понятная логика ограничений


**При поездке к метро:**

При поездке к метро будем предлагать пользователю список ближайших доступных станций на выбор.
Для этого создаем клиентскую ручку `/4.0/maas/v1/nearest-metro`, которая будет отдавать доступные для текущей точки А места высадки у метро. Точки стоит искать на расстоянии не более ~5км от точки A. Также стоит ограничить максимальное количество выдаваемых точек в ответе (в центре Москвы их может быть очень много) 

Для поиска точек метро в заданном радиусе можно использовать сервис `masstransit`. 
В сервисе уже реализована логика по работе с остановками общественного транспорта. Наиболее похожая на то что нам нужно ручка - `/v2/stops` - можно на ее основе создать рядом нужную нам ручку. **TBD:** либо мы можем просто получать от сервиса все станции метро Москвы и кэшировать их в сервисе `maas` и в нем уже сами будем делать поиск ближайших станций. С учетом того что станций всего 278 - по ним по всем можно просто пробежаться в цикле и померить линейное расстояние - это будет быстро. Для оптимизации можем все точки заранее перевести в проекцию Меркатора и просто считать линейное расстояние в ней. 
И в идеальном мире для найденных ближайших станций мы должны дополнительно еще пробежаться по возможным пикап-поинтам и выдать ближайший.

По-хорошему мы должны также позволить пользователю поставить точку B у метро самому но с некоторым ограничением по расстоянию от точек выхода метро. В пилоте это ограничение можно было бы упростить и проверять удаленность точки A/B только от центра станции (проверку делать в ручке валидации промокода).

Проработаем отдельно здесь: [TAXIBACKEND-35927](https://st.yandex-team.ru/TAXIBACKEND-35927)

**При поездке от метро:**

При поездке от метро флоу выбора точек для пользователя практически ничем не будет отличаться от обычного флоу: в саджесте он найдет соответствующее метро и поставит произвольно точку B. Если routestats при этом в ответе укажет о недоступности использования промокода, то на клиентах мы покажем сообщение, в котором мы предложим пользователю переставить точки. Проверка точек будет осуществляться при валидации промокода в ручке `/maas/check-promocode`.

**TBD:**  

Разумно было бы отображать все доступные области выбора точек на карте (как для точки A, так и для B в обоих направлениях поездок), но в пилоте скорее всего не будем это делать.

Также разумно было бы отдавать такие пины у метро, где разрешена бесплатная стоянка, проработаетм здесь:[TAXIBACKEND-35927](https://st.yandex-team.ru/TAXIBACKEND-35927)

### Валидация промокода (активация в coupons)


Валидация промокода будет производиться в момент создания офера (на саммари) и в момент завершения поездки. Что будем проверять:
- расстояние по прямой между точками A и B должно быть не более 5 км
- одна из точек A и B должна находиться в некоторой близости от метро (в идеале мы должны смотреть на расстояние от выходов метро, и возможно стоило бы заранее обрисовать для каждой станции разрешенную область и возможно в будущем мы захотим для некоторых станций задать ее руками). В пилоте же мы может просто в цикле пробежаться и померить расстояния от центров всех станций (их всего 278). Все станции можем получить от сервиса `masstransit` и закэшировать их. **TBD:** возможно для этого подойдет уже существующая ручка `/v1/stops` или `/v2/stops`
- отсутствие промежуточных точек
- поездка должна быть завершена у изначальной точки B (проверяем что заказ не сброшен на таксометр)
- стоимость поездки должна быть не более предельной (частичную оплату по промокоду не разрешаем). При проверки этого условия мы не должны учитывать стоимость платного ожидания (платное ожидание разрешаем пользователю оплатить сверху из своего кармана)
- метод оплаты должен быть карточным (эта проверка и так есть сейчас и она должна быть по хорошему перенесена из py2 в coupons)
  

**Проверка промокода в coupons:**

На данный момент валидация промокодов происходит перед созданием офера при проходе `routestats -> pricing -> coupons`  

При проверке maas-промокода сервис `coupons` будет ходить в сервис `maas` в ручку `/check-promocode` (аналогично тому, как сейчас происходит проверка промокодов Лавки). 
В параметры запроса нужно будет добавить маршрут заказа (A, B и промежуточные точки) и прокидывать их в `/check-promocode`. Как быстрый вариант реализации - можно делать это через существующее поле payload (туда сейчас можно положить любой json).

**Проблемы с таймингами в coupons:**
Сейчас у ручки  `/couponcheck` существуют проблемы c таймингами - сервис таймаутит в 1% - 5% случаев (прайсинг не ретраит ручку чтобы не афектить роутстатс). Для нас это означает, что пользователь не сможет воспользоваться промокодом 
Возможно, что мы можем позволить себе запуститься с этим в пилоте - по умолчанию в этом сулчае мы попросим пользователя изменить точку A или B и скорее всего ему повезет при повторном походе в routestats. 

Возможные варианты доработок в coupons, которые могут улучшить ситуацию:
- распараллеливание внешних проверок (сейчас они происходят последовательно) 
- уменьшение таймаутов при походе в cardstorage: сейчас теряем там 180 сек (из 300 имеющихся у нас в распоряжение) и в 50% случаев ловим таймаут - в этом сулчае используется фолбэк (ответ от другой ручки cardstorage у которого тайминги 50мс)
- перейти с монги на postgress
 
**Проверка промокода в прайсинге:**

Все проверки связанные с ценой и сбросом с фиксы на таксметр должны быть реализованы в прайсинге.

**Пробрасывание ошибки валидации в routestats:**

**TBD:** В MVP варианте делаем плагин в роутстатс, который в случае признака `coupon.valid_any=true` вернет клиентам сообщение типа такого: "Для выбранных точек A и B поездка недоступна, попробуйте изменить маршрут".
В случае же признака `valid=false` клиенты должны будут перейти на сайт покупки промокода
В идеальном мире мы должны научиться пробрасывать полноценную расшифровку ошибки по всей цепочке `maas -> coupons -> pricing -> routestats` или, как менее предпочтительный вариант, повторить все проверки купона в плагине `routestats` и сформулировать сообщение там.


### Просмотр информации об оставшихся поездках

![картинка](https://jing.yandex-team.ru/files/andreykostin/Spectacle.w17076.png)

Делаем 2 ручки:
`/4.0/maas/v1/subscription/info` - клиентская ручка, которая отдаст информацию о текущем статусе абонемента и оставшихся поездках 
`/maas-authproxy/v1/subscription/info` - внешняя ручка для ВТБ/Метро, которая также отдаст информацию по абонементу

При этом нам необходимо убрать промокод абонемента из выдачи сервиса coupons. Для этого в `coupons` мы добавим новый тип сервиса `maas` и будем отфильтровывать в выдачи промокоды этого сервиса.


## Рефанд 
Рефанда не будет. Компенсировать можно выдачей промокодов.



## Переход в приложение YandexGo из приложения Мосметро 

Переход будет осуществляться через диплинк следующего формата:

`yandextaxi://nearest-metro?pass_id=1234&lat_a=55.1&lon_a=37.1&lat_b=55.2&lon_b=37.2`

где  все параметры являются необязательными и имеют следующее применение:  
- `pass_id` — идентификатор абонемента. Если не передан, то будет выбран последний использованный/приобретенный абонемент
- `lat_a`, `lon_a` — координаты точки А. Если не переданы, то по умолчанию будут использованы координаты текущего местоположения пользователя.
- `lat_b`, `lon_b` — координаты точки B. Итоговая точка B будет выбрана из списка доступных точек высадки для поездки от выбранной точки A, с учетом максимальной близости к указанной в качестве аргумента. Если координаты не переданы, то по умолчанию будет использовано место высадки у ближайшего к точке A метро. 

Для того, чтобы маршрут такси до ближайшего метро в приложении  YandexGo имел минимальное расхождение с маршрутом, отображаемом в приложении Мосметро, предлагается организовать передачу списка возможных точек B для выбранной точки А. Для этого приложение Мосметро будет ходит в нашу ручку `/maas-authproxy/v1/nearest-metro`.
Данная ручка будет принимать в качестве параметра точку A и отдавать список доступных точек B.


# Оценка

- [5d] создать прокси-сервиса maas-authproxy для внешних запросов
- [41d] создать внутренний сервис maas:
    - [3d] `/user/register` (внешняя)
    - [3d] `/user/update` (внешняя)
    - [4d] `/subscription/reserve` (внешняя)
    - [2d] `/subscription/activate` (внешняя)
    - [2d] `/subscription/сancel` (внешняя)
    - [2d] `/subscription/info` + `/subscription/status/` (внешняя)
    - [2d] `/available-tariffs` (внешняя)
    - [1d] `/available-tariffs/user` (внешняя) используем код из `/subscription/reserve`
    - [5d] `/nearest-metro` (внешняя)
    - [2d] `/4.0/product-info` (клиентская) 
    - [2d] `/4.0/subscription/info` (клиентская)
    - [2d] `/4.0/maas/v1/nearest-metro` (клиентская) по аналогии с `/nearest-metro`
    - [3d] `/check-promocode` (внутренняя) используем части кода из `/nearest-metro` 
    - [3d] `/shortcut` (внутренняя) 
    - [5d] метрики, алерты и что-то еще не учтеное
- [7d] доработка coupons 
    - [2d] проверка промокода   
    - [2d] невидимость промокодов абонементов 
    - [3d] ручка проверки промокода во время завершения поездки (будет вызываться из процессинга)
- [1d] доработка `/personalstate` (сервис user-state)
- [1d] доработка `/products`
- [2d] доработка `/zoneinfo`
- [3d] плагин для `/routestats` 
- [?] отдавать станции метро в `masstransit` (тут нам поможет Женя Зарубкин)


**ИТОГО: 60d = ~ 15 недель (с запасом) = ~ 4 месяца (с запасом)**
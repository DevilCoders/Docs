## Задача

Мы умеем задавать пользователю вопросы о качестве поездки, но вопрос задаётся 
в эксперименте на группу водителей. Хочется добавить возможность выбирать, какой вопрос задавать про этого водителя. 
Например, если по этому водителю ответов на какой-то вопрос уже достаточно, можно задать другой. 
Для этого надо добавить крутилку вопросов.

## Схема решения

Менеджеры продукта и команда ML предложили такой подход:

![](img/questions_diagram.jpg)

## Решение

## Реализация крутилки

Крутилку можно реализовать в сервисе `passenger-feedback`. 
Нам надо связать вопрос с водителем и хранить данные о ранее заданных вопросах.
Для этого можно добавить в сервис новую базу postgres `passenger_feedback`.
В базе будет две таблицы - одна будет хранить текущий вопрос для водителя, 
другая - историю вопросов.

1. Таблица текущих вопросов.

Будет иметь пять столбцов:

| driver_id | current_question_id | answer_ids                           | answer_values | updated_at |
| --------- |---------------------|--------------------------------------|---------------|------------|
| 12345     | driver_has_mask     | [`positive`, `positive`, `negative`] | [ 1, 1, 0]    | 1538576982 |

Для подсчёта ответов id ответов не нужны, но можно сохранить их. 
Так потом мы сможем сопоставить ответ, хранящийся в базе фидбеков, и значение.

Если эксперимент будет раскатан на 100%, число записей в таблице будет стремиться к числу водителей.
В России в месяц 600к уникальных водителей. 
Вряд ли записи в этой базе будут храниться дольше месяца (исключение - водитель долго не ездил).
Если посчитать, что ожидаемый размер записи 128байт, 
можно оценить максимальный ожидаемый размер таблицы как 128б * 600000 = 73Мб.

2. Таблица истории вопросов.

Будет иметь 6 столбцов:

| id  | driver_id | question_id         | answer_ids                           | answer_values | updated_at |
|-----| --------- |---------------------|--------------------------------------|---------------|------------|
| 123 | 12345     | driver_has_mask     | [`positive`, `positive`, `negative`] | [ 1, 1, 0]    | 1538576982 |

В ней будем хранить все вопросы, которые задавались по этому водителю.

Если эксперимент будет раскатан на 100%, для каждого водителя может быть по несколько записей в базе.
Активных водителей в месяц в России всего 600к. 
Если реально активных водителей в 3 раза больше, и для каждого хранится по 10 вопросов, 
а размер самой записи составляет 1Кб, размер таблицы будет 
1Кб * 600000 * 3 * 10 = 17Гб. 

Получается, что минимального размера базы 20Гб должно хватить на обе таблицы, во всяком случае, на этапе запуска.

Вопросы можно будет указать в эксперименте, про который напишу дальше. 

Как будет выглядеть выбор вопроса для водителя:
1. Ищем в таблице текущих вопросов вопрос для этого водителя.
2. Если вопроса в таблице нет - получаем новый с учётом веса, сохраняем в базу и отдаём на клиент.
3. Если вопрос в таблице есть - смотрим, есть ли негативные ответы среди текущих ответов. 
Если есть  - отдаём текущий вопрос на клиент.
Порог замены вопроса здесь не проверяем - проверим при сохранении ответа.
4. Если вопрос в таблице есть, негативных ответов не было. Переносим вопрос со всеми ответами в историю. 
Получаем новый вопрос из крутилки. 
Текущий вопрос из крутилки не выкидываем, полагаемся только на вероятность выпадания с учётом весов.
Сохраняем вопрос в базу и отдаём на клиент.

Выбор вопроса реализуем в ручке `/4.0/passenger-feedback/v1/feedback-proposal` 
сервиса `passenger-feedback`.

Как будет выглядеть сохранение ответа:
1. Получаем значение ответа (0 или 1) по id ответа.
2. Проверяем порог замены вопроса. Если в базе текущих вопросов количество ответов равно величине порога, 
переносим самый ранний ответ в таблицу истории. Сохраняем новый ответ в таблицу текущих вопросов.

Сохранение ответа реализуем в ручке `/passenger-feedback/v2/feedback`. 

### Репликация данных

Для того, чтобы исторические данные было удобно анализировать, 
будем реплицировать значения из базы с историей вопросов на YT c помощью сервиса репликации.

Можно будет воспользоваться сервисом архивации для удаления старых данных (если потребуется).

### Эксперимент

Будем задавать вопросы через эксперимент. Он будет содержать список вопросов с возможными ответами. 
Для вопросов будет указан вес, а для ответов - значение (0 или 1).
Ещё в эксперименте можно будет указать порог, при котором заменяется вопрос 
(с дефолтным значением 3 - 3 положительных ответа).

Можно использовать эксперимент `ride_quality_surveys`, чтобы иметь возможность 
управлять вопросами с крутилкой и без одним экспериментом и удобно разбивать на группы.

Тогда в него нужно добавить веса вопросов, значения ответов, признак того, 
что используется крутилка, и значение порога проверки ответов.
Эксперимент будет выглядеть так:

```
type: object
additionalProperties: false
properties:
    enabled:
        type: boolean
    use_questions_engine:
        type: boolean
        description: использовать ли крутилку вопросов
    negative_answers_check_threshold:
        type: integer
        description: значение, при котором заменяется вопрос, 
            если среди стольких последних ответов были только положительные.
            Только для крутилки вопросов.
        default: 3
    survey_questions:
        type: array
        items:
            $ref: '#/definitions/SurveyQuestion'
required:
    - enabled
    - survey_questions

definitions:
    SurveyAnswer:
        type: object
        description: данные ответа опроса
        properties:
            ...
            value:
                type: integer
                description: значение для оценки ответов в крутилке. 
                    0 (нет) или 1 (да)
        required:
            - id
            - tanker_key
        additionalProperties: false

    SurveyQuestion:
        type: object
        description: вопрос и ответы предлагаемого опроса
        properties:
            ...
            question_weight:
                type: number
                description: вес вопроса для выбора в крутилке
        required:
            - question_id
            - question_tanker_key
            - answers
        additionalProperties: false
```

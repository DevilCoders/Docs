## Определение ДТП
### Этап 1
**Продуктовое описание:**

Приложение таксометра может определять ДТП по нескольким факторам (один из самых важных - факт длительной остановки такси), о чем оно сообщает серверу таксометра. В момент, когда сервер таксометра посчитал, что дтп произошло, он дергает сервис центра безопасности

Общий флоу:
* сервер таксометра сообщает центру безопасности факт ДТП
* сервер ЦБ сохраняет информацию о дтп в базу, отправляет пуш клиенту
* клиент по пушу (и возможно по launch из цб, если пуша не было) получает окошко с вопросом "было ли дтп", и клиент может ответить 'да'/'нет'
* сервер ЦБ хранит у себя один из 3 вариантов (пользователь не ответил, пользователь ответил `ок`, пользователь ответил `было дтп`)
* таксометр имеет возможность отправить центру безопасности факт о том же дтп но с повышенной уверенностью в этом. В зависимости от степени уверенности и факта реакции пользователя могут выполняться различные действия (например постановка таски на саппортов, чтобы они набрали клиента и спросили лично)

**Немного о статистиках**:
со стороны таксометра 400 срабатываний в день (то есть всего 146000 записей в год)

**Критичность**:
если пуш не дойдет или попап не отобразится - никаких криитичных процессов мы не затронем (продумывается отдельно в рамках продуктовых хотелок открытие попапа не по пушу а по отдельному флагу)

#### POST /v1/accidents (3d)
// ручка требует лишь внутренней межсервисной авторизации
```json
{
   "order_alias_id": "order_alias_id",
   "idempotency_key": "idempotency_key",
   "occurred_at": "2018-11-30T13:22:34Z",
   "confidence": 40 // вероятность совершения дтп (считаем что в процентах)
}
```

200 OK
```json
{
  "accident_id": "accident_id"
}
```
confidence - тип уверенности таксометра. пока обсуждались варианты 5 минут (низкая степень уверенности) и 30 минут (высокая степень уверенности)

На стороне таксометра необходимо обдумать конфигурирование количества запросов в сервис ЦБ и вероятность, которую они отсылают.
Со стороны бэкенда нужно продумать реализацию в общем выбора стратегий в зависимости от вероятности, присланной Таксометром.

Клиентам отправляется пуш уведомление со следующим телом:
```json
{
  "payload": 
    {
       "msg": "У вас все в порядке?",
       "timestamp": "2019-06-21T18:42:00+0000",
       "deeplink": "yandextaxi://accident?order_id=xxx", 
       "id": "uuid"
    }
}
```

#### GET /4.0/safety_center/v1/accidents?order_id=abc (1d)
200 OK
```json
{
   "accidents": [
    {"accident_id": "id1", "status": "questionable"}, 
    {"accident_id": "id2", "status": "unconfirmed"}
   ]
}
```
- если есть `questionable` инциндент - отображать попап с вопросом
- если есть `unconfirmed` - не реагировать
- если есть `confirmed` - предложить отменить такси

Бэкенд гарантирует что в ответе всегда не больше одного questionable. order_id присылается клиенту в пуше.

#### PUT /4.0/safety_center/v1/accidents/status?accident_id=abc (1d)
```json
{
   "accident_happened": false
}
```
200 OK
```json
 {}
```

#### Изменения backend-cpp протокола
Вынос отмены заказа из totw в полноценную ручку
#### POST /3.0/ordercancel (4d)
```json
{
   "id": "user_id",
   "order_id": "order_id",
   "break": "user"/"accident", // аналогично как в totw, как вариант добавляется accident
   "cancel_state": "paid"/"free" // аналогично как в totw
}
```
200 OK
```json
{
  "status": "cancelled"
}
```
Ручка:
1) в случае если accident - проверяет факт доступности пользователю отмены из-за дтп. 
2) отменяет поездку в рамках логики, которая была в totw

Пока `/ordercancel` разрабатывается, отмена с `"break": "accident"` добавлена в `/taxiontheway`, при этом проверка наличия происшествия отсутствует. Возможность такой отмены регулируется конфигом `TAXIONTHEWAY_CHECK_IF_ACCIDENT_HAPPENED_ON_CANCEL`. 

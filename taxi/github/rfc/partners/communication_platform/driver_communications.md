**Название сервиса**

`driver-communications`

**Какую продуктовую проблему решает сервис?**

Сейчас водителю из разных источников сыпется очень много типов коммуникаций (пуши, смс, чат с поддержкой и тд).
Бывает, что коммуникация приходит в ненужный момент или одно и то же присылается несколько раз. Хочется создать
сервис, который будет единственной точкой выхода для коммуникаций с водителем.

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Мы будем использовать уже существующие рещения, просто "причешем их" и сделаем единую входную точку в виде нового сервиса.
Сервис будет взаимодействовать непосредственно с таксометром, отдавая ответ в определенном формате (flatter).
При этом сервис будет взаимодействовать с уже работающими сервисами `communications`, `feeds` и `CRM платформой` и новыми сервисами `политики
коммуникаций` и `сценириев`. Благодаря этому будет возможно расширение функционала платформы.

Был рассмотрен вариант переиспользования сервиса `support-chat`, но мы отказались от этой идеи, так как сервис хранит чат, как
документ mongoDB, а поэтому накладывает ограничения на размер чата, который в текущей постановке задачи ожидается "бесконечным".
Хочется, чтобы item-ом был не чат, а единое сообщение, которое может перемещаться между чатами и по факту не связано с чатом
напрямую. В дополнение, сервис не готов держать ожидаемую нагрузку до 3к RPS и имеет особенности подходящие только для чата
поддержки.

В будущем планируется, что чат поддержки также будет использоваться в коммуникационной платформе, а новый сервис будет работать
как proxy между таксометром и `support-chats`.

**Как именно сервис будет решать поставленные перед ним задачи?**

[Ссылка на тикет с продуктовым описанием](https://st.yandex-team.ru/TAXIMETERBACK-9377).

[Ссылка на дизайн](https://www.figma.com/file/S1264VQA0v9NetNs4GlDjn/%D0%A2%D0%B0%D0%BA%D1%81%D0%BE%D0%BC%D0%B5%D1%82%D1%80-%D0%9B%D0%B5%D0%BD%D1%82%D0%B0?node-id=747%3A1023).

[Ссылка на скелеты флаттера](https://gist.github.yandex-team.ru/skorotkov/baf97df201be5ab9627d209231cd1b7b).

Будет заведена либа для флаттера.

**Разрабатывается один сервис или система?**

Cистема (но конкретно это арх ревью на сервис driver-communications).

**Сколько и какие сервисы входят в систему?**

1) `driver-communications`
2) [communications](https://wiki.yandex-team.ru/taxi/backend/architecture/communications/)
3) [policy](https://wiki.yandex-team.ru/taxi/backend/architecture/policy/)
4) [crm платформа](https://wiki.yandex-team.ru/taxi/crm/platform/)
5) [support-scenarios](https://wiki.yandex-team.ru/taxi/backend/supportteam/Sxema-raboty-servisa-support-scenarios/)
6) [experiments-3.0](https://wiki.yandex-team.ru/taxi/backend/architecture/experiments3/)
7) [feeds](https://wiki.yandex-team.ru/taxi/backend/architecture/communications/feeds/)

**С кем взаимодействует сервис?**

[feeds](https://wiki.yandex-team.ru/taxi/backend/architecture/communications/feeds/)
1. Feeds - используется в нескольких направлениях: хранилище сообщений и мета-информации о них, получение новых сообщений для водителя,
отправки метрик (сообщение доставлено, сообщение прочитано, ответы водителя в опросах). Для получения информации о том, какие новосити
и сообщения нужно показать водителю, сервис `feeds` взаимодействует с сервисами `policy` и `efficiency` (сервис разрабатывается, будет
отвечать за ранжирование новостей, временный непоказ и тд).
2. Все ручки получения сообщений имеют etag в качестве аргумента; etag последнего полученного сообщения хранится на стороне таксометра и
он приходит с ним для получения новых и для понимания, какие сообщения будут считаться новыми.
3. При отказе сервиса получение сообщений станет невозможным. Сервис является критичным для работы платформы. В случае недоступности,
для пользователя будет возвращен список чатов, но при переходе в него он буден видеть сообщение о временном недоступности сервиса. Однако,
на стороне таксометра будет кеширование чатов, что должно сглаживать user-experience.
4. Используется стандартный конфиг CLIENT_QOS c указаными настройками ретраев и таймаутов. Если сервис `feeds` 500-ит для каждого запроса
который должен был уйти в сервис, создается stq-задачу, которая должна доставить данные в `feeds` (например, доставить метрики),
когда он поднимится. stq-задача не создается для запросов от таксометра на получение чатов.

[support-scenarios](https://wiki.yandex-team.ru/taxi/backend/supportteam/Sxema-raboty-servisa-support-scenarios/) - НЕ В MVP
1. Support-scenarios - сервис для проигрывания сценариев. Пример: водителю пришло первое сообщение из опроса, он дал на него ответ и
теперь мы должны понять, какое сообщение послать следующим. Мы идем в сервис сценариев и указываем сообщение и ответ на него, в ответ
возвращается сообщение ответ, которое мы должны вернуть водителю. И так далее по цепочке.
2. Гарантируется, что для пары сообщение и ответ есть только одно сообщение-ответ. Апи будет обсуждено позже.
3. Над сервисом поднят кеш. В случае отказа сервиса сценарии могут работать ок в большинстве случаев, так как в основном сценарии прописываются
для массовых рассылок (опросы, новости). Соответственно данных будет мало и ожидается временная работа только на кешах. 
4. Аналогично сервису `feeds`.

[communications](https://wiki.yandex-team.ru/taxi/backend/architecture/communications/)
1. Communications - используется для отправки пушей водителю.
2. Гарантируется, что пуш будет отправлен 1 раз, но не гарантируется доставка. В случае недоставки таксометр получит уведомление чуть позже через
ручку поллинга `driver/v1/chats/polling`.
3. При отказе сервиса таксометр получит уведомление чуть позже через ручку поллинга `driver/v1/chats/polling`.
4. Используется стандартный конфиг CLIENT_QOS c указаными настройками ретраев и таймаутов.

**Какие базы использует?**

Какие СУБД и почему используются. Какие БД в них будут использоваться.

Будем использовать СУБД PosgreSQL - нами будут использоваться одна база данных и 
несколько связанных между собой таблиц; необходим быстрый доступ к данным по ключу;
объем данных будет большой и необходимо поддержание шардированных данных, если это
будет необходимо при росте сервиса.

База `driver-communications` будет использоваться для хранения вспомогательных данных для
общения с `feeds`.

**Какие периодические процессы?**

`replier` - запускается, когда приходит сообщение от водителя(реакция на новость, ответ на опрос и тд). Отправляет полученные
результаты в сервис `feeds`. Если сервис после нескольких попыток ретраев не ответил,
то решедулим таску на более позднее время когда сервис поднимется. Так мы не теряем данные и они точно доставляются до метрик CRM.
Когда сообщение обработано, дергается ручка для отправки пуша, если есть новые сообщения (сделано для сценариев).

`message-status-sender` - аналогично предыдущей таске отправляет статусы доставки и прочитываемости сообщений в сервис `feeds`.

`scenario-message-getter` - при запросе, что водитель ответил на сообщение, формируем задачу, которая должна дождаться следующего
сообщения по цепочке сценария из сервиса `support-scenarios`. Сообщение будет получено таксометром при следующем запросе или через
пуш.

**Прикрепите схему того, где этот сервис находится в текущей инфраструктуре**

1. Проект не влияет на цикл заказа.
2. Потребитель сервиса - таксометр.

![Alt text](./communications_platform.png?raw=true "Схема взаимодействия. Вариант")
Суть:
- `feeds` выставляют легковесную ручку, которая просто отвечает на вопрос, есть ли новые сообщения (или сколько их есть);
соответственно когда таксометр спрашивает о начличии новых сообщений, мы проверяем есть ли такие и таксометр шлет уведомление;
это сделано на случай, если пуш не дошел
- когда водитель приходит за новостями, таксометр дергает ручку `driver/v1/chats/message`; мы идем в feeds и пытаемся наполнить каждый чат:
для каждого чата есть определенные для него теги из конфига, мы запрашиваем в ручке `v1/fetch` новости с указанными тегами и ожидаем, что по
переданному etag нам вернется упорядоченных список сообщений с такой информацией: прочитано ли сообщение (для отрисовки), текст сообщения,
если сообщение "отвечает" на какое-то сообщение выше, то есть указание на сообщение родитель; также передается новый etag
- таким образом мы наполняем каждый чат сообщениями предназначенными для этого чата (с указанными тегами)

Мной был продуман концепт, что feeds ходит в наш сервис при получении новых сообщений от CRM и мы храним эту информацию у себя, и сами отправляем
пуш. Но в этом случае получается дублиурование данных в 2х сервисах + пуш доходит дольше из-за петли запросов из сервиса в сервис.

Также есть вариант напрямую полить `feeds` с таксометра, но тогда нарушается схема взаимодействия с инфраструктурным сервисом `feeds` + в светлом
будущем когда поллинг будет единый, сервис будет также отвечать проксе, которая будет собирать все поллинги и ответ должен быть достаточно коротким
и емким, а конкретные сообщения водитель увидит уже на экране сообщений.

**Какие данные и по какой схеме сервис будет хранить в базе?**

Предварительно планируем хранить таблицы:

`active-chats` - активные чаты для водителя.
Пример: водителю пришел опрос, тогда, чтобы он не мешался с другими новостями, мы выделяем
его в отдельный чат, добавляем новый чат для опроса в `active-chats` этого водителя. Тогда новое сообщение с опросом пойдет
в отдельный чат questions. Когда опрос будет пройден, чат пропадет из активных и уже не будет доступен водителю, но сообщения
будут доступны в `feeds`.

Таблица имеет поля: driver_id, chat_ids

**Какие конфиги используются?**

`available-chats` - конфиг 3.0 с доступными чатами для водителей.

`chat-tags` - хранит информацию о том, сообщения с каким тегом попадают в какой чат
поля. Берется соответствие tag в массив чатов, куда этот тег может попадать и в зависимости
от того, какие активные чаты сейчас есть у водителя (например, один водителяь попадает в эксперимент,
когда диагностика выделяется в отдельный чат, а не в общеновостной (в списке ДОСТУПНЫХ чатов данного водителя
появляется чат диагностики), в его отдельный чат выделяется диагностика, тогда внутри chat_ids появится
"чат диагностики", а default_chat_id == "общеновостной"). 

Примерные поля: tag: default_chat_id (дефолтный чат, если не подошел ни один чат из chat_ids), chat_ids (чаты, куда может подойти тег)

`chat-meta` - хранит информацию по каждому чату

Примерные поля: chat_id: {какая-то инфа}

**Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

Объем данных:

Сервис не хранит тела сообщений, он хранит только какую-то информацию по чатам для получений сообщений от `feeds`.
Тогда объем хранимых данных можно ограничить как (кол-во водителей * объем информации по чатам).

кол-во водителей - 5296805 (на 12.05.20) - но не все водители активны. Как удалось выяснить, активных водителей порядка
миллиона. [Водителей на линии можно посмотреть здесь](https://grafana.yandex-team.ru/d/HvScxq_mk/taxi_supply_diagnostics?orgId=1&refresh=30s&from=now-1y&to=now)
итого: (1000000 * 1Kb + 1Kb) / 1024 / 1024 = 1 Гб

Про изменение данных:
кол-во сообщений в день - цифра ограниченная политикой коммуникаций. [Считали здесь](https://st.yandex-team.ru/TAXICRM-4592)
Пока считаем, что водителю приходит не более 100 сообщений в день. Тогда объем изменяемых данных можно ограничить как
(кол-во водителей * объем изменяемой инфы чатов * новые сообщения).
итого: (1000000 * 100b * 100) = 95 Mb в день = 1 kb/s

Основной тип запроса это SELECT. UPDATE над данными выполняется только при наличии новых сообщений для водителя.

**Какие операции над данными заложены?**

`SELECT chat_ids from active-chats`
`UPDATE active-chats set chat_ids={} where driver_id={}`

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

Нет

**Какая нагрузка ожидается?**
[Водителей на линии можно посмотреть здесь](https://grafana.yandex-team.ru/d/HvScxq_mk/taxi_supply_diagnostics?orgId=1&refresh=30s&from=now-1y&to=now)

POST `driver/v1/chats/polling` - ручка получения инфы, есть ли новые сообщения; заплатка, если не дошел пуш
Дергается, чтобы быстро проверить, есть новые сообщения вообще или нет и, например, отправить уведомление.
для каждого водителя на линии вызывается раз в 5 минут: 100к / (5 * 60) = 333 RPS
ВАЖНО: мы делаем ответ ручки максимально простым, чтобы в светлом будущем, когда все поллинги срастутся в одну ручку, которая
будет давать ответ по всем статусам, эта ручка также вошла в эту систему.

POST `driver/v1/chats/messages` - ручка получения списка чатов + сообщения + meta-инфа (таксометру проще просить всю партянку)
Ожидаемый RPS: аналогично предыдущему 333 RPS

POST `driver/v1/chats/{chat_id}/messages/list` - ручка получения сообщений конкретного чата, используется для пагинации сообщений,
подгрузки старых сообщений
Ожидаемый RPS: предположительно будет дергаться после уведомления, что есть непрочитанные сообщения, поэтому ограничим сверху
333 RPS + надо учитывать пагинацию, поэтому RPS будет скорее х2 = 667 RPS.

POST `driver/v1/chats/{chat_id}/reply` - общая ручка для принятия ответов, голосовалок, сообщений от водителя; если ответ происходит по
сценарию, то принимаем это в аргументах; если сообщение является ответом на сообщение, также принимамаем в теле; запускает таску
`metrics-sender` и в некоторых случаях `scenario-message-getter`; когда таска отработает, на таксометр придет пуш, и нужно будет прийти за
новыми сообщениями.

Ожидаемый RPS: Оцениваем в худшем случае как ответ на каждое новое сообщение -> 100000 * количество сообщений в сутки, которые
в процессе подсчета [Считали здесь](https://st.yandex-team.ru/TAXICRM-4592)

POST `driver/v1/chats/{chat_id}/messages/status` - запускает таску по изменению статуса сообщения `message-status-sender`
Ожидаемый RPS: аналогично `driver/v1/chats/{chat_id}/reply`

Итого порядка 1.5к RPS на сервис.

Нагрузочное тестирование будет делаться.

**Какие фолбеки предусмотрены на сам этот сервис?**

Сервис взаимодействует напрямую с таксометром. Фоллбэки не предусмотрены. Специфические кейсы неответов соседних
сервисов описаны выше.

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

Фолбэк на каждый компонент описан выше в описании сервисов.

Какие особенности будут при отключении ДЦ.
Ожидается повышение нагрузки на оставшиеся дц. Шардированных напрямую данных нет, консистентность должна сохраняться.

Как будет тестироваться отказоустойчивость.
1) Будут написаны ft-тесты для проверки разных сочетаний отказов соседних сервисов и проверки, что сервис работает ожидаемо
при этих отказах.
2) Будет проведено нагрузочное тестирование и стресс-тестинг.

**Какие возможности масштабируемости закладываются?**

Поскольку данные сервиса не шардируются, при росте количества машин, сервис будет равномерно распределять 
нагрузку между всеми машинами. На каждой машине должны жить данные отписанные выше.
Чем больше машин, тем меньше нагрузка на каждую машину.

`PostgreSQL` - расширяем

Соседние сервисы:
`feeds`, `support-scenarios`, `communications` и `policy` - на старте договариваемся, что сервис будет доработан, чтобы выдерживать необходимый RPS.

Хорошо масштабируется горизонтально (добавить машин) - запрос на получение новостей для конкретного водителя.
Не масштабируется вертикально (добавить мощи) - бессмысленно.

**Какие точки отказа есть в сервисе?**

1) PostgreSQL
2) feeds

На остальные сервисы есть fallback-и.

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

И для продукта, и технчески необходимо мониторить:
1) количество читаемых сообщений в сутки по каждому водителю.
2) количество сообщений которые ожидают быть показанными.
3) сколько сообщений удаляются из очереди на будучи показанными.
4) метрики по голосованиям, опросам, лайкам и дизлайкам
5) типы приходящих и отобранных новостей (теги, мета-инфа)

**Укажите технические метрики**

1) тайминги `feeds` (таймауты/ок)
2) размер базы и отдельных таблиц
3) bad/ok RPS ручек

**Какая функциональность ожидается в сервисе в будущем?**

Этапы разработки совсем MVP-MVP:
1) Создание макета сервиса с базой и доступами - 2w (делается параллельно, не блокирует разработку,
но очень важная)
2) Ручка `driver/v1/chats/{chat_id}/messages/status` БЕЗ ТАСКИ - 2d
3) Ручка `driver/v1/chats/messages` - 5d - требуется сдлеать либу для флаттера
4) Ручка для пагинации `driver/v1/chats/{chat_id}/messages/list` - 3d 
5) Ручка поллер `driver/v1/chats/polling` - 2d
6) Настройка мониторингов - 1d

Итого: 3w-4w (в зависимости от 1)

Доделки:
1) сделать таску `replier`
2) сделать таску `message-status-sender`
3) сделать таску `driver-communication-info-updater`
4) интегрироваться со сценариями и сделать таску `scenario-message-getter`

**Какое изменение нагрузки планируется?**

С появлением новых типов новостей, ожидается, что колличество приходящих из `feeds` новостей
будет увеличиваться, может расти rps на ручку получения сообщений.

С появлением типов новостей, для которых очень важна скорость доставки, ожидается, что RPS на ручку получения новостей
может увеличиться.

**Активно ли будет изменяться сервис?**

Если MVP взлетит - да, так как будут появляться новые типы коммуникации, которые захочется протащить через единую платформу.

<hr>

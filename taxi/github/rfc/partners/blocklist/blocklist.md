#### Название сервиса

`blocklist`

#### Какую продуктовую проблему решает сервис?

Сервис ЧС используется для ограничения доступа к заказам для различных
бизнес-сущностей: *водителей*, *курьеров*, *машин* и т.д.

Для чего продукту нужен сервис:
   - Блокировки от саппорта по различным жалобам.
   - Блокировки антифрода по различным нарушениям
   (например нарушение правил работы в аэропорту).
   - Блокировки фотоконтроля 
   (например если ВУ водителя не соответствует требованиям сервиса)
   - Блокировки системы Маяк (блокируем водителей за регулярные
   некритические нарушения: отмены, превышения скорости)
   - Блокировки водителей за низкий рейтинг

#### Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?
Продукту нужно расширить возможности сервиса блокировок. 

В данный момент сервису не хватает 
[следующих возможностей](./service_lacks.md).

Существующий сервис написан на ***C#***. Язык не
поддерживается инфраструктурой разработки, от него требуют
отказаться, поэтому расширить сервис мы не можем.


#### Как именно сервис будет решать поставленные перед ним задачи?
Сервис будет написан на языке, который поддерживает
инфраструктура. Это позволит нам вносить в него нужные
продукту доработки. 

[Требования продукта к сервису](./product_needs.md)

[API сервиса блокировок](./api/blocklist.yaml)

[Архитектурное описание](https://wiki.yandex-team.ru/taxi/backend/architecture/blacklist/#ustrojjstvosistemy)

#### Разрабатывается один сервис или система?
Один сервис. В будущем, возможно, появится отдельная библиотека
с оффлайн кешом и сервис-кэш.

#### С кем взаимодействует сервис?
   - [Сервис кандидатов](https://wiki.yandex-team.ru/taxi/backend/architecture/candidates/)
   будет использовать `blocklist` в качестве
   [фильтра](https://wiki.yandex-team.ru/taxi/backend/architecture/candidates/#filtr).
   - `blocklist` будет использовать [сервис персональных данных](https://wiki.yandex-team.ru/taxi/backend/architecture/personaldataservice/)
   для замены персональных данных идентификаторами.

#### Какие базы использует?
PostgreSQL.

***TODO**: вписать названия базы*

#### Какие периодические процессы?

- Наполнение кеша блокировок
- Вычищение протухших блокировок

#### Прикрепите схему того, где этот сервис находится в текущей инфраструктуре

![service place](./images/service_place_in_taxi.png)

#### Какие данные и по какой схеме сервис будет хранить в базе?

![db schema](./images/db.png)

##### Blocks:
- identity - Идентификатор пользователя, добавившего
блокировку (Yandex-uuid)
- predicate - предикат в определённом формате.
Сервис умеет вычисляеть его для конкретного водителя,
чтобы сказать, заблокирован ли он. Предикат может
иметь именованные параметры. Они хранятся в таблице
`kwargs`.
- created - дата создания блокировки
- expires - дата истечения блокировки
- tags - набор меток, позволяющих классифицировать
блокировку
- reason - причина блокировки в определённом формате
- ticket - тикет, в рамках которого производится блокировка

##### Kwargs:
- block_id - Идентификатор блокировки (внешний ключ для 
id в таблице Blocks. Отношение - один ко многим)
- key - имя параметра в предикате
- value - значение параметра в предикате


#### Какие конфиги используются?

TODO

#### Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?

Сейчас в базе ЧС приблизительно **300 тысяч** записей.
В новой базе каждая запись будет занимать примерно **1
Кб** (оценка сверху).
Если записей станет в **3** раза больше, то вся база 
будет занимать **1 Гб** + история. Минимального объёма
postgres в **10 Гб** должно хватить с запасом на всё.

По данным за 24 часа всего было удалено **2600**
блокировок и добавлено **3700**.
Средняя скорость изменения данных таким образом равна
**75 байт** в секунду.

В пике нагрузка составляла **20** записей в секунду
или **20 Кб** в секунду.

**NB:**
- на каждую созданную блокировку водителя
происходит фактически 2 удаления: по **license_pd_id** и
по **license_number**.
- удаления блокировок происходят преимущественно не за счёт
ручки ***/remove*** сервиса, а за счёт внутреннего процесса,
который удаляет истёкшие блокировки.

#### Какие операции над данными заложены?

Создание и удаление блокировки.

#### Есть ли какой-то стейт в памяти, как он обновляется и валидируется?

Предполагает кеш. Обновляться он будет регулярно по
установленному графику. Возможно, инкрементально.

#### Какая нагрузка ожидается?

По данным за 48 часов в ручки существующего сервиса блокировок
было зделано запросов:
- /add      - 895
- /addbulk  - 3
- /remove   - 4
- /driver   - 92
- /car      - 34
- /reply    - 1

В пике наблюдалось **56** запросов в секунду.

Также сюда относится пиковая нагрузка в **2000** запросов
в секунду в ручку /driver/check, часть функций которой
ляжет на сервис блокировок. Эта нагрузка ляжет
на кеш.

#### Какие фолбеки предусмотрены на сам этот сервис?

Сервис **candidates** будет использовать устаревшие кеши при
невозможности обновить их из сервиса блокировок.

#### Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?

Никаких

####Какие возможности масштабируемости закладываются?

Если блокировок станет слишком много, 
можно шардировать БД, например, по правилам kwargs.


#### Какие точки отказа есть в сервисе?

- Сервис ПД (необходим для добавления новых блокировок).
- Postgres.

#### Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить

- Доля блокировок через новый сервис против старого сервиса
- Процессы, переведённые на новый сервис

#### Укажите технические метрики

- Количество блокировок по параметрам
- Время наполнения кеша
- Ошибки по ручкам

#### Какая функциональность ожидается в сервисе в будущем?

- Новые кварги для предикатов
- Более сложные условия блокирования

#### Какое изменение нагрузки планируется?

Линейный рост количества блокировок примерно на 
**3000** в месяц.

#### Активно ли будет изменяться сервис?

Со средней скоростью.
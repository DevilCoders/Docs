## Какие задачи решаем в порядке приоритета
1. Дать возможность исполнителям заказов Еды и Лавки работать в сервисах Такси. 
На данный момент необходимо поддержать пеших курьеров, вело- и курьеров с мопедами.
2. Дать возможность заводить новые типы транспорта (будет актуально например для грузоперевозок)
3. Дать возможность пешим конвертироваться в водителей и наоборот

Тикет: https://st.yandex-team.ru/CARGODEV-840
Общий роадмап: https://st.yandex-team.ru/CARGODEV-617

## Предметная область
В нашем сервисе начинают работать не только таксисты.
Такси превращается в логистический сервис, к которому должны подключаться разномастные курьеры, дальнобойщики и т д.

Когда поддержку курьеров только начинали делать, предполагалось, что в базах партнёрки они будут временным явлением, и очень скоро переедут в отдельные БД, бекенд и приложение.
Это не случилось, и курьеры, мопеды и фуры становятся постоянными жителями баз данных партнёрки.

Цикл заказа обобщается и един для всех типов заказов и исполнителей. Например, пользователю неважно, доставит его заказ таксист, велосипедист или фура.

В то же время supply-часть сервиса очень разная для разных типов водителей:
- [Тут](https://st.yandex-team.ru/TAXIMETERBACK-9276#5e98a9edfc5b453d2b245e15) определен список мест, которые должны работать по-разному для водителей с разными типами ТС
- [Тут](https://st.yandex-team.ru/CARGODEV-617) для разных типов транспортов расщепляется маршрутизация, притягивание на графе, расчет ETA и прочее.

Итого, вместо термина водитель теперь правильнее использовать термин "исполнитель".
Вместо термина "машина" или "автомобиль" - "транспортное средство".

Исполнитель может выполнять заказы такси, для чего у него должно быть соответствующее транспортное средство, лицензия, путевой лист и т. д.
Транспортное средство в данном случае - легковой автомобиль, однако не исключено, что в Азии мы разрешим возить пассажиров на мопедах, а в Африке - на грузовиках.
Тот же исполнитель может выполнять и заказы доставки. Для этого он может использовать ту же самую машину, а может вообще пересесть на велосипед.
Аналогично пеший исполнитель может обзавестись машиной, пройти фотоконтроль, получить лицензий на осуществление таксомотоной деятельности и путевой лист.

Транспортное средство может подлежать учёту или не подлежать. Мы ведём список всех автомобилей в системе по их гос. номерам.
При этом, пока что мы не хотим вести учёт велосипедов и самокатов.

## Вопросы
1. приходят ли курьеры со своим велосипедом, или им кто-то его выдает? (служба доставки, Яндекс, какой-нибудь партнер) <уточнить у еды>
2. актуально ли, что связка ТС<->водитель должна быть отдельной сущностью? <обосновать>


Концептуальная схему связей можно представить так: https://jing.yandex-team.ru/files/s-uskov/Screen%20Shot%202020-04-30%20at%2012.30.11%20AM.png

Такая схема расширяется:
- можно добавить самолёт в качестве ТС
- можно добавить навигацию телепортом.
- можно добавить композитную навигацию (в духе, пешком + ТС: "оставь машину на парковке и пройдись пешком, а потом мы тебе назначим заказ обратно к точке, где ты оставил машину).

Схема не отражает связь ТС и типов навигации с другими сущностями в системе. О них ниже в роадмапе.

Способ навигации начинает выступать одним из фильтров при назначении водителя на заказа (например, для пеших недоступен эконом).

## Дорожная карта ПП

### Блок "техно-MVP"
1. Пишем сервис-заглушку, отдающий типы транспортов по водителям. см [CARGODEV-840](https://st.yandex-team.ru/CARGODEV-840).
Сервис просто конвертирует поле courier_type в transport_properties.
Желательно используем формат кешей api-over-db, чтобы меньше писать кода и чтобы получить миграции схем кешей из коробки
**Чекпоинт - граф может начинать использовать новый сервис, ожидаем запуска пешей маршрутизаации**

### Блок "Свойства маршрутизации"
1. Заводим новую таблицу и в driver-profiles соответствующую GET-ручку:
 ```
 navigation_methods={
   "park_id": "id",
   "driver_profile_id:"id",
   "updated_ts":<timestamp>,
   "update_source": <блок с автором изменений - где-то уже такой делали>,
   "navigation_methods: [
       {"type":"pedestrian"},
       {"type":"bicycle"},
       {"type":"public_transport"},
       {"type":"vehicle", "vehicle_id":"uuid"},
   ]
 };
 ```
 Эта сущность задаёт доступные водителю способы передвижения и в перспективе заменяет привязку к ТС по полю car_id. 
 Некоторые из них могут комбинироваться (например, пеший + ОТ + велосипед).
 Тип vehicle стоит отдельно - он не может совмещаться с другими способами. По крайней мере, пока.
 POST-ручка, которая будет в будущем в driver-profiles, будет выполнять контроль целостности этих ограничений
 
 2. Пишем джобу синхронизации, инкрементально вычитывающую изменения водителей, и выполняющую синхронизацию:
 ```
 dbdrivers.courier_type:"walking_courier" -> navigation_methods=["pedestrian"]
 dbdrivers.courier_type=null|dbdrivers.car_id=<uuid> -> navigation_methods=["vehicle"]
 ```
 Поля drivers.courier_type и drivers.car_id объявляем как deprecated
 
 3. Выставляем ручку POST /navigation-types с ограниченными возможностями

 3. В Оптеуме и используемых апишках расширяем карточку курьера, добавляем возможность проставлять опции маршрутизации
 
 4. Переписываем сервис-заглушку driver-transport. Теперь он проксирует свои запросы в navigation_methods.
 
 **Чекпоинт - в диспетчерской поддержаны опции маршрутизации, они отдаются в сервисе driver-transport инфраструктурным сервисам. Есть дополнительный бонус: Заведена новая сущность для привязки водителей к ТС, которую давно планировали**
 
 Дальше идет технобеклог, который можно делать в фоновом режиме:
 1. Добавляем в ручку POST /navigation-types возможность делать привязку ТС, менять пешего курьера на водителя и обратно, и т. д.
 2. Заменяем везде чтение courier_type на использование ручек сервиса driver-transport или navigation-methods
 2. Заменяем везде чтение car_id на использование ручек сервиса driver-transport или navigation-methods
 3. Переносим проставление тега walking_courier в отдельную джобу или STQ, подписанную на изменения navigation-types
 4. Заменяем везде выставление courier_type на вызов ручки POST /navigation-methods 
 (ПРОБЛЕМА: появятся распределённые операции там, где их не было)
 5. Заменяем везде выставление car_id на вызов POST /navigation-methods
 
 **Альтернативные более быстрые варианты**
 1. Не заводить отдельную таблицу, сделать способы навигации полем в dbdrivers.drivers.
 По времени средне, но плохо, т. к. не приближает нас к отделению привязки водитель<->ТС в отдельную сущность
 2. Оставить поля courier_type, car_id, рядом подселить пачку флажков "has_bike", "has_public_transport" и т. д.
 Делается очень быстро и умеренно-грязно, но:
 - не решает проблемы с courier_type (поле нерасширяемо, обложено костылями для сверки с тегами).
 - отдаляет нас от переноса связки ТС<->водитель в отдельную сущность
 - отдаляет от удаления костылей с фейковыми автомобилями, разбросанными по всему бекенду
 - флажки, courier_type и car_id должны поддерживаться в консистентном состоянии. Если не вводится новая сущность, то эта логика потенциально будет скопипащена в нескольких местах

 
 ### Блок "Мопеды и поддержка произвольных типов транспорта"
 TODO
 Кратко:
 - расширяем dbcars.cars полем vehicle_type:car|truck|motorbike|etc
 - расширяем модели в auto_dictionary полем vehicle_type
 - сервис driver-transport начинает соединять данные из navigation_types и из cars.vehicle_type
 - заводим сущность vehicle-type с настройками обработки типов ТС для тех мест, где это необходимо. Аналог - справочник стран.
 
 Альтернативные подходы опишу позже
 
 ### Блок "Синхронизация с режимом работы"
 TODO
 Кратко: эффективность хочет проставлять режим работы для водителей с разными типами навигации.
 На режим работы можем завязать разветвления в работе водителей:
 - показ карты суржа и ряда других разделов в таксометре
 - штрафы активности
и т. д.

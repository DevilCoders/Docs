# QC Admin 2.0

Админка фотоконтроля - собирательный термин в фотоконтроле, включающий в себя 
весь флоу того, что происходит с проверкой от момента, как водитель 
(пользователь) прислал весь комплект документов и до момента, когда по проверке 
выносится финальная резолюция

Текущее решение и функциональность описаны [тут](./.NET%20solution.md)

### Цели

Объем экзаменов ФК постоянно растет, как в ширину (добавляются новые проверки).
Так и в глубину (увеличивается частота проверок). Из-за этого остро встает 
вопрос эффективности асессоров. Для увеличения эффективности флоу проверки 
достаточно быстро меняются:
* Придумываются все новые автоматические "этапы" проверки 
    (распознавание документов, поиск дубликатов, проверка скоринга и т.п.)
* Постоянно расширяется UI асессоров. Добавляются новые каналы коммуникаций.
Вкладки истории проверок. Дополнительные кнопки резолюций.

Дополнительно планируется появление новых заказчиков со своими требованиями и идеями.

Наша команда не в состоянии удовлетворять всех заказчиков в кратчайшие сроки.
Поэтому хочется предоставить заказчикам простой и удобный иструмент по добавлению 
различных этапов и предоставить им самим возможность разрабатывать UI под их 
конкретные требования.

В этом случае наша команда сможет сосредоточиться на улучшении инфраструктуры сервиса,
разработке универсальных "кубиков", которые позволят заказчикам решать их задачи. 

### План по переезду

#### Этап 1. Отделение коммуникаций (4d)
Коммуникации можно отправлять не в момент принятия резолюции, а по результатам
мониторинга изменений проверок и состояний. В первоначальном варианте следует:
* Выставить в C# ручки, которые отправят email в парк. (<x-service>/utils/qc/email)
* Написать джобу отслеживания состояний (state/list) (Можно в taxi-qc-exams)
* Написать джобу отслеживания проверок (pass/list) (Можно в taxi-qc-exams)
Джоба по state будет отправлять push driver-check (на каждое "значительное" изменение)
Джоба по pass'ам будет обрабатывать только Resolved проверки. 
И последовательно отправлять сообщение в чат водителю (возможно через feeds), а
в случае неуспешной резолюции дополнительно письмо в парк.
В дальнейшем код должен отделится в отдельный [сервис](./../notifications.md)

#### Этап 2. Отделение "меток" (5-8d)
Нужно оценить количество меток используемых в сервисе и пойти по одному из трех вариантов:
1. Навешивать метки на соответствующие сущности в сервисе driver-tags.
Плюсы:
    * Доступность наших меток везде внутри сервиса такси, можно не заниматься дополнительной синхронизацией
    * Не нужно заказывать дополнительную инфраструктуру
Минусы:
    * Нет возможности завести свой дополнительный тип сущности.
    * Большинство тегов используется только в контексте асессоров и не нужны всему такси.
    Не хочется превращать driver-tags в помойку
    * Есть возможность конфликта имен.
2. Написать свой сервис qc-tags
Плюсы:
    * Легкое порождение собственных сущностей
    * Легкая миграция. Можно создать сервис вокруг существующих мест хранения
    * Можно расширять функциональность и вырастить сервис в сервис assessor-communications
Минусы:
    * Необходимость заказа собственной инфраструктуры
    * Собственное сопровождение сервиса
    * Урезанная функциональность
3. Сделать новую реплику сервиса tags
Плюсы:
    * Не нужно писать дополнительный код. Все работает из коробки
    * Можно заводить собственный сущности, топики и т.п.
Минусы:
    * Сложность поддержки чужого кода 
    (либо мы поддерживаем "чужой" код, либо будут сложности с согласованием)
    * Нужна полноценная миграция существуюущих данных
    * Нужна дополнительная инфраструктура
    
Предпочтительным вариантам выглядит вариант **номер 3**.
План по переходу на него:
1. Заказываем инфраструктуру **(1d)**
2. Силами группы тегов выкатываем новую реплику **(1-2d)**
3. Добавляем в шарпах код сохранения меток в новом сервиса **(1d)**
4. Пишем скрипт миграции текущих меток в сервис **(1-2d)**
5. Меняем чтение из dbdrivers/dbcars на чтение из сервиса **(1d)**
6. Удаляем код сохранения. Вычищаем метки из dbdrivers/dbcars **(1-2d)**
    
#### Этап 3. Простая версия "асессорский" qc-pools (4-5d).
1. Создаем инфраструктуру, детально разрабатываем схему БД **(2d)**
2. Пишем таску перекладывания проверок в пулл **(2d)**
3. Пишем пулл для асессорских проверок **(2d)**
    * Добавление проверки в pool при получении проверки в статусе Pending
    * Удаление проверки при получении проверки в статусах Resolved/Cancelling
4. Простые продуктовые метрики - количество проверок в пулле, количество Cancelling проверок
5. Технические метрики. Cтандартные метрики джобы:
    * отставание курсора
    * количество обработанных проверок по каждому экзамену
6. Monrun мониторинг на WARN/CRIT по количеству проверок в пулле.

#### Этап 4. Доделки пока идет UI разработка новых проверок в Yang'e. (?d)
1. Сделать fetcher "меток" **(1d)**
2. Сделать сохранение "меток" при вынесении резолюции **(2d)**
3. Сделать простые правила маршрутизации по пуллам **(3-4d)**
4. Настроить логирование в отдельную коллекцию на YT (а-ля qc-log) **(1-2d)**
5. Написание полноценной админки для заведения пуллов и настроек правил маршрутизации. **(4d)**

#### Этап 5. Перенос "автоматических" проверок (4d)
1. Перенос Nirvana, Sts, Toloka'и **(1d)**
2. Написание джобы для проверки фотоконтроля ДКК ML **(3d)**
3. Мелкие доделки вида поиска циклов маршрутизации и т.п.

**Сервис gas_stations**

Он же gas-stations

**Какую продуктовую проблему решает сервис?**

Есть проект Я.Заправки и Я.Диспетчерская, они интегрированы. Директор парка может принять оферту и
у его водителей появится кнопка Заправка с помощью которой он сможет заправится на АЗС со счета таксометра.
[Детали по проекту](https://wiki.yandex-team.ru/users/a-pianov/projects/yandex-taxi-gas/).
[Текущее описание функциональности](https://wiki.yandex-team.ru/gasfortaxi/).

В такси планируется увеличение количества самозанятых водителей. Хочется, чтобы самозанятые водители,
которые сами себе директора имели такие же возможности, как и водители, прикрепленные к парку.

Сервис `gas_stations` предназначен для предоставления возможности заправляться со счета таксометра для самозанятых
водителей.

Дальше, после перехода на Диспетчерскую 2.0 все взаимодействие диспетчерской с Я.Запрвками будет так же проходить
через сервис `gas_stations`.

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Если самозанятые водители (ИП и СМЗ), они сами себе директора и никогда не заходят в Диспетчерскую, так
как она им не нужна и доступа они не имеют. Проблема в том, что они не могут подтвердить оферту и начать заправляться,
поэтому требуется интерфейс таксометра и поддержка backend-а для решения данной задачи.

Задача является достаточно уникальной с точки зрения бизнеса и пока что не вписывается
в логику уже существующих сервисов, типа `driver-profile-view`.

Планируется, что данный сервис будет единственной точкой входа для общения с Я.Заправками, не зависимо от
потребителя.

**Как именно сервис будет решать поставленные перед ним задачи?**

Дисклеймер: далее описана общая концепция, не вся она достежима в первой итерации.

Сервис предоставляет внутренние и внешние ручки, которые выполняют:
1) подписание оферты на использование заправок (для Оптеума и Таксометра)
2) отмену подписания оферты на использование заправок (для Оптеума и Таксометра)
3) изменение лимита, который можно потратить на заправки со счета таксометра (для Оптеума и Таксометра)
4) возврат информации о статусе подписание оферты (для Оптеума и Таксометра)
5) изменение статуса подписания оферты, как callback на ответы сторонних сервисов (см. ниже)

В первой итерации планируется поддержание пунктов: 1, 3, 4, 5 только для Таксометра (реализация задачи о самозанятых).
Пункт 3 будет поддержан через подписание нового договора.

**Разрабатывается один сервис или система?**

Разрабатывается сервис.

**С кем взаимодействует сервис?**

Потребители:
1. Таксометр - с первой итерации
2. Диспетчерская 2.0 (Оптеум) - со второй итерации

Сервисы:
1. Сервиc `taxi-partner-contracts`
[Ссылка на информацию о сервисе](https://wiki.yandex-team.ru/taxi/backend/architecture/taxi-partner-contracts/)
Как используется?
Вызывается для создания документа-оферты, который необходимо подписать водителю (или директору парка).
Вызывает `gas_stations`, как callback на создание оферты. 

Как гарантируется идемпотентность при запросах?
Каждый запрос подписывается уникальным ключом inquiry_id, который описывает поданную заявку на подписание
оферты. Сервис не допускает создание 2х заявок с одинаковым идентификатором.

Как поддерживаются отказы?
Если сервис `taxi-partner-contracts` не отвечает или отвечает очень долго, то возвращаем пользователю
ответ со смыслом "Договор пытались принять, но возникла ошибка, требуется повторное принятие". После чего
пользователь должен попробовать подписать договор еще раз.

Как организованы ретраи?
Прописаны в конфиге клиента, точные цифры будут указаны в процессе разработки и согласования с ответственными
за сервис.

2. Сервис `tanker` (Я.Заправки)
[Ссылка на информацию о сервисе](https://wiki.yandex-team.ru/benzin/)

Как используется?
Вызывается для создания кабинета заправок.

Как гарантируется идемпотентность при запросах?
Если существует созданный кабинет в Я.Заправках, он не создается повторно.
При ошибке создания кабинета пользователь должен будет еще раз попробовать создать кабинет (будет
указано в ошибке).

Как поддерживаются отказы?
Если доступ к кабинету Я.Заправок ограничен, то пользователю возвращается информативная ошибка.
При ошибке создания кабинета пользователь должен будет еще раз попробовать создать кабинет (будет
указано в ошибке).

Как организованы ретраи?
Прописаны в конфиге клиента, точные цифры будут указаны в процессе разработки и согласования с ответственными
за сервис.

3. xservice (временное решение)
Сейчас используется ApiKey сохранение для `Я.Заправок` в `Redis`. [См. тут](https://github.yandex-team.ru/taximeter/taxi-cloud-yandex/blob/8b548432bb008a82689e7e41812336971fe07562/src/Yandex.Taximeter.Core/Services/Gas/GasStationsService.cs#L295)
Не хочется тащить эту логику в новый сервис, так как потом общение с Заправками будет переведено на APIv7.
Временно в xservice будет выставлена ручка для получения api-key для похода в заправки.

**Какие периодические процессы?**

На данный момент периодических процессов не планируется.

**Прикрепите схему того, где этот сервис находится в текущей инфраструктуре**

![Alt text](./taxi_gas_stations_service.png?raw=true "Схема взаимодействия в первой итерации")

1. Как технически проект влияет на цикл заказа.
На цикл заказа никак.

2. Кто будет потребителями сервиса.
Изначально потребителем сервиса будет только `таксометр` - подписание оферты и получение информации
о статусе подписания оферты.
Далее потребителем становится `Диспетчерская 2.0` (использование аналогично таксометру).

**Какие базы использует? Какие данные и по какой схеме сервис будет хранить в базе?**

Какие таблицы, индексы, уровни изоляции транзакций, особенности запросов и тп.
Объем хранимых данных, как их подразумевается чистить. Ресурсы под СУБД (cpu, ram, disk).

Первая итерация:
Используется СУБД `PostgreSQL`, `MongoDB`.
Используется коллекция `dbparks.parks` из `MongoDB`([см. использование](https://github.yandex-team.ru/taximeter/taxi-cloud-yandex/blob/8b548432bb008a82689e7e41812336971fe07562/src/Yandex.Taximeter.Core/Repositories/MongoDB/Docs/Park/ParkDoc.cs)), и сущность `gas_stations` оттуда, которая хранит в себе информацию о доступности/недоступности
заправок для данного парка или водителя и время принятия оферты.
[Смотри схему здесь](https://pages.github.yandex-team.ru/taxi/schemas/Taxi_Documentation/Mongo%20collections/parks/dbparks/)

Также используется временное хранилище состояний подписания оффера во внутреннем хранилище, `PostgreSQL`. Несет в себе функцию:
когда отправляется запрос на создание кабинета в `partner-contracts` сохраняет время запроса и сопутствующую информацию
для срабатывания таймаута при отсутствии ответного запроса и быстром возвращении состояния "на подписании" без перезапросов.
[См. тут](https://github.yandex-team.ru/taximeter/taxi-cloud-yandex/blob/8b548432bb008a82689e7e41812336971fe07562/src/Yandex.Taximeter.Core/Services/Gas/GasStationsService.cs#L97)

Вторая итерация:
Используется СУБД `PostgreSQL`.
Используется база `dbparks.gas_stations`, перенесенная из сущности `gas_stations` внутри `dbparks.parks`.
Схема данных будет разрабатываться позже.

**Какие операции над данными заложены? Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

Производятся прямые запросы к базе на чтение (частая операция, происходит при запросе "отдай статус создания кабинета")
и на запись (только при создании кабинета, ручка "принять оферту").

В дальнейшем планируется вынесение из `dbparks` сущность `gas_stations`,
тогда сам сервис будет выполнять роль сервиса api над данными.

Запросы к базе (расписано только для ручек в первой итерации):
1. ручка `/driver/v1/offer/state` - будет вызываться при работе с экраном таксометра, во время ожидания принятия оферты. Периодичность запроса обсуждаема с таксометром.
Пока, предположительно, раз в 5 секунд.
2. ручка `/driver/v1/offer/accept` - можно считать относительно приходящих каждый день новых самозанятых, [см. график](https://grafana.yandex-team.ru/d/cvcz5iUik/selfemployed?orgId=1&refresh=30s).
3. ручка `/driver/v1/account/created` - аналогично `/driver/v1/offer/accept`, так как это callback.

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

Работа происходит напрямую с базой, так как пока планируется низкий RPS, кеш не требуется.

**Какая нагрузка ожидается?**

1. ручка `/driver/v1/offer/state` - будет вызываться при работе с экраном таксометра, во время ожидания принятия оферты. Периодичность запроса обсуждаема с таксометром.
Пока, предположительно, раз в 5 секунд. ~ 2 RPS.
2. ручка `/driver/v1/offer/accept` - можно считать относительно приходящих каждый день новых самозанятых, [см. график](https://grafana.yandex-team.ru/d/cvcz5iUik/selfemployed?orgId=1&refresh=30s).
Т.Е. в худшем случае 5RPS, но в среднем очень низкий RPS (сейчас ~100к СМЗ всего + меньше 100 регистраций в час в среднем).
3. ручка `/driver/v1/account/created` - аналогично `/driver/v1/offer/accept`, так как это callback.

Нагрузочное тестирование не далается, так как есть продовые данные.

**Какие фолбеки предусмотрены на сам этот сервис?**

Если сервис не отвечает, то пользователь не может получить доступ к кабинету заправок.
Возвращается 500 Internal Error, так как сервис не критичен.

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

Поведение при отказе соседних сервисов описано выше.

Какие особенности будут при отключении ДЦ?
Сервис хранит в себе данные общие для всех пользователей. При отключении одного ДЦ ожидается, что сервис из других ДЦ 
будет отдавать ответ вне зависимости от пользователя. Шардирования данных нет.

При полном отказе пользователи не будут иметь доступа к кабинету заправок (создание, переход в него).

Как будет тестироваться отказоустойчивость?
Поведение при отказе сервисов уже описано выше.
при отказе базы возвращается 500 Internal Error, так как сервис не критичен.

**Какие возможности масштабируемости закладываются?**

Существует конфиг регуляции процессов внутри сервиса: [см. ссылку](https://tariff-editor.taxi.yandex-team.ru/dev/configs/edit/TAXIMETER_GAS_STATIONS_SETTINGS?name=GAS)

Поскольку данные сервиса не шардируются, при росте количества машин, сервис будет равномерно распределять
нагрузку между всеми машинами. На каждой машине должны жить данные отписанные выше.
Чем больше машин, тем меньше нагрузка на каждую машину.

`PostgreSQL` - расширяем
`MongoDB` - уже имеет большой запаc

Соседние сервисы:
`taxi-partner-contracts` - должен мочь выдерживать RPS ручки `/driver/v1/offer/accept`, на данный момент утвержадается, что это возможно, можно [посмотреть графики](https://grafana.yandex-team.ru/d/03MUg1bik/taxi_conductor_taxi_partner_contracts?orgId=1&refresh=30s).
`tanker` (Я.Заправки) - должен мочь выдерживать RPS ручки `/driver/v1/offer/accept`, на данный момент утвержадается, что это возможно.

Хорошо масштабируется горизонтально (добавить машин) - запрос на получение состояния оферты.
Не масштабируется вертикально (добавить мощи) - бессмысленно.

**Какие точки отказа есть в сервисе?**

1) Соседние сервисы.
2) PostgreSQL.
3) Mongo.

Фоллбэки описаны выше.

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить. Укажите технические метрики.**

И для продукта, и технчески необходимо мониторить:
1) количество успешных созданий кабинета
2) количество успешных запросов статуса создания кабинета
3) количество ошибочных созданий кабинета (алерт, на ошибки > 30%)
4) количество ошибочных запросов статуса создания кабинета (алерт, на ошибки > 20%)

Технически необходимо мониторить:
1) количество таймаутов при ожидании callback со стороны `taxi-partner-contracts` на создание кабинета 
2) bad/ok rps в Я.Заправки

Все графики с указанными выше показателями будут жить в [графане](https://grafana.yandex-team.ru).

**Какая функциональность ожидается в сервисе в будущем?**

Этапы разработки для первой итерации:
1) реализация ручки `/driver/v1/offer/state` - 1w (нужно разбираться как прикручивать базу, пока я этого не умею)
2) реализация ручек `/driver/v1/offer/accept`, `/driver/v1/account/created` - 1w
3) реализация ручки `/service/v1/offer/state` - 2d - ручка переиспользует `/driver/v1/offer/state`
4) реализация ручек `/service/v1/offer/accept`, `/service/v1/account/created` - 2d - ручки переиспользуют `/driver/v1/offer/accept`, `/driver/v1/account/created`
5) переезд с `Redis` на что-то другое для сохранения состояний

**Какое изменение нагрузки планируется?**

Нагрузка будет увеличиваться пропорционально росту количества самозанятых водителей в Я.Такси.

**Активно ли будет изменяться сервис?**

После реализации плана в пункте выше сервис НЕ планирует активно изменяться.

**Как раскатываем?**
1. Раскатываем сервис полностью.
2. Стреляем ручными запросами.
3. Переключаем ручки через конфиг или эксперимент - проверяем, что все работает.
4. Раскатываем на 100%.

**Авторизация**
Ручки таксометра - через driver-authorizer
Сервисы - TVM2.0
Я.Заправки - ApiKey

<hr>

**Не забыть**
1. Заказать дырки:
- тестинг
- прод
2. Протащить TVM авторизацию везде
3. Сделать графики и мониторинги


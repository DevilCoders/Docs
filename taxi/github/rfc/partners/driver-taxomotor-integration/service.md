**Название сервиса**

`deptrans-driver-status-integration`

**Какую продуктовую проблему решает сервис?**

В 4 квартале 2020 года в Москве вводят в эксплуатацию систему "цифровых профилей" для таксистов - АИС "КРТ". Она будет контролировать режим труда и отдыха водителей, не допустит регистрации в базе водителей с поддельными удостоверениями, без опыта водительского стажа и т.д.

Каждому водителю при регистрации через ГосУслуги присваивается уникальный идентификатор (**ID**), который в дальнейшем должен использоваться сквозным образом во всех информационных системах (ИС), связанных с деятельностью такси, в том числе и Яндекс.Такси

Все ИС связанные с деятельностью такси должны сообщать в АИС "КРТ" о подключениях и отключениях водителей к системе приёма заказов. В нашем случае это выход на линию и уход с линии. В ответ АИС "КРТ" вернёт данные о состоянии смены водителя и о времени её окончания.

Сервис `deptrans-driver-status-integration` будет инкапсулировать в себе логику по взаимодействию с АИС "КРТ" и предоставит остальным внутренним сервисам Яндекс.Такси удобные и расширяемые методы для работы с АИС "КРТ". 

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Подходящего сервиса в который можно подселить новый функционал нет. Планируется много логики, которую удобно сразу отселить в отдельный сервис. 

Нужно уметь отвечать на вопрос "Может ли водитель выполнять заказы в данный момент".
Из существующего такой функционал ближе всего к проверке лицензий, которая реализована в виде фильтра в `candidates`, но для данной задачи возмножностей одних фильтров недостаточно.

Нужно взаимодействовать с внешним сервисом для отправки событий по изменению статусов водителей и проверки состояния смены водителя.

Ещё нужно дать возможность водителям устанавливать свой **ID**. 

**Как именно сервис будет решать поставленные перед ним задачи?**

* Делаем компонент для взаимодействия с АИС "КРТ". Получение/сохранение токена, подстановка токена в остальных запросах.
* Делаем водительские ручки для установки/получения **ID**. Перед сохранением нового **ID** проверяем его соответствие номеру ВУ в АИС "КРТ".
* Делаем периодик-таску для сохранения событий по изменению статусов водителем. Получает события от `driver-status` и сохраняет в очереди `deptrans.status_queue`.
* Делаем периодик-таску для обработки очереди `deptrans.status_queue` и отправки статусов в АИС "КРТ". При отправке обновляем текущее состояние смен. Очередь используем для только для отправки актуального статуса, при отправке будем удалять запись из очереди. 
* Делаем межсервисные ручки для инкрементального наполнения кешей. В них будут ходить сервисы `driver-diagnostics` и `candidates` для получения **ID** водителей и состояния и время окончания смены. По этим данным делаем фильтры, результаты которых будем отображать в диагностике `Я.Про` и `UberDriver`.

  Для удобства потребителей в ответе межсервисных ручек можно отдавать профили с park_id и driver_id в качестве идентификатора, получая их из кеша над `driver-profiles`.

**Разрабатывается один сервис или система?**

Один сервис 

**С кем взаимодействует сервис?**

1. `Я.Про` и `UberDriver`
   
   Получение/установка **ID**.
   Ошибки обрабатываем стандартным для клиента способом.

   Вместо самого **ID** на клиент можно возвращать факт его наличия, если **ID** является секретом, который желательно не показывать и лишний раз не передавать по сети.

2. `driver-status`

    Отправка событий по изменению статуса в `deptrans-driver-status-integration` через logbroker. Читаем из топика /taxi/contractor-statuses-events как в сервисе `contractor-status-history`.

3. `driver-trackstory`

    Для получение позиций водителей при обработке статусов. Посылаем обновления только для определённых регионов по конфигу. Изначально - Москва. 

4. `driver-diagnostics` и `candidates`

    Ходят в `deptrans-driver-status-integration` для наполнения кешей по биндингам и статусам из системы АИС "КРТ" в фильтрах для диагностики.
    * Один фильтр - проверка заполнения **ID** по региону. 
    * Второй - проверка статуса смены по региону.
    
    При отказе `deptrans-driver-status-integration` не будем показывать проблему в списке диагностики на клиенте.
    В MVP в `driver-diagnostics` добавляем неблокирующие проверки. В будущем добавляем в `candidates` аналогичные фильтры с возможностью отключения в качестве фолбека. 

5. `АИС "КРТ"`

    Проверка водителей и отправка статусов.

6. `personal`

    Получение ВУ по driver_license_pd_id

7. `driver-categories-api` -

    Получение категорий для фильтрации статусов. Будем отправлять статусы, только если водитель работает хотя бы по одному тарифу из списка в конфиге. Изначально "Эконом", "Комфорт", "Комфорт+". 

**Какие базы использует?**

только свою

**Какие периодические процессы?**

Периодик-такса для обработки событий из /logbroker/taxi/contractor-statuses-events. Получает события по изменению статусов водителя и сохраняет в таблицу `deptrans.status_queue`. 

Другая периодик-таска отправляет статусы водителя из `deptrans.status_queue` в АИС "КРТ" и удаляет обработанные статусы из очереди. Возвращаемый АИС "КРТ" актуальный статус смены и время до которого она действует сохраняются в таблице `deptrans.session_statuses`. 

**Прикрепите схему того, где этот сервис находится в текущей инфраструктуре**

1. Как технически проект влияет на цикл заказа.

    В MVP будем показывать в диагностике неблокируюище проблемы. В перспективе сделает фильтры в `candidates`, которые будут фильтровать водителей попадающий в зону действия эксперимента по **ID** и наличию активной смены.

2. Кто будет потребителями сервиса.

    Основные потребители это `driver-diagnostics` и `candidates`. Незначительные - `Я.Про` и `UberDriver`.

**Какие данные и по какой схеме сервис будет хранить в базе?**

Таблица для хранения связки профиля с **ID** по driver_license_pd_id.
Будет меняться редко, только при изменении ВУ водителя.

`deptrans.profiles`
  * driver_license_pd_id
  * deptrans_id - **ID**, идентификатор водителя в АИС "КРТ"
  * updated_at - дата изменения + индекс

Таблица для хранения результатов проверки водителя при отправке статусов
Будет меняться часто, можно хранить историю за последние 1-30 дней

`deptrans.session_statuses`
* driver_license_pd_id
* session_status - статус на момент последнего обновления сессии
* updated_at - дата изменения + индекс
* ended_at - дата окончания + индекс

Таблица с очередью для отправки статусов в АИС "КРТ" 

`deptrans.status_queue`
* park_id - идентификатор парка
* driver_id - идентификатор водителя внутри парка
* status - последний актуальный статус водителя

**Какие операции над данными заложены? Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

`deptrans.profiles`

Из оценки в 1кк уникальных ВУ в Москве получим около 100мб. 


`deptrans.status_queue`

В `driver-status` около 1.1k rps на смену статуса. 
На водителей Москвы приходится примерно 20%.
Итого нам нужно обрабатывать 220 событий в секунду и по каждому сохранять результат обновления статуса в базе.
Таким образом в секунду будем обновлять около 20 кб. 

Из расчёта, что в сутки в Москве 400к уникальных водителей (пик активных * 10) таблице будет не больше 40 мб, если хранить только последние сутки.

`deptrans.session_statuses`

Так же по количеству уникальных водителей можно оценить размер таблицы сверху в 100 мб.

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

кеш над driver-profiles для получения driver_licence_pd_id

кеш над driver-categories-api для получения категорий

**Какая нагрузка ожидается?**

На водительскую driver/v1/deptrans-status/v1/id GET/POST ручку от `Я.Про` и `UberDriver` меньше 1rps

На ручки получения обновлений от `driver-diagnostics` и `candidates` internal/v1/id/updates и internal/v1/status/updates нагрузка зависит от интервала обновления кешей.

При 1 секунде/10 минутах для инкрементального/полного обновления соответственно 62 инстанса `candidates` дадут нагрузку < 100 rps

При 10 секундах/10 минутах < 10 rps


**Какие фолбеки предусмотрены на сам этот сервис?**

* не показываем проблемы в блокировках
* не показываем привязанный **ID** на клиенте

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

* При недоступности АИС "КРТ" не разгребаем очередь обновления статусов `deptrans.status_queue`, не отправляем статусы. Когда АИС "КРТ" становится доступным начинаем разгребать очередь и посылать актуальные статусы.

* При недоступности driver-profiles - используем данные из кеша, после рестарта не поднимаем сервис
* При недоступности driver-categories-api - используем данные из кеша, после рестарта не поднимаем сервис

**Какие возможности масштабируемости закладываются?**

Поскольку данные сервиса не шардируются, при росте количества машин, сервис будет равномерно распределять нагрузку между всеми машинами. На каждой машине должны жить данные отписанные выше. Чем больше машин, тем меньше нагрузка на каждую машину.
Скорей всего будем упираться в ручки АИС "КРТ" пока там не сделают балковые методы 

**Какие точки отказа есть в сервисе?**

  1. База. Какое-то время можно жить на кешах
  2. `driver-profiles` - при недоступности не поднимаемся после рестарта
  3. `driver-trackstory` - не посылаем обновления статусов в АИС "КРТ"

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

На время работы в неблокирующем режиме оцениваем сколько саплая мы можем потерять после переключения.

**Укажите технические метрики**

rps, тайминги, ошибки

**Какая функциональность ожидается в сервисе в будущем?**

Этапы разработки:

1. Заглушки на сервере для тестирования клиентов -  1д
2. Компонент для взаимодействия с АИС "КРТ" - 2д
   * Получение и сохранение токена
   * Обёртки для остальных ручек 
3. Обработка истории статусов - 5д
    * Периодик-таска для сохранения событий переключения статусов в очередь - 2д
    * Периодик-таска для отправки статусов из очереди в АИС "КРТ"
4. Меняем заглушки на настоящие ручки -  2д
5. Новые проверки в `driver-diagnostics` - 4д
   * Фильтр с проверкой наличия **ID** - 2д
   * Фильтр с проверкой текущего статуса - 2д
6. Подчистка техдолга - 3д

**Какое изменение нагрузки планируется?**

Если в будущем сервис будет работать не только в Москве - пропорционально количеству водителей в новых регионах

**Активно ли будет изменяться сервис?**

После завершения интеграции - нет

<hr>

## Бизнесовая задача

### Продуктовые ограничения

#### Этап 1

  Показываем водителям неблокирующие ограничения в диагностике, собираем статистику

#### Этап 2

  Переключаем ограничения в блокирующий режим

**Название сервиса**

driver-diagnostics

**Какую продуктовую проблему решает сервис?**

Сервис проводит полную диагностику водителя и возвращает результат. Большинство проверок будет производиться через сервис candidates.

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

В данный момент функционал диагностики выполняет ручка /driver/check в driver-protocol.
Она берет проверки из tracker, хотя проверка водителя на заказ осуществляется через candidates.
Из за этого возникают случаи, когда мы даем неверную резолюцию в диагностике.
Функционал планируется модифицировать и расширять, а развивать код в устаревшем dp не хочется.
Поэтому нужен отдельный сервис, который инкапсулирует водительскую диагностику.

**Как именно сервис будет решать поставленные перед ним задачи?**

Планируется завести в сервисе набор ручек, которые будут отдавать информацию о диагностике:
 - взаимодействие с Таксометром будет производиться через 2 ручки: одна будет поллится и отдавать количество проблем, вторая отдавать подробную информацию для экрана диагностики.
 - ручка для админки
В перспективе добавим проверку через диагностику при переключении тарифов.
Для этого нужно будет взаимодействовать с driver-categories-api
Также возможно добавление ручки для диспетчерской.

Все ручки будут иметь единую логику для проверок. Основным источником проверок информации будет ручка /satisfy сервиса candidates.
Также в сервисе будет набор проверок, которые по каким-то причинам не смогли переехать на candidates.

После выполнения всех проверок водительская ручка будет собирать конструктор для экрана диагностики из списка причин:
 - добавлять понятный пользователю текст
 - deeplink на другой экран, ссылка на внешний ресурс или конструктор с инструкцией как исправить проблему
 - уровень критичности проблемы, от которого будет расположение сообщения на клиенте
Для этого в первой итерации будет заведен конфиг, который будет определять какую именно информацию нужно показать клиенту, если фильтр сообщил о проблеме.

Текущие проверки, которые есть в /driver/check и чем они будут заменены:
 - CheckDriverTags - проверка тегов. В текущем виде нет в candidates. К тому же есть warning теги, поэтому придется дублировать логику в новом сервисе.
 - GeoareaCheck - тут достается ближайшая геозона. Нужно для проверки тегов, дублируем в новом сервисе.
 - CheckTaximeterVersion - проверка, что версия выше минимальной. Аналогичная логика в фильтре infra/taximeter_version. Можем передавать в /satisfy мин. версию из нашего конфига.
 - check_selfemployed_block, CheckSelfemployedRestrictions - Проверки СМЗ. Состоят из 2 частей: проверка минимальной версии Таксометра, поддерживаемой СМЗ и блок/warning отвязавшимся водителям.
 - CheckInvalidBankprops - проверка реквизитов СМЗ. Вынесем в фильтр
Проверки версий можно закопать. Вторая часть отлично выносится в фильтр в candidates.
 - CheckZoneTaximeterVersion - проверка, что версия выше минимальной в зоне (локальный форсапдейт). Легко унести в фильтр
 - QcServiceCheck - Проверка QC. Блокировки будем получать из шарпов. 
 - CheckPhotoStatus - проверка фото водителя. Будет вынесено в фильтр в candidates в [этом](https://nda.ya.ru/t/2kodyZe63Vycuq) тикете
 - check_driver_balance - проверка баланса, выставление onlycard
 - check_driver_weariness - Логика уже дублирована в candidates
 - check_reposition - Проверки дублированы в candidates. Осталось понять, что делать с запросом в StopRepositionIfNeed(...)

Проверки в driver/check, которые используют редис:
 - check_car_blacklist - уедет в сервис блеклистов. [Тикет](https://st.yandex-team.ru/TAXIMETERBACK-9317)
 - check_driver_blacklist - аналогично car_blacklist
 - check_time_block - закапываем
 - check_status_and_chain - уже проверяется в candidates
 - check_aggregator - Добавим в шарповую ручку с проверками блоков

Фильтры в candidates указаны в [этой](https://nda.ya.ru/t/yBRUomku3VzRrz) таблице. Детали могут обновляться

Водительские блокировки будем получать из шарповой [ручки](https://nda.ya.ru/t/BwacciKn3VzS94).
Если candidates вернули упавший фильтр driver-blocks, то ищем блокировку у нас в кэше.
Если блокировку не находим, то идем напрямую в шарпы за информацией.

В текущий момент большинство блокировок в C# используют редис.
Быстро завести на них фильтры в candidates не получится.
На первом этапе оставляем проверки в шарпах, т.к. они критичны для диагностики, позже переведем их на candidates.
Дополнительных доработок со стороны driver-diagnostics для поддержания фильтров по блокировкам не понадобится.

Блокировки по фотоконтролю получаем по схеме, аналогичной остальным шарповым блокам.
При тапе на экран, водитель будет переходить на отдельный экран фотоконтроля с подробной информацией.
За информацией по брендингу, будем отдельно ходить в qc

Планируемые конфиги:

DRIVER_DIAGNOSTICS_ITEMS - основной конфиг. Будет содержать список причин со следующими параметрами:
 - название фильтра или дополнительной проверки. Пример - проверка брендинга вне candidates.
 - дополнительные поля у проверки. Например, для проверки усталости нам нужно узнать время, до которого заблокирован водитель. Или список требований
 - танкерный ключ с текстом проблемы
 - флаг для отображения. Нужно ли показывать данную причину на Таксометре
 - критичность. От нее зависит экран, на котором будет показа проверка
 - action. Что будет происходить при тапе на проблему
Форматы action:
 - deeplink. Переход на экран, который поможет починить проблему. Пример - фотоконтроль
 - конструктор. Формирует экран с описанием
 - внешний url. Пример - прохождение экзамена

DRIVER_DIAGNOSTICS_TARIFFS_SETTINGS
Содержит список проверок, которые необходимы для определенного тарифа.
Например, для детского тарифа нужно соответствующее требование в фильтре requirments

DRIVER_DIAGNOSTICS_SATISFY_REQUEST
Список параметров, которые добавляются в запрос ручки /satisfy.
Нужно, что мы без перевыкатки смогли добавить проверку нового требования или определнного фильтра.
Важно - позволяет добавлять только статичные параметры в запрос. Динамические параметры типа zone_id нужно добавлять в коде

DRIVER_DIAGNOSTICS_FALLBACK
Нам важно раличать случаи, когда фильтр прошел успешно или не запускался совсем.
В этом конфиге будет список фильтров-зависимостей, которые нам критичны.
Если упало что-то из этого списка, мы будем знать, что пропустили важные фильтры с проверками и будем выставлять меньший интервал для ретрая или отдавать 500.

**Этапы разработки**

1. 
Заводим новый сервис с водительскими и админскими ручками, добавляем поход в /satisfy сервиса cadidates.
Переносим в candidates все проверки, на которые можно быстро завести фильтр. Пример - проверки СМЗ.
В driver-diagnostics переносим все действующие проверки из driver/check, которые не заезжают в candidates. Пример - проверка тэгов.
Добавляем поход в шарпы за водительскими блокировками, кэширование блокировок.
Добавляем метрики, которые позволяют показать фильтры из candidates, на которые у нас нет настроек.

2. 
Проверки водительских фото и блокировок переводим на фильтры в candidates, убираем лишние запросы.

3. 
Оставляем в сервисе только те проверки, что вляют на количество заказов водителя или полностью его блокируют.
Добавляем удобную систему для дополнительных проверок, которые не попадают в candidates.

**Разрабатывается один сервис или система?**

Один сервис

**С кем взаимодействует сервис?**

 - ручка /satisfy сервиса candidates
 - driver-authorizer для авторизации водителей
 - geoareas для наполнения кэша по геозонам
 - в первой версии перенесем из /driver/check поход в driver-photos. Позже откажемся от прямых запросов в пользу фильтра в candidates
 - шарповая ручка из [тикета](https://nda.ya.ru/t/BwacciKn3VzS94)
 - в перспективе driver-categories-api. Понадобится при добавлении проверка на влючения тарифа

**Какие базы использует?**

Никакие

**Какие периодические процессы?**

Нет

**Планируется обработка персональных данных**

Нет

**Какие данные и по какой схеме сервис будет хранить в базе?**

В сервисе будет набор кэшей:
 - кэш геозон через библиотеку client-zone-geoindex
 - кэш водительских статусов через библиотеку driver-status-cache
 - кэш водительских блокировок. Будет наполняться по всем активным водителям из кэша статусов из ручки, добавленной в [тикете](https://nda.ya.ru/t/BwacciKn3VzS94)
Если фильтр driver-blocks вернул блок водителя, то нам нужно получить полный список блокировок.
Для этого сначала ищем водителя в нашем кэше. Если не нашли, то идем напряумаю в шарпы


**Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

—

**Какие операции над данными заложены?**

—

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

Нет

**Какая нагрузка ожидается?**

Сервис заберет на себя нагрузку /driver/check из dp.
Сейчас это ~1500 rps с пиками до 2000.
Планируется, что rps уменьшится благодаря доработкам клиента (становится меньше сценариев, при которых дергается ручка) и изменению логики переключения статуса "На линии".
[Тикет](https://nda.ya.ru/t/lLfc61i33VzVFs) на клиентские метрики


**Какие фолбеки предусмотрены на сам этот сервис?**

- В Таксометре: водитель не сможет зайти в раздел диагностики
- В админке: невозможно будет посмотреть диагностику по водителю

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

При отказе других сервисов водительская ручка будет отдавать неполную диагностику.
Т.к. ручка полится Таксометром, то водитель получит нужыне данные, но позже.
В перспективе будем смотреть в сторону умной политики ретраев.
Сможем сделать только доработками бекэнда, т.к. интервал ретрая будет отдаваться в хидере ответа ручки.

**Какие возможности масштабируемости закладываются?**

...

**Какие точки отказа есть в сервисе?**

1. Отказ ручки /satisfy candidates
2. Отказ ручек других проверок, которые живут вне candidates. На первом этапе таким местом будет запрос в driver-photos

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

- Список причин, которые мы отдаем водителю с количеством водителей, увидевших каждую проблему.

- Скорость прохождения проверок для разблокировки.

**Укажите технические метрики**

- Перцентили времени ответ
- Нагрузка водительской ручки
- Список фильтров в candidates для которых мы не описываем причину блокировки водителю.
Пример: добавили новый фильтр, но не настроили сообщение для диагностики. Метрика должно сразу показывать, что мы не обрабатываем причину блокировки, и не показываем водителю понятное описание.

**Какая функциональность ожидается в сервисе в будущем?**

Добавить механизм для удобного добавление причин-предупреждений, которые отображаются в диагностике, но не блокируют водителя.
Добавить поэтапное прохождение проверок на клиенте.
Добавить проверку тарифов через диагностику при переключении тарифов в Таксометре.

**Какое изменение нагрузки планируется?**

Линейное от количества активных водителей

**Активно ли будет изменяться сервис?**

В основном, в случае добавления новых проверок, которые нельзя добавить в фильтр в candidates


## Архитектура

### API

GET ручка `/driver/v1/diagnostics/v1/polling/check`
На вход принимает авторизационные хидеры, описанные [здесь](https://nda.ya.ru/t/vdNVZIam3VyYHb)

Ответ ручки: TBD

GET ручка `/driver/v1/diagnostics/v1/info`

Ответ ручки: TBD

### Клиентская логика

Водительское приложение опрашивает ручку для поллинга.
Ручка возвращает в ответе количество проваленных проверок и интервал, через который нужно будет сделать запрос заново.

Если водитель пеоеходит на экран диагностики, то вызывается ручка /info, которая отдает полную информацию по диагностике.
Ручка отдает коструктор с экраном, на котором будет список проверок.
Всего существует 4 экрана, раделенных по критичности проверок: Полная блокировка, Блокировка по времени, Безусловные, Блокирует часть работы.
При нажатии на причину, пользователь переходит к сценарию, который помогает ее устранить.

### Технические ограничения

Важно понимать, что проверки для диагностики, находящиеся в данном сервисе работают в обход candidates.
Если эти проверки будут провалены, то водитель все еще сможет получить заказ.

### Как раскатываем

В ручку будут ходить все Таксометры, начиная с новой версии X.
Функционал будет раскатываться вместе с раскаткой клиента.

### Безопасность

Не планируется работать с ПД


### Как раскатываем

Новая версия Таксометров будет ходит только в наши ручки за диагностикой.
Раскатка фичи будет происходить с раскаткой клиента.


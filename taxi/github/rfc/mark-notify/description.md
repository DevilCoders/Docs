## Бизнесовая задача

### Описание

Сохранять информацию о том, что нотификации были показаны пользователю чтобы избежать повторного показа.

### Гипотеза

Сейчас эта задача решается каждым сервисом отдельно.

примеры:
- старые ФС баннеры
- персональные цели
- сервис промоушенов

кроме этого такой функционал понадобится в кошельке (кэшбэке) и еще много где может быть полезным
(например для отправки sms если не дошел пуш).

Гипотеза состоит в том, что можно сэкономить на клиентской и бэкэнд разработке если сделать для единый механизм, решающий эту задачу.

### Продуктовые ограничения

#### Все этапы

1. Клиент должен запоминать факт показа и ретраить ручку seen пока не получит ответ 200
2. Клиент должен запоминать факт показа и не показывать нотификацию повторно, доставка информации
от ручки seen до целевого сервиса имеет лаг, не исключено что значительный.

Ключ запоминания нотификации - связка tag+id. Время запоминания определяется для каждого типа нотификации независимо
с учетом продуктовых требований конкретных фич.

## Архитектура

### Высокоуровневая архитектура

Клиент дергает ручку `seen` сервиса `mark-notify` когда пользователю показана нотификация.
Сервис `mark-notify` запускает stq задачу, которая доставляет факт показа до целевого сервиса.

### Влияние на цикл заказа

На цикл заказа не влияет

### Компоненты

#### Сервис mark-notify

Сервис имеет только ручку `/seen`. Ручка сохраняет факт показа нотификации(запуская stq таску).

Сервис будет написан на uservices, так как разработчикам это удобнее.

#### STQ `mark-notify`

Находит сервис, в который надо доставить нотификацию и доставляет ее.
Доставка осуществляется двумя способами:
1) вызов метода АПИ интегрированного сервиса
2) отправка события в LogBroker топик

События бывают трех типов:
1) Клиентские
2) Водительские
3) Неавторизованные

Формат АПИ одинаковый среди всех сервисов в рамках одного типа события.
Формат сообщения в LogBroker одинаковый для всех интеграций в рамках одного типа события.

События разных типов отличаются данными о пользователе.

Для клиентского события это:
- user_id
- uid + bound_uids
- phone_id

Для водительского:
- db_id
- uuid

Для неавторизованного события данные ограничены тэгом и ID.

### API

#### `mark-notify`

Ручка `/seen`:

```json
tc.taxi.yandex.net/4.0/mark-notify/v1/seen
{
  "tag": "promotions",
  "id": "some-promotion-id",
}
```

Идемпотентность ручки гарантируется за счет ручек сервисов-потребителей - на каждый запрос будет создаваться stq таска,
в случае ретраев возможно параллельное исполнение тасок с одинаковыми параметрами.

### Нагрузка

На первых этапах ожидается не более 100 RPS, с интеграцией большего количества потребителей нагрузка будет расти.

### Внешние сервисы

#### Используемые сервисы

1. Сервисы, прописанные в конфиге интеграции. АПИ должно быть реализовано по шаблону.

### Клиентская логика

1. При разработке фич нужно интегрироваться с отправками seen сообщений по нотификациям.

### Отказоустойчивость

Если сервис недоступен или невозможно поставить stq таску в очередь - клиентское приложение будет ретраить ручку с экспоненциальным бэкоффом.

Если недоступен сервис-потребитель - stq таска будет рескедулиться с экспоненциальным бэкоффом.
В конфиге для доставки через АПИ можно указать опциональное значение максимального количества попыток доставить событие.

### Мониторинги, алерты, бизнесовые графики, логи

1. TBD: графики и мониторинги OK RPS/bad RPS и графики и мониторинги stq.
2. В дальнейшем возможно нужно будет сделать раздельные графики по сервисам-потребителям

### Технические ограничения

Чем мы осознанно жертвуем: до этапа когда это будет необходимо жертвуем разделением графиков
и мониторингов по сервисам-потребителям.

### Этапы

1. Hack Friday: Реализовать сервис в uservices с ручкой и запуском несуществующей stq таски - 1д
2. Реализовать stq таску - 2д
3. Графики, мониторинги, раскатка - 2д
4. Интеграция с первыми потребителями - ??

### Как раскатываем

Отправка событий с клиентов в ручку seen включается экспериментом-3 в ручке launch.

### Безопасность

Сервис не работает с персональными данными и нет необходимости подключаться к `takeout`

### TODO
Подумать про нотификации от водителей

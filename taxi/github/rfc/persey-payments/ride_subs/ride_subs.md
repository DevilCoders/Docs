# Подписки на пожертвования с поездок

## Задача

Нужно дать пользователю возможность подписаться на отчисления сдачи с каждой поездки в адрес одного из благотворительных фондов. Сдача -- стоимость поездки округленная вверх по некоторому модулю, например, 10. В первой итерации отчисления производятся только с поездок с `payment_tech.type` = `card`

## Реализация

### Как идентифицировать пользователя
- Идентифицировать пользователя будем по паре (`uid`, бренд).
- По `phone_id` нельзя, потому что непонятно, как контролировать переходы номеров телефонов из рук в руки. Если новый владелец телефона автоматически получит подписку на донат, при этом не согласившись с офертой благотворительного фонда, будет нехорошо
- С портальными аккаунтами проблем нет -- они не протухают. Фониши протухают, и чтобы не получилось, что через 3 месяца все подписавшиеся на донат фониши автоматически с этого доната слетают, были уточнены следующие вещи:
  - при логине пользователя в фониш, приложение получает паспортный `X-Token`. `X-Token` нужен, чтобы можно было залогинить пользователя во все яндексовые приложения на устройстве, если пользователь залогинился вручную хотя бы в одном. `X-Token` имеет ttl 1 год с последнего его использования. С помощью `X-Token` можно получить `OAuth`-токен для конкретного приложения.
  - фониш не протухает, если им пользовались (успешно проверяли токены) менее 60 дней назад и номер подтвержден менее 365 дней назад
  - в такси конфиг периодичности подтверждения номера телефона `PORTAL_AUTH_PHONE_CONFIRMATION_PERIODS_SECONDS` выставлен в 10 лет, соответственно периодических подтверждений, предупреждающих протухание, нет
  - если фониш не протух и пользователь залогинен на устройстве A в фониш uid_A, то при логине по тому же номеру телефона на устройстве B `X-Token` с устройства A будет инвалидирован, то есть на устройстве A пользователя разлогинит (требование СИБ). На устройстве B пользователя залогинит в старый фониш с uid_A, пользователь будет видеть все свои карты и другие данные. Тут можно заметить, что так как телефон можно не подтверждать 365 дней и фониш не протухнет, то новый владелец сим-карты в принципе может получить доступ к картам старого. Ответственность за это лежит на сервисе, как эта проблема решена в такси, я не выяснил.
  - если фониш протух и пользователь залогинен на устройстве A в фониш uid_A, то при логине по тому же номеру телефона на устройстве B будет создан новый фониш uid_B, не имеющий никакого отношения к uid_A. `X-Token` на устройстве A инвалидирован не будет, фонишем uid_A можно будет пользоваться дальше. Однако, если `X-Token` с устройства A будет утерян, зайти в фониш uid_A уже не получится
  - Получается, что если пользователь сидит с фониша на одном устройстве, у донатов с поездок нет проблем. Если пользователь переходит на другое устройство, пока фониш не протух, у донатов нет проблем. Если пользователь переходит на новое устройство, когда фониш протух, то на старом устройстве все остается как раньше, на новом пользователь не будет подписан на донаты. Единственное негативное последствие -- это то что мы потеряем поездки с этого устройства.
  - Чтобы понять, как вообще ведет себя время жизни фониша, по логам ручки `zalogin/v1/launch/auth` для фонишей было построено [распределение](https://jing.yandex-team.ru/files/kokokosttn/uhura_2020-06-30T20%3A00%3A58.999085.png) пользователей по количеству дней, прошедших с прошлого подтверждения номера телефона. На графике не видно локальных минимумов около 60 и 365 дней. Это значит, что негативных кейсов "фониш протух, пользователь перешел на новое устройство, а старое забросил" немного, значит в них нет особой проблемы. Если посмотреть на [отношение](https://jing.yandex-team.ru/files/kokokosttn/uhura_2020-06-30T19%3A46%3A11.997928.png) графиков подтверждения телефона и ручки `/3.0/launch`, то можно заметить, что оно явно убывает со временем. Однако резкого падения около 365 дней опять же нет, так что нельзя сказать, что протухание фонишей является причиной убывания.
Таким образом, в большинстве своем фониши тоже не протухают и их можно использовать для хранения подписки на донат с поездок.

### Как подписки прорастают между уидами
В рамках одного бренда, если человек подписался с фониша `A` и впервые взаимодействует с сервисом из портала `B`, связанного с фонишем `A`, то подписка прорастет в портал `B`. После первого взаимодействия портала с сервисом, для него уже ведется отдельный учет подписки. Так сделано, чтобы, во-первых, при привязке портальной почты к аккаунту такси подписка не сбрасывалась, во-вторых, если у человека к порталу привязано несколько фонишей, то при дальнейших подписках/отписках от имени портала не было никаких неожиданных подписок/отписок на фонишах. 

### Откуда брать заказ

Заказы будем получать из процессинга 2.0 по ключу `handle_complete` в очередь `persey_payments_ride_subs`. `handle_complete` выбран потому что нас интересуют исключительно успешные поездки. Также к моменту обработки `handle_complete` в py2 процессинге не обязательно отрабатывает обработчик `handle_finish`, для списания доната нам нужна окончательная стоимость поездки: `sum_to_pay.ride`, поэтому `persey_payments_ride_subs` должна поллить до того как `handle_finish` исполнится. Если посмотреть на реализацию чаевых в py2, там тоже дожидаются, пока `invoice_handler.finish_ride` в `handle_finish` отработает и потом рассчитывают величину чаевых. Также, чаевые не рассчитываются пока флаги `need_accept` и `need_disp_accept` не будут установлены в False, потому что если один из этих флагов поднят, цена может измениться или вообще выставиться в 0. `sum_to_pay.cashback` проставляется где-то рядом с `sum_to_pay.ride` в `handle_finish`. Проблема есть только с `sum_to_pay.tips`, которые пользователь может проставить вплоть до суток с окончания заказа. Продуктово решили, что важно, чтобы транзакция на округление была рядом с транзакцией за поездку, поэтому с возможностью некруглой итоговой суммы из-за чаевых придется мириться. Компенсируется это тем, что в истории поездок показываем отдельно цену поездки и цену чаевых: таким образом пользователю должно быть понятно, в чем дело.

### stq для заказов из процессинга

Из процессинга будем передавать `order_id`, данные пользователя (айдишники, ip, тарифную зону), данные о способе оплаты и локали заказа. Если заказ оплачивается картой, то:
- проверяем, есть ли у пользователя подписка. В большом проценте случаев у пользователя подписки нет и мы можем завершиться
- поллим пока исполнится `handle_finish`
- идем в `dbtaxi.orders` за флажами акцептов, если они подняты -- reschedule на период из конфига 
- идем в `transactions` за `sum_to_pay`, если цена поездки равна 0, завершаемся.
- считаем сумму доната, если равна 0, завершаемся
- пишем донат в `persey-payments.donation` в состоянии `started`
- идем в `transactions-persey`, создаем инвойс на ту же карту, которой платят за поездку, апдейтим его суммой списания

### stq для инвойсов из transactions-persey
transactions-persey -- инсталляция таксишного сервиса transactions для оплат сервиса persey-payments. transactions тут используется как прослойка перед трастом. stq-коллбек из transactions-persey будет называться `payments_persey_callback`. Смотрит на приходящий `operation_status`. `failed/clear_fail` -> пишем состояние `not_authorized` для соответствующего доната. `clear_success` -> пишем состояние `finished` для доната. Таким образом ведется учет успешных донатов

### ручки управления подпиской
`/4.0/persey-payments*` находятся за passenger authorizer. Вот их список:
1) `/4.0/persey-payments/v1/charity/ride_subs`
    - `post` -- пишет в `persey_payments.ride_subs` данные о пользователе и подписке
    - `get` -- возвращает информацию о подписке, если она есть
    - `put` -- позволяет поменять модуль округления
    - `delete` -- отписка
2) `/4.0/persey-payments/v1/charity/main_screen` -- возвращает информацию о благотворительном фонде, если он указан. Если фонд не указан, выбирает его конфига, если в конфиге ничего нет -- случайно. Возвращает информацию о количестве участников проекта, доступные варианты модуля округления
3) `/4.0/persey-payments/v1/charity/static` -- возвращает статику для клиентов, дергается на каждом запуске приложения

### другие ручки
В приложении такси помимо того чтобы иметь возможность подписаться на донат и делать списания каждую поездку требуется:
1) На экране завершения поездки отображать величину доната, а так же стоимость поездки с учетом доната. К этому времени фактически списание ещё не произведено. Величина доната должна рассчитываться быстро, чтобы не тормозить requestconfirm -- критичную ручку цикла заказа. Для этого есть ручка `/internal/v1/charity/ride_donation/estimate`
2) Считать сумму доната от текущей стоимости поездки (быстро, потому что используется в taxiontheway -- критичной ручке цикла заказа) (ручка `/internal/v1/charity/ride_donation/calculate`), и уметь принимать синхронный платеж (ручка `/4.0/persey-payments/v1/charity/ride_subs/pay`) -- это все для applepay флоу, о котором подробно написано ниже
3) Отображать величину доната в истории поездок пользователя и в админке заказов для саппорта

Для (3) есть ручка `/internal/v1/charity/ride_donations`, которая по списку заказов ходит в базу и достает оттуда величины донатов

Для (1), (2) реализовано несколько кешей: 
a) ride_subs_order -- хранит по заказу модуль округления и фонд подписки
b) ride_subs_paid_order -- хранит по заказу сумму доната, если по заказу есть донат

Кеши заполняются stq-таской `ride_subs_fetch`, которая ставится из процессинга в момент нахождения водителя на заказ. Также в этой таске мы пишем в базу все `yandex_uid` пользователя, чтобы если во время поездки пользователь подпишется/отпишется/поменяет модуль округления, обновить кеши.

Кеши далее используются в ручках, которые сообщают пользователю информацию о ещё несовершенном донате во время поездки, базой эти ручки не пользуются. Кеши могут на десятки секунд отставать от базы, поэтому они не используются для списания денег. В редких случаях показывать пользователю неактуальную информацию приемлемо, поэтому для информации кеши сойдут. 

В `/internal/v1/charity/ride_donation/estimate` мы смотрим, если донат по заказу совершен -- отдаем его величину, если не совершен, но есть модуль округления в кеше -- отдаем естимейт по переданной стоимости заказа. В `/internal/v1/charity/ride_donation/calculate` если донат по заказу совершен, отдаем наружу слова благодарности для показа пользователю, если нет и модуль округения проставлен в кеше, возвращает сумму доната, статику, а так же информацию, необходимую совершения платежа (для applepay -- это код страны, мерчант, локализованное название позции, trust service token)

### рассылка email'ов
Для событий подписки, отписки, изменения модуля округления реализована возможность отправлять email пользователю. Для такси в итоге этой фичей не пользуются. 

### Рассчет уникальных пользователей и сумм их донатов
Есть джоба в фоне, которая по успешным донатам считает (1) пользователей (несколько `yandex_uid` и `email` могут принадлежать одному человеку, в сервисе все `email`/`yandex_uid` пользователя объединяются под `supporter_id`) (2) разбивку пожертвований `supporter_id` по `oneshot` (разовый донат через `help.yandex.ru`), `subs` (подписка на ежемесячный донат через `help.yandex.ru`), `ride_subs` (подписка на округление)

### applepay

На клиентах есть пункт в экране поездки, нажав на который можно выписать отдельный токен для пожертвования. Так сделано, потому что нельзя одним и тем же токеном заплатить в сторону такси и в сторону НКО с юридической точки зрения.   
Логика показа пункта не зависит от того, окончена ли поездка.  
До оплаты в пункте запрашивается подтверждение, после оплаты выражается благодарность. Пункт следует показывать только если из totw пришла информация в поле `ride_donation` (в это поле проксируется как есть ответ ручки `/internal/v1/charity/ride_donation/calculate`). Если пришло `pay_info`, надо показывать запрос на подтверждение в том случае, если способ оплаты, которым вы хотите воспользоваться содержится в `payment.payment_types`. Если пришло `thank_info`, надо показывать благодарность. Просьба на клиенте тоже поддерживать стейт (оплачено/не оплачено) и использовать его. Это необходимо, потому что после оплаты `thank_info` станет приходить не сразу, а секунд через 20. Чтобы было, что показывать эти 20 секунд, идентичное `thank_info` приходит и из `/4.0/persey-payments/v1/charity/ride_subs/pay`  
Если человек подтверждает перевод, то:

1) Клиент берет последний известный ему естимейт размера доната и данные applepay
2) Клиент получает applepay токен на эту сумму
3) Клиент дергает ручку `/4.0/persey-payments/v1/charity/ride_subs/pay`
4) Бек просто переводит эти деньги на терминал фонда


### Маркет

Существенное ограничение: списание должно производиться с __привязанной__ к сервису (паспорту) карты (согласно оферте). Поэтому договорились, что:
1) На экране управления подпиской даем пользователю возможность выбрать из привязанных/привязать карту и выбрать её *дефолтной* для округлений.
2) Если оплата корзины проводится с карты, которая является привязанной, Маркет передает в persey-payments card_id этой карты, persey-payments проводит с нее списание
3) Если оплата корзины проводится не привязанной картой, persey-payments проверяет, есть ли на подписке *дефолтная* привязанная карта, если есть -- проводит с нее списание
4) Иначе списания не происходит

Если оплата заказа осуществляется с помощью applepay/googlepay, то для оплаты пожертвования должен быть сгенерирован токен на сумму из ручки `/estimate` (описана ниже) и передан в ручку `/pay`, только в этом случае оплата пройдет  

Грубое описание ручек:
1) Для экрана управления подпиской Маркет использует по сути те же ручки, что и такси: `/ride_subs` (crud подписки), `/main_screen` (инфа собственно для экрана). Единственное отличие: сделаем их аналогии для авторизации по паспортной куке, сделаем апи для управления *дефолтной* картой  
2) Для флоу заказа с округлением в Маркете в persey-payments нужны 3 ручки:  
    а) `/estimate` -- по `yandex_uid` и сумме заказа возвращает сумму округления и есть ли на подписке *дефолтная* карта (а также какие-нибудь атрибуты подписки, если требуется)  
    б) `/pay` -- по `yandex_uid`, `payment_method_type`, `payment_method_id`, `order_id` и сумме списания из ручки `/estimate` производит списание  
    в) `/ride_donations` -- по списку `order_id` Маркета возвращает платежи (сумма, статус, мб карта или ещё что-то требуется)  

Все ручки ходят в базу, то есть время ответа будет 100-500 мс, если критично отвечать быстрее, надо что-то сделать. Но кажется не критично: не ответила `/estimate` -- не округляем, не ответила `/pay` -- не округляем, не ответила `/ride_donations` -- не показываем сумму округления или показываем то что пришло из `/pay`

Как понимаю, в `/estimate`, `/pay` и `/ride_donations` ходить будет бек маркета, в `/ride_subs`, `/main_screen` наше вебвью с сессионной кукой
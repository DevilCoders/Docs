# Решаемая задача

Так получилось, что transactions не отдают наши чеки. Поэтому мы вынуждены создавать чеки через Еду и самостоятельно их рендерить.

# Что делаем?

* Закидываем в Еду item-ы заказа (там формируется чек);
* Через какое-то время забираем чек в json-форме у Еды (он формируется какое-то время, в среднем около минуты, вроде);
* Рендерим чек из json в файл;
* Складируем файл в хранилище;
* Отдаём получившиеся чеки там, где требуется (история/админка).

# Закидываем в Еду item-ы заказа

Я так понял, этот момент прорабатывает Андрей Костин. Закидывание item-ов будет происходить где-то внутри флоу оплаты при клирах и рефандах. Здесь деталей касаться не буду.

# Забираем чек в json-форме у Еды

На данный момент Еда не сделала нам ручку для отдачи чеков. Но уже известно, что чеки создаются какое-то время, то есть они будут готовы не обязательно сразу после отдачи item-ов в Еду.
Еда поделилась примером json-а чека, который они присылают. Лежит рядом с rfc в eda.json.

Получение чеков будем делать через stq-таску, которая будет ставится в момент отправки item-ов в Еду. Таска будет жить в iiko-integration и с какой-то заданной периодичностью запускаться и пытаться получить чек у Еды. Соответственно, в случае не успеха таска будет перепланироваться. В случае успеха будем переходить к пункту про рендеринг. При этом, будем перепланировать таску n раз с периодом T (количество и период зададим конфигом, в периоде будем ориентироваться на среднее время генерации чека), после n попыток начинаем просто ронять таску и писать ошибку в лог. stq будет её перезапускать, экспоненциально увеличивая период. Это на случай непредвиденных проблем, чтоб не забить воркер проблемными задачами.

Для получения чека можно будет использовать documentId, который мы же сами и составляем. По идее, было бы здорово чтоб documentId составлялся из invoice_id и версии состава чека из changelog. У нас будет чек на оплату для первой версии и 1+ чек на возврат для версий 2, 3 и т.д. Это позволит если что получить чек из Еды и позже, если что-то пойдёт не так. 

Предполагаю, что невозможность поставить таску - довольно редкое событие. В случае, если таску поставить не выходит, буду писать ошибку в лог и не ломать флоу оплаты. Просто потом перезапускать для таких заказов получение чека вручную через скрипт https://github.yandex-team.ru/taxi/tools-py3/blob/master/taxi_stq_agent_py3/queue_task.py

# Рендерим чек из json в файл

Для рендера будем использовать сервис Check: https://wiki.yandex-team.ru/spirit/check/ , ручку POST /pdf. С ответственным за сервис я связался, им ок. Сервис не планируется закапывать в ближайшее время. Нагрузку мы на них создадим меньше 1 RPS. Формат запроса можно увидеть в check_request.json.

Рендерим в pdf, так как:
* у всех остальных сервисов чеки в pdf;
* iOS и Android говорят, что им ок в pdf;
* фронтам без разницы pdf или html;
* вес у pdf-ок меньше, чем у html (из личных наблюдений один и тот же чек в pdf весит в 5 раз меньше html).

Рендер будем производить прямо в той же stq таске, в которой получили json. В случае, если сервис рендера по каким-то причинам не будет доступен, то будем фейлить таску и перепланировать, но предполагается, что это некая редкая исключительная ситуация. Для всех перезапусков таски будем действовать согласно плану выше.

Отдельный вопрос, а хватает ли нам данных для рендера?
В этом комменте результаты раскопок касательно полей в Еде и Check: https://st.yandex-team.ru/TAXIBACKEND-30559#5f44fdf3558e052f3a2d4926 . Кажется, единственное поле с которым пока проблемы это Заводской номер ККТ. Но у Яндекс.ОФД оно есть, надеюсь, Еда справится с тем, чтоб получить его и передать нам.

# Складируем файл в хранилище

Полученый при рендеренге файл будет отправляться на хранение в S3 MDS. В базу будет сохраняться ссылка на файл с соответствующей пометкой для чека. Имя файла будет составляться из order_id и documentId, чтобы гарантировать уникальность.

Соответственно S3 под наши нужды надо заказать у админов.
Какого размера?
Отталкиваюсь от MVP и целюсь на год:
12 000 (заказов в месяц) * 12 (количество месяцев) * 2 (думаю, в серднем чеков будет точно меньше 2 на заказ) * 40 (кб, примерно вес одного чека в pdf) = 12 Гб (приблизительно округлённое значение)
Итого с запасом брать 1Тб

Чтобы не толкаться на запись в таблицу orders, организую отдельную таблицу receipts. Каждая строка в ней будет отдельным чеком. У каждого чека будет прописан order_id, documentId, type (refund/payment), cost (сумма чека, по идее её должно получиться передать в таску, либо взять из json-чека), key (ключ, по которому можно получить из mds файл).
Как в py3 составить вручную вечную ссылку на файл в s3 я не нашёл, готовый генератор создаёт временную ссылку судя по параметру expires_in, поэтому пока будем хранить key.
order_id и documentId - будут уникальными полями + по полю order_id будет индекс, чтоб получать все чеки заказа.
Первичный ключ будет составной из order_id и documentId.
Порядок чеков нам не критичен, уточнил это у Антона Лямина.

Таска идемпотентна, проблем с двойной постановкой фактически нет. Чтоб избежать лишних записей в MDS можно проверять перед записью наличие файла там.

# Отдаём получившиеся чеки

В ручке истории и админке будем отдавать просто массив объектов, где каждый объект будет содержать заголовок чека, сумму (если получится) и ссылку на чек в MDS. Соответсвенно отдаём столько, сколько удалось получить по order_id из таблицы receipts.
Ссылку генерируем налету, чтоб не забивать базу копиями шаблонов.

# Алерты

Думаю, поставлять в соломон метрику из stq, в случае если таска превысила какое-то количество попыток выполнения (либо время от создания таски). Также поставлять метрику об успешной/неуспешной постановке тасок в очередь. По метрикам навесить алерты и слать их в наш чат в телеграмм.

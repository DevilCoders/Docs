# Возврат денег пользователю по ресторанному заказу

## Контекст

Актуальное описание сервиса: [тык](https://wiki.yandex-team.ru/users/a-lyamin/servis-yandex.pay/)


В первой версии MVP мы планировали создавать заказ в Еде, что облегчало нам задачу, 
т.к. мы могли не думать о реализации всех стандартных воркфлоу по заказу, в т.ч. о рефанде заказа. 

На текущем этапе развития Еды мы больше не имеем возможность воспользоваться 
их сервисами и вынуждены делать рефанд заказа самостоятельно.


 ## Решение

Чтобы сделать рефанд любого заказа средствами сервиса transactions достаточно вызвать 
`/invoide/update` и передать туда новый список позиций заказа. 
В случае полного рефанда заказа список позиций должен быть пустым, а в случае частичного 
- без тех позиций за которые возвращаем деньги. 
В зависимости от того, был ли клир, будет сделан рефанд, либо существующая транзакция 
будет изменена (до ее клира).


### Доработки сервиса `iiko-integration`

1. **В БД** к заказу добавляем поля:
    -  `version` (по умолчанию =0), которое будет хранить порядковый номер изменения состава заказа.
    -  `draft_items` (опциональное), в котором будем хранить черновой состав заказа (по которому еще не созданы транзакции)

2. **Создаем новую ручку `/order/refund`**, которая будет являться ручкой админки (реализуем через АБК), 
в качестве аргументов принимает:
   - `order_id` - id заказа 
   - `items` - новый список позиций заказа с указанием их количества 
 (позиции в заказе должны быть подмножеством существующих в нем изначально позиций).
   - `version` - текущая версия заказа (полученная в ответе ручки, отдающей инфу по заказу)
    
   В этой ручке выполняем следующие действия:
   1. В рамках одной транзакции: 
      1. Проверяем, что заказ находится в одном из следующих статусов:
      `HELD_AND_CONFIRMED|CLEARING|CLEARED|REFUNDING`. Если нет - отвечаем 409.
      2. Проверяем что новые айтемы являются подмножеством текущих. 
      Если новый состав заказа идентичен текущему составу в `items` овечаем 200
      3. Проверяем что (`request.version == order.version`) ИЛИ ((`request.version == order.version + 1`) И (`request.items == order.draft_items`)). Если нет - овечаем 409.
      4. Инкрементируем `version` в том случае, если `request.items != order.draft_items`
      5. При необходимости обновляем `draft_items` (если по каким-то позициям рефанд производится полностью - выставляем по ним `quantity=0`)
   2. Ставим stq-таску `restaurants_order_update_transactions` (см. следующий пункт)

   В том случае, если фронт получит ответ 200 или 409, ему необходимо будет сходить еще раз в ручку которая отдает информацию по заказу (чтобы получить свежую версию заказа). 

1. **Создаем  stq-очередь `restaurants_order_update_transactions`**. 
В качестве ключа таски будем передавать `order_id`. 
В аргументах также передаем  `order_id`. В таске выполняем следующие действия:
   1.  Идем в `transaction` за текущей вресией `OperationVersion`, для этого дергаем ручкку `/invoice/retrieve`
   2.  Идем в базу и забираем `draft_items` и `version`. Если `draft_items == null` - успешно завершаем таску.
   3.  Вызываем `/invoice/update` и передаем туда новый список item'ов, сформированный из `draft_items`. В качестве `operation_id` (ключа идемпотентности) используем `version`. 
   И передаем также `OperationVersion`. Если получили 409 (значит нас кто-то обогнал) - фейлим таску.
   4.  В рамках одной транзакции проверяем, что `version` не изменилось и обновляем сипсок позиций в заказе в `items` и `amount` по всему заказу согласно `draft_items`. И очищаем `draft_items`. 
   В том случае, если значение `version` поменялось - ничего не обновляем и фейлим таску. 
В рамках данной таски должно гарантироваться выполнение всех перечисленных действий - т.е. если что-то пошло не так на любом этапе - падаем и ждем когда stq нас перезапустит.

4. **Расширяем стейт-машину статусов** новым статусом `REFUNDING`. 
Переход в этот статус возможен из  `CLEARED`, а также из `HELD_AND_CONFIRMED|CLEARING|REFUNDING` (в случае если пропустили какой-то статус из за кривой нотификации). 
Переход из `REFUNDING` возможен только в `CLEARED` (а также сам в себя).
Перевод статуса в обе стороны будет осуществлять stq-таска `payments_eda_callback`

5. **Дорабатываем ручку обновляющую заказ**, которая будет вызвана из stq-таски `payments_eda_callback`. (с учетом нового статуса `REFUNDING`)
   
6. **В ручке админки, которая отдает информацию по заказу**  теперь отдаем `version` заказа (который нужно будет подставить далее в вызов `/order/refund`). 
А также можем отдавать признак того что по заказу существует не исполненный `draft` или даже список `draft_items`   


При этом делать дополнительный вызов `/invoice/clear` нам нигде не требуется 
(если клира еще не было, то он и так будет вызван, в остальных же случаях клир вроде бы не требуется)

Также предполагается, что существующие у каждого item'а в заказе product_id уникальны. 
Если это не так, то нам самим необходимо создавать уникальные `item_id`, которые мы будем передавать фронту админки вместе с остальной информацией по заказу.


### Доработки сервиса `payments-eda`
В `payments_eda_callback` теперь также отправляем нотификацию в iiko-integration по статусу REFUNDING


## Открытые вопросы
1. Нужно ли нам давать ресторану информацию по рефандам? 
Если да, то необходимо отдельно проработать расширение ресторанного API в части поллинга заказов (или в части отчетности перед рестораном со стороны Еды?).

**TODO:** Уточняем этот вопрос вместе с Едой и затем вносим изменения отдельным ПРом. 
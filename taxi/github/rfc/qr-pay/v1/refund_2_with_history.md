# Сохранение истории рефандов и еще некоторые вещи

## Контекст

Для саппорта QR-pay в части платежей и рефандов не хватает следующих вещей:

1. Отображать идентификатор платежа в трасте
2. Получать список возможных причин рефанда
3. Сохранять и отображать историю рефандов. Нужно сохранять следующие поля:
   - тикет
   - причину рефанда
   - логин оператора запустившего рефанд
   - сумму рефанда
   - время создания (запуска)
   - время исполнения
   - идентификатор рефанда в трасте


## Доработки в iiko-integration
  
На схеме ниже отображена основная суть изменения (а далее приведено описание доработок)

![Схема](https://jing.yandex-team.ru/files/andreykostin/QR-pay%20flow%287%29.png)

### Доработка БД 
В заказ добавляем новое поле `order_changes`, которое будет представлять собой массив событий изменяющих состав заказ, и одновременно будет являться по совей сути очередью задач на обновление транзакций по заказу. Элементом массива `order_changes` будет событие со следующими полями:
   - `version` - версия заказа на этапе внесения изменений 
   - `items` - обновленный список позиций заказа 
   - `amount_difference` - изменение суммы заказа, вычисляется как разница нового и предыдущего значений `total_price` (будет использоваться для уведомления еды по рефандам)
   - `status=PENDING|PROCESSING|DONE` - статус обработки данного измениея. Назначения статусов: 
     - `PENDING` - изначальный статус, означает что изменения ожидают обработки и еще не имеют отражения ни в transactions ни в еде. В этом статусе одновременно могут находиться сразу несколько событий
     - `PROCESSING` - означает, что изменения уже отражены в операциях в transactions и идет процесс холда/списания средств. Одновременно в `PROCESSING` может находиться не более 1 события. Т.е. текущие статус заказа и состояние операций в `transactions` должнв отражать обработку того единственно события, что находится в статусе `PROCESSING` 
     - `DONE` - означает, что транзакция заклирена, а Еда уведомлена о списании/рефанде средств
   - `сreated_at` - время создания события
   - `updated_at (optional)` - время обновления статуса
   - `operation_id (optional)` - id операции в transactions. Изначально NULL. Значение устанавливается одновременно с созданием операции в `transactions` и переводом статуса в `PROCESSING` 
   - `type=CHARGE|REFUND` - тип события `CHARGE` соответствует положительному значению `amount_difference`, а `REFUND` - отрицательному.
   - `ticket (optional)` - название тикета (только для `type=REFUND`)
   - `ticket_type (optional)` = chatterbox|startrack (только для `type=REFUND`)
   - `reason_code (optional)` - код причины рефанда (только для `type=REFUND`)
   - `operator_login (optional)` - логин того кто запускает рефанд (только для `type=REFUND`)
  
Поле `draft_items` удаляем, т.к. оно больше не нужно (по сути его заменяет первое по списку событие в статусе `PENDING`).


### Доработка ручки создающей заказ
При создании заказа помещаем в него первое событие с `type=CHARGE` в статусе `PENDING`. 


### Доработка ручки /admin/qr-pay/v1/order/refund
1. В качестве параметров запроса добавляем новые поля 
   - `ticket` - название тикета
   - `ticket_type=chatterbox|startrack` - тип тикета
   - `reason_code` - код причины рефанда
   - `operator_login` - логин того кто запускает рефанд

2. Вставляем в конец массива `order_changes` новое событие с `type=REFUND` 
3. Как и раньше ставим stq-таску в очередь `restaurants_order_update_transactions`


### Доработка stq-таски restaurants_order_update_transactions
делаем все также как и раньше, но со следующими отличиями
1. Ищем в заказе событие в статусе `PROCESSING`, если находим, то сразу завершаем таску. (т.к. последняя созданная операция в transactions еще процессится, мы не можем запускать процессинг следующей)
2. Если событие в статусе `PROCESSING` не найдено, то берем первое по списку событие в статусе `PENDING` и достаем из него `items` (вместо `draft_items` из предыдущего решения)
3. После успешного похода в сервис `transactions` в ручку `/invoice/update` (и создания новой платежной операции) переводим статус события в `PROCESSING`, обновляем в нем поле `operation_id` и  сохраняем все в базу


### Доработка обработки переходов статуса (ручка обновления статуса заказа)
При любом обновлении статуса проверяем, что `operation_id` из запроса совпадает с `operation_id` в событие со статусом `PROCESSING`. Если не совпадает, то отвечаем 404.

При переходе `REFUNDING->CLEARED` мы должны: 
1. Сходить в базу и получить список событий рефанда
2. В списке событий  найти то, которое находится в статусе `PROCESSING`
3. Для найденного события уведомить Еду о сумме клира/рефанда и о новом списке items
4. В случае успеха поменять статус события на `DONE` (а статус заказа в `CLEARED`) и записать изменения в базу. 
5. Если в истории заказа присутствуют события в статусе `PENDING`, то ставим stq-таску в очередь `restaurants_order_update_transactions`.
Если мы зафейлились сразу после 4-го пункта, то на следующей итерации ретрая ручки обновляющей статус заказа мы будем иметь здесь переход `CLEARED->CLEARED` и в этом случае после п.1 мы можем сразу перейти к п.5

При обновлении пользователя и `invoice_id` заказа, обновляем первое (и на самом деле единственное событие) c `type=CHARGE`. Очищаем  поле `operation_id` и возвращаем статус в `PENDING` (в том случае, если ранее уже была создана платежная операция и событие было переведено в статус `PROCESSING`)


### Доработка ручки /admin/qr-pay/v1/order
1. В качестве `trust_id` заказа отдаем `external_payment_id` первой транзакции которая соответствует операции операции `CHARGE`  в `transactions` 
2. Отдаем список возможных причин рефанда (берем из конфига).
3. Отдаем историю изменения заказа (=историю рефандов). Для каждого operation_id ищем в  `transactions` соответствующую транзакцию (в общем случае ее може и не быть, если изменения цены прошли вниз во время холда, но в нащем случае такого не будет) и берем из нее `external_payment_id` в качестве `trust_id`



## Доработки в сервисе payments-eda

### Доработка ручки /4.0/payments/v1/orders
После похода в сервис `transactiosn` в `/invoice/create` (создание нового invoice для новго пользователя) и обновления ползователя и  `invoice_id` в `iiko-integration` **не идем в** `/invoice/update` - вместо этого ставим таску в `restaurants_order_update_transactions`. Это позволит избежать дублирования в двух сервисах кода, обновляющего позиции заказа в `transactions`, и переведет процессинг всех платежных операций по заказу на единую stq-очередь (что позволит избегать в будущем различных гоночных эффектов)

### доработка payemnts_eda_callback
Помимо статуса заказа необходимо также передавать `operation_id` текущий (последней) операции

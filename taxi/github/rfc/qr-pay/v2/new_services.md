# Контекст

Во процессе реализации первой версии проекта "Оплата по qr-коду в ресторане" мы срезали множество углов, реализовав большую часть нужного функционала в сервисе iiko-integration и частично переиспользовали существующий в payments-eda (адаптировав его под наши нужды):

**Сервис iiko-integration**
- взаимодействует с ресторанной системой: ресторан создает/закрывает заказы и получает по ним статусы оплаты (пока взаимодействуем  только с iiko, но планируется подключение также и r-keeper к тому же API)
- хранит информацию о составе заказа, проведенным транзакциям, чеках (внутренний API предоставляет доступ к этим данным) 
- процессит оплату заказа: обновляет инвойс в сервисе transactions-eda и обрабатывает колбэки на его изменения, передает данные по завершенным транзакциям в Еду, шлет уведомления пользователю, отдает информацию о кэшбэке в сервис cashback. 
- имеет клиентские ручки для получения информации по ресторанам и истории заказов
- имеет админские ручки для получения информации по заказу и запуска рефанда
  
**Сервис payments-eda**
- отдает клиентам информацию по заказу и способах оплаты
- по запросу клиента запускает оплату заказа: создает инвойс в transactions-eda и обновляет состояние заказа в iiko-integration 
- отдает клиенту информацию по статусу оплаты заказа 
- проксирует вызов колбэка от transactions-eda в iiko-integration и в cashback
  

 Процесс оплаты заказа выглядит так:

 ![Схема](https://jing.yandex-team.ru/files/andreykostin/QR-payment-flow-2.png)  


# Проблемы текущей архитектуры 

1. iiko-integration - это сервис, который полностью открыт наружу для взаимодействия с ресторанами. А это значит, что наружу также торчат все внутренние ручки (под TVM) дающие доступ к внутренним данным по заказам (в т.ч. модифицирующие ручки), что не хорошо с точки зрения ИБ. 
2. iiko-integration задумывался как микросервис, задача которого предоставлять ресторанам API для открытия/закрытия заказов и слежения за их статусом, но по факту является комбайном по решению самых разных задач (см описание выше), которые можно разбить на 4 части: взаимодействие с партнером (рестораном), взаимодействие с пользователем, внутренняя работа с заказами в т.ч. процессинг оплаты/рефанда, внутренняя работа с данными партнеров (ресторанов)
3. Решение использовать сервис payments-eda изначально базировалось на предположении, что у нас получится почти полностью переиспользовать существующую реализацию для заказов еды/лавки, однако по факту удалось переиспользовать только код, отвечающий за получение способов оплаты, а все остальное пришлось реализовать с нуля, т.к. флоу оплаты QR совершенно не похож на типичный флоу Еды (в нашем случае даже не существует заказа на стороне Еды). Т.е. фактически сейчас в сервисе paymetns-eda существуют совершенно независимые (чужеродные) и при этом достаточно крупные ветки кода для QR-заказов.
4. Сервис payments-eda в скором времени перестанет поддерживаться текущими мейнтейнерами, т.к. переезжает в новый сервис eats-payments (uservices).
5. Основная нагрузка приходится на сервис iiko-integration, который реализован в py3, и получает суммарно на каждый подключенный ресторан нагрузку примерно в 1rps.  Исходя из чего мы ожидаем появления проблем при подключения 500 ресторанов и скорее всего достигнем предела не добравшись до 1000.
6. В коде присутствует некоторое количество костылей, которые не трудно убрать при рефакторинге.

В целом можно подытожить все вышеперечисленное и констатировать, что при текущей архитектуре добавление новых фич может быть весьма дорогим, а возможности по масштабированию весьма ограниченны (особенно, если мы захотим подключать другие ресторанные системы или магазины или чего либо еще, где может быть использован флоу оплаты по QR).  


# Новая архитектура

Закрываем все вышеперечисленные проблемы созданием 3 новых сервисов в uservices (на замену iiko-integration и payments-eda). Все клиентские ручки выносим в api-proxy. 

![Схема](https://jing.yandex-team.ru/files/andreykostin/QR-payment-flow-2%281%29.png)

## 1. Сервис для работы с qr-заказами

Создаем сервис `qr-orders`, который будет отвечать за работу с заказом - по сути это почти весь текущий код сервиса `iiko-integration` отвечающий за работу с базой orders:
1. `/qr-orders/v1/create` - создает заказ с определенными айтемами и данными партнера. За основу берем существующую ручку `/external/v1/orders` из которой убираем все что касается авторизации ресторан и др. специфику взаимодействия с партнером.
2. `/qr-orders/v1/get` - отдает заказ по его id. Переносим как есть существующую ручку `/v1/order`
3. `/qr-orders/v1/get-by-user` - отдает список заказов для  указанного пользователя. За основу берем клиентскую ручку `/4.0/qr-orders/v1/orderhistory/list`, но избавляем ее от специфики пользовательского запроса/ответа. 
4. `/qr-orders/v1/get-statuses` - балковая ручка для получения статусов заказов. За основу берем существующую ручку `/external/v1/orders/status/list` из которой убираем все, что касается авторизации ресторана, специфики внешних статусов (отдаем внутренний статус) и т.п. 
5. `/qr-orders/v1/update-partner-status` - ручка изменяющая статус партнера (сейчас в коде это именуется как `restaurant_status`). Берем за основу существующую ручку  `/external/v1/order/status` и также убираем из нее специфику взаимодействия с партнером.
6. `/qr-orders/v1/start-payment` Берем за основу ручку `/v1/order/authorized-update` и добавляем в нее логику создания инвойса (переносим из сервиса `payments-eda` из ручки `/4.0/payments/v1/orders`).
7. `/qr-orders/v1/get-cashback` - отдает информацию о кэшбэке для сервиса cashback. Переносим как есть существующую ручку `/v1/cashback`.
8.  `/qr-orders/v1/admin/get` - отдает заказ для админки. Перенести как есть `/admin/qr-pay/v1/order`.
9.  `/qr-orders/v1/admin/get-by-invoice` - отдает заказ для админки по invoice_id сервиса transactions-eda. Перенести как есть `/admin/qr-pay/v1/order_by_invoice_id`.
10. `/qr-orders/v1/admin/find` - отдает список заказов удовлетворяющих заданным критериям.  Перенести как есть `/admin/qr-pay/v1/orders-search`.
11. `/qr-orders/v1/admin/refund` - рефандит заказ частично или полностью. Перенести как есть `/admin/qr-pay/v1/order/refund`.
12. `stq/qr_orders_transactions_callback` - stq-таска, которая обрабатывает колбэк от сервиса transactions-eda, который мы будем получать по `originator=qr_payments` (в конфигурации transactions-плагина для сервиса transactions-eda добавляем эту очередь в качестве колбэка по этому новому ориджинатору). Эта stq-таска должна заменить собой `stq/payments_eda_callback` (часть кода, связанную с qr) + вызов ручки `/v1/order/update` (саму ручку переносить не будем)
13. `stq/qr_orders_close` - stq-таска, которая запускает клир транзакции. Аналогично существующей `stq/payments_eda_close_order` (сервис paymens-eda).  
14. `stq/qr_orders_cancel` - stq-таска, которая обнуляет в transactions-eda стоимость заказа и запускает клир (т.е. возвращает деньги пользователю). Аналогично `stq/payments_eda_cancel_order` (сервис paymens-eda).  
15. `stq/qr_order_update_transactions` - stq-таска, которая обновляет инвойс в сервисе transactions-eda согласно обновившимся данным заказа. Перенести как есть `stq/restaurant_order_update_transactions`
16. `stq/qr_order_process_cleared` - stq-таска, которая обрабатывает успешно заклиренную транзакцию заказа и отправляет нужные данные в Еду.  Перенести как есть `stq/restaurant_order_process_cleared`
17. `stq/qr_order_render_receipt` - stq-таска, которая рендерит чек Еды.  Перенести как есть `stq/restaurant_order_render_receipt`. Либо выбрасываем за ненадобностью после того, как Еда перейдет на создание чеков через Траст
18. `stq/qr_order_expired` - stq-таска, которая экспайрит незакрывшиеся заказы спустя некоторое время после их создания. Перенести как есть  `stq/restaurant_order_expired`
19. `stq/qr_order_cashback_notify` - stq таска которая уведомляет Еду о зачисленном кэшбэке. Перенести как есть `stq/restaurant_order_cashback_notify`
20. переносим как есть крону для сбора метрик `iiko_integration.crontasks.collect_metrics`

## 2. Сервис для работы с данными qr-партнеров

Сейчас все данные о партнерах (адреса, хэши api-ключей, проценты комиссий, и т.п.) находятся в 2х больших конфигах IIKO_INTEGRATION_RESTAURANT_GROUP_INFO и IIKO_INTEGRATION_RESTAURANT_INFO. 
Все это по хорошему нужно превратить в отдельный сервис `qr-partners` со свой базой и следующим API:
1. `/qr-partners/v1/get-authorize` - ручка для авторизации партнера - отдает внутренний id партнера и информацию о нем по его api-key
2. `/qr-partners/v1/get` - ручка для получения информации о партнере по его id 
3. `/qr-partner/v1/get-near` - отдать список ближайших партнеров по геокоординате. За основу берем клиентскую ручку `/4.0/qr-pay/v1/restaurants` но избавляемся от специфики пользовательского запроса/ответа.
4. `/qr-partners/v1/admin/create` - админская ручка добавления нового партнера
5. `/qr-partners/v1/admin/update` - админская ручка изменяющая данные созданных ранее партнеров
6. `/qr-partners/v1/admin/find` - админская ручка отдающая список партнеров по запросу с какими либо параметрами (н (адрес, ИНН, и т.п.). Для пустого запроса может отдавать полный список партнеров
7.  Переносим ручку `/internal/v1/qr-objects` (iiko-integration) - нужна для отображения объектов на карте  
8.  Создаем крону для для выгрузки данных по партнерам в YT - аналогично `iiko_integration.crontasks.upload_qr_ids`

## 3. Сервис по взаимодействию с qr-партнерами

Все что касается взаимодействия с ресторанными системами выносим в новый сервис `qr-partner-integration` (с названием  еще можно подумать, но iiko-integration плохо отражает реальность, т.к. на то же самое API мы сажаем r-keeper и возможно что-то еще в будущем). Сервис будет полностью открыт во внешний мир и не должен иметь внутреннего API.

Из сервиса iiko-integration выносятся следующие ручки:
1. `/external/v1/orders` - авторизует ресторан (`/qr-partner/v1/get-authorize`) и создает заказ (`/qr-orders/v1/create`)
2. `/external/v1/orders/status/list` - авторизует ресторан (`/qr-partner/v1/get-authorize`) и получет запрашиваемые статусы заказов (`/qr-orders/v1/get-statuses`). Адаптирует статусы и http-ответы под внешний API.
3. `/external/v1/order/status` - авторизует ресторан (`/qr-partner/v1/get-authorize`) и изменяет статус заказа `/qr-orders/v1/update-partner-status`
4. переносим крону для проверки активности ресторанов по каждому заказу `iiko_integration.crontasks.check_external_activity` Если ресторан в течении долгого времени не запрашивает статус заказа, то экспарим заказ через ручку `/qr-orders/v1/update-partner-status` не дождаясь, того как пользователь отсканирует qr и начнет его оплату 

## 4. Взаимодейстиве с пользователем 

Все ручки взаимодействия с пользоваететелм выносим в api-proxy:
1. Выносим из iiko-integration:
   1.  `/iiko-integration/v1/orderhistory/list` - отадет сипсок заказов для истории. Внутри будем ходить в `/qr-orders/v1/get-by-user`.
   2.  `/iiko-integration/v1/orderhistory/order` - отдает информацию по конкретному заказу в истории. Внутри будем ходить в `/qr-orders/v1/get`. 
   3.  `/4.0/qr-pay/v1/restaurants` -  отдает список ближайших ресторанов. Внутри будем ходить в `/qr-partner/v1/get-near`
   4.  `/4.0/qr-pay/v1/restaurant` -  отдает информацию по конкретному ресторану. Внутри будем ходить в `/qr-partners/v1/get`
2. выносим из payments-eda:
   1. `/4.0/payments/v1/preorder` - отдает на клиенты информацию по заказу и способах оплаты. Внтури будем ходить в `/qr-orders/v1/get` и в `/v1/payment-methods-availability/` сервиса eats-payments
   2. `/4.0/payments/v1/orders` - запускает оплату заказа. Внутри еще раз сходим в `/v1/payment-methods-availability/`, затем в `/qr-orders/v1/start-payment`.
   3. `/4.0/payments/v1/orders/retrieve` - отдает информацию по статусу оплаты заказа. Внутри будем ходить в `/qr-orders/v1/get`


## Вопросы-ответы для архитектурного ревью


**Название сервиса** 

 iiko-integration (новый)
 payments-eda (дорабатывается)
 
 
**Какую продуктовую проблему решает сервис?**

Мы хотим побуждать пользователя оплачивать заказы в ресторанах 
через superapp начисляя ему кэшбэк, который он снова потратит в такси 
(или где-то еще в будущем). Для этого мы будем печатать qr-код 
с диплинком для оплаты заказа через суперапп. 


**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

На этапе MVP делаем решение основанное на существующем флоу Еды.

Новый сервис iiko-integration нужен, потому что:
- нужна интеграция с ресторанной системой - это внешний партнер (на данный момент iiko) -
Будем получать внутренние заказы ресторанна и создавать их в еде. 

Нужна доработка payments-eda, потому что:
- Сейчас заказ создается в еде, а потом обрабатывается в payments-eda, 
в нашем случае мы будем создавать заказ в еде получив его от ресторанной системы. 
Новый флоу на клиентах, связанный с оплатой по qr-коду.
- После оплаты заказа нужно инициировать начисление кэшбэка. 
 
 
**Как именно сервис будет решать поставленные перед ним задачи?**

Флоу заказа:
1. Официант закрывает заказ -> iiko идет в iiko-integration с id ресторана, id заказа и составом предчека ->
iiko-integration идет в Еду чтобы создать по предчеку заказ -> возвращаем iiko id заказа 
и диплинк на этот заказ завернутый в qr-код -> iiko печатает чек с qr-кодом
2. iiko начинает полить iiko-integration, запрашивая состояние этого заказа 
(в будущем тут может быть взаимодействие через WebSocket)
3. Пользователь фотографирует qr-код через приложение -> superapp идет в payments-eda
-> payments-eda запрашивает состав предчека у Еды, и запрашивает доступные 
способы оплаты клиенту у cardstorage -> возвращает всю информацию клиенту
4. Пользователь выбирает способ оплаты и нажимает оплатить -> клиент идет в payments-eda
c этой информацией -> payments-eda запрашивает информацию у Еды по заказу, 
если заказ не закрыт, то через сервис transactions-eda инициируем заморозку денег
и сообщает пользователю о том что надо ждать оплаты (клиент начинает полить статус оплаты).
5. В stq-колбэке (который инициирует trasactions-eda) обрабатываем изменения статусов транзакций и когда деньги успешно захолжены идем в cashback 
чтобы начислить кэшбэк, и запускает операцию clear.
6. Клиент на очередной итерации поллинга запрашивает состояние оплаты и получает сообщение о том что заказ успешно оплачен и в ближайшее время произойдет начисление кэшбэка.
7. iiko на очередной итерации поллинга запрашивает состояние заказа в iiko-integration ->
iiko-integration запрашивает состояние у Еды -> возвращает iiko информацию о том что заказ успешно закрыт.
 
  
**Разрабатывается один сервис или система?**

один новый сервис iiko-integration, но правки потребуется в payments-eda. 
Кроме того, дургими командами правки вносятся также в кэшбэке, биллинге, еде


**С кем взаимодействует сервис?**

iiko-integration:
1. С ресторанной системой iiko:
    - ресторан приходит к нам за qr-кодом
    - мы получаем информацию о предчеке
    - сообщаем ресторану об оплате
2. C Едой: создаем заказ в Еде, запрашиваем состояние оплаты заказа
3. C клиентом через api-proxy: клиент получает информацию о доступности фичи и списке ресторанов с кэшбэком 
    
paymets-eda:
1. С клиентом: 
    - клиент получает информацию о предчеке 
    - выбирает разрешенные payment_method
    - инициирует оплату
    - получает информацию об успешности прохождения оплаты
2. C Едой:  сообщает об оплате
3. C cardstorage: получаем доступные клиенту способы оплаты.
4. С сервисом transactions: стандартный флоу оплаты
5. С сервисом кэшбэка: зачисление кэшбэка после успешного холда средств.
 
Идемпотентность всех операций обеспечивается по ключу = id заказа, определяемого парой: 
- id ресторана (client_id для Еды)
- id заказа в системе iiko
Актуальное состояние заказа всегда хранится в Еде. 


**Какие базы использует?**

На этапе MVP не планируем использовать бд (полученную от iiko информацию по заказам
храним в Еде и в qrcode на чеке).


**Какие периодические процессы?**

Внутри сервиса периодических процессов нет, но iiko будет полить заказы. 


**Схема того, где этот сервис находится в текущей инфраструктуре**

![Получение списка ресторанов](https://jing.yandex-team.ru/files/andreykostin/go_pay_availability.png)
![Печать предчека и обноввление статуса заказа](https://jing.yandex-team.ru/files/andreykostin/go_pay_iiko.png)
![Оплата заказа](https://jing.yandex-team.ru/files/andreykostin/go_pay_user_pay.png)



**Какие данные и по какой схеме сервис будет хранить в базе?**

--

**Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

--

**Какие операции над данными заложены?**

--

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

нет

**Какая нагрузка ожидается?**

Для iiko-integration:
На каждый ресторан имеем  
 - не более ~0.5 RPS - iiko полит статусы заказов

Нагрузка от api-proxy (от ручки /products) не боллее 300 RPS.

На этапе MVP предполагаем не более 100 ресторанов, 
при успехе максимум до 10000 к концу года.
Итого: не более 350 RPS на старте и не более 1500 PRS в будущем
(нагрузку в будущем будем снижать либо переходом на WebSocket для взаимодействия 
с iiko либо лонгполлингом).


Для payments-eda:
На каждый ресторанный заказ имеем:
 - 1 раз создаем заказа 
 - 1 раз клиент получает информацию о заказе
 - несколько раз ходит за получением статуса оплаты заказа
 В сумме на ресторан бдуем иметь не более 0.5 RPS
 В сумме по 100 ресторанам получаем прибавку в нагрузке 50 RPS


**Какие фолбеки предусмотрены на сам этот сервис?**

1. Со стороны iiko: не печатаем qr-code на чеке и не отслеживаем оплату по этому заказу 
2. Со стороны клиентов: после ретраев сообщаем об ошибке.
3. Со стороны Еды: если по созданному заказу в течении некоторого достаточно долгого TTL 
не пришло подтверждение оплаты - закрываем заказ как неоплаченный 
(в случае если платежная операция была запущена, то постановка соответствующей 
stq-таски, которая обрабатывает результат операции и сообщает об этом еде - 
гарантируется со стороны сервиса transactions)

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

1. Еда: если не можем создать заказ в Еде - отвечаем iiko ошибкой (iiko не печатает qrcode на чеке)
2. transactions и cardstorage: если есть проблема с какой-либо платежной операцией, то отвечаем клиенту ошибкой. 
Если проблемы начались после холда, то деньги автоматически будут разблокированы спустя некоторое время - 
значит мы также можем считать заказ не оплаченным и ответить клиенту ошибкой. 
Клиент может оплатить заказ через ресторан.

  
**Какие возможности масштабируемости закладываются?**

Горизонтальное масштабирование путём увеличения количества инстансов

**Какие точки отказа есть в сервисе?**

iiko-integration:
- взаимодействие с Eda

payments-eda: 
 - Eda
 - cardstorage
 - transactions
 - сashback. 

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

- Общее количество созданных в ресторане заказовс qr-кодов
- Количество просмотренных по qr-коду заказов
- Количество заказов, оплаченных по qr-коду

**Укажите технические метрики**

помимо существующих и стандартных:
- количество текущих (незакрытых) заказов
- количество проблемных заказов (не удалось оплатить)
- количество проблем с зачислением кэшбэка

**Какая функциональность ожидается в сервисе в будущем?**

* Оплата по QR-коду, расположенному на столе с разделением на отдельные заказы и без участия официанта
* Свой флоу заказа, независимый от Еды (скорее всего будем обобщать флоу payments-eda и выносить в отдельный сервис)
* История заказов

**Какое изменение нагрузки планируется?**

В случае хороших результатов эксперимента планируется дальнейшее увеличение 
количества ресторанов и пропорциональный рост нагрузки (до 1000 RPS к концу года).

**Активно ли будет изменяться сервис?**

Если будет успех, то да. Планируется переносить qr-код на стол, 
оплачивать заказ без участия официанта, вероятно создавать свой флоу заказов 
 независимый от Еды.

### Продуктовые ограничения

на этапе MVP:
- нет оплаты кешбеком (ждем биллинг)
- правила кешбека - задаются конфигом в админке
- нет возможности вернуть средства пользователю после успешной оплаты (договариваемся с ресторанами?) 

## Архитектура
### API iiko-integration
#### ручка `POST /orders`
iiko сообщает о новом заказе и запрашивает qr-код для чека. 
Мы создаем заказ в Еде.

Параметры запроса:
```json
{
  "client_id": "id ресторана",
  "internal_order_id": "id заказа в системе iiko",
  "bill": {
    "currency": "RUB",
    "amount": "100",  
    "elements": [
      {
        "name": "наименование позиции в предчеке",
        "amount": "120"          
      },
      ...    
    ]        
  }   
}
```
Ответ 200:
```json
{
  "order_id": "id заказа Еды",
  "bill_lines": [
    {
      "type": "text",
      "value": "Оплати через yandex-go и получи кэшбэк 30%!"
    },
    {
      "type": "qr-code",
      "value": "yandex-go.ru/go-pay/orders&order_id=id"
    },
    ...
  ]
}
```
Идемпотентность обеспечивается ключом `internal_order_id`.

#### ручка `POST /orders/list`
iiko поллит статус оплаты заказа. Мы ходим с аналогичным запросом в Еду.  

Параметры запроса:
```json
{
  "client_id": "id ресторана", # здесь скорее всего не нужен, но может пригодиться как минимум для технических метрик
  "orders": [
    "id незакрытого заказа",
    ...  
  ]  
}
```

Ответ 200:
```json
{
  "orders": [
      {
         "id": "id заказа",
         "status": "WAITING|PAYED|CANCELED|NOT_FOUND"       
      },
      ...
  ]
}
```

#### ручка  `GET /availability`
api-proxy приходит за статусом.  
По кофигу и экспериментам определяем доступность в текущей зоне для данного пользователя
 
Параметры запроса:
```json
{
  "uuid": "uuid",
  "phone_id": "phone_id",
  "nearest_zone": "zone",
  ...
  TBD 
}
```
ответ 200:
```json
{
  "is_available": true|false,   
}
```
TBD

#### ручка `GET /restaurants`
Клиенты через api-proxy приходят за списком ресторанов и величиной кэшбэка для каждого из них.
Через конфиг и эксперименты формируем список ресторанов.

Параметры запроса:
```json
{
  "nearest_zone": "zone",
  "uuid": "uuid",
  "phone_id": "phone_id",
  # другие пользовательские аргументы от passenger-authorizer 
}
```
Ответ 200:
```json
{
  "restaurants":[
    {
      "name": "Название ресторана",
      "cashback": "30%",          
    },
    ...
  ]    
}
```

### API payments-eda

#### API ручки `GET 4.0/payments/v1/preorder`
Ручка уже существует, и возвращает клиенту состав предчека заказа.
  
Расширяем API в части параметров запроса:
 - добавляем в enum-параметр `service` новый тип `restaurant`.

Расширяем API в части параметров ответа 200:
```json
{
  "cashback": {
    "rate": "30%",
    "amount": "300",
    "currency": "RUB"
  },
  ...   
}
```

 
#### API ручки `POST /4.0/payments/v1/orders`
Уже существующая ручка, для подтверждения оплаты пользователем

Расширяем API в части параметров запроса:
 - добавляем в enum-параметр `service` новый тип `restaurant`.

Идемпотентность обеспечивается по ключу - order_id. 

#### API ручки `GET /4.0/payments/v1/orders`
Новая ручка - нужна для отображения статуса заказа
Клиент полит ручку с периодом указанном в заголовке `X-Polling-Delay` 
до получения статуса `PAYED` или `DECLINED`.

Единственным параметром запроса является  `order_id`.

Ответ 200:
```json
{
  "message": "Ожидайте оплаты",
  "status": "WAITING|PAYED|DECLINED"
}
```


### Технические ограничения

На этапе MVP жертвуем:
- алертами
- возможно частично мониторингом
- используем сервисы Еды для реализации оплаты ресторанного чека 
(в будущем вероятно потребуется обобщение и вынос всего флоу оплаты заказа в отдельный сервис)

### Как раскатываем
0. Создаем в офисе ресторан с iiko-системой (iiko разворачивает у нас свой ресторанный сервер) - тестируем полный цикл на нем. 
1. с iiko и одним рестораном договариваемся о закрытом тесте на проде
2. раскатываем эксперимент на себя
3. раскатываем на Москву

#### Техническая раскатка
За раскатку отвечает эксперимент 3.0, который работает в `/products` 
и может раскатываться по пользовательским аргументам

### Безопасность
1. Авторизация iiko по API Key v1.0 (вопрос пока остается открыт, ждем ответа ИБ)
2. Никаких ПД не храним
3. Для того чтобы защититься от подмены заказов в диплинк добавляем
``` 
hmac=HMAC_SHA256(key_from_secdist, "order_id:restaurant_id")
```
и при получении запроса на определенный заказ в payments-eda проверяем 
соответствие order_id <-> hmac

### Очень примерная оценка сроков:

iiko-integration:
- [2d] `POST /orders`
- [3d] `POST /orders/list`
- [2d] `GET /availability` (можно заменить на yaml-реализацию в api-proxy)
- [2d] `GET /restaurants` (можно заменить на yaml-реализацию в api-proxy)

payments-eda:
- [2d] `GET 4.0/payments/v1/preorder`
- [2d] `POST /4.0/payments/v1/orders`
- [2d] `GET /4.0/payments/v1/orders`
- [2d] обработка изменения статусов оплаты в stq-callback

cashback:
- [?] новая ручка для начисления кэшбэка (пока прорабатывается и не понятно какая команда делает)

transactions-eda: 
- [?] возможно придется делить инвойсы по сервисам (все зависит от ответа Еды и проработки со сторон биллинга) 

 
 Итого пока:  17d + запас ~= 22d  
 C учетом рапараллеливания на 3-4 человека: ~1.5w  

## Оплата заказа несколькими пользователями

Нужно при неудачной оплате заказа одним пользователем (статус HOLD_FAILED) давать оплатить его другому

Из двух описанных решили выбрать вариант с генерацией eda_order_id на нашей стороне потому что:
1. Он требует меньше доработок
2. Не будут создаваться лишние заказы в Еде
3. Создание заказа по передаваемому id уже поддержано в api Еды



###Первый вариант (будем использовать его): меняем связь пользователя с заказом в момент оплаты и генерим id Еды на нашей стороне
Схема взаимодействия с Едой в multipay-orders-v1.plantuml
Изменения в флоу:
1. /preorder - не проверяем uid для статуса HOLD_FAILED
2. /orders (изменения только для статусов PENDING/HOLDING/HOLD_FAILED) - 
	1. для статуса HOLDING - пользователь повторно вызвал оплату своего заказа
	   1. проверяем что заказ из iiko-integration принадлежит пользователю (сравниваем uid-ы)
	   2. используем eda_order_id который уже записан в iiko-integration заказ
	2. для статусов PENDING, HOLD_FAILED с новым uid - создаем связь пользователя и заказа
	   1. генерим eda_order_id из iiko_order_id, yandex_uid, service
	   2. апдейтим в iiko-integration eda_order_id, новый uid и статус HOLDING (точка синхронизации)
	   3. создаем заказ в Еде
	3. для статуса HOLD_FAILED со старым uid - пользователь повторно пробует оплатить заказ после неудачи
	   1. апдейтим статус HOLDING в iiko-integration (точка синхронизации)
	4. создаем инвойс используя eda_order_id из пунктов выше
3. payments_eda_stq_callback - обновляем статус по eda_order_id

####Как защитимся от гонок?
Пункты (2.2.2, 2.3.1) выстпауют точкой синхронизации - при обновлении заказов в них проверяется uid пользователя,
таким образом что если в заказе уже другой пользователь - выкинется ошибка.
Синхронизировать запросы одного пользователя не нужно - у него будет один и тот же eda_order_id.
Получается что инвойс создастся только пльзователю который первый вызвал /orders


####Доработки по сервисам:
#####iiko-integration:
1. ручку /order/update научить обновлять заказы по eda_order_id
2. доработать ручку /order/update чтобы она:
   проверяла принадлежность заказа по uid - возвращала ошибку при обновлении чужого
   (кроме обновения со статуса HOLD_FAILED)
3. решили не делать: при обновлении eda_order_id сохранить eda_order_id + uid + order_id
   в отдельную таблицу (задача на слуай если потребуется история попыток оплаты)

#####payments-eda:
1. /preorder - убрать проверку пользователя для статуса HOLD_FAILED
2. /orders - перед созданием заказа в Еде и инвойсом 
   1. генерить eda_order_id (из iiko_order_id, yandex_uid, service - так он будет уникальным для связки пользователь-заказ)
   2. вызывать /order/update с eda_order_id, uid, статусом HOLDING.
   (при несовпадении uid, кроме перехода из HOLD_FAILED, нужно обработать ошибку /order/update)
   3. использовать сгенеренный eda_order_id для создания заказа в Еде и инвойса
3. payments_eda_stq_callback - обновлять заказ в iiko-integration по eda_order_id, а не по id
   (id инвойса будет совпадать с eda_order_id)
   
   

###Второй вариант: меняем связь пользователя с заказом в момент оплаты, eda_order_id генерится на стороне Еды
Схема взаимодействия с Едой в multipay-orders-v2.plantuml
Изменения в флоу:
1. /preorder - не проверяем uid для статуса HOLD_FAILED
2. /orders (изменения только для статусов PENDING/HOLDING/HOLD_FAILED) - 
	1. для статуса HOLDING - пользователь повторно вызвал оплату своего заказа
	   1. проверяем что заказ из iiko-integration принадлежит пользователю (сравниваем uid-ы)
	   2. используем eda_order_id который уже записан в iiko-integration заказ
	2. для статусов PENDING, HOLD_FAILED с новым uid - создаем связь пользователя и заказа
	   1. создаем заказ в Еде
	   2. апдейтим его eda_order_id, новый uid и статус HOLDING в iiko-integration (точка синхронизации)
	   3. используем дальше eda_order_id из апдейта (нужно если создание заказа не идемпотентно)
	3. для статуса HOLD_FAILED со старым uid - пользователь повторно пробует оплатить заказ после неудачи
	   1. апдейтим статус HOLDING в iiko-integration (точка синхронизации)
	   2. используем дальше eda_order_id из апдейта (нужно если создание заказа не идемпотентно)
	4. создаем инвойс используя eda_order_id из пунктов выше
3. payments_eda_stq_callback - обновляем статус по eda_order_id

####Как защитимся от гонок?
Пункты (2.2.2, 2.3.1) выступают точкой синхронизации - 
Для запросов разных пользователей из-за проверки uid в апдейте для второго пользователя вернется ошибка.
Получается что инвойс создастся только пльзователю у которого первым выполнился iiko-integration/update в /orders.
Для разных запросов одного пользователя в случае с идемпотентным созданием заказа в Еде синхронизация не потребуется,
без идемпотентности нужно доработать апдейт чтобы он возвращал только первый eda_order_id пользователя
(так он будет одинаковый даже в разных запросах).


####Доработки по сервисам:
#####iiko-integration:
1. ручку /order/update научить обновлять заказы по eda_order_id
2. доработать ручку /order/update чтобы она:
   1. проверяла принадлежность заказа по uid - возвращала ошибку при обновлении чужого
      (кроме обновения со статуса HOLD_FAILED)
   2. если создание заказа в еде не идемпотентно - 
        возвращала eda_order_id обновленного заказа
        и не перезаписывала eda_order_id когда uid в заказе и запросе совпадают
        (нужно для синхронизации запросов от одного пользователя)
3. решили не делать: при обновлении eda_order_id сохранить eda_order_id + uid + order_id
   в отдельную таблицу (задача на слуай если потребуется история попыток оплаты)

#####payments-eda:
1. /preorder - убрать проверку пользователя для статуса HOLD_FAILED
2. /orders - после создания заказа в Еде и до создания инвойса добавить:
   1. создание заказа в Еде (если есть ключ идемпотентности - генерить по uid, iiko_order_id, service)
   2. вызывать /order/update с eda_order_id, uid, статусом HOLDING.
      (при несовпадении uid, кроме перехода из HOLD_FAILED, /order/update вернет ошибку)
   3. использовать id заказа в Еде (из вызова /order/update если создание не идемпотентно) для создания инвойса
3. payments_eda_stq_callback - обновлять заказ в iiko-integration по eda_order_id, а не по id
   (id инвойса будет совпадать с eda_order_id)



###Третий вариант (идея): при переводе в HOLD_FAILED сбрасывать uid, eda-order-id и status в PENDING
Продумывал такой вариант, но все равно нужно вводить точку синхронизации в /orders чтобы обошлось без гонок.
Не хватает возможности создать заказ в Еде при сбосе статуса на PENDING.

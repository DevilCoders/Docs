
# Проблема

Сейчас у нас есть клиентское API самокатов для России. К нему мы хотим добавить API для самокатов Wind'a. 
В идеальном светлом будущем у нас будет единый клиентский API на самокаты во всех странах, однако, нам будет сложно добиться полной унификации API и флоу на старте, поэтому мы должны научиться расщеплять обработку запросов на бэке.


# Предлагаемое решение (TLDR)

План такой:
1. Добавляем `api_teg` в эксперимент `scooters`, что автоматически пробросит тег в ответ `/products`
2. Создаем прокси-сервис для роутинга (он же сервис авторизации на стороне wind) - это точка входа для всего API. В нем будем роутить запросы либо по тегу либо по координатам пина. Еси по коодрдинатам, то будем так же определять тег используя тот же эксп `scooters`. В каждом ответе также будем возвращать тег.
3. В layers пока ничего не прокидываем, но держим в уме, что при острой необходимости можем прокинуть там тег в каждый самокат
4. Передавать тег или координату в клиентских запросах - выбираем по ситуации (основные критерии выбора: актуальность данных и их доступность). Некоторые ручки могут быть полностью унифицированными сразу на старте - для них ничего не нужно будет передавать (оговариваем отдельно какие). Первый кандидат на унификацию: трекинг заказа - по хорошему мы должны проверять наличие активного заказ вне зависимости от координат/тега и в драйве и в винде (но чтобы как-то снизить нагрузку можем например подгружать заказ от соответствующего партнера только в том случае если хотя бы по одной из координат пользователя или пина мы попали в соответствующий тег. Координаты в этом случае будем передавать в теле запроса) 
5. Когда можем использовать тег - лучше использовать его, а не координаты пина. Тег лучше маркирует запросы, нам будет легче понять какое API в какой момент используется.

# Предлагаемое решение (Подробно)

Маршрутизация клиентского запроса может осуществляться следующими способами:
1. По условию попадания координат пина в заданный полигон - это основной (первичный) и наилучший способ определения адреса проксирования запроса. Мы будем стремиться всегда использовать его. Однако, в некоторых ситуациях мы скорее всего не сможем воспользоваться этим способом, т.к. у нас не будет координат (например, в случае сканирования qr-кода через камеру в OS). 
2. Матчингом тега нужного нам api/флоу. Этот способ может быть использован тогда, когда невозможно использовать способ 1. Тег может быть определен на клиенте (например при сканировании qr-кода на самокате выбираем нужный тег в зависимости от типа полученного линка) или получен и закеширован при использовании 1-го способа маршрутизации.
3. (альтернативный) Через определение страны по IP - этот метод кажется весьма ограниченным (не сможем расщеплять api внутри одной страны) и ненадежным (криво определим страну при использовании VPN) - считаю, что нет смысла его рассматривать


## Прокси-сервис для роутинга клиентских запросов

На базе либы base-proxy создаем прокси-сервис, который будет являться точкой входа для всех клиентских запросов в части самокатного API во всех странах (т.е. существующий российский API также сажаем сюда), в котором мы сможем гибко настраивать роутинг всех запросов. В качестве рабочего названия сервиса примем: `scooters-api-router`.

Правила маршрутизации будем мапить по api-тегу. На старте у нас будет существовать 3 возможных значения api-тега:
- `drive_scooters` - для российских самокатов 
- `wind` - для самокатов wind
- `unified` - для полностью унифицированного API/флоу одинаково подходящего для всех типов самокатов (будем стремиться к этому варианту)

По умолчанию всегда будем искать правило маршрутизации для полученного `path` и тега `unified`. Если не найдем, то будем пытаться найти правило для api-тега, который определим по одному из 2 хедеров или версии приложения следующим образом:
1. Если в запросе есть хедер `X-Api-Tag` то достаем значение тега из него.
2. Если в запросе нет хедер `X-Api-Tag`, то будем определять тег через эксперимент `scooters`, в кварги которого положим: 
  - координаты пина (если есть) - их будем искать в хедере `X-Geo-Point` в json-формате: `[lon, lat]`;
  - версию приложения;
  - phone_id и т.п. по желанию. 
  
Если тег определить не удалось, или он был определен как `unified` (что по сути то же самое) - то кидаем 400 (или лучше что-то типа 406, чтобы не сливалось на графиках) т.к. к этому моменту мы уже должны были поискать правило роутинга по `unified` (в самом начале).

Если для найденного тега не нашлось правила роутинга, то также кидаем 400. 

В успешный ответ также добавляем api-тег в хедер `X-Api-Tag`, чтобы при необходимости клиент мог закэшировать на своей стороне и использовать для последующих запросов. Здесь стоит заметить, что по возможности нам стоит избегать кэширования тега на клиентской стороне или быть предельно акуратными в этом, т.к. рано или поздно не тот тег может выстрелить нам в ногу. В некоторых ситуациях вполне допустимо самостоятельное определение тега клиентами без обращений к бэку (например по qr-коду).

### По совместительству сервис авторизации?

Для использования API wind'a нам понадобится также авторизационный прокси-сервис.
Чтобы не плодить цепочку из 2х мелких проксирующих сервисов, возможно, нам стоит объединить этот сервис с сервисом авторизации в wind'е - бонусом получим небольшую оптимизацию (-1 уровень вложенности для всех запросов).


## Определение api-тега в точках входа 

Все возможные точки входа можно разбить по следующим категориям:
1. Точки входа на экраны с общей инфой про фичу, ЛК, промо и т.п. Сейчас все эти точки приходят в ответе ручке `/products` и кажется здесь  у нас ничего не будет меняться в том числе и для wind'a - можем слать тег здесь.
2. Точки входа на экраны с информацией про самокат/офер/бронирование:   
   1. Через сканирование qr-кода самоката. Здесь есть 2 варианта: через наше приложение (кнопка сканирования приходит в `/products`) или через системную камеру. В обоих кейсах api-тег может быть определен на клиентах через парсинг содержимого qr-кода.
   2. Через взаимодействие с самокатами на карте. Сейчас все объекты на карте приходят через `/layers/` - там мы можем добавить api-тег.
3. Точки входа на экран заказа (трекинг текущего заказа) - тут кажется разумным делать сразу единый клиентский API (на бэке по идее мы и так будем знать какого типа у нас заказы) и вне зависимости от координат пользователя нам следует трекать все его заказы.

### Получение api-тега в ручке /products

Будем передавать api-тег в эксперименте scooters, в value которого положим:

```json
{
  "api_tag": "wind"
  ...
}
```

### Получение api-тега через layers

Для того чтобы нам не попасть не в тот API при тапе на соседний самокат на карте  (т.к. его координата теоретически может сильно отличаться от координат пина) предлагается слать api-тег также для всех самокатов в ответе layers. 
Мы могли бы слать api-teg в actions:

```json
{
 "features": [
    {
      "id": "scooter_42",
      "options": [
        {
          "on": "tap",
          "actions": [
            {
              "type": "walk_route",
              "dst": {
                "position": [
                  37.61171833,
                  55.73031667
                ]
              },
              "api_tag": "wind" 
            },       
            {
              "type": "pick_scooter",
              "car_number": "1074",
              "api_tag": "wind"
            }
          ]
        }
      ],
      ...
    },
    ...
 ],
 ...
}
```

Но скорее это все же преждевременно, потому что весь API используемый при тапе на самокат и так либо легко унифицируется (как минимум пеший маршрут) либо может быть расщеплен уже на бэке по координате или номеру самоката. Кроме того клиент всегда может слать в хедер `X-Geo-Point` не координаты пина, а координаты самоката, которые и так уже приходят в ответе layers.

Да и сам кейс попадания в "не тот" самокат выглядит пока крайне маловероятным - пожалуй это имеет смысл только в том случае, если мы захотим на одной территории использовать оба типа самокатов, что само по себе уже не позволяет расщепить API по геозонам и вынуждает нас делать полностью унифицированный API.

Поэтому предлагаю расширять API layers и слать тег только в том случае, если мы поймем, что нам это действительно необходимо.


## Оценка

- [3d] Создать сервис `scooters-api-router` и реализовать логику роутинга
- [1d] (кажется можно пока не делать) добавить тег в layers (если делать, то вместе с остальной доработкой карты, по идее будет не дорого)
- [1d] запас на непредвиденное 

ИТОГО: 4...5d 

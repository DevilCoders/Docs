## Опросник для ревью комитетом

**Название сервиса**

zoneinfo

**Какую продуктовую проблему решает сервис?**

Повышение стабильности Такси

**Почему нельзя решить эту задачу без разработки нового сервиса существующими решениями?**

Повышать стабильность монолита в наших условиях выглядит бессмысленной задачей. Лучше уносить логику в микросервисы.

**Как именно сервис будет решать поставленные перед ним задачи?**

Реализует базовую логику ручки zoneinfo. Будет служить вначале фолбеком на протокольную ручку, а после отказа от нее - ядром ответа.

**Разрабатывается один сервис или система?**

Один сервис

**Сколько и какие сервисы входят в систему?**

zoneinfo

**С кем взаимодействует сервис?**

1. Какие (микро-)сервисы и как используются.
  * Сервис конфигов - строим кеш конфигов
  * Сервис экспериментов 3 - строим кеш экспериментов
  * Сервис taxi-tariffs - строим кеш настроек зон
  * Сервис territories - строим кеш стран
  * Сервис localizations-replica - строим кеш переводов
2. Как гарантируется идемпотентность внешний операций.
  * Сервис только читает данные
3. Как поддерживается консистентность данных при частичных отказах.
  * Сервис сам не держит данных. Консистентность остается на сервисах-поставщиках.
4. Как организованы ретраи внешних сервисов.
  * Мы вызываем внешние сервисы только для построения кешей.

**Какие базы использует?**
Mongo:
  * images
  * requirements

**Какие периодические процессы?**

Обновление кешей

**Прикрепите схему того, где этот сервис находится в текущей инфраструктуре**

1. Как технически проект влияет на цикл заказа.
  * Отдает приложению информацию о зоне
2. Кто будет потребителями сервиса.
  * Только api-proxy

**Какие данные и по какой схеме сервис будет хранить в базе?**

Свои данные не хранит.

**Какой объем данных будет храниться и какой объем будет изменяться в единицу времени?**

-

**Какие операции над данными заложены?**

-

**Есть ли какой-то стейт в памяти, как он обновляется и валидируется?**

Кеши. Обновляются с разной частотой.

**Какая нагрузка ожидается?**

Нагрузка ручки zoneinfo до карантина в пике примерно 400рпс. Вероятно, будет расти со временем.
Планируем пострелять, как закончим разработку.

**Какие фолбеки предусмотрены на сам этот сервис?**

На него нет фолбеков.

**Какие фолбеки предусмотрены внутри этого сервиса на взаимодействие с другими сервисами?**

todo
Фолбэк на каждый компонент должен быть описан. Какие особенности будут при отключении ДЦ. Как будет тестироваться отказоустойчивость.

**Какие возможности масштабируемости закладываются?**

...

**Какие точки отказа есть в сервисе?**

...

**Укажите ключевые продуктовые метрики сервиса, за которыми планируете следить**

...

**Укажите технические метрики**

...

**Какая функциональность ожидается в сервисе в будущем?**

Возможно, заберем необязательные поля ответа zoneinfo в другую ручку
Возможно, сделаем фолбек для zonaltariffdescription

Этапы разработки:
Оценки в общем времени, не чистое время разработки.

1. Подготовка api-proxy
  * Уносим zoneinfo за api-proxy, просто пробрасываем до протокола(?3d)

2. Разработка сервиса
  * Заводим сервис, подключив к нему готовые либы вроде конфигов(3d)
  * Делаем в сервисе тарифов ручки для того, чтобы поднять кеш tariff_settings(4d)
  * Делаем либу с кешом tariff_settings над сервисом тарифов(3d)
  * Делаем кеш над dbtaxi.requirements(2d) 
  * Делаем кеш над dbtaxi.images(2d)
  * Переносим в uservices логику Visibility helper(?2w)
  * Делаем логику по фильтрации требований(1w)
  * Наполняем ответ нужными данными из кешей(3d)
  
2. Включение
  * Включаем на команду разработки для проверки в проде
  * Проверяем набор данных в ответе на достаточность
  * В апи прокси делаем отправку ивента в антифрод и убрать ее из протокола
  * Включаем как фолбек для всех


**Какое изменение нагрузки планируется?**

...

**Активно ли будет изменяться сервис?**

Расчет на то, что не будет меняться вообще. То есть редко.

<hr>

## Архитектура

### API

Ручка `v1/core`:

```js
{
  // Была в самой первой версии от 2017 года. Там просто загрузка строчки из переводов.
  // Source: localizations
  "copyright": "© 2011–2020 ООО «Яндекс.Такси»",
  // Хоть не помечено как required, но очевидно берем в обязательные
  // Source: dbtaxi.countries
  "country_code": "RU",
  // Хоть не помечено как required, но очевидно берем в обязательные. Берется из страны кстати.
  // Source: dbtaxi.countries
  "currency_code": "RUB",
  // Прямое значение из tariff_settings. Берем в обязательные.
  // Source: dbtaxi.tariff_settings
  "exact_order_round_minutes": 1,
  // Прямое значение из tariff_settings. Берем в обязательные.
  // Source: dbtaxi.tariff_settings
  "exact_order_times": [
    600
  ],
  // Прямое значение из tariff_settings. Берем в обязательные.
  // dbtaxi.tariff_settings
  "is_beta": false,
  // TAXIBACKEND-18673. По закону должны возвращать для России, берем в обязательные.
  // Просто запись в танкере по id страны
  // Source: dbtaxi.countries, localizations
  "legal_entity": "ООО «Яндекс.Такси», ОГРН: 5157746192731, 115035, город Москва, Садовническая улица, дом 82, строение 2, помещение 916, часы работы 10–19.",
  // Прямое значение из tariff_settings. Берем в обязательные.
  // Source: dbtaxi.tariff_settings
  "max_route_points_count": 5,
  // Next lebel
  "max_tariffs": [
    {
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "can_be_default": true,
      // tariff_settings и ZONES_TARIFFS_SETTINGS. Берем в обязательные.
      // Source: dbtaxi.tariff_settings, configs
      "card": {
        "options": [],
        "subtitle": "Для коротких поездок"
      },
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "class": "econom",
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "comments_disabled": false,
      // Грузим из танкера по ключу из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings, localizations
      "description": "Toyota Ist, Nissan March, Daihatsu Boon",
      // Берем в фолбек, а то вдруг саммари сломается.
      // Source: dbtaxi.tariff_settings, dbtaxi.images
      "icon": {
        "size_hint": 480,
        "url": "https://tc.mobile.yandex.net/static/images/10593/d3f4727f-9650-4f86-84a4-96fdeb500d51",
        "url_parts": {
          "key": "TC",
          "path": "/static/images/10593/d3f4727f-9650-4f86-84a4-96fdeb500d51"
        }
      },
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "id": "econom",
      // Берем в фолбек, а то вдруг саммари сломается.
      // Source: dbtaxi.tariff_settings, dbtaxi.images
      "image": {
        "size_hint": 480,
        "url": "https://tc.mobile.yandex.net/static/images/40230/cc890826-975a-43db-8761-6d6f65456238",
        "url_parts": {
          "key": "TC",
          "path": "/static/images/40230/cc890826-975a-43db-8761-6d6f65456238"
        }
      },
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "is_default": false,
      // Длинная история с visibility_helper. И кажется, не выйдет поставить просто false
      // Леша Быков хочет сделать библиотеку в uservices для этого.
      // Ему там понадобятся tariff_settings, geoareas и experiments 3.0.
      // То есть включив эту библиотеку, мы возьмем все ее кеши.
      // Можно сделать временное решение в виде какого-то конфига со список фолбек тарифов, которые мы будем считать
      // видимыми, а все остальные нет. Добавить в него только эконом, комфорт и доставку.
      // Source MVP: configs
      // Source post MVP: visibility_helper(dbtaxi.tariff_settings, geoareas, experiments3)
      "is_hidden": false,
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "mark_as_new": false,
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "max_route_points_count": 2,
      // Берем из танкера по ключу из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings, localization
      "name": "Эконом",
      // Берем из танкера по ключу из tariff_settings + поля сразу из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings, localization
      "notifications": {
        "altpin_clarification": {
          "show_count": 3,
          "translations": {
            "button": "Понятно",
            "text": "Рядом есть место, откуда можно уехать дешевле. До него пару минут пешком.",
            "title": "Пройтись пару минут и сэкономить"
          },
          "type": "tariff_popup"
        },
        "antisurge_clarification": {
          "show_count": 3,
          "translations": {
            "button": "Понятно",
            "text": "Некоторые водители едут туда же, куда и вы. Можно найти таких: за счёт этого поездка дешевле.",
            "title": "Поиск чуть дольше, зато сэкономите"
          },
          "type": "tariff_popup"
        }
      },
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "only_for_soon_orders": false,
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings
      "restrict_by_payment_type": [
        "applepay",
        "card",
      ],
      // Прямое значение из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings, localization
      "service_levels": [
        50
      ],
      // Берем из танкера по ключу из tariff_settings. Берем в обязательные.
      // Source: dbtaxi.tariff_settings, localization
      "short_description": "Для коротких поездок",
      // Подробности описаны в архитектуре сервиса
      // Source: dbtaxi.tariff_settings, db.requirements, localization
      "supported_requirements": [
        {
          "default": false,
          "label": "Перевозка домашнего животного",
          "name": "animaltransport",
          "persistent": false,
          "type": "boolean"
        },
        {
          "default": false,
          "label": "Лыжи или сноуборд",
          "name": "ski",
          "persistent": false,
          "type": "boolean"
        }
      ],
    }
  ],
  // Берется из страны. Проще взять сразу в обязательные, вместе с currency_code
  // Source: dbtaxi.countries
  "min_hold_amount": "1",
  // Методы оплаты из tariff_settings + некоторая проверка доступности метода для кошелька и коопаккаунта
  // Явно берем в фолбек, но возможно без таких методов, требующих доп проверок
  // Source: dbtaxi.tariff_settings
  "payment_options": {
    "applepay": true,
    "cash": true,
    "coop_account": true,
    "corp": true,
    "coupon": true,
    "creditcard": true,
    "googlepay": true,
    "personal_wallet": true
  },
  // Из страны, берем в обязательные
  // Source: dbtaxi.countries
  "region_id": 225,
  // Прямое значение из tariff_settings. Берем в обязательные.
  // Source: dbtaxi.tariff_settings
  "req_destination": false,
  "req_destination_rules": {
      "min_timedelta": 1500
  },
  // Прямое значение из tariff_settings. Берем в обязательные.
  // Source: dbtaxi.tariff_settings
  "skip_main_screen": true,
  // Прямое значение из tariff_settings. Берем в обязательные.
  // Source: dbtaxi.tariff_settings
  "skip_req_destination": false,
  // Из конфига ZONEINFO_TARIFFS_URL_INFO по app_name.
  // Сделана была еще в первой версии ручки в 2017 году, сейчас уже не выяснить, обязательно или нет,
  // но мне кажется, что по закону мы должны детальную оферту показывать. Берем в фолбек.
  // Source: configs
  "tariffs_url": "https://m.taxi.yandex.ru/zone-tariff/?id=yuzhnosakhalinsk",
  "tariffs_url_parts": {
    "key": "MTAXI",
    "path": "/zone-tariff/?id=yuzhnosakhalinsk"
  },
  // Прямое значение из tariff_settings. Берем в обязательные.
  // Source: dbtaxi.tariff_settings
  "tz": "+1100",
}
```

### Технические ограничения

Чем мы осознанно жертвуем: алертами, отсутствием запаса под xN рост, редкие гонки, отсутутвие необходимого рефакторинга и тп. ВСЕ должно быть четко описано и скоммуницировано менеджеру и ревьюеру архитектуры.

Стараемся не жертвовать ничем. Нам нужен стабильный сервис сразу.

### Как раскатываем

#### Раскатка этапа 1

1. По эксперименту X на стафф.
2. На город Y.
3. По остальным городам.

#### Техническая раскатка

За раскатку отвечает эксперимент 3.0, который работает в ручке `/zoneinfo` и может раскатываться по следующим аргументам: `personal_phone_id`, `phone_id`, `country`, `zone`.

### Безопасность

Так как ничего не храним, то и ПД нет.

### Компоненты и технические детали их использования

#### localizations
Есть готовый кеш в uservices, можно задавать время обновления и кейсет.
Берем кейсеты tariff и client_messages.

#### configs
Есть встроенный кеш, даже с копией в файловую систему. Нужно указать явный список. Предварительно это: ZONEINFO_TARIFFS_URL_INFO, ZONES_TARIFFS_SETTINGS, новый конфиг про is_hidden возможно

#### dbtaxi.countries
Есть готовый кеш, поднят над сервисом territories

#### dbtaxi.tariff_settings
Делаем кеш на основании сервиса тарифов. Допиливаем нужные ручки сами.
Обновляем раз в минуту. Лаг кеша не влияет, так как настройки зон меняют редко.

#### db.requirements
Как мы фильтруем требования:
 - берем все client_requirements требования из категории из tariff_settings
 - смотрим не попало ли оно в выключенные через эксперимент3 вида "disabled_requirement_"
 - явно проверяем требование hourly_rental на то, включен ли эксперимент hourly_rental
 - ищем требование в базе db.requirements

Дальше просто добавляем требования в ответ.

Есть еще один сложный момент с флагом glued:
 - берем список glued_requirements требования из категории из tariff_settings
 - под экспериментом only_one_glued_requirement возможно оставляем только одно 
 - собственно добавляем флажок glued для требований, что остались
И это очень неприятно: эта логика про glued не выглядит стабильной и в сервис могут придти ее менять.
Но и не брать ее нельзя: непонятно, что будет, если проигнорировать этот эксперимент.

В целом код про требования мне совсем не кажется стабильным. И карго продолжают что-то делать в этом районе прямо сейчас.

В итоге предлагаю так:
 - реализуем простую логику:
  - disabled_requirement_ не проверяем
  - эксперимент hourly_rental не проверяем
  - флажок glued ставим всем на основании glued_requirements из категории
 - делаем конфиг IRREGULAR_REQUIREMENTS
  - в него добавляем все требования, которым нужна экстра логика
  - на старте добавляем в него hourly_rental и карго требования(если они захотят)
  - требования из этого конфига убираем из ответа фолбека
  - в api-proxy делаем отдельные вызовы в отдельные сервисы, которые могут добавить такие требования в ответ

#### images
Кеша images в uservices нет. Вряд ли коллекция очень большая, можно сделать кеш. Вопрос над монгой или подпишемся сделать сервис? В backend-cpp коллекция используется в 6 ручках.

В итоге варианты:
  - делать сервис над базой и кеш над сервисом - дорого
  - делать кеш над монгой - неправильно в рамках нынешнего подхода?
  - не возвращать картинки - мб сломается

Я предлагаю сделать кеш над монгой.

#### experiments3
Эксперименты3 неизбежно нужны VisibilityHelper'у. Есть готовая компонента с кешем.

## Шаблоны {#templates}

Шаблон в конфигураторе - это описание графа настроек в формате yaml. Граф может настраивать агентские схемы в сервисах, может готовить инфраструктуру сервисов и что душе пожелается.

Построение шаблона заключается в композиции блоков.

### Блоки {#blocks}
У каждого блока есть общие поля, такие как название, тип, входные и выходные параметры, список явных зависимостей. Входные параметры обычно задаются как список строк формата `<блок параметра>.<название выходного параметра блока>`. Выходные параметры у каждого блока описываются по-своему. Про типы написано в разделе [Типы переменных](#vartypes). Явные зависимости запрещают начинать выполнять блок до завершения всех блоков зависимостей.

Блоки вычислений, валидаций и интеграции можно сделать повторяемыми. Для этого нужно прописать `repeat.var`, переменную, которая обязана быть типа array (см. пример блока интеграции). Для каждого значения списка во время исполнения графа будет создан подблок, и выходы всех подблоков объединятся в список выходных параметров повторяющегося блока. То есть все выходные типы преобразуются как `type -> array[type]`. Такой подход позволяет запустить несколько экземпляров одного блока во время исполнения, причем количество определяется значением переменной, а не самим шаблоном. Настоятельно рекомендуется использовать такой подход только для блока интеграции и не передавать слишком длинные списки во избежание деградации производительности.

Также блоки вычислений, валидаций и интеграции можно кэшировать. По дефолту оно **включено** - это означает, что если входные параметры не изменились по сравнению с последним завершившимся блоком, то новый блок возьмет выходные параметры предыдущего и сразу завершится. Чтобы отключить, нужно прописать `cache: false`. В апи есть возможность запускать графы без кэширования

Далее будут описаны разные типы блоков.

#### Модуль {#module}
Модуль на данный момент является корневым блоком в шаблоне. Он описывает глобальные входы и выходы, а также вложенные полезные блоки.

У входов есть 3 поля - название, тип и флаг, является ли параметр зависящим от окружения. Например, tvm может зависеть от окружения, в которое будет раскатываться граф.

```yaml
type: module
name: global
inputs:
  - name: service_id
    type: string
    env: false
outputs:
  - name: ticket_key
    var: ticket.key
children:
  - type: ...
    name: ...
    ...
  - type: ...
    name: ...
    ...
```

#### Интеграция {#integration}
Блок описывает интеграцию с сервисами. Работа представляет собой отправку сообщения в очередь sqs, процессинг на стороне сервиса и получение ответа через другую очередь sqs. Данный блок нужен для непосредственных настроек сервисов.

Выходные параметры состоят из названия и типа. Если из интеграции вернулось значение, не подходящее под заданный тип, то будет ошибка выполнения графа.

Аргументы описывают JSON, который будет отправлен в sqs в виде сообщения. В аргументах разрешается в качестве значения полей подставлять переменные - для этого нужно дописать `$` перед названием из входов.

В поле интеграции указываются название sqs очереди и название задачи, соединенные точкой. Для более подробной информации об очередях и формате сообщений обратитесь к разделу [Подключение интеграций](integrations.md)

```yaml
type: integration
name: balance_tvm
repeat:
  var: global.tvm
cache: true
depends: [create_ticket]
integration: balance.setup_tvm
inputs:
  - global.service_id
outputs:
  - name: mdh_service_id
    type: string
args:
  service_id: $global.service_id
  tvm: $global.tvm
  acl:
    methods: [GetBalance, GetAccount]
```

#### Подшаблоны {#embed}
Блок позволяет встроить другой шаблон как часть текущего шаблона.

Входы данного блока сопоставляются со входами подшаблона, а к выходным параметрам подшаблона можно обращаться как `<embed_block_name>.<output_name>`

На данный момент версию подшаблона обязательно нужно указывать, в одном шаблоне нельзя использовать несколько подшаблонов с одним названием.

```yaml
type: embed
name: balance
depends: [balance_calc]
inputs:
  - global.service_id
template:
  code: balance_template
  version: 3
```

#### Вычисления {#calc}
Блок позволяет выполнять простые преобразования над имеющимися параметрами. Бывает полезно конкатенировать строки, складывать значения, etc.

Задаются несколько выражений, которые имеют выходное название переменной (которое одновременно является выходом блока), а также само выражение. Про выражения написано ниже.

```yaml
type: calc
name: balance_calc
depends: [ticket_create]
inputs:
  - balance.conf  # обязано иметь тип строки
exprs:
  - var: conf_long
    expr:
      add: [$balance.conf, _conf]  # конкатенация переменной с константой "_conf"
```

#### Валидации {#validate}
Блок позволяет выполнять простые логические выражения для валидации переменных.

В случае ошибки при выполнении выражения или результате `false` любого выражения блок завершается с ошибкой
```yaml
type: validate
name: balance_validation
depends: [ticket_create]
inputs:
  # параметры eq обязаны иметь одинаковый тип
  - global.balance_service_id
  - balance_service.id
exprs:
  - expr:
      eq: [$global.balance_service_id, $balance_service.id]  # проверка на равенство
```

### Выражения на YAML
Такие выражения могут использоваться в блоке вычислений для преобразований параметров, а также в блоке валидации. Они всегда представляют собой название операции и список агрументов. Пример:
```yaml
slice:
  - abcde
  - 2
  - 4
# результат 'cd'
```

При этом поддерживается возможность делать вложенные операции, то есть вместо аргументов-констант можно передавать валидные выражения. У каждого выражения есть возвращаемый тип. У примера выше возвращаемый тип - строка. Соответственно, все вложенные типы тоже обязаны возвращать ожидаемые типы. Типы проверяются в момент валидации шаблона.

#### Типы переменных {#vartypes}
Сейчас поддерживаются следующие типы:
* `int` - целочисленный тип
* `float` - дробный тип, 8 байт
* `string` - строковый тип
* `array[<type>]` - массив значений типа, указанного в квадратных скобках
* `any` - произвольный тип

Типы нужны для того, чтобы переменные можно было использовать в выражениях. Например, переменную типа `any` нельзя конкатенировать со строкой.

#### Операции
Самую актуальную версию с кодом и возможными операциями можно посмотреть в пакете [configops](https://a.yandex-team.ru/arc/trunk/arcadia/billing/library/go/billingo/pkg/configops)

##### Трансформации
* `add(...union[int, float, string]) -> union[int, float, string]` - принимает произвольное число параметров одинакового типа и складывает их (для строк сложение - конкатенация)
* `slice(union[string, array[anytype]], first int, last int) -> union[string, array[anytype]]` - возвращает первый аргумент с индекса `first` (включительно) до индекса `last` (не включительно)
* `split(s string, sep string) -> array[string]` - сплитит строку по сепаратору, в граничных случаях поведение как в Go методе `strings.Split`
* `len(union[string, array[anytype]]) -> int` - длина контейнера
* `index(array[anytype], int) -> anytype` - взять элемент массива по индексу
* `toInt(union[int, float, string]) -> int` - конвертирует значение в целочисленный тип. float округляется вниз
* `toString(union[int, float, string]) -> string` - конвертирует значение в строковый тип

##### Логические
Под `comparable` типами подразумевается `union[int, float, string, array[comparable]`

Тип `bool` не может быть использован в качестве значения для дальнейших трансформаций. Пока только для вложенных логических операций

* `eq(first, second comparable) -> bool`
* `in(comparable, array[comparable]) -> bool`
* `or(...bool) -> bool`
* `and(...bool) -> bool`


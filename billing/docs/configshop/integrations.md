## Подключение к конфигуратору

Чтобы конфигуратор мог настраивать систему, к ней нужно написать **интеграцию**. В общем случае каждая интеграция слушает свою очередь sqs, обрабатывает входящие сообщения о настройке от конфигуратора и отправляет в очередь конфигуратора ответное сообщение об успехе/неуспехе.

{% note warning %}

Ответное сообщение необходимо посылать при любых обстоятельствах

{% endnote %}

Пример блока интеграции в шаблоне, на который будем ссылаться:
```yaml
name: balance_service
type: integration
integration: balance.set_service
inputs:
  - global.id
outputs:
  - name: id
args:
  service_id: $global.id
```

### Заведение очереди SQS
Для получения очереди достаточно завести тикет в очереди [CONFIGSHOP](https://st.yandex-team.ru/CONFIGSHOP). Нужно указать желаемое название очереди и желаемые доступы до очереди. На первых порах можно явно пинговать @kositsyn-pa и @ozhegov.

В ответ мы пришлём 3 очереди: для dev, test и prod. Очереди будут [fifo](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) с названиями по паттерну `<queue_name>-<env>.fifo`.
Имеет место следующее соответствие:

Окружение |    Очередь интеграции    | Ответная очередь | Access Key
:---: |:---:| :---: | :---:
dev | `<queue_name>-dev.fifo`  | `configshop-dev.fifo` | configshop-test
test | `<queue_name>-test.fifo` | `configshop-test.fifo` | configshop
prod | `<queue_name>-prod.fifo` | `configshop-prod.fifo` | configshop


В шаблонном описании названием очереди является значение поля `integration` до точки (в примере balance). Env берется из апи вызовов для запуска графов.

### Протокол общения
Все сообщения передаются в JSON формате.

#### Входящее сообщение
Тело:
* `block_id: int` - внутренний идентификатор блока, нужен только чтобы сопоставить входящее сообщение с исходящим
* `task_type: string` - название настройки. Короткое название действия, которое нужно выполнить интеграции.
Совпадает cо значением после точки в поле `integration` (в примере set_service)
* `action: string` - что нужно сделать с настройкой. Валидные значения `create`, `update`, `delete`. Сейчас это поле либо `create`, либо `update`
* `params: dict` - произвольный словарь параметров, необходимых интеграции. Сюда будут переданы `args` из описания блока
* `state: dict` - словарь с состоянием, которое было возвращено интеграцией в предыдущем запуске. Поле присутствует, если `action != create`

Атрибуты:
* `JobName: string` - то же самое, что `task_type`

#### Исходящее сообщение

Тело:
* `block_id: int` - идентификатор блока из соответствующего входящего сообщения
* `state: dict` - исходящие параметры. Могут использоваться как исходящие параметры графа или входящие параметры других блоков.
* `error: struct`
  * `code: string` - буквенный короткий код ошибки.
  * `args: dict` - произвольные данные, которые связаны с ошибкой и могут помочь для отображения её на фронте.

Предлагается использовать следующие коды ошибок, хотя сейчас можно придумать что-то своё:
* `LOGIC_ERROR` - ошибка, которая вообще никогда не должна возникать. Означает баг в коде.
* `VALIDATION_ERROR` - в интеграцию переданы неверные параметры.
* `CONSISTENCY_ERROR` - ожидали какой-то инвариант для данных, но он оказался неверен. Зачастую по смыслу граничит с логической ошибкой, поскольку она, например, может быть следствием ручного вмешательства в базу данных.
* `INTERNAL_ERROR` - внутренняя ошибка, которую не получилось определить в более конкретную категорию.

Атрибуты:
* `JobName: string` - всегда `integration`

### Логика работы интеграции
Хорошее свойство, которым стоит обладать интеграции - идемпотентность. При одинаковых входах с точностью до `block_id` должны быть одинаковые выходы, и при повторной обработке состояние системы не должно меняться.

В будущем конфигуратор научится кэшировать блоки, а пока идемпотентность важна.

#### Обработка ошибок
Если ошибка временная, и ретрай может ее решить, то достаточно завершить обработку без удаления сообщения из входящей очереди.
Если же ошибка вечная, то нужно отправить исходящее сообщение, удалить входящее и завершить обработку.

### Интеграционное тестирование {#testing}

1. Завести в [configshop/tests/integration](https://a.yandex-team.ru/arc/trunk/arcadia/billing/configshop/tests/integration) директорию
   со своими тестами
2. Настроить ya.make:
   ```yamake
   # поднять sqs
   INCLUDE(${ARCADIA_ROOT}/billing/configshop/tests/recipes/start_sqs.inc)
   # создать core очереди, а так же аргументами добавить кастомные очереди для интеграции
   # замечание: создаются fifo очереди, то есть к названиям заданных очередей автоматически добавится суффикс ".fifo"
   USE_RECIPE(billing/configshop/tests/recipes/sqs_prepare/recipe integration-test)

   # поднять core сервисы configshop
   INCLUDE(${ARCADIA_ROOT}/billing/configshop/tests/recipes/start_all_services.inc)
   # поднять тестовую прокси, которая умеет по 1 запросу запустить граф и дождаться завершения
   INCLUDE(${ARCADIA_ROOT}/billing/configshop/tests/recipes/testproxy/recipe.inc)
   # добавить кастомные рецепты для тестов
   INCLUDE(${ARCADIA_ROOT}/billing/configshop/tests/recipes/testintegration/recipe.inc)
   ```
3. Использовать [апи конфигуратора](https://a.yandex-team.ru/arc/trunk/arcadia/billing/configshop/pkg/server/handlers/v1.go) (TODO: ссылка на swagger) для тестирования или подключить тестовую прокси. Endpoint для прокси нужно взять из переменной окружения `CONFIGSHOP_TEST_PROXY_URL`, запросы слать на `/`.

   Формат запроса в тестовую прокси:
   ```json
   {
       "template": "type: module\nname: global...",
       "template_name": "test_template",
       "general_inputs": {
           "input1": 134
       },
       "env_inputs": {
           "tvm": 100500
       },
       "env": "test"
   }
   ```
   Название шаблона лучше указывать разным в пределах одного запуска рецептов. При успешном завершении графа в ответ придет успешный ответ метода `HTTP GET /v1/export`

## Account Rollups
Данный запрос возвращает все обновленные роллапы для текущего окна. Само обновление этим запросом не проиходит - это делается отдельно, чтобы маленькими кусочками консистентно обновлять aggregated_sequence_id по аккаунтам.

### Аргументы
Текущее окно состоит из `last_aggregated_id` и `future_aggregated_id` (таблица `t_rollup`) и представляет собой промежуток seq_id эвентов, которые будут учтены в роллапах. В запросе передаются как аргументы $1 и $2

Для исключения проблем кросс-шардовости дополнительно эвенты фильтруются по seq_id, принадлежащим текущему шарду. Это необходимо, чтобы не обновлять `future_aggregated_id` на id из других шардов. Границы передаются как аргументы $3 и $4

### CTE events
В этой части запроса берутся все новые эвенты, т.е. больше `t_account.aggregated_sequence_pos` (хотя кажется что это лишнее условие). Далее один эвент может размножиться на несколько, если он обновляет несколько сабсчетов. Дополнительно к ним приписывается время последнего теоретически возможного роллапа до данного эвента - это нужно для следующей CTE

### CTE rollups
Теперь мы группируем эвенты по паре `(subaccount_id, dt)`. Замечу, что поля с функцией max однозначно определяются по этой паре, то есть можно было бы написать any, если синтаксис позволял бы (не включил эти колонки в group by, чтобы не усложнять сортировку)
При такой группировке мы сложили все debit и credit, а в качестве dt выступает время, описанное в конце CTE events. Благодаря такому времени мы сможем найти все предыдущие и последующие роллапы (или создать новый в будущее), а также благодаря этому есть гарантия, что разные группы при надобности создадут **разные** роллапы

### CTE rollups_with_past
Подклеиваем последний роллап к группам, чтобы понимать, какие значения должны быть у нового роллапа при необходимости создания.
Параллельно с этим с помощью оконной функции в пределах одного сабаккаунта считаем префиксные суммы групп эвентов. Понятно, что при трех группах эвентов последний роллап надо будет обновить на сумму всех трех групп, именно поэтому нужны префиксные суммы.

### CTE rollups_with_future
Теперь **для каждой** группы достаем **все** будущие роллапы с правильно посчитанными суммами. Что такое правильные суммы: если роллап новый, то нужно взять сумму последнего роллапа и посчитанного префикса. Если же роллап старый, то достаточно прибавить лишь сумму от текущей группы - далее в последней части суммы от всех групп просуммируются для одинаковых роллапов.

Как создаются новые роллапы: сначала для каждой группы подклеиваем следующую дату, в которую теоретически может быть роллап. Опять же важно подчеркнуть, что разные группы обязательно создают разные роллапы, если нужно.
Далее с помощью подзапроса подклеиваем новый или старый роллап со следующей датой, а также подклеиваем все роллапы с датой больше. Таким образом, мы всегда обновляем все следующие роллапы и создаем новый на следующую дату, если нужно. Замечу, что в данной схеме мы можем создать роллап, даже если в далеком будущем уже есть и другие.

### SELECT
Как я уже указал выше, некоторые роллапы получились с одинаковыми `(subaccount_id, dt)`, и их нужно просуммировать.
В `old_debit/old_credit` записаны предыдущие значени роллапов (0 для новых), нужно лишь добавить сумму amount по всем группам в пределах ключевой пары. Агрегация по created нужна лишь для того, чтобы на стороне приложения убедиться, что один роллап либо всегда обновляется, либо создается, но не вместе.

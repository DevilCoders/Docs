###### Принцип работы
1. Канал задач - канал в который задача поступает в пул на выполнение (через вызов Submit).
1. При создании пула запускается рутина диспатчер.
   Ее функция слушать канал задач, запускать новых воркеров, контролировать их количество и передавать им задачу на выполнение.
   Необходимость запустить нового воркера проверяется при обработке каждой поступающей задачи.
   Диспатчер не запустит больше воркеров чем указано при создании пула.

1. Каждый воркер это отдельная горутина. Все они в бесконечном цикле слушают канал воркеров.
   Когда диспатчер отправляет в этот канал задачу один из воркеров ее берет и выполняет.
   Если задач нет определенный (настраиваемый) период, то воркер-рутина завершится.
   При необходимости диспатчер запустит новых воркеров при поступлении задач.

1. Задача это функция.
   Первый параметр это контекст. Его сам воркер передаст в функцию при запуске задачи.
   В задаче необходимо обрабатывать завершение этого контекста.
   Иначе есть шанс что задача зависнет и займет воркера навечно.
   Т.к. в го нет возможности завершить горутину извне - внутри самого пула невозможно завершить уже запущенную задачу.
   Таймаут выполнения возможно контролировать только из самой реализации задачи.
   Второй параметр логгер. Его тоже пул передает в задачу сам.
   В этом логгере добавлены информативные поля с идентификаторами пула, воркера и задачи для дебага.

1. Параметры необходимые для логики задачи, а также канал для возвращения значения
   и ошибки из задачи нужно передавать в задачу через замыкание

###### Инструкция
1. Создаем pool
   ```go
   pool, err := New(context.Background(), maxWorkers, logger(t), BufferCapacity(2), PoolName("test_pool"))
   ```
   В первый параметр передается обобщающий контекст приложения. Когда он завершится - завершатся все воркеры.
Второй параметр ограничивает кол-во воркеров (задач), которые могут быть одновременно выполняться.
Третий параметр логгер - для дебажных сообщений пула.
В последний параметр можно передавать опции. Они перечислены в https://a.yandex-team.ru/arc/trunk/arcadia/billing/library/go/billingo/pkg/workerpool/options.go
   Те опции что влияют на выполнение описаны ниже. Те что только на логирование - нет.

2. Добавляем задачу в пул
   ```go
   if err := pool.Submit(func(ctx context.Context, logger log.Logger) {
       logger.Debug("Inside submitted task")
   }); err != nil {
       return err
   }
   ```
   Submit вернет ошибку если пытаемся добавить задачу в остановленный пул.
   Если кол-во воркеров меньше заданного при создании пула максимального - Submit не блокирует выполнение.
   Если все воркеры заняты - Submit заблокирует выполнение до освобождения воркера.
   Есть возможность задать буфер задач (опция ```BufferCapacity()``` при создании пула, по-умолчанию 1).
   Если буфер задан, то когда все воркеры заняты Submit не будет блокировать выполнение, пока буфер не заполнится.
   Пример: максимальное кол-во воркеров 20, буфер 10 - Submit заблокируется на 31 вызове.

1. Параметры логики задачи передаем в нее через замыкание
   ```go
   param := "ololo"
   _ = pool.Submit(func(ctx context.Context, logger log.Logger) {
       logger.Debug("User param here", log.String("parameter", param))
   })
   ```

1. Возвращаемые значения и ошибки передаем при необходимости из задачи через каналы (которые передаем в задачу через замыкание)
   ```go
   outC := make(chan int)
   errC := make(chan)
   _ = pool.Submit(func(ctx context.Context, logger log.Logger) {
       logger.Debug("Return value")
       outC <- 111
       logger.Debug("Return error")
       errC <- errors.New("Some error")
   })
   if err := <-errC; err != nil {
       return err
   }
   res := <- outC
   ```

1. Если в пул надо отправить поток задач - зовем сабмит в цикле. Одновременно будет выполняться не более maxWorkers задач.
   ```go
   for _, val := range []int{1, 2, 3, 4, 5} {
       // в цикле очень важно пересоздавать переменную для замыкания.
       input := val
       _ = pool.Submit(func(ctx context.Context, logger log.Logger) {
           logger.Debug("Inside task use input not val", log.Int("input", input))
       })
   }
   ```
   Т.к. значение переменной при замыкании берется не в момент сабмита таски а в момент ее выполнения.
   А цикл в го использует одну и ту же переменную (val).
   Засабмитились когда val = 1, выполняться таска начала когда val = 3 - в таске будет использоваться val = 3

1. После добавления всех задач, нужно вызвать pool.Stop() чтобы дождаться окончиния их выполенения
   ```go
   if err := pool.Stop(); err != nil {
       return err
   }
   ```
   Ошибка будет возвращена если выполнение оставшихся задач заняло дольше чем задано опцией ```PoolStopTimeout()```

1. Если пул должен работать до самого завершения процесса,
   то сабмитить таски надо в отдельной горутине, а для завершения звать WaitContext
   ```go
   // ctx это например основной контекст приложения который завершится по сигналу
   go func() {
       select {
       case <-ctx.Done():
           return
       default:
           if err := pool.Submit(func(ctx context.Context, logger log.Logger) {
               logger.Debug("Add another task")
           }); err != nil {

           }
       }
   }()

   pool.WaitContext(ctx)
   ```
   Когда контест отменится - пул вызовет Stop и дождется завершения всех уже переданных задач.
   Если при этом пытаться продолжать лить задачи в пул - Submit вернет ошибку.

1. Если нужно передать задачу пулу и дождаться ее выполнения надо звать ```SubmitWait```

###### Потенциальные доработки
1. Можно сделать чтобы Submit возвращал объект Task в котором уже будут пресозданы каналы для возвращаемого значения и ошибки
   ```go
   task := pool.Submit(func(ctx context.Context, logger log.Logger) (any, error)
       return "output", nil
   })
   <- task.Done()
   if err := task.Error(), err != nil {
       return err
   }
   // т.к. дженериков нет надо будет кастовать
   res := task.Result().(string)
   ```

1. Можно сделать чтобы Submit принимал и входящее значение, тогда сложнее ошибиться с замыканием.
   ```go
   pool.Submit(
       func(ctx context.Context, logger log.Logger, input any) {
           val := input.(string) // val будет "value"
       },
       "value"
   )
   ```
   При необходимости передавать несколько параметров - передавать структуру.

## Общие замечания

### Валидация по swagger-схеме

Сейчас настроено так, что все запросы валидируются по схеме, которую отдает сам вайтспирит. Схема ранее не валидировалась, поэтому при написании новых тестов могут возникать ошибки валидации. В таких случаях следует править `swagger.yaml`, который отдает WS.

## Тестирование WhiteSpirit

### Запуск тестов локально

Достаточно выполнить команду (удобнее всего прямо из idea):
```shell script
./gradlew test
```
Настройка списка касс и их параметров происходит через конфиг: `default-properties.gradle`

В общих чертах схема такая:
- с помощью docker-compose будут подняты вайтспирит и кассы,
- дождемся пока у касс взлетит api, а вайтспирит на запрос о доступных кассах выдаст все указанные в конфиге серийники,
- кассы будут через WS зарегистрированны на указанные лица (впрочем это можно отключить для каждой кассы в отдельности) и к моменту запуска тестов должны быть в состоянии `CLOSE_SHIFT`
- прогонятся тесты на этом локальном вайтспирите,
- все контейнеры остановятся.

### Запуск тестов на уже поднятом вайтспирите

Например запуск на дев-стенде:
```shell script
./gradlew test -PbuildProfile=dev
```
Соответствующие настройки будут взяты из конфига для указанного профиля (в данном случае `profile-dev.gradle`).

Схема работы примерно такая же как с локальным WS, но ничего локально не поднимается и регистрация (с текущими настройками) не происходит. А запросы идут в указанный в конфиге вайтспирит.

## Локальный запуск WhiteSpirit и виртуальных касс

### Локальный запуск с настройкой касс

```shell script
./gradlew run
```
Приложение запустит вайтспирит и кассы, дождется, пока всё взлетит, зарегистрирует кассы и напишет в консоль `Service ready. Press enter to exit...`.
На `127.42.42.100:8080` будет доступен вайтспирит. Также до вайтспирита можно будет достучаться на динамически выделенный порт на локалхосте (адрес будет написан в консоль).
По нажатии на Enter - все сервисы будут остановлены.

### Запросы к JSON API поднятых касс

К поднятым через `./gradlew run` кассам можно обращаться через JSON API, команды которого описаны в [документации](../proto_docs/starrus/Starrus_protocol.pdf) (глава 4).
Для этого нужно узнать порт, на котором поднята нужная касса. Сделать это можно поиском в консоли по подстроке `/fr/api/v2/`.
В передаваемый json помимо аргументов команды нужно добавлять поле `"Password": 30` и `"RequestId": "<uuid4>"`.

Пример:
* Linux
```shell
curl -vsX POST http://localhost:55020/fr/api/v2/GetTableField -d '{"RequestId":"'$(cat /proc/sys/kernel/random/uuid)'","Password":30,"Table":250,"Row":1,"Field":1}' | jq .
```
* MacOS X
```shell
curl -vsX POST http://localhost:55020/fr/api/v2/GetTableField -d '{"RequestId":"'$(uuidgen)'","Password":30,"Table":250,"Row":1,"Field":1}' | jq .
```

### Compose

Поднять WS и кассы можно и без джавового кода, на одном только docker-compose. Но, тогда кассы будут чистенькие (не зарегистрированные ни на какое юрлицо) и конфигурировать их придется ручками.
 
compose-файл для сборки лежит в этой директории, шаблон файлика для запуска в src/main/resources. В шаблон нужно подставить серийники касс и фискальных накопителей.
 
Запуск и остановка стандартным образом:
```shell script
docker-compose up
docker-compose down
```
Если всё прошло успешно:
- WS начнет массово строчить сообщения в консоль - будет активно искать кассы в заданной подсети.
- Swagger поднимется на `127.42.42.100:8080`. Там в частности через ручку info можно проверить что все заданные кассы WS нашел.
 

#### Запуск на Mac OS X

Работа с `docker-compose` из `testcontainers` по умолчанию происходит в специальном контейнере, для запуска которого монтируется папка из
`java.io.tmpdir`. В случае OS X это `/var/folders`, который нельзя смонтировать в докер-контейнер.

Для того чтобы обойти эту проблему, можно использовать локальный `docker-compose`,
 соответствующим образом [настроив](./src/main/java/ru/yandex/whitespirit/it_tests/whitespirit/providers/LocalServiceProvider.java)
 запускалку `docker-compose`. Сейчас это делается автоматически для запусков из-под OS X через `build.gradle`.

N.B. Также проблему можно решить, подменив tmpdir на директорию, пригодную для монтирования, например так:
`export _JAVA_OPTIONS=-Djava.io.tmpdir=/private/tmp`

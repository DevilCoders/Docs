# Назначение
tape - минималистичная локальная 'нирвана'. Позволяет строить и параллельно (но строго в рамках GIL) выполнять графы задач. В настоящую многопоточность не умеет, зато грамотно обходит большинство граблей, расставленных питоном в тредах. Умеет сохранять текущий стейт (какие задачи уже выполнились) локально или в YT, и, в случае рестарта, выполнять только то, что еще не выполнено. Накладывает на пользователя полезное ограничение - заставляет четко структурировать решаемую задачу на крупные подблоки с понятными зависимостями, не дает писать запутанный код.

# Использование

## Hello World
```
class PrintHello(tape.Task):
    def __init__(self):
        tape.Task.__init__(self)

    def __call__(self, runner):
        print("Hello )"

class PrintWorld(tape.Task):
    def __init__(self):
        tape.Task.__init__(self)

    def __call__(self, runner):
        print("World")


class PrintHelloWorld(tape.Task):
    def __init__(self):
        tape.Task.__init__(self)

    def __call__(self, runner):
        # При создании таски сначала нужно указать ее зависимости
        # (они есть всегда - вы никогда не знаете, от чего зависит родительская таска),
        # после чего засабмитить ее в запускалку (не перепутайте порядок!
        # При сабмите все зависимости должны быть обозначены, т.к. таска может сразу полететь выполняться)
        print_hello = PrintHello(
        # Это стартовая подзадача, она зависит лишь от зависимостей родителя. Если одна из тасок сбросится,
        # это повлечет перевыполнение всех задач, которые от нее зависят
        ).depends(*self.dependencies
        # Есть еще вариант зависимости по времени - запускать только после указанной зависимости, но рестарт зависимости не повлечет рестарт таски
        # .wait(...)
        # Сабмит с уникальным идентификаторов в рамках всей программы. Один uid может выполниться лишь 1 раз
        ).submit(runner, self.uid / "print_hello")

        print_world = PrintWorld(
        ).depends(print_hello
        ).submit(runner, self.uid / "print_world")

        # - Это не обязательно, при выходе таска подождет своих потомков в любом случае
        # - Еще можно подождать прямо при регистрации таска:
        #   PrintWorld().submit(runner, "print_world").wait()
        # - Еще можно подождать все подтаски при помощи self.wait_children()
        runner.wait(print_world)

runner = tape.LocalRunner(5)
task = PrintHelloWorld()
runner.run(task, "helloworld")
```

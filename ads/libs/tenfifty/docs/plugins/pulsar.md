# Pulsar

{% note warning %}

При использовании с бэкендом tape плагин полноценно работает только на Python 3. Некоторые действия работают и на Python 2, но большого смысла сами по себе не имеют. Полноценная поддержка Python 2 при использовании tape не планируется.

На бэкенде Nirvana плагин работает в том числе в сборке для Python 2.

{% endnote %}

## Демонстрация     {#demo}
В примере ``train_catboost.yaml`` есть [секция](https://a.yandex-team.ru/arcadia/ads/libs/tenfifty/bin/tool/example_tasks/train_catboost.yaml?rev=r9534519#L118), отправляющая метрики в Pulsar. Она закомментирована, чтобы пользователи не отправляли метрики непреднамеренно, запустив пример, не разобравшись в нём, но её можно раскомментировать, она работает.

## Пакеты метрик    {#metrics_package}
Чтобы отправить метрики в Pulsar, нужно сначала добавить их в специальные артефакты-пакеты метрик.

Пакеты метрик создаются действиями PackageMetrics и PackageCatboostModelMetrics, если им ничего не подаётся на вход `package`. Если же подать им на вход существующий пакет, они добавят метрики в него (но они, как и прочие действия, не изменяют входной артефакт, а создают новый).

## Действие PackageMetrics (`package_metrics`)      {#package_metrics}
Добавляет в пакет метрики с определёнными аннотациями, поддерживаемые Pulsar. Пакет может содержать любое количество метрик.

**input:**
    * `package` (необязательный): существующий пакет, в который нужно добавить метрики. Если не задан, создаётся новый пакет.
    * `metrics` (необязательный): MLMetrics из [плагина metrics](metrics.md), либо список таких артефактов — добавляемые метрики.

Хотя бы один вход должен быть задан.

**output:** новый созданный пакет метрик

**parameters:**
    * `processors` (список словарей) — обработчики метрик (см. ниже)

### Обработчики метрик      {#metrics_processors}
Чтобы определить, какие метрики добавлять в пакет и как, действие прогоняет каждую метрику через список обработчиков метрик. Каждый обработчик задаётся так:

* `resulting_metric_name` (строка, обязательный): желаемое название метрики в Pulsar.
* `resulting_slice_name` (строка, по умолчанию `"$slice$"`): желаемое название выборки в Pulsar.
* `resulting_total_slice_name` (строка, необязательный): желаемое название выборки в Pulsar, когда метрика посчитана по всему датасету. Если отсутствует, применяется `resulting_slice_name` (`$slice$` заменяется на `_all_`).
* `tags` (список строк, необязательный): теги, которыми помечаются метрики.
* `filter:` (необязательная секция): определяет, какие метрики принимает обработчик. Если отсутствует, то принимаются все метрики.
  * `slice_requirements` (словарь, см. ниже): определяет выборки, метрики по которым принимает обработчик, см. ниже. Если отсутствует, принимаются все выборки.
  * `include_total_slice` (true/false, необязательный): определяет, включать ли метрики, посчитанные по всему датасету. Если присутствует `slice_requirements`, то по умолчанию `false`; если `slice_requirements` отсутствует, по умолчанию true.
  * `include_metrics` (список строк, необязательный): названия метрик, которые принимает обработчик. (например, `"rmse"`). Если отсутствует, принимаются все.
  * `include_artifacts` (список строк, необязательный): названия входных артефактов, метрики по которым принимает обработчик.

`slice_requirements` — это список «название колонки → список значений». Выборка в `eval_metrics` определяется комбинацией колонок: каждая комбинация значений этих колонок составляет отдельную выборку. Если указаны `slice_requirements`, принимаются только такие метрики, где в каждой колонке, упомянутой в `slice_requirements`, стоит одно из значений из соответствующего списка.

Действие проверяет каждую метрику (т.е. комбинацию имени артефакта, имени метрики и выборки) на соответствие секции `filter` в каждом обработчике в списке, по очереди. Первый обработчик, который она проходит (или у которого отсутствует `filter`), добавляет её в пакет — остальные обработчики не задействуются. Если ни один обработчик не принял метрику, она не добавляется.

В параметрах `resulting_metric_name`, `resulting_slice_name` и `resulting_total_slice_name` допускаются следующие **подстановки**:

* `$artifact$` — название входного артефакта, из которого взята метрика.
* `$slice$` — автоматически формируемое название выборки вида `имя_колонки_1=значение_колонки_1,имя_колонки_2=значение_колонки_2` и т.д.
* `$bool_slice_name$` — как `$slice$`, только если значение колонки `1` или `True`, то оно отсутствует (остаётся только имя), а если оно равно `0` или `False`, получается `¬название_колонки`. В остальных случах получается то же, что в `$slice$`. Эту подстановку удобно использовать, если каждая выборка определяется одной (или несколькими) булевыми колонками.
* `$bool_slice_name:-название_колонки,-ещё_одно` — как `$bool_slice_name`, только указанные с минусом названия колонок вообще исключаются из подстановки. Если исключились вообще все названия колонок, происходит исключение.
* `$$`: один знак доллара.

## Действие PackageCatboostModelMetrics (`package_catboost_model_metrics`)      {#package_catboost_model_metrics}

{% note warning %}

Пока что не реализовано на бэкенде Nirvana. Работает только на бэкенде tape.

{% endnote %}

Добавляет в пакет метрики, полученные во время обучения модели CatBoost. На данный момент можно использовать только для добавления кривой обучения.

**input:**
    * `package` (необязательный): существующий пакет, в который нужно добавить метрики. Если не задан, создаётся новый пакет.
    * `models` (обязательный): Model (Catboost), например, из [TrainCatboostModel](catboost.md#train_catboost_model) или список таких моделей.

**output:** новый созданный пакет метрик

**parameters:**
    * `training_log_processors` (список словарей) — обработчики метрик протокола обучения (см. ниже)

### training_log_processors     {#training_log_processors}
Метрикой считается комбинация из названия входного артефакта, названия метрики (например, `"Logloss"`), набора данных (`set`, обычно `"learn"` и `"test"`), факта отношения выборки к учебным или валидационным данным (может отличаться от сета). В Pulsar метрика отправляется в виде списка значений ``[(номер итерации, значение метрики)]`` с типом `Plot`.

Общий принцип работы обработчиков метрик тот же, что у [обработчиков](#metrics_processors) в PackageMetrics, но с другими параметрами.

* `resulting_metric_name` (строка, обязательный): название метрики в Pulsar.
* `resulting_slice_name` (строка, по умолчанию `"$set$"`): название выборки для метрики в Pulsar.
* `filter`:
    * `include_learn` (булево значение, необязательный): включать ли метрики на тренировочных данных.
    * `include_test` (булево значение, необязательный): включать ли метрики на валидационных данных.
        * Если и `include_learn`, и `include_test` отсутствуют, оба считаются `True`, иначе один отсутствующий считается `False`.
    * `include_metrics` (список строк, необязательный): какие метрики принимает обработчик. Если отсутствует, то все.
    * `include_sets` (список строк, необязательный): какие наборы данных принимает обработчик. Если отсутствует, то все.
    * `include_artifacts` (список строк, необязательный): имена входных моделей, которые принимает обработчик. Если отсутствует, то все.

Действие проверяет каждую метрику по фильтрам каждого обработчика, идя по списку, и останавливается на первом подходящем, как и [в PackageMetrics](#metrics_processor).

В параметрах `resulting_metric_name` и `resulting_slice_name` допускаются следующие **подстановки**:

* `$artifact$` — название входного артефакта.
* `$metric$` — название метрики.
* `$set$` — название набора данных.
* `$learn_or_test$` — раскрывается в `learn` если это тренировочные данные, `test` если валидационные.
* `$$` — знак доллара.

## Действие SendMetricsToPulsar     {#send_metrics_to_pulsar}

{% note warning %}

На бэкенде tape это действие работает только на Python 3.

{% endnote %}

Отправляет пакет метрик в Pulsar, создавая там новый «инстанс» (описание одного запуска одной модели на одном датасете).

**input:** пакет метрик.

**output:** отсутствует. Ссылка на инстанс пока что просто печатается в консоль.

**parameters:**

* `model_name` (строка, обязательный): название модели, состоящее из латинских букв, цифр и символов подчёркивания. Оно может быть любым, но обязательно должно быть.
* `dataset_name` (строка, обязательный): строка того же формата, название датасета.
* `instance_name` (строка, необязательный): строка того же формата, название инстанса. Если отсутствует, то у инстанса в Pulsar не будет названия (что не страшно, потому что главный идентификатор инстанса — GUID).
* `instance_description` (строка, необязательный): описание инстанса. Произвольный текст, может отсутствовать.
  * Ни один из указанных выше параметров не обязан быть уникальным. В Pulsar могут существовать инстансы с одинаковыми именами, одинаковыми именами моделей или датасетов и пр.
* `dashboard_id` (строка, необязательный): ID дашборда в [Datalens](https://datalens.yandex-team.ru/), который нужно привязать к инстансу. Если присутствует, дашборд будет показываться на странице инстанса в Pulsar.

Все эти параметры инстанса потом можно изменить вручную через API Pulsar или через веб-интерфейс.

## Как сделать дашборд для отображения метрик       {#dashboard_how_to}
Сервис Pulsar интегрирован с сервисом Datalens и позволяет создавать дашборды для отображения метрик.

О том, как создавать дашборды в целом, можно почитать в [документации Datalens](https://datalens.yandex-team.ru/docs/). Скорее всего, потребуются начальные знания Javascript.

Посмотреть на инстанс с дашбордом, созданный из tenfifty, можно тут:

* [Инстанс в Pulsar](https://pulsar.yandex-team.ru/instances/976d0a65-d343-4990-9f7e-dc25d4b558ba)
* [Сам дашборд](https://datalens.yandex-team.ru/doaiwtpsv5xy5-obuchenie-c-ml-na-tenfifty?id=976d0a65-d343-4990-9f7e-dc25d4b558ba). Параметр `id` в ссылке можно заменить на ID другого инстанса той же структуры.
* [Папка со всеми компонентами дашборда](https://datalens.yandex-team.ru/navigation/p0lvan5hw0tyh-tenfifty-c-ml). Код компонент снабжён подробными комментариями.

Если вы раньше не пользовались Datalens, обратите внимание, что код каждого «чарта» (компонента дашборда) разделён на несколько вкладок, и вам следует просмотреть их все. Кроме того, вы можете подставить параметр `id` в адресную строку при просмотре кода чарта, чтобы иметь возможность сразу же выполнить чарт на данных.

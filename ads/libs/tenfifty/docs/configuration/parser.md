# Создание графов через YAML

Основной способ создания графа &ndash; через YAML-конфиги.

Все описание графа, как и в Python API, сводится к описанию действий, а также проставлению связей между ними.

Рассмотрим, например, как мог бы выглядеть конфиг с "Hello, World!":

```yaml
graph:
    # s = create_string(value="Hello, world!")
    # или же просто: s = "Hello, world!"
    create_s:
      action: create_string
      output: s
      parameters:
        value: "Hello, world!"

    # print(s)
    print_s:
      action: print
      depends: create_s
      # можно и так
      # depends:
      #     - create_s
      input: s
```

Итак, в корне конфига должно лежать поле `graph`, в котором и будут перечисляться все действия данного графа.

Для создания действия мы должны указать:
- его имя в графе (`create_s` и `print_s` в примере выше). Имя должно быть уникальным в данном графе. С помощью данного имени далее можно строить зависимости между действиями;
- имя операции, которую мы хотим вызвать (`create_string` и `print` в примере). По сути является id-шником операции. Указывается в поле `action` в секции данного действия.

Также действие может:
- порождать артефакты. Выходы указываются в поле `output`. В данном поле мы определяем, артефакты с какими именами появятся в графе. Далее порожденные артефакты можно будет использовать в качестве входных в других действиях. Важно, что имена выходных артефактов не обязаны быть уникальными в графе, то есть два разных действия могут породить артефакты с одинаковыми именами;
- принимать артефакты на вход. Входные артефакты (а точнее их имена в графе) перечисляются в поле `input`. Так как имена артефактов в графе неуникальны, то для правильного сопоставления артефакта его имени необходимо также проставить зависимости между действиями;
- зависеть от других действий. Есть два типа зависимостей: `do_before` и `do_after`/`depends`. Зависимости гарантируют, что данное действие будет выполняться до или после указанных действий, и, таким образом, их выполнение нельзя будет распараллелить. Данные зависимости определяют, какое множество артефактов мы "видим" при выполнении данного действия, или же, проще говоря, какие артефакты мы можем подать на вход;
- принимать параметры. Перечисляются в поле `parameters`. Являются свойством операции. Так, в примере выше у операции `create_string` есть параметр `value`, который определяет, чем мы проинициализируем нашу переменную. Когда tenfifty разбирает YAML, все словари (mappings) преобразуются в питоновские OrderedDict с сохранением порядка ключей, и в параметрах некоторых действий порядок ключей важен.

{% note info %}

Необязательно проставлять прямые зависимости между действиями, обменивающимися артефактами. Достаточно лишь, чтобы между ними существовала цепочка зависимостей.

{% endnote %}

{% note warning %}

Если во входах действия указано имя, которое генерируется в двух различных цепочках зависимостей, то граф построить не удастся.

{% endnote %}

### Входы и выходы      {#inputs_and_outputs}
Входы (и выходы) вызываемой операции могут быть именованными и неименованными, и в зависимости от этого входные (и выходные) артефакты перечисляются одним из трех способов:
* ```yaml
  input: art  # output: ...
  ```
* ```yaml
  input:  # output: ...
    - art1
    - art2
    - art3
  ```
* ```yaml
  input:  # output: ...
    model: model_art
    datasets:
      - dataset1
      - dataset2
  ```

В третьем примере операция имеет два именованных входа: `model` и `datasets`. Важно, что эти имена являются свойством операции. `model_art`, `dataset1` и `dataset2` здесь &ndash; имена артефактов в графе, которые были порождены ранее.

## Параметризация, секции data и exec   {#parametrization}
Есть возможность вынести параметры действий из графа в отдельную секцию ``data``. Вот пример такого конфига:

```yaml
graph:
  get_log:
    action: get_log
    output: log
    parameters:
      path: //home/ads/tenfifty/examples/logs/log1/1d
      start_date: !eval data.start_date
      end_date: !eval data.end_date
      unit: 1d
  get_log2:
    action: get_log
    output: log2
    parameters:
      path: //home/ads/tenfifty/examples/logs/log2/1d
      start_date: !eval data.start_date
      end_date: !eval data.end_date
      unit: 1d
  join_logs:
    action: do_join
    depends:
      - get_log
      - get_log2
    input:
      left: log
      right: log2
    output: joined_log
    parameters:
      keys:
        - key
    # Дальше какие-то действия с объединённым логом
data:
  start_date: 2021-10-10
  end_date: 2021-10-12    # exclusive
```
В секции ``data`` могут быть любые данные, она превращается в объект, похожий на словарь (только к ключам можно обращаться как используя квадратные скобки, так и как к атрибутам, через точку). Секцию ``data`` можно использоваться в выражениях ``!eval``.

Выражения ``!eval`` могут быть любыми вычисляемыми выражениями Python. Они должны возвращать тот тип данных, который ожидается от соответствующего параметра. Выражения ``!eval`` могут использоваться только в поле ``parameters``, но не в полях ``action``, ``input``, ``output`` и других.

Вычисление выражений ``!eval`` на данный момент происходит во время создания графов действий из конфигураций. В будущем могут появиться действия, которые вычисляют ``!eval`` во время работы.

Некоторую трудность может вызвать то, что даты в tenfifty на данный момент должны быть строками: из-за этого трудно написать выражение типа «такая-то дата плюс три дня». Возможно, это будет в скором времени пересмотрено. Пока этого не сделано, можно либо задавать нужные даты вручную, либо вычислять их в [секции exec](#exec).

Утилита ``tenfifty_tool`` позволяет добавлять или заменять данные в секции ``data`` при помощи ключа ``--data`` или ``-D``. Допустимы в том числе выражения типа ``-D key.subkey.subsubkey value``. Ключи должны быть идентификаторами Python. И ключи и значения воспринимаются как строки, подстановки делаются до выполнения [секции exec](#exec).

Возможностью подставлять данные через командную строку рекомендуется пользоваться только при необходимости (например, в регулярном обучении).

### Секция exec     {#exec}
Для более сложных случаев параметризации можно использовать секцию ``exec``. В ней можно исполнить любой код на Python и изменить секцию data.

Например:

```yaml
data:
  start_date: 2021-10-10
exec: |-
    from datetime import datetime, timedelta
    TIME_FORMAT = "%Y-%m-%d"

    def advance_date(from_date, **timedelta_kwargs):
        return (datetime.strptime(from_date, TIME_FORMAT) + timedelta(**timedelta_kwargs)).strftime("%Y-%m-%d")

    # И тут мы устанавливаем data.end_date, предыдущая секция graph работает без изменений
    data.end_date = advance_date(data.start_date, days=2)
```

Имена, определённые в секции ``exec`` (в т.ч. импортированные), будут доступны в выражениях eval, поэтому можно написать и так:

```yaml
graph:
  get_log:
    parameters:
      end_date: !eval advance_date(data.start_date, days=2)
```

Однако **данные** (в отличие от функций или модулей) **лучше сохранять в data, а не в отдельные переменные**.

# Python API

## Создание собственного исполняемого файла
Если не хватает возможностей бинарника [tenfifty_tool](../quickstart.md), то можно собрать свой бинарник с помощью модулей `Parser` и `entry`.

Самый простой скрипт для этого будет выглядеть так:

```python
import sys
import ads.libs.tenfifty as ml
# Далее импортируйте все нужные плагины

assert len(sys.argv) >= 3   # Название программы, название файла конфигурации, название бэкенда, затем опции

# Порядок следующих двух строк важен!
backend, services = ml.entry.init_backend(sys.argv[2:])
graph = ml.Parser.parse(sys.argv[1])

backend.run(graph, services)
```

`ml.entry.init_backend` принимает список из названия бэкэнда и опций к нему. Чтобы получить справку по бэкэндам и их опциям, вызовите `ml.entry.format_help()`.

При необходимости граф действий можно также собрать программно (см. ниже), а не считывать из файла.

{% note warning %}

Перед тем, как создавать граф действий (с помощью `ml.Parser.parse(...)` или иными способами), надо задать используемый бэкенд. Это делается автоматически при создании объекта бэкенда (в т.ч. с помощью `ml.entry.init_backend`), последний созданный бэкенд задаётся в качестве используемого. Также задать бэкенд можно вручную вызовом функции `ml.set_backend(backend)`.

{% endnote %}


## Программное создание графа действий
{% note alert %}

На данный момент API для создания графов действий нельзя считать стабильным, и он в принципе не предназначен для постоянного использования. Предпочитаемый способ использования tenfifty — собрать исполняемый файл и натравить на [файлы конфигурации](parser.md). Программное создание графов задач рассматривается как промежуточная стадия миграции с других оркестраторов пайплайнов: предполагается, что в них будут встраивать функцию создания графов tenfifty, потом графы будут дампить в файлы конфигурации, а потом постепенно перейдут на использование только tenfifty.

{% endnote %}

{% note warning %}

Действует предупреждение из предыдущего раздела: перед тем, как создавать граф действий, надо задать используемый бэкэнд. Это делается автоматически при создании объекта бэкэнда (в т.ч. с помощью `ml.entry.init_backend`), последний созданный бэкэнд задаётся в качестве используемого. Также задать бэкэнд можно вручную вызовом функции `ml.set_backend(backend)`.

Заданный бэкенд определяет, какие объекты на самом деле будут создаваться при вызове конструктора Action (будут создаваться реализации действий для конкретного бэкенда).

Возможно, такое поведение в будущем будет пересмотрено.

{% endnote %}

Для создания графа действий конструируется объект `ml.MLGraph`:

```python
graph = ml.MLGraph()
```

Далее создаются объекты для нужных действий, наследники `ml.Action` или `ml.CompositeAction`.

Конструкторы простых действий (Actions) имеют следующий вид:

```python
def __init__(self,
                 inputs,            # type: tp.Dict[str, tp.Union[Artifact, tp.List[Artifact]]]
                 output_names,      # type: tp.Dict[str, tp.Union[str, tp.List[str]]]
                 name=None,         # type: str
                 parameters=None    # type: tp.Dict[str, tp.Any]
                 ):
    ...
```

`inputs` — словарь вида «название входа → входной артефакт или список артефактов». Названия входов зависят от действия (они такие же, как в файлах конфигурации), а артефакты — это объекты, соответствующие выводам, их нужно брать из предыдущих действий. Первыми действиями в цепочках должны быть те, у которых нет входов, например, `ads.libs.tenfifty.plugins.yt.GetDatasetFromYt` или `ads.libs.tenfifty.plugins.yt.GetLog`.

Как правило, если у действия один вход, то он использует имя по умолчанию — в таком случае для создания списка можно использовать функцию `ml.create_single_input` (например: `ml.create_single_input(some_dataset)`). Список артефактов является единым входом, поэтому, например `ads.libs.tenfifty.plugins.catboost.PrepareCatboostPool` имеет один вход и выход.

`output_names` — словарь вида «название выхода → название выходного артефакта или список названий выходных артефактов». Названия выходов зависят от действия (они такие же, как в файлах конфигурации), а названия выходных артефактов произвольные. Каждому выходному артефакту должно быть присвоено своё имя, не совпадающее с именами других выходных артефактов того же действия (но при этом может совпадать с именами входных артефактов).

`name` — название действия. Оно произвольное, но должно быть уникальным в объекте MLGraph, однако имена действий в графе и имена действий в подграфах внутри композитных действий могут совпадать.

`parameters` — словарь параметров. Их имена и допустимые значения зависят от действия, они такие же, как в файлах конфигурации.

{% note info %}

С определённого момента при обработке конфигурации вместо обычных словарей (dict) стали создаваться OrderedDict (это класс-наследник dict), и некоторые действия учитывают порядок ключей в своих параметрах.

При создании собственных действий не следует полагаться на порядок ключей в `inputs`, `output_names` и `parameters`, но вполне допустимо регламентировать использование `OrderedDict` в каких-либо значениях внутри `parameters`.

{% endnote %}

Созданное действия нужно добавить в граф с помощью `graph.add_node(action)`

После создания действия можно получить его выходные артефакты вызовом `action.get_output()` (для выхода по умолчанию) или `action.get_output(name)` (для именованных выходов) и использовать эти выходные артефакты в качестве входов для следующих действий, определяя таким образом поток данных.

В директории [`bin/example_programs`](https://a.yandex-team.ru/arc/trunk/arcadia/ads/libs/tenfifty/bin/example_programs) есть примеры программ, создающих графы действий через API. Начать знакомиться можно с [примера обучения CatBoost](https://a.yandex-team.ru/arc/trunk/arcadia/ads/libs/tenfifty/bin/example_programs/train_catboost).

{% note warning %}

Действия, между которыми нет зависимости по входным/выходным артефактам, могут запускаться параллельно. Если одно из таких действий по какой-либо причине надо обязательно запустить после другого, вызовите `graph.add_action_edge(first, second)`.

{% endnote %}


## Композитные действия
[Композитные действия](../composite_actions/overview.md) на данный момент бывают двух типов:

1. Имеющие такое же API, что обычные Actions (например, [`plugins.yt.GetLog`](../plugins/yt.md#g_log)).
2. Имеющие особое API, которое пока не предназначено для программного использования: [RunIterativeTask](../composite_actions/iterative_train.md) и [RunSequentialTask](../composite_actions/sequential_train.md)). Их, однако, можно использовать в конфигах. Также можно написать собственное действие и использовать его в конфиге внутри этих композитных (см. [`bin/example_programs/fibonacci`](https://a.yandex-team.ru/arc/trunk/arcadia/ads/libs/tenfifty/bin/example_programs/train_catboost)).

Имеются также декораторы, «превращающие» обычные действия в композитные (например, `ForEach`). На данный момент такие композитные действия будут иметь то же API, что оригинальные (т.е. обычные Actions).

## Собственные действия
Порядок создания собственных действий описан в [обзоре плагинов](../plugins/overview.md).

Примеры программ (не являющихся «полноценными» плагинами), с собственными действиями:

* [bin/example_programs/custom_executable](https://a.yandex-team.ru/arc/trunk/arcadia/ads/libs/tenfifty/bin/example_programs/custom_executable`) — простой пример собственного бинарника.
* [bin/example_programs/fibonacci](https://a.yandex-team.ru/arc/trunk/arcadia/ads/libs/tenfifty/bin/example_programs/fibonacci) — пример с использованием [RunIterativeTask](../composite_actions/iterative_train.md).

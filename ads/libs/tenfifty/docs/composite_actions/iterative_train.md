# Итеративное обучение

Представлено композитным действием `RunIterativeTask` (`iterative_task`).

Позволяет обернуть определенный набор действий в цикл, или же, иначе говоря, выполнить повторяющийся набор действий определенное число раз.

Параметризуется множеством входов, выходов, количеством итераций, а также "задачей" &ndash; графом, описывающим набор действий, вызываемых на каждой итерации.

{% note info %}

Все, описанное ниже, будет больше относиться к описанию "цикла" в yaml-конфиге, однако конечно же его можно создать и через python api.

{% endnote %}

### Считаем числа Фибоначчи

Приведем отрывок программы, считающей 11-е число Фибоначчи (представим, что у нас определены операции суммы `calc_sum` и копирования `copy` значения числа, а также уже проинициализированы переменные `a` и `b`):

```yaml
graph:
    # initialization of variables "a" and "b"
    # for example, a = 0, b = 1
    ...


    # main loop
    loop:
        action: iterative_task
        input:
            - a
            - b
        output:
            - a
            - b
        parameters:
            iterations: 10
            task:
                graph:
                    # c = a + b
                    calc_sum:
                        action: calc_sum
                        input:
                            - a
                            - b
                        output: c
                    # a = b
                    update_a:
                        action: copy
                        depends: calc_sum
                        input: b
                        output: a
                    # b = c
                    update_b:
                        action: copy
                        depends: update_a
                        input: c
                        output: b

    # we can access both "a" and "b" here
    ...
```

{% note info %}

Данный пример можно найти в [аркадии](https://a.yandex-team.ru/arc_vcs/ads/libs/tenfifty/bin/example_programs/fibonacci). Для его запуска необходимо выполнить команду `./fibonacci_example example_task.yaml`.

{% endnote %}

Итак, у действия на самом деле два параметра:
* `iterations` &ndash; собственно число итераций, которое необходимо проделать;
* `task` &ndash; описание графа, которое подчиняется тем же требованиям, что и описание основного, внешнего графа.

Действие в конфиге можно вызвать по имени `iterative_task`.

Входы и выходы могут иметь произвольные типы; их может быть сколько угодно, а может и не быть вовсе. Перечисляются списком, порядок не важен.

На первую итерацию цикла придут те версии артефактов, что были определены извне, но далее они будут перезаписываться. Важно, что связка различных итераций цикла происходит по именам артефактов, поэтому в конце каждой итерации вероятно придется копировать содержимое посредством `copy`.


### Свойства и требования
Некоторые свойства "цикла":
* В начале каждой итерации будут видны лишь те артефакты, которые были поданы на вход.
* Множество входов может быть больше множества выходов. Все артефакты, имена которых указаны в качестве входов, но не указаны в качестве выходов, не будут меняться по итерациям (точнее, длительность жизни измененных версий будет ограничена лишь данной итерацией, на следующую итерацию измененная версия не попадет).
* Множество выходов может быть больше множества входов. При этом артефакты, которые передаются на выход, но не подаются на вход, по сути будут доступны лишь тогда, когда мы выйдем из цикла.
* Все артефакты, указанные в качестве выходных, должны присутствовать в единственном экземпляре по окончании итерации. Таким образом в графе не должно существовать двух параллельных ветвей, в которых определяются артефакты с одним и тем же выходным именем.

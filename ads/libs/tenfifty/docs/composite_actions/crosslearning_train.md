# Обучение c CrossLearning

Представлено композитным действием `RunCrossLearningTask` (`crosslearning_task`).

В некоторых конфигурациях стекинга становится возможной неявная передача целевого значения с нижележащего уровня на более высокие посредством предсказаний низкоуровневых моделей (aka "утечка таргета").
В таком случае высокоуровневые модели склонны к переобучению на предсказаниях нижестоящих моделей.

Для решения этой проблемы предназначен CrossLearning.
Этот подход позволяет обучать модель низкого уровня только на части данных.
На оставшейся же части данных эта модель осуществляет предсказание, которое в свою очередь передается моделям высокого уровня для их обучения.

Идея разбиения датасета и обучения моделей аналогична k-folds кросс-валидации:
* обучающая выборка разбивается на k непересекающихся одинаковых по объему частей (fold);
* производится обучение k моделей низкого уровня на k−1 части обучающей выборки, а тестирование осуществляется на исключенном фолде.

Покрытие всего датасета предсказаниями осуществляется тем, что каждый фолд является тестовым для одной из моделей.

## Параметры

Композитное действие выполняет параллельный запуск задач из `parameters->task->graph`, для каждой из которых предопределены следующие артефакты:
* `context.train` - обучающая выборка сформированная из k-1 фолда;
* `context.to_apply` - тестовый фолд.

Выходные артефакты композитного действия определяются перечислением названий выходных артефактов внутренней задачи.
Например, если метрики и предсказания во внутренней задаче помещались в артефакты с именами `cl_metrics` и `cl_datasets` соответственно,
то, определив выходные артефакты композитного действия с теми же именами, можно получить списки метрик в артефакте `cl_metrics` и список фолдов с предсказаниями в артефакте `cl_datasets`.

На данный момент композитное действие поддерживает два способа разбиения на фолды:
* ручное, когда пользователь передает на вход композитному действию список артефактов;
* автоматическое, когда входной артефакт разбивается на переданное в параметре `folds_count` количество фолдов (см. детали ниже).

{% note info %}

В случае передачи композитному действию лога следует иметь в виду, что каждая таблица будет воспринята как отдельный фолд.
Для избежания подобного нужно упаковать лог действием `merge_tables` перед использованием в композитном действии.

{% endnote %}

### Автоматическое разбиение на фолды

Если на вход композитному действию передан единичный артефакт, ожидается, что пользователь определит в параметре `folds_count` требуемое количество фолдов для автоматического разбиения.

Разделение данных осуществляется равномерно с использованием колонки идентификатора строки, которую можно определить в параметре `id_column`.
Значение по умолчанию для этого параметра: "__id".
Ожидается, что эта колонка содержит целочисленные значения, а деление будет осуществляться по правилу:

    __id % $folds_count == fold_id
здесь `fold_id` - внутренний идентификатор фолда.

Пользователь может повлиять на разбиение, заполняя эту колонку идентифкатора строки.

В случае возникновения потребности в ином способе разбиения просьба сообщить, воспользовавшись [контактами](../contacts.md).

## Пример

{% include notitle [crosslearning_task](../_includes/demonstration/crosslearning_task.md) %}

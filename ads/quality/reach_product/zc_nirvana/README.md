# Считалка zC для охватного продукта

Инструмент для вычисления zC в экспериментах с охватной рекламой.
Строит граф в нирване по заданному конфигу, формирует отчёт для тикетов, после завершения расчётов отчёт приходит на почту и/или дампится в тикет.

Чем это поколение лучше [предыдущего](../zc_calculator_v2)?
 - В отличие от набор связанных друг с другом тасок в `Sandbox` тут используется наглядный граф в Нирване. Проще понять, что пошло не так, проще отслеживать квоту, проще подхачить параметры на ходу;
 - Вместо кучи кастомного кода здесь переиспользуется множество операций из общей библиотеки - следовательно, всё работает стабильнее;
 - Непрозрачная схема грепа событий и вычисления `action`'ов заменена на простые и понятные `yql`'и;
 - Новая фича: считаем `zC` по дням и по срезам, без написания новых конфигов и прочих лишних движений;
 - Новая фича: получаем результат на почту или в тикет в виде таблицы.

Переход на `yql` для подготовки таблиц помимо наглядности ещё и значительно расширяет арсенал методов построения событий и срезов.
Собственно `zc` под капотом считается с помощью всё-того же [apc_check](../../apc_check), есть экспериментальный режим для расчётов прямо на `YT` (пока неверифицированный).

Как пользоваться: собираем [бинарник](bin), пишем конфиг, запускаем командой `./zc --config-yaml conf.yaml`.

## Аргументы

Схему аргументов можно подсмотреть в [протобуфе](lib/args/conf.proto).
Большинство опций имеют разумные дефолты, но всё, что хочется - можно переопределить.
Аргументы можно как писать в конфиг, так и в командную строку (приоритетнее, удобно для бинарных флагов).

Примеры конфигов - рядом с [бинарником](bin).

Все опции сгруппированы в 4 группы.

### `experiment_settings`

Группа параметров для определения принадлежности хитов к экспериментам.

+ `field [str]` - поле, по которому попадание хита в выборки. По умолчанию `ActivetestIds`;
+ `full_traffic_zc [bool]` - флаг использования всего трафика. Если активен - то каждая выборка из эксперимента сравнивается с дефолтом (т.е. все хиты, не попавшие ни в одну выборку), в противном случае все выборки (кроме контрольной) сравниваются с контрольной;
+ `exp_data` - метапараметр с двумя возможными схемами:
  + `ab_ticket` - структура с данными о тикете, из которого следует взять информацию об эксперименте. Из тикета берутся все выборки, первый из них считается контрольным. Параметры:
    + `ticket [str]` - идентификатор тикета (**обязательный**);
    + `control_test_id [int]` - переопределение контрольной выборки;
    + `no_control [bool]` - флаг (по умолчанию `False`); если активен - то считаем, что контрольной выборки нет. Имеет смысл только в случае `full_traffic_zc == True`;
    + `ignore_test_ids [[int]]` - список выборок, которые следует проигнорировать (контроль игнорировать нельзя!). Полезно, например, для того, чтобы убрать уже отключенные выборки и не тратить на них попусту ресурсы.
  + `explicit_test_ids` - структура с явной информацией о выборках:
    + `test_ids [[int]]` - список идентификаторов выборок (**обязательный**);
    + `control_test_id [int]` - контрольная выборка (**обязательна** при вычислении `zc` по всему трафику).

Предпочтительнее использовать `full_traffic_zc` и задавать тикет вместо явного перечисления выборок.

### `events_grep_settings`

Группа параметров для отбора только интересующих нас хитов и определения разрезов.

+ `actions_data` - метапараметр с данным по целевым действиям; список из структур:
  + `action_name [str]` - название целевого действия (по умолчанию будет названо `ActionXXX`, поэтому лучше придумать что-то своё);
  + `expression [str]` - выражение для вычисления действия, будет подставлено `as-is` в `yql`-скрипт (**обязательно**);
+ `weight_expression [str]` - выражение для вычисления веса хита, будет подставлено `as-is` в `yql`-скрипт (по умолчанию все хиты имеют вес `1`);
+ `bid_expression [str]` - выражение для вычисления итоговой ставки, будет подставлено `as-is` в `yql`-скрипт (по умолчанию просто `RealCost`);
+ `billed_expression [str]` - выражение для вычисления снятых с рекламодателя денег, будет подставлено `as-is` в `yql`-скрипт (по умолчанию просто `EventCost`);
+ `gid_expression [str]` - выражение для вычисления идентификатора группы, будет подставлено `as-is` в `yql`-скрипт, должно возращать `uint64` (по умолчанию - `OrderID`);
+ `condition_expression [str]` - выражение для отбора хита, будет подставлено `as-is` в `yql`-скрипт, должно возвращать `True/False` (можно оставить пустым, тогда будет считаться тривиальным `True`);
+ `tables_data` - метапараметр с данными по источникам хитов на `YT`; список, каждый элемент которого - это одна из структур:
  + `single_table [str]` - полный путь к таблице (**обязательный**);
  + `log_data` - данные про регулярные логи:
    + `log_dir [str]` - путь к директории с логами (**обязательный**);
    + `datetime_format [str]` - формат времени в именах таблиц; если не задан - то программа попытается распрарсить его из пути директории;
    + `step [int]` - интервал времени между двумя соседними таблицами в секундах; если не задан - то программа попытается распрарсить его из пути директории;
    + `datetimes [[str]]` - список (**непустой**) из строк, каждая из которых соответствует интервалу времени в формате `datetime_format`. Может быть в виде одной временной точки (напр. `2022-04-08T13:00:00`), или в виде промежутка (`2022-04-06 .. 2022-04-12`). Для промежутков правая граница продлевается на `step` от заданной (т.е. в промежутке из примера будут взяты логи, начиная с `2022-04-06` и заканчивая, но не включая `2022-04-13`);
+ `slice_data` - метапараметр с данными для определения разрезов (подробнее про разрезы ниже), список из структур с полями:
  + `slice_name [str]` - название разреза (**обязательно**);
  + `slice_expression [str]` - выражение для вычисления значения разреза, будет подставлено `as-is` в `yql`-скрипт (**обязательно**);
  + `values [[str]]` - список (**непустой**) значений разреза, на которых следует вычислить `zc`;
+ `premap_declarations [str]` - дополнительные декларации в `yql`-скрипте, будет вставлена `as-is`. В ней можно определять функции, константы и прочее, что используется в других выражениях.
+ `sampling_percentage_default` и `sampling_percentage_exps` - настройки семплирования хитов из дефолта и экспериментальных выборок. Крайне рекомендуется на длинных временных интервалах, иначе результата можно и не дождаться.

По этим параметрам будет составлен `yql`-скрипт, который будет применён к объединению всех таблиц из `tables_data`.

##### Про разрезы

Разрез - это множество хитов (подмножество всех хитов, которые удовлетворяют `condition_expression`), объединённых одинаковым значением заданного набора других выражений.
Каждый разрез характеризуется ключами и значениями.
К примеру, в разрез `[FA = 'a', FB = 'b']` попадут все хиты, у которых значение поля `FA` равно `'a'`, а значение поля `FB` равно `'b'`.

**ВАЖНО**: в конфиге задаётся набор отдельных ключей разрезов, а множество всех разрезов строится как булеан.
К примеру, пусть задано два ключа: `FA` со значениями `('a1', 'a2')` и `FB` со значениями `('b1', 'b2')`.
Тогда zC будет считаться по 9 разрезам:
1) `[FA = 'a1', FB = 'b1']`;
2) `[FA = 'a1', FB = 'b2']`;
3) `[FA = 'a2', FB = 'b1']`;
4) `[FA = 'a2', FB = 'b2']`;
5) `[FA = 'a1']`;
6) `[FA = 'a2']`;
7) `[FB = 'b1']`;
8) `[FB = 'b2']`;
9) `[]` (тривиальный разрез, совпадающий со всем множеством хитов);

Нетрудно видеть, что увлекаясь разрезами очень просто получить комбинаторный взрыв.
Каждая отдельная операция вычисления zC - это yql-запрос и отдельный подграф, поэтому при большом числе ключей ждать придётся долго.

### `zc_settings`

Группа параметров для вычисления `zC`.

+ `bootstrap_iterations [int]` - число-бутстрэп итераций;
+ `min_group_size [int]` - минимальный размер группы, группы меньше из вычислений исключаются;
+ `min_conversion_rate [float]` - минимальная конверсионность в группе, если меньше - то группа исключается;
+ `use_apc_check [bool]` - флаг использования `apc_check` (по умолчанию включён, для продовых задач так и должно быть, второй путь пока не отлажен);
+ `apc_check_threads [int]` - число тредов `apc_check`;
+ `apc_check_ram_per_thread [int][MiB]` - сколько RAM выделить на один тред. *Примечание*: дефолт выставлен достаточно щедрый, на маленьких табличках Нирвана будет ругаться не недоиспользование памяти. Поэтому для коротких вычислений можно ставить поменьше;
+ `apc_check_max_ram [int][MiB]` - верхняя граница общей RAM для `apc_check`;
+ `apc_check_disk_redundancy_factor [float]` - коэффициент запаса по диску при чтении таблицы с YT (очевидно, должен быть больше 1);
+ `apc_check_max_disk [int][GiB]` - максимально допустимый диск под таблицу;
+ `apc_check_ttl [int]` - `ttl` кубика с вычислением zc в минутах;
+ `split_by_day [bool]` - флаг расчёта zC по каждому дню. Если активен (по умаолчанию - нет) - то zC посчитается на всём интервале и на каждом календарном дне отдельно.

##### `split_by_day`

Важно помнить, что разбиение производится по границам суток.
Т.е. если общий интервал - с `2022-04-12T13:00:00` по `2022-04-14T06:00:00`, то отдельно посчитается zC по трём промежуткам: с `2022-04-12T13:00:00` по `2022-04-13T00:00:00`, с `2022-04-13T00:00:00` по `2022-04-14T00:00:00` и с `2022-04-14T00:00:00` по `2022-04-14T06:00:00`.

### `execution_settings`

Группа параметров, определяющих токены, пути к графам и прочее.
Большинство опций говорят сами за себя.

+ `yt_pool [str]`;
+ `yt_token [str]`;
+ `yql_token [str]` -  не указывать отдельно, тогда возьмётся `yt_token`;
+ `nirvana_secret [str]`;
+ `yt_cluster [str]`;
+ `mr_account [str]`;
+ `nirvana_quota [str]`;
+ `workflow_id [str]` - `id` воркфлоу в Нирване, где граф будет запущен в отдельном инстансе. Необязателен, но очень удобно создать себе один воркфлоу и все графы запускать в нём. Если не задан - то граф будет лежать в каком-то общем джанке;
+ `subgraphs_workflow_id [str]` - `id` отдельного воркфлоу для складывания подграфов. Удобнее всего указать оба. Если будет только один - то подграфы будут лежать вместе с основными графами и захламлять интерфейс.
+ `reporter_login [str]` - автор письма с результатами (можно оставить пустым, будет от залогиненого юзера);
+ `email_recipients [str]` - логины получателей писем с результатами;
+ `calculate_exp_stats [bool]` - флаг вычисления ограниченных метрик по эксперименту (в основном `cost` и последующий расчёт `zc * cost`);
+ `no_drop [bool]` - если флаг активен - то временные таблицы не буду сразу удаляться с `YT` после завершения графа (но останутся временными и будут удалены сборщиком мусора);
+ `post_to_startrek [bool]` - если флаг активен - то будет пост в тикет в Стартреке с результатами;
+ `startrek_ticket [str]` - `id` тикета в Стартреке. Если не задан и флаг `post_to_startrek` активен - то будет использован экспериментальный тикет (если его нет - то запостить не получится);
+ `startrek_token [str]`.
+ `task_name [str]` - какой-нибудь человекочитаемый идентификатор таска, чтобы не запутаться, когда их много.
+ `yt_workdir [str]` - путь к директории на ыте, куда следует складывать промежуточные таблицы (по дефолту будет `//home/$MR_ACCOUNT/users/$USER/reach_zc`)


## Help

Вопросы, предложения, баг-репорты и прочее - к [@alex-serov](https://staff.yandex-team.ru/alex-serov).

## Общие алерты для big_rt процессингов

### MessageLag + TimeLag

Все процессинги читают какие-то источники. 
Обычно все пытаются выдерживать какие-то SLA по максимальной задержке в обработке события, 
а значит нужно смотреть на TimeLag между временем записи самой старой незакоммиченной записи 
(или самой старой невычитаннной - тут есть варианты) и текущим моментом.

Но есть проблема - не по всем источникам есть TimeLag и не везде он независим от процессинга 
(= графики не исчезнут/заморозятся при проблемах в процессинге). 
А еще TimeLag не пишется как-то единообразно и часть точности теряется в гистограммах.

Однако для всех источников сейчас поддержан MessageLag. 
Это количество сообщений (по факту попугаев) записанных писателем, 
но не вычитанных \[и закоммиченных] читателем.
Он дает хоорошее понимание, догоняется или отстает сейчас процессинг. 
При маленьких значениях по нему можно понять, что у нас и маленький TimeLag 
(если по каджой партиции текущий MessageLag меньше k * количество записываемых строк в секунду, то явно все хорошо).

Но MessageLag - это попугаи, без ухищрений и приближений не понять, какое отставание по времени. 
Так же непонятен реальный объем данных. А при изменении уровня батчевания писаелем можно наблюдать спецэффекты 
(например, если при существующем большом MessageLag писатель начнет писать тот же поток более мелкими батчами, 
то на графиках вы увидите быстрый рост MessageLag, несмотря на то, 
что вы можете активно догоняться и сокращать TimeLag и лаг в байтах).

| Источник       | TimeLag  | MessageLag  |
|----------------|----------|-------------|
| LB             | ✔        | ✔           |
| QYT            | × (*1)   | ✔           |
| Swift Queue    | ~ (*2)   | ~ (*2)      |
| YT directory   | ×        | ✔           |
| Sorted table   | × (*3)   | ×           |

\*1) Для QYT есть планы поддержать TimeLag.

\*2) Swift Queue - в этом плане ни рыба, ни мясо. Лаг этой очереди разбит на две части, 
по одной части (что хранится в памяти в буфферах писателей) есть честный TimeLag, 
а по другой (записанной в низлежащий QYT) есть MessageLag в попугаях (плюс на него уже повлияла деградация Swift-а).

\*3) Sorted table сапплаер специфичен тем, что ходит по кругу и by design не должен догоняться. 
Поэтому к нему неприменимы обычные понятия лагов. 
Но у него есть метрика time_overrun - показывающая насколько секунд уже просрочен текущий период обхода таблицы.

Теперь попробуем собрать вместе и дать рекомендации:
* Если вы читаете рт поток данных:
  <br> Смотрите на TimeLag если он есть. И настраивайте алерты с нужными порогами.
  <br> На MessageLag тоже смотрите. Алерты тоже можно настраивать, но там будут некоторые сложности с подбором порогового значения MessageLag.
* Если вы читаете оффлайн заливки (пишутся несколько раз в сутки большими пачками, большую часть времени скорость записи 0):
  <br> Делайте алерт, что MessageLag был нулевым хотя бы раз в K часов. Не рекомендуется делать пороговые значения MessageLag для алертов тут.
* Если вы читаете сервис-лог / другую сортиованную таблицу по кругу:
  <br> Делайте алерт на time overrun оставляя позволительный для вас запас на превышение периода обхода.


[Бигб-шный геренатор алертов на лаги](https://a.yandex-team.ru/arc/trunk/arcadia/ads/bsyeti/tools/solomon/alerts/resharder_alerts.py). 
Переиспользовать этот код не рекомендуем, так как хотим делать общее решение на solo. 
Если вы в этом поможете будет круто :)

### Алерты на стабильную работу

Помимо лагов стоит просто мониторить стабильную работу сервиса.

Со стороны чисто big_rt-шного это фейлы эпох. Если у вас что-то не закоммитилось после всез ретраев или процессинг кидает исключения, 
то будут фейлиться эпохи. Рекомендуем здесь алерт такого вида: смотреть, что 95% моментов времени доля пофейленных эпох меньше 5% (числа можно крутить, конечно).
Подход хорош тем, что не триггерится на прострелы при релизах и на какой-то минимальный фон. Плох тем, что в текущем виде, смотрит на все шарды суммарно и может пропустить постоянные фейлы эпох по одному шарду из 1000.
[Бигб-шный геренатор алерта на фейлы эпох](https://a.yandex-team.ru/arc/trunk/arcadia/ads/bsyeti/tools/solomon/alerts/caesar_alerts.py?rev=r8863608#L207)

Можно делать алерт на число ERROR сообщений в логах.

Если умеете, алерты на OOM-ы и coredump-ы.

Так тут стоит отдельно мониторить всякие бизнесовые фейлы. Если фейлятся запросы во внешние системы, если приходят невалидные строчки и т. д.

Это не отдельная система логгирования.

Здесь просто лежат функции, которые позволяют легко инициализировать логгер `library/cpp/logger/global`.
А так же функции реализующие так называемые метки тредов/файберов.

Метка - по сути thread-local (и fiber-local) синглтон, который содержит строчку, которая кратко описывает, что делает данная нить процессинга.

Пример: в продовом решардере bigb на некотором хосте в рамках CS обрабатывающей топик `offline-crypta/crypta-profiles-json-log` из LB VLA, 
есть файбер балансера, который следит за тем, что обрабатываются именно те шарды, которые должны обрабатываться.

И этот файбер имеет короткую метку: `vla_offline_crypta__crypta_profiles_json_log-balancer`.
(Эти метки удобны, когда грепаешь логи. 
Легко выцепить из всего потока сообщения написанные в рамках обработки 
конкретного шарда конкретного лога. Или в рамках балансера отдельного лога. И т. д.)

И полную метку: `[602976/rt_cosy/vla_offline_crypta__crypta_profiles_json_log-balancer]` в которой добавляется thread id и имя потока 
(очень удобно, когда с помощью GDB цепляешься).

Пример строчки лога:
```
INFO: 2020-06-08 15:02:46.893 +0300 consuming_system.cpp:242 [602976/rt_cosy/vla_offline_crypta__crypta_profiles_json_log-balancer] Balancer iteration begin. ActiveShards=1, total=20, max_shards=2, max_to_check=1
```
Строчка была записана такой строчкой кода:
```
INFO_LOG << TL << "Balancer iteration begin. ActiveShards=" << ShardsInfos.size() << ", total=" << shardsCount
                         << ", max_shards=" << maxShards << ", max_to_check=" << maxShardsToCheck << "\n";
```

В big_rt часто встречаются опции вида ThreadLabelPrefix, 
через которые можно передать префикс для короткой метки. 
И этот префикс будет использоваться для меток файберов дочерних сущностей.

Нельзя отрицать, что этот модуль - это костыль-велосипед, 
возможно в будущем будет заменен на что-то лучшее. Но пока свою задачу он решает.
# Библиотека `big_rt`

Тикет для пожеланий и улучшений BIGB-893. Для пожеланий и улучшений по документации BIGB-967.

Если вы раздумываете, надо ли это вам, поговорите с [Егором Хайруллиным](https://staff.yandex-team.ru/mikari).

Чат в телеграмме для обсуждения вопросов связанных с кодом: [BigRT code](https://t.me/joinchat/AXv6gBoN8SGEG6zrT-Lmyg).

## Возможности

* Позволяет написать свой реалтайм-процессинг, читающий данные из Logbroker, QYT (aka queue over yt) или статических таблиц на YT.
При этом процессинг может быть как stateless, так и stateful со стейтом в динамических таблицах на YT.
То есть можно делать простой маппинг, а можно аггрегировать события, например, в профили пользователей.

* Решает проблему балансировки - вам достаточно просто поднять N инстансов с BigRT-процессом и одинаковым конфигом.
А инстансы уже сами договорятся, какой шард кто будет процессить.
[Подробнее про балансировку](lib/consuming_system/master_slave_balancer)

* Без постороннего вмешательства делает (частичные) перезапуски при необходимости.
Например, если изменилось количество партиций в читаемом топике логброкера или пользовательский код кинул исключение в плохом месте.

* Пишет метрики в Solomon, по которым можно понять состояние процессинга.


## Краткий обзор архитектуры

Запушенный BigRT-процессинг на инстансе представляет собой дерево долгоживущих задач.
Задаче обычно соответствует запущенный файбер, ответственный за какую-то задачу.
Задача может порождать дочерние задачи и всегда дожидается их завершения перед своим полным завершением.

В качестве примера можно привести задачу медиатора,
которая полностью отвечает за процессинг конкретного шарда, и работает пока ее не остановят извне по какой-либо причине.
В случае нетривиальных ошибок, может перезапускаться поддерево задач.

```
ConsumingSystem
├─> Public config updater
└─> ConsumingSystem iteration
    ├─> Shard list cache
    ├─> Balancer
    └─⇶ Mediator (медиаторов столько, сколько шардов обрабатывается в рамках ConsumingSystem)
        ├─> Consumer
        │   └─> ShardProcessor
        └─⇶ Supplier (сапплаеров столько, сколько сконфигурировано)
```

* `ConsumingSystem` (сокращается CS)
  1) В распределенном смысле: отвечает за процессинг одной шардированной сущности, например, одного LB-топика или одной очереди на YT.
  2) На конкретном хосте: отвечает за часть процессинга одной шардированной сущности на одном хосте.
     Процессинг работает, пока его не остановят извне.

  В обоих смыслах отвечают за то, чтобы правильно поделить работу между воркерами и обрабатывать шарды.
* `Public config updater` - отвечает за регулярную публикацию информации о ConsumingSystem на YT,
   которая может быть использована внешними инструментами (big_rt_cli).
* `ConsumingSystem iteration` - делает основную работу ConsumingSystem,
   но может завершаться из-за внутренних ошибок или если изменилось количество шардов в логе.
   Запускает и перезапускает медиаторы для нужных шардов.
* `Balancer` - отвечает за определение актуального списка шардов для обработки.
* `Shard list cache` - регулярно получает и кеширует на YT количество шардов источника данных. 
   От него ConsumingSystem узнает, сколько всего шардов в источнике данных.
* `Mediator` - отвечает за процессинг одного шарда.
   Работает пока не будет остановлен извне.
   Организует передачу данных от поставщиков-сапплаеров к потребителю-шардпроцессору.
* `Consumer` - запускает Shard processor - пользовательский код обработки данных.
* `Supplier` - читает данные из Logbroker/QYT/статических_таблиц для передачи их в пользовательский Shard processor.
* `ShardProcessor` - отвечает за обработку данных одного шарда
   (возможно из нескольких параллельных источников - join).
   По сути эта функция, которая работает на протяжении всей обработки шарда
   и осуществляет обработку данных из него.
   Функция получает объект `TConsumingSystem::IConsumer`, из которого может получать
   чанки данных с ручками для коммита этих данных.
   Есть два шаблона-класса для реализации этой функции: `stateless_shard_processor` и `stateful_shard_processor`.

Такое разделение на задачи обеспечивает некоторую изоляцию знаний и ответственности:
* Mediator отвечает только за свой шард и ничего не знает об остальных, кроме их количества.
* ShardProcessor отвечает только за обработку и коммит данных.
  Он ничего не знает о значениях оффсетов отдельных сообщений -
  он работает с ручками, инкапсулирующими в себе информацию об оффсетах.
  (На самом деле может получить эту информацию, но на ее надежность нет гарантий).
* Supplier знает только про свой шард и источник, из которого он читает.
  Наружу он отдает самораспаковывающиеся сообщения, чтобы у пользователя был контроль, в каком контексте совершать тяжелую по CPU работу.

## Материалы
1) [Рассказ на техновстрече](https://wiki.yandex-team.ru/market/development/indexer/technomeetup/#2020-09-24texnovstrechamarketasegoromxajjrullinymijuriempechatnovymprobigrticaesar) (обзор сверху)
2) [Рассказ про ядро big_rt](https://frontend.vh.yandex-team.ru/player/46630693375073fbbaba84306061f8e6?from=partner&mute=1&autoplay=1&tv=0&no_ad=false&loop=true&play_on_visible=false) (consuming system, mediator, механизм exactly once, процессоры)
3) Рассказ про swift queue [часть 1](https://frontend.vh.yandex-team.ru/player/4c36dd365c346c6eb1533e7140a87d5b?from=partner&mute=1&autoplay=1&tv=0&no_ad=false&loop=true&play_on_visible=false), [часть 2](https://frontend.vh.yandex-team.ru/player/4a3ba27eeb079fb984223de42c1030ec?from=partner&mute=1&autoplay=1&tv=0&no_ad=false&loop=true&play_on_visible=false), [часть 3](https://frontend.vh.yandex-team.ru/player/453a18c294fde5ac8a3731913059716c?from=partner&mute=1&autoplay=1&tv=0&no_ad=false&loop=true&play_on_visible=false).

[Альбом с видео про bigrt](https://moderator.video.yandex-team.ru/m/service-films?offset=0&service=video-nda&albumN=926) на moderator.video.yandex-team.ru

## Глоссарий

* QYT (aka queue over yt) — упорядоченная дин-таблица (но не сортированная)
* ConsumingSystem / CS, Mediator, Supplier, ShardProcessor - смотрите предыдущий пункт.
* stateless_shard_processor и stateful_shard_processor - шаблоны-классы для удобной реализации функции ShardProcessor. Создают удобства для описания stateless и stateful процессинга.
* State manager - сущность, которая объединяет в себе знания о том, как загрузить что-нибудь для строк лога. Используется в stateful_shard_processor. Подбробнее [тут](lib/processing/state_manager).


## FAQ

Q: Как деплоиться?
<br>
A: Самостоятельно. Это библиотека, которая позволяет легко написать бинарь, который можно запустить в N экземплярах и процессинг пойдет.
Железо для запуска, проброс секретов, провязку с Solomon... нужно делать самостоятельно на своей любимой системе деплоя.
[Человек, который умеет деплоиться в Samogon](https://staff.yandex-team.ru/pechatnov).
[Человек, который умеет деплоиться в Nanny](https://staff.yandex-team.ru/nicklavr?from=suggest)

Q: Можно ли как-то легко подгружать read-only стейт во время процессинга?
<br>
A: Да, это можно делать как произвольным способом из функции для процессинга данных,
так и автоматически из динтаблиц в YT (смотрите [информацию про стейт-менеджеры](lib/processing/state_manager)).
Можно подгружать несколько таких стейтов по разным ключам.

Q: Можно ли как-то легко обновлять сразу несколько стейтов на основе каждой записи?
<br>
A: Зависит от того, как часто у вас будут конфликты при записи.
Ведь при обработке разных шардов могут быть востребованы одни и те же ключи.

Q: Где посмотреть примеры?
A: В demo. Но надо учитывать, что они максимально упрощены, а параметры в конфигах могут быть рассчитаны на локальный yt, и на реальных кластерах с такими параметрами работать нельзя (может быть плохо либо вам, либо кластеру yt).

## Что сделано/делается на основе этой библиотеки?
* Bigb ([человек для вопросов](https://staff.yandex-team.ru/pechatnov))
  * Resharder - сервис читающий 60+ топиков из логброкера, делающий небольшой маппинг,
  распределяющий записи в зависимости от затронутого пользователя по шардам и записывающий их в QYT.
  По сути есть много тредов-файберов на разных хостах,
   каждый из которых читает свой шард и
   периодически коммитит в одной транзакции:
    1) оффсет, до которого дочитан шард, в динтаблицу,
    2) решардированные записи в QYT
  * Buzzard - сервис, читающий решардированные данные и
  обновляющий на их основе профили пользователей в динтаблице на YT.
  (Пока использует big_rt только частично, но big_rt развивается,
   чтобы можно было перевести его полностью (при этом получив выигрыш от перехода)).
* Цезарь
* Oбработка данных для антифрода ([человек для вопросов](https://staff.yandex-team.ru/nicklavr))
<br>  Http-ручка -> QYT -> обновление стейтов с помощью big_rt
* Команда searchpers Шлюнкина (факторы для веб поиска) ([человек для вопросов](https://staff.yandex-team.ru/skorodumov-s))
    1. User History - эмбеддинги урлов и запросов пользователя по поисковым логам
    https://a.yandex-team.ru/arc/trunk/arcadia/quality/personalization/big_rt/user_history
    2. Rapid Clicks - статистика посещений урлов и хостов по логу браузера (в будущем и по поиску)
    https://a.yandex-team.ru/arc/trunk/arcadia/quality/personalization/big_rt/spylog

* Тут можете записать себя


## Смотрите также:
* TStopToken — обертка над NYT::TFuture для удобного управления живостью разных задач/компонент.
Можно проверить, подписаться, сделать дочерний токен и прочее.
* [yt profiling](https://a.yandex-team.ru/arc/trunk/arcadia/yt/yt/library/profiling) - либа для отдачи метрик в solomon. (Еще используется [safe_stats](https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/safe_stats), но с него уезжаем)
* [big_rt_cli](https://a.yandex-team.ru/arc/trunk/arcadia/ads/bsyeti/big_rt/cli) — позволяет удобно создать очередь с нужными атрибутами и структурой:  `./big_rt_cli queue create`/`./big_rt_cli consumer create`. И не только очередь, там много разных команд.
